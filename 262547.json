{"path":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","commits":[{"id":"a114c79cee12feb72f81641925268f6e3e4f051e","date":1364002322,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r = (r == null ? getReader(core, config, directoryFactory, path) : r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"058801f8673d53a5abac8088204860ec29a40f0d","date":1364178882,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r == null ? getReader(core, config, directoryFactory, path) : r);\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = this.reader.directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    this.createdDirectory = r == null;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r = (r == null ? getReader(core, config, directoryFactory, path) : r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":["e22ffe8cc51a892ae103df018822d7873e901c2a","a114c79cee12feb72f81641925268f6e3e4f051e","96d207426bd26fa5c1014e26d21d87603aea68b7"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r == null ? getReader(core, config, directoryFactory, path) : r);\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    this.createdDirectory = r == null;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r == null ? getReader(core, config, directoryFactory, path) : r);\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = this.reader.directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    this.createdDirectory = r == null;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r == null ? getReader(core, config, directoryFactory, path) : r);\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    this.createdDirectory = r == null;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r == null ? getReader(core, config, directoryFactory, path) : r);\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = this.reader.directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    this.createdDirectory = r == null;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f7914dd715bfbe93f7d33558a8f33a784debbd1","date":1391680815,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r == null ? getReader(core, config, directoryFactory, path) : r);\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    this.createdDirectory = r == null;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r == null ? getReader(core, config, directoryFactory, path) : r);\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    this.createdDirectory = r == null;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r == null ? getReader(core, config, directoryFactory, path) : r);\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    this.createdDirectory = r == null;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r == null ? getReader(core, config, directoryFactory, path) : r);\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    this.createdDirectory = r == null;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":["15f9a498a407241cefcbd00ca7fc84d5e7fa573e","15f9a498a407241cefcbd00ca7fc84d5e7fa573e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30b6ad849a21206db510322a3f583ca70ae20a2f","date":1399996150,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    this.createdDirectory = r == null;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r == null ? getReader(core, config, directoryFactory, path) : r);\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    this.createdDirectory = r == null;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08a910473f0b0dd5091433ffc6c04ce481567cc3","date":1400005623,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    this.createdDirectory = r == null;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r == null ? getReader(core, config, directoryFactory, path) : r);\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    this.createdDirectory = r == null;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r == null ? getReader(core, config, directoryFactory, path) : r);\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    this.createdDirectory = r == null;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b906bdda81aff118473358c14c280e6f07feeda","date":1412632498,"type":5,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n                           boolean closeReader, boolean enableCache, boolean reserveDirectory,\n                           DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n                           boolean closeReader, boolean enableCache, boolean reserveDirectory,\n                           DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7f7914dd715bfbe93f7d33558a8f33a784debbd1"],"55980207f1977bd1463465de1659b821347e2fa8":["c9fb5f46e264daf5ba3860defe623a89d202dd87","6b906bdda81aff118473358c14c280e6f07feeda"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["058801f8673d53a5abac8088204860ec29a40f0d","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"6b906bdda81aff118473358c14c280e6f07feeda":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"08a910473f0b0dd5091433ffc6c04ce481567cc3":["30b6ad849a21206db510322a3f583ca70ae20a2f"],"56572ec06f1407c066d6b7399413178b33176cd8":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","93dd449115a9247533e44bab47e8429e5dccbc6d"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"7f7914dd715bfbe93f7d33558a8f33a784debbd1":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["058801f8673d53a5abac8088204860ec29a40f0d"],"058801f8673d53a5abac8088204860ec29a40f0d":["a114c79cee12feb72f81641925268f6e3e4f051e"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","08a910473f0b0dd5091433ffc6c04ce481567cc3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a114c79cee12feb72f81641925268f6e3e4f051e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"30b6ad849a21206db510322a3f583ca70ae20a2f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6b906bdda81aff118473358c14c280e6f07feeda"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d","30b6ad849a21206db510322a3f583ca70ae20a2f"],"55980207f1977bd1463465de1659b821347e2fa8":[],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"6b906bdda81aff118473358c14c280e6f07feeda":["55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"08a910473f0b0dd5091433ffc6c04ce481567cc3":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["55980207f1977bd1463465de1659b821347e2fa8","6b906bdda81aff118473358c14c280e6f07feeda"],"7f7914dd715bfbe93f7d33558a8f33a784debbd1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["37a0f60745e53927c4c876cfe5b5a58170f0646c","7f7914dd715bfbe93f7d33558a8f33a784debbd1"],"058801f8673d53a5abac8088204860ec29a40f0d":["37a0f60745e53927c4c876cfe5b5a58170f0646c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","c9fb5f46e264daf5ba3860defe623a89d202dd87"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a114c79cee12feb72f81641925268f6e3e4f051e"],"30b6ad849a21206db510322a3f583ca70ae20a2f":["08a910473f0b0dd5091433ffc6c04ce481567cc3"],"a114c79cee12feb72f81641925268f6e3e4f051e":["058801f8673d53a5abac8088204860ec29a40f0d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","37a0f60745e53927c4c876cfe5b5a58170f0646c","56572ec06f1407c066d6b7399413178b33176cd8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}