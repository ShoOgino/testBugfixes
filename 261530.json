{"path":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","sourceNew":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new HashMap<String, List<String>>();\n    SimpleOrderedMap<Object> fields = new SimpleOrderedMap<Object>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n    \n    SimpleOrderedMap<Object> dynamicFields = new SimpleOrderedMap<Object>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n    \tpopulateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<Object>();\n    for( FieldType ft : schema.getFieldTypes().values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<Object>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    finfo.add(\"fields\", fields);\n    finfo.add(\"dynamicFields\", dynamicFields);\n    finfo.add(\"uniqueKeyField\", \n              null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","sourceOld":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new HashMap<String, List<String>>();\n    SimpleOrderedMap<Object> fields = new SimpleOrderedMap<Object>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n    \n    SimpleOrderedMap<Object> dynamicFields = new SimpleOrderedMap<Object>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n    \tpopulateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<Object>();\n    for( FieldType ft : schema.getFieldTypes().values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<Object>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    finfo.add(\"fields\", fields);\n    finfo.add(\"dynamicFields\", dynamicFields);\n    finfo.add(\"uniqueKeyField\", \n              null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","sourceNew":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new HashMap<String, List<String>>();\n    SimpleOrderedMap<Object> fields = new SimpleOrderedMap<Object>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n    \n    SimpleOrderedMap<Object> dynamicFields = new SimpleOrderedMap<Object>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n    \tpopulateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<Object>();\n    for( FieldType ft : schema.getFieldTypes().values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<Object>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    finfo.add(\"fields\", fields);\n    finfo.add(\"dynamicFields\", dynamicFields);\n    finfo.add(\"uniqueKeyField\", \n              null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","sourceOld":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new HashMap<String, List<String>>();\n    SimpleOrderedMap<Object> fields = new SimpleOrderedMap<Object>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n    \n    SimpleOrderedMap<Object> dynamicFields = new SimpleOrderedMap<Object>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n    \tpopulateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<Object>();\n    for( FieldType ft : schema.getFieldTypes().values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<Object>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    finfo.add(\"fields\", fields);\n    finfo.add(\"dynamicFields\", dynamicFields);\n    finfo.add(\"uniqueKeyField\", \n              null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","sourceNew":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new HashMap<String, List<String>>();\n    SimpleOrderedMap<Object> fields = new SimpleOrderedMap<Object>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n    \n    SimpleOrderedMap<Object> dynamicFields = new SimpleOrderedMap<Object>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n    \tpopulateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<Object>();\n    for( FieldType ft : schema.getFieldTypes().values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<Object>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    finfo.add(\"fields\", fields);\n    finfo.add(\"dynamicFields\", dynamicFields);\n    finfo.add(\"uniqueKeyField\", \n              null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","sourceOld":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new HashMap<String, List<String>>();\n    SimpleOrderedMap<Object> fields = new SimpleOrderedMap<Object>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n    \n    SimpleOrderedMap<Object> dynamicFields = new SimpleOrderedMap<Object>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n    \tpopulateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<Object>();\n    for( FieldType ft : schema.getFieldTypes().values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<Object>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    finfo.add(\"fields\", fields);\n    finfo.add(\"dynamicFields\", dynamicFields);\n    finfo.add(\"uniqueKeyField\", \n              null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb037ddbc4ef8b427189b9ca13486ea830d0c766","date":1325813112,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","sourceNew":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<String, List<String>>();\n    Map<String, Object> fields = new TreeMap<String, Object>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<String, Object>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<Object>();\n    Map<String, FieldType> sortedTypes = new TreeMap<String, FieldType>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<Object>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<Object>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<Object>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","sourceOld":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new HashMap<String, List<String>>();\n    SimpleOrderedMap<Object> fields = new SimpleOrderedMap<Object>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n    \n    SimpleOrderedMap<Object> dynamicFields = new SimpleOrderedMap<Object>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n    \tpopulateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<Object>();\n    for( FieldType ft : schema.getFieldTypes().values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<Object>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    finfo.add(\"fields\", fields);\n    finfo.add(\"dynamicFields\", dynamicFields);\n    finfo.add(\"uniqueKeyField\", \n              null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"47672ac722215a3b485acf3479dcd768c83ee4f8","date":1344978977,"type":3,"author":"Greg Bowyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","sourceNew":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<String, List<String>>();\n    Map<String, Object> fields = new TreeMap<String, Object>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<String, Object>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<Object>();\n    Map<String, FieldType> sortedTypes = new TreeMap<String, FieldType>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<Object>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      field.add(\"similarity\", getSimilarityInfo(ft.getSimilarity()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<Object>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<Object>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","sourceOld":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<String, List<String>>();\n    Map<String, Object> fields = new TreeMap<String, Object>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<String, Object>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<Object>();\n    Map<String, FieldType> sortedTypes = new TreeMap<String, FieldType>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<Object>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<Object>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<Object>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","sourceNew":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<String, List<String>>();\n    Map<String, Object> fields = new TreeMap<String, Object>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<String, Object>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<Object>();\n    Map<String, FieldType> sortedTypes = new TreeMap<String, FieldType>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<Object>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      field.add(\"similarity\", getSimilarityInfo(ft.getSimilarity()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<Object>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<Object>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","sourceOld":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<String, List<String>>();\n    Map<String, Object> fields = new TreeMap<String, Object>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<String, Object>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<Object>();\n    Map<String, FieldType> sortedTypes = new TreeMap<String, FieldType>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<Object>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<Object>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<Object>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","sourceNew":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<String, List<String>>();\n    Map<String, Object> fields = new TreeMap<String, Object>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<String, Object>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<Object>();\n    Map<String, FieldType> sortedTypes = new TreeMap<String, FieldType>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<Object>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      field.add(\"similarity\", getSimilarityInfo(ft.getSimilarity()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<Object>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<Object>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","sourceOld":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<String, List<String>>();\n    Map<String, Object> fields = new TreeMap<String, Object>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<String, Object>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<Object>();\n    Map<String, FieldType> sortedTypes = new TreeMap<String, FieldType>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<Object>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<Object>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<Object>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","sourceNew":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<>();\n    Map<String, Object> fields = new TreeMap<>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<>();\n    Map<String, FieldType> sortedTypes = new TreeMap<>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      field.add(\"similarity\", getSimilarityInfo(ft.getSimilarity()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","sourceOld":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<String, List<String>>();\n    Map<String, Object> fields = new TreeMap<String, Object>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<String, Object>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<Object>();\n    Map<String, FieldType> sortedTypes = new TreeMap<String, FieldType>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<Object>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      field.add(\"similarity\", getSimilarityInfo(ft.getSimilarity()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<Object>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<Object>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"123698fbe83b595f9e084f0019cd35ab4a01d7f7","date":1399070065,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","sourceNew":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<>();\n    Map<String, Object> fields = new TreeMap<>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<>();\n    Map<String, FieldType> sortedTypes = new TreeMap<>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getIndexAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      field.add(\"similarity\", getSimilarityInfo(ft.getSimilarity()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","sourceOld":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<>();\n    Map<String, Object> fields = new TreeMap<>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<>();\n    Map<String, FieldType> sortedTypes = new TreeMap<>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      field.add(\"similarity\", getSimilarityInfo(ft.getSimilarity()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"69dab3bc0b0a7594aee1afc0a3d21285b9555620","date":1476962740,"type":3,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","sourceNew":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<>();\n    Map<String, Object> fields = new TreeMap<>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<>();\n    Map<String, FieldType> sortedTypes = new TreeMap<>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getIndexAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      field.add(\"similarity\", getSimilarityInfo(ft.getSimilarity()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"similarity\", getSimilarityInfo(schema.getSimilarity()));\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","sourceOld":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<>();\n    Map<String, Object> fields = new TreeMap<>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<>();\n    Map<String, FieldType> sortedTypes = new TreeMap<>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getIndexAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      field.add(\"similarity\", getSimilarityInfo(ft.getSimilarity()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","sourceNew":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<>();\n    Map<String, Object> fields = new TreeMap<>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<>();\n    Map<String, FieldType> sortedTypes = new TreeMap<>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getIndexAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      field.add(\"similarity\", getSimilarityInfo(ft.getSimilarity()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"similarity\", getSimilarityInfo(schema.getSimilarity()));\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","sourceOld":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<>();\n    Map<String, Object> fields = new TreeMap<>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<>();\n    Map<String, FieldType> sortedTypes = new TreeMap<>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getIndexAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      field.add(\"similarity\", getSimilarityInfo(ft.getSimilarity()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d057970b5f9fcaabc49d2f54c59a5d2a09da1769","date":1495200448,"type":3,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","sourceNew":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<>();\n    Map<String, Object> fields = new TreeMap<>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<>();\n    Map<String, FieldType> sortedTypes = new TreeMap<>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getIndexAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      field.add(\"similarity\", getSimilarityInfo(ft.getSimilarity()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"similarity\", getSimilarityInfo(schema.getSimilarity()));\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","sourceOld":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<>();\n    Map<String, Object> fields = new TreeMap<>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<>();\n    Map<String, FieldType> sortedTypes = new TreeMap<>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getIndexAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      field.add(\"similarity\", getSimilarityInfo(ft.getSimilarity()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"similarity\", getSimilarityInfo(schema.getSimilarity()));\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getSchemaInfo(IndexSchema).mjava","sourceNew":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<>();\n    Map<String, Object> fields = new TreeMap<>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<>();\n    Map<String, FieldType> sortedTypes = new TreeMap<>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getIndexAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      field.add(\"similarity\", getSimilarityInfo(ft.getSimilarity()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"similarity\", getSimilarityInfo(schema.getSimilarity()));\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","sourceOld":"  /**\n   * Return info from the index\n   */\n  private static SimpleOrderedMap<Object> getSchemaInfo( IndexSchema schema ) {\n    Map<String, List<String>> typeusemap = new TreeMap<>();\n    Map<String, Object> fields = new TreeMap<>();\n    SchemaField uniqueField = schema.getUniqueKeyField();\n    for( SchemaField f : schema.getFields().values() ) {\n      populateFieldInfo(schema, typeusemap, fields, uniqueField, f);\n    }\n\n    Map<String, Object> dynamicFields = new TreeMap<>();\n    for (SchemaField f : schema.getDynamicFieldPrototypes()) {\n      populateFieldInfo(schema, typeusemap, dynamicFields, uniqueField, f);\n    }\n    SimpleOrderedMap<Object> types = new SimpleOrderedMap<>();\n    Map<String, FieldType> sortedTypes = new TreeMap<>(schema.getFieldTypes());\n    for( FieldType ft : sortedTypes.values() ) {\n      SimpleOrderedMap<Object> field = new SimpleOrderedMap<>();\n      field.add(\"fields\", typeusemap.get( ft.getTypeName() ) );\n      field.add(\"tokenized\", ft.isTokenized() );\n      field.add(\"className\", ft.getClass().getName());\n      field.add(\"indexAnalyzer\", getAnalyzerInfo(ft.getIndexAnalyzer()));\n      field.add(\"queryAnalyzer\", getAnalyzerInfo(ft.getQueryAnalyzer()));\n      field.add(\"similarity\", getSimilarityInfo(ft.getSimilarity()));\n      types.add( ft.getTypeName(), field );\n    }\n\n    // Must go through this to maintain binary compatbility. Putting a TreeMap into a resp leads to casting errors\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<>();\n\n    SimpleOrderedMap<Object> fieldsSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : fields.entrySet()) {\n      fieldsSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"fields\", fieldsSimple);\n\n    SimpleOrderedMap<Object> dynamicSimple = new SimpleOrderedMap<>();\n    for (Map.Entry<String, Object> ent : dynamicFields.entrySet()) {\n      dynamicSimple.add(ent.getKey(), ent.getValue());\n    }\n    finfo.add(\"dynamicFields\", dynamicSimple);\n\n    finfo.add(\"uniqueKeyField\",\n        null == uniqueField ? null : uniqueField.getName());\n    finfo.add(\"defaultSearchField\", schema.getDefaultSearchFieldName());\n    finfo.add(\"similarity\", getSimilarityInfo(schema.getSimilarity()));\n    finfo.add(\"types\", types);\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["47672ac722215a3b485acf3479dcd768c83ee4f8"],"eb037ddbc4ef8b427189b9ca13486ea830d0c766":["c26f00b574427b55127e869b935845554afde1fa"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["eb037ddbc4ef8b427189b9ca13486ea830d0c766","47672ac722215a3b485acf3479dcd768c83ee4f8"],"69dab3bc0b0a7594aee1afc0a3d21285b9555620":["123698fbe83b595f9e084f0019cd35ab4a01d7f7"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"d057970b5f9fcaabc49d2f54c59a5d2a09da1769":["69dab3bc0b0a7594aee1afc0a3d21285b9555620"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["eb037ddbc4ef8b427189b9ca13486ea830d0c766","47672ac722215a3b485acf3479dcd768c83ee4f8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["123698fbe83b595f9e084f0019cd35ab4a01d7f7","69dab3bc0b0a7594aee1afc0a3d21285b9555620"],"47672ac722215a3b485acf3479dcd768c83ee4f8":["eb037ddbc4ef8b427189b9ca13486ea830d0c766"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["69dab3bc0b0a7594aee1afc0a3d21285b9555620","d057970b5f9fcaabc49d2f54c59a5d2a09da1769"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"123698fbe83b595f9e084f0019cd35ab4a01d7f7":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d057970b5f9fcaabc49d2f54c59a5d2a09da1769"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["123698fbe83b595f9e084f0019cd35ab4a01d7f7"],"eb037ddbc4ef8b427189b9ca13486ea830d0c766":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","47672ac722215a3b485acf3479dcd768c83ee4f8"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"c26f00b574427b55127e869b935845554afde1fa":["eb037ddbc4ef8b427189b9ca13486ea830d0c766"],"69dab3bc0b0a7594aee1afc0a3d21285b9555620":["d057970b5f9fcaabc49d2f54c59a5d2a09da1769","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e9017cf144952056066919f1ebc7897ff9bd71b1"],"d057970b5f9fcaabc49d2f54c59a5d2a09da1769":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"47672ac722215a3b485acf3479dcd768c83ee4f8":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"123698fbe83b595f9e084f0019cd35ab4a01d7f7":["69dab3bc0b0a7594aee1afc0a3d21285b9555620","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e9017cf144952056066919f1ebc7897ff9bd71b1","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}