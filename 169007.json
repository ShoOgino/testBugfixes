{"path":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int).mjava","commits":[{"id":"61e52acc0f10ced3042a4d0257710497d5ccf4ad","date":1289767503,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", start);\n\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_offset != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ab1f5591dc05f1f2b5407d809c9699f75554a32","date":1290008586,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", start);\n\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_offset != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43e368cad6a1cc3992f44375801ea528f49b542e","date":1290206535,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int).mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int).mjava","sourceNew":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", start);\n\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_limit != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","sourceOld":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", start);\n\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_offset != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int).mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int).mjava","sourceNew":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", start);\n\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_limit != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","sourceOld":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", start);\n\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_offset != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", start);\n\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_limit != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6fc486b95961ecae1316cd7c5acd720d966c59bd","date":1296749246,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int).mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int).mjava","sourceNew":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", group_offset);\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_limit != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","sourceOld":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", start);\n\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_limit != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int).mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int).mjava","sourceNew":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", group_offset);\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_limit != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","sourceOld":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", start);\n\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_limit != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int).mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int).mjava","sourceNew":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", group_offset);\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_limit != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","sourceOld":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", start);\n\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_limit != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9c7cdfe5a1ea9db97faa404b251fa644faa73597","date":1308345959,"type":5,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int,boolean).mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int).mjava","sourceNew":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit, boolean includeNGroups) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    if (includeNGroups) {\n      result.put(\"ngroups\", sortedGroups.size());\n    }\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", group_offset);\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_limit != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","sourceOld":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", group_offset);\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_limit != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7edfc3f7caa7b49a18fe367692768b33b018e9db","date":1308374217,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int,boolean).mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#buildGroupedResult(IndexSchema,List[Grp],int,int,int,int).mjava","sourceNew":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit, boolean includeNGroups) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    if (includeNGroups) {\n      result.put(\"ngroups\", sortedGroups.size());\n    }\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", group_offset);\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_limit != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","sourceOld":"  public static Object buildGroupedResult(IndexSchema schema, List<Grp> sortedGroups, int start, int rows, int group_offset, int group_limit) {\n    Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n    long matches = 0;\n    for (Grp grp : sortedGroups) {\n      matches += grp.docs.size();\n    }\n    result.put(\"matches\", matches);\n    List groupList = new ArrayList();\n    result.put(\"groups\", groupList);\n\n    for (int i=start; i<sortedGroups.size(); i++) {\n      if (rows != -1 && groupList.size() >= rows) break;  // directly test rather than calculating, so we can catch any calc errors in the real code\n      Map<String,Object> group = new LinkedHashMap<String,Object>();\n      groupList.add(group);\n\n      Grp grp = sortedGroups.get(i);\n      group.put(\"groupValue\", grp.groupValue);\n\n      Map<String,Object> resultSet = new LinkedHashMap<String,Object>();\n      group.put(\"doclist\", resultSet);\n      resultSet.put(\"numFound\", grp.docs.size());\n      resultSet.put(\"start\", group_offset);\n      List docs = new ArrayList();\n      resultSet.put(\"docs\", docs);\n      for (int j=group_offset; j<grp.docs.size(); j++) {\n        if (group_limit != -1 && docs.size() >= group_limit) break;\n        docs.add( grp.docs.get(j).toObject(schema) );\n      }\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"43e368cad6a1cc3992f44375801ea528f49b542e":["61e52acc0f10ced3042a4d0257710497d5ccf4ad"],"7edfc3f7caa7b49a18fe367692768b33b018e9db":["6fc486b95961ecae1316cd7c5acd720d966c59bd","9c7cdfe5a1ea9db97faa404b251fa644faa73597"],"9ab1f5591dc05f1f2b5407d809c9699f75554a32":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","61e52acc0f10ced3042a4d0257710497d5ccf4ad"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["3bb13258feba31ab676502787ab2e1779f129b7a","6fc486b95961ecae1316cd7c5acd720d966c59bd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9c7cdfe5a1ea9db97faa404b251fa644faa73597":["6fc486b95961ecae1316cd7c5acd720d966c59bd"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","43e368cad6a1cc3992f44375801ea528f49b542e"],"61e52acc0f10ced3042a4d0257710497d5ccf4ad":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","6fc486b95961ecae1316cd7c5acd720d966c59bd"],"3bb13258feba31ab676502787ab2e1779f129b7a":["9ab1f5591dc05f1f2b5407d809c9699f75554a32","43e368cad6a1cc3992f44375801ea528f49b542e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9c7cdfe5a1ea9db97faa404b251fa644faa73597"],"6fc486b95961ecae1316cd7c5acd720d966c59bd":["43e368cad6a1cc3992f44375801ea528f49b542e"]},"commit2Childs":{"43e368cad6a1cc3992f44375801ea528f49b542e":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","3bb13258feba31ab676502787ab2e1779f129b7a","6fc486b95961ecae1316cd7c5acd720d966c59bd"],"7edfc3f7caa7b49a18fe367692768b33b018e9db":[],"9ab1f5591dc05f1f2b5407d809c9699f75554a32":["3bb13258feba31ab676502787ab2e1779f129b7a"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ab1f5591dc05f1f2b5407d809c9699f75554a32","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","61e52acc0f10ced3042a4d0257710497d5ccf4ad"],"9c7cdfe5a1ea9db97faa404b251fa644faa73597":["7edfc3f7caa7b49a18fe367692768b33b018e9db","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"61e52acc0f10ced3042a4d0257710497d5ccf4ad":["43e368cad6a1cc3992f44375801ea528f49b542e","9ab1f5591dc05f1f2b5407d809c9699f75554a32"],"3bb13258feba31ab676502787ab2e1779f129b7a":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"6fc486b95961ecae1316cd7c5acd720d966c59bd":["7edfc3f7caa7b49a18fe367692768b33b018e9db","29ef99d61cda9641b6250bf9567329a6e65f901d","9c7cdfe5a1ea9db97faa404b251fa644faa73597","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7edfc3f7caa7b49a18fe367692768b33b018e9db","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}