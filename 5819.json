{"path":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","sourceNew":"  public static Bits getLiveDocs(IndexReader r) {\n    if (r.hasDeletions()) {\n      final List<Bits> liveDocs = new ArrayList<Bits>();\n      final List<Integer> starts = new ArrayList<Integer>();\n\n      try {\n        final int maxDoc = new ReaderUtil.Gather(r) {\n            @Override\n            protected void add(int base, AtomicReader r) throws IOException {\n              // record all liveDocs, even if they are null\n              liveDocs.add(r.getLiveDocs());\n              starts.add(base);\n            }\n          }.run();\n        starts.add(maxDoc);\n      } catch (IOException ioe) {\n        // should not happen\n        throw new RuntimeException(ioe);\n      }\n\n      assert liveDocs.size() > 0;\n      if (liveDocs.size() == 1) {\n        // Only one actual sub reader -- optimize this case\n        return liveDocs.get(0);\n      } else {\n        return new MultiBits(liveDocs, starts, true);\n      }\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  public static Bits getLiveDocs(IndexReader r) {\n    if (r.hasDeletions()) {\n      final List<Bits> liveDocs = new ArrayList<Bits>();\n      final List<Integer> starts = new ArrayList<Integer>();\n\n      try {\n        final int maxDoc = new ReaderUtil.Gather(r) {\n            @Override\n            protected void add(int base, AtomicReader r) throws IOException {\n              // record all liveDocs, even if they are null\n              liveDocs.add(r.getLiveDocs());\n              starts.add(base);\n            }\n          }.run();\n        starts.add(maxDoc);\n      } catch (IOException ioe) {\n        // should not happen\n        throw new RuntimeException(ioe);\n      }\n\n      assert liveDocs.size() > 0;\n      if (liveDocs.size() == 1) {\n        // Only one actual sub reader -- optimize this case\n        return liveDocs.get(0);\n      } else {\n        return new MultiBits(liveDocs, starts, true);\n      }\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","sourceNew":"  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<AtomicReaderContext> leaves = reader.getTopReaderContext().leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final AtomicReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  public static Bits getLiveDocs(IndexReader r) {\n    if (r.hasDeletions()) {\n      final List<Bits> liveDocs = new ArrayList<Bits>();\n      final List<Integer> starts = new ArrayList<Integer>();\n\n      try {\n        final int maxDoc = new ReaderUtil.Gather(r) {\n            @Override\n            protected void add(int base, AtomicReader r) throws IOException {\n              // record all liveDocs, even if they are null\n              liveDocs.add(r.getLiveDocs());\n              starts.add(base);\n            }\n          }.run();\n        starts.add(maxDoc);\n      } catch (IOException ioe) {\n        // should not happen\n        throw new RuntimeException(ioe);\n      }\n\n      assert liveDocs.size() > 0;\n      if (liveDocs.size() == 1) {\n        // Only one actual sub reader -- optimize this case\n        return liveDocs.get(0);\n      } else {\n        return new MultiBits(liveDocs, starts, true);\n      }\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":["d743dbdc40bef0a47a5d54d99623ef0c2eb5923e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d743dbdc40bef0a47a5d54d99623ef0c2eb5923e","date":1344896544,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","sourceNew":"  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<AtomicReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final AtomicReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<AtomicReaderContext> leaves = reader.getTopReaderContext().leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final AtomicReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","sourceNew":"  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<AtomicReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final AtomicReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<AtomicReaderContext> leaves = reader.getTopReaderContext().leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final AtomicReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c188105a9aae04f56c24996f98f8333fc825d2e","date":1345031914,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","sourceNew":"  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<AtomicReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final AtomicReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<AtomicReaderContext> leaves = reader.getTopReaderContext().leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final AtomicReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c93396a1df03720cb20e2c2f513a6fa59b21e4c","date":1345032673,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","sourceNew":"  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<AtomicReaderContext> leaves = reader.getTopReaderContext().leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final AtomicReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<AtomicReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final AtomicReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","sourceNew":"  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<AtomicReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final AtomicReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<AtomicReaderContext> leaves = reader.getTopReaderContext().leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final AtomicReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3b4a63b6b0155323dde6b827e0dc22a43580753","date":1346168671,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Bits} instance for this\n   *  reader, merging live Documents on the\n   *  fly.  This method will return null if the reader \n   *  has no deletions.\n   *\n   *  <p><b>NOTE</b>: this is a very slow way to access live docs.\n   *  For example, each Bits access will require a binary search.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<AtomicReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final AtomicReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<AtomicReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final AtomicReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Bits} instance for this\n   *  reader, merging live Documents on the\n   *  fly.  This method will return null if the reader \n   *  has no deletions.\n   *\n   *  <p><b>NOTE</b>: this is a very slow way to access live docs.\n   *  For example, each Bits access will require a binary search.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<AtomicReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final AtomicReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<AtomicReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final AtomicReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Bits} instance for this\n   *  reader, merging live Documents on the\n   *  fly.  This method will return null if the reader \n   *  has no deletions.\n   *\n   *  <p><b>NOTE</b>: this is a very slow way to access live docs.\n   *  For example, each Bits access will require a binary search.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<LeafReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final LeafReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Bits} instance for this\n   *  reader, merging live Documents on the\n   *  fly.  This method will return null if the reader \n   *  has no deletions.\n   *\n   *  <p><b>NOTE</b>: this is a very slow way to access live docs.\n   *  For example, each Bits access will require a binary search.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<AtomicReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final AtomicReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22aab7a3b640b0dba26cc5e9416bc7af93614b46","date":1462575761,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Bits} instance for this\n   *  reader, merging live Documents on the\n   *  fly.  This method will return null if the reader \n   *  has no deletions.\n   *\n   *  <p><b>NOTE</b>: this is a very slow way to access live docs.\n   *  For example, each Bits access will require a binary search.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<LeafReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final LeafReaderContext ctx = leaves.get(i);\n        if (ctx.reader().getIndexSort() != null) {\n          throw new IllegalArgumentException(\"cannot handle index sort: reader=\" + ctx.reader());\n        }\n\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Bits} instance for this\n   *  reader, merging live Documents on the\n   *  fly.  This method will return null if the reader \n   *  has no deletions.\n   *\n   *  <p><b>NOTE</b>: this is a very slow way to access live docs.\n   *  For example, each Bits access will require a binary search.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<LeafReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final LeafReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"815972da4a13279b8e975d2e32ca450649d6c295","date":1462635959,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Bits} instance for this\n   *  reader, merging live Documents on the\n   *  fly.  This method will return null if the reader \n   *  has no deletions.\n   *\n   *  <p><b>NOTE</b>: this is a very slow way to access live docs.\n   *  For example, each Bits access will require a binary search.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<LeafReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final LeafReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Bits} instance for this\n   *  reader, merging live Documents on the\n   *  fly.  This method will return null if the reader \n   *  has no deletions.\n   *\n   *  <p><b>NOTE</b>: this is a very slow way to access live docs.\n   *  For example, each Bits access will require a binary search.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<LeafReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final LeafReaderContext ctx = leaves.get(i);\n        if (ctx.reader().getIndexSort() != null) {\n          throw new IllegalArgumentException(\"cannot handle index sort: reader=\" + ctx.reader());\n        }\n\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e775de416dd2d8067b10db1c8af975a1d5017e","date":1539906554,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiBits#getLiveDocs(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getLiveDocs(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Bits} instance for this\n   *  reader, merging live Documents on the\n   *  fly.  This method will return null if the reader\n   *  has no deletions.\n   *\n   *  <p><b>NOTE</b>: this is a very slow way to access live docs.\n   *  For example, each Bits access will require a binary search.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<LeafReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final LeafReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Bits} instance for this\n   *  reader, merging live Documents on the\n   *  fly.  This method will return null if the reader \n   *  has no deletions.\n   *\n   *  <p><b>NOTE</b>: this is a very slow way to access live docs.\n   *  For example, each Bits access will require a binary search.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Bits getLiveDocs(IndexReader reader) {\n    if (reader.hasDeletions()) {\n      final List<LeafReaderContext> leaves = reader.leaves();\n      final int size = leaves.size();\n      assert size > 0 : \"A reader with deletions must have at least one leave\";\n      if (size == 1) {\n        return leaves.get(0).reader().getLiveDocs();\n      }\n      final Bits[] liveDocs = new Bits[size];\n      final int[] starts = new int[size + 1];\n      for (int i = 0; i < size; i++) {\n        // record all liveDocs, even if they are null\n        final LeafReaderContext ctx = leaves.get(i);\n        liveDocs[i] = ctx.reader().getLiveDocs();\n        starts[i] = ctx.docBase;\n      }\n      starts[size] = reader.maxDoc();\n      return new MultiBits(liveDocs, starts, true);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3c188105a9aae04f56c24996f98f8333fc825d2e":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c","d743dbdc40bef0a47a5d54d99623ef0c2eb5923e"],"a3b4a63b6b0155323dde6b827e0dc22a43580753":["d743dbdc40bef0a47a5d54d99623ef0c2eb5923e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["3c188105a9aae04f56c24996f98f8333fc825d2e"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","d743dbdc40bef0a47a5d54d99623ef0c2eb5923e"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","a3b4a63b6b0155323dde6b827e0dc22a43580753"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["a3b4a63b6b0155323dde6b827e0dc22a43580753"],"22aab7a3b640b0dba26cc5e9416bc7af93614b46":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d743dbdc40bef0a47a5d54d99623ef0c2eb5923e":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"815972da4a13279b8e975d2e32ca450649d6c295":["22aab7a3b640b0dba26cc5e9416bc7af93614b46"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["04e775de416dd2d8067b10db1c8af975a1d5017e"]},"commit2Childs":{"3c188105a9aae04f56c24996f98f8333fc825d2e":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["3c188105a9aae04f56c24996f98f8333fc825d2e","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","d743dbdc40bef0a47a5d54d99623ef0c2eb5923e"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"a3b4a63b6b0155323dde6b827e0dc22a43580753":["05a14b2611ead08655a2b2bdc61632eb31316e57","c9fb5f46e264daf5ba3860defe623a89d202dd87"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["05a14b2611ead08655a2b2bdc61632eb31316e57"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["22aab7a3b640b0dba26cc5e9416bc7af93614b46","04e775de416dd2d8067b10db1c8af975a1d5017e"],"22aab7a3b640b0dba26cc5e9416bc7af93614b46":["815972da4a13279b8e975d2e32ca450649d6c295"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d743dbdc40bef0a47a5d54d99623ef0c2eb5923e":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","a3b4a63b6b0155323dde6b827e0dc22a43580753","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"815972da4a13279b8e975d2e32ca450649d6c295":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","05a14b2611ead08655a2b2bdc61632eb31316e57","815972da4a13279b8e975d2e32ca450649d6c295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}