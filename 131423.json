{"path":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","commits":[{"id":"1cfa38e36fa296bb93d77df7d5556257dffa4535","date":1362635543,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"/dev/null","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["61d55d0cc95bfc03461b5c355153ca28c49076eb","e0571cb12a71d379cc6bd0d3b70fe1d8867a109d","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","eba342e8f50703ef6d48ac759b5fd5798b34d669"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4764d6a56926c997601171ea05e7a1ddd1ea8e9a","date":1363456411,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"25bbd8e76cd29f2d4b262a24d6a42c754706b143","date":1365910543,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b64a893a6d2efaa60e289534b1f8713e4aa2c776","date":1373480880,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e0571cb12a71d379cc6bd0d3b70fe1d8867a109d","date":1377475564,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":["1cfa38e36fa296bb93d77df7d5556257dffa4535"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3333dd7044501b4f20231ea55ab64e688285d153","date":1384785078,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            Map<String,String[]> params = req.getParameterMap();\n            // don't proxy for internal update requests\n            if (coreUrl != null && (params == null || !params.containsKey(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM))) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee1ef27d4745020ed103d5f0ce07b61ce288aa21","date":1384798766,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n            if (coreUrl != null && solrReq.getParams().get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            Map<String,String[]> params = req.getParameterMap();\n            // don't proxy for internal update requests\n            if (coreUrl != null && (params == null || !params.containsKey(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM))) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a107a8208e7664c1947b651f804058ec9a4b07a5","date":1384800721,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            //solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n            //if (coreUrl != null && solrReq.getParams().get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n            if (coreUrl != null) { \n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n            if (coreUrl != null && solrReq.getParams().get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e5ef402099a6d54398ce3ac65c0b7506bbfece5","date":1384830813,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null\n                && queryParams.get(DistributedUpdateProcessor.DISTRIB_FROM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            //solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n            //if (coreUrl != null && solrReq.getParams().get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n            if (coreUrl != null) { \n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a51acc2e27bfb18091f9395494aebe82266f7ce7","date":1385611742,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null\n                && queryParams.get(DistributedUpdateProcessor.DISTRIB_FROM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        if (ex instanceof Error) {\n          throw (Error) ex;\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          log.debug(\"Closing out SolrRequest: {}\", solrReq);\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":["1cfa38e36fa296bb93d77df7d5556257dffa4535","25bbd8e76cd29f2d4b262a24d6a42c754706b143"],"bugIntro":["dd58edae941cd399e58c1bf7f3318a77220e7c79"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eba342e8f50703ef6d48ac759b5fd5798b34d669","date":1391662062,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        if (ex instanceof Error) {\n          throw (Error) ex;\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        if (ex instanceof Error) {\n          throw (Error) ex;\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":["1cfa38e36fa296bb93d77df7d5556257dffa4535"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"afb6bf9ce227ab6aac5068547e286ecc958b8b9d","date":1394661169,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        if (ex instanceof Error) {\n          throw (Error) ex;\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        if (ex instanceof Error) {\n          throw (Error) ex;\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0622fbd990643ae4cacb693db6a0c82cf8916ae2","date":1397637446,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrServer.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrServer.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        if (ex instanceof Error) {\n          throw (Error) ex;\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        if (ex instanceof Error) {\n          throw (Error) ex;\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5a233896b7f16ac9b4ed601ef8207d98f1f0500","date":1398857046,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        if (ex instanceof Error) {\n          throw (Error) ex;\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrServer.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrServer.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        if (ex instanceof Error) {\n          throw (Error) ex;\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"992ee8958a5e702ec8978e61bea29908023389ad","date":1399584397,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        if (ex instanceof Error) {\n          throw (Error) ex;\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        if (ex instanceof Error) {\n          throw (Error) ex;\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bc3927f103b45d420c43cf38657662bf275bbf42","date":1402757170,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        if (ex instanceof Error) {\n          throw (Error) ex;\n        }\n        if (ex.getCause() != null && ex.getCause() instanceof Error)  {\n          log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          throw (Error) ex.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        if (ex instanceof Error) {\n          throw (Error) ex;\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":["dd58edae941cd399e58c1bf7f3318a77220e7c79"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        if (ex instanceof Error) {\n          throw (Error) ex;\n        }\n        if (ex.getCause() != null && ex.getCause() instanceof Error)  {\n          log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          throw (Error) ex.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        if (ex instanceof Error) {\n          throw (Error) ex;\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd58edae941cd399e58c1bf7f3318a77220e7c79","date":1403152370,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        if (ex instanceof Error) {\n          throw (Error) ex;\n        }\n        if (ex.getCause() != null && ex.getCause() instanceof Error)  {\n          log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          throw (Error) ex.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":["bc3927f103b45d420c43cf38657662bf275bbf42","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrServer.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrServer.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrServer.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrServer.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrServer.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrServer.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7947ef57ebadfb891b1c694f0772d616987e57c8","date":1412445663,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        handler = cores.getRequestHandler(path);\n        if( handler!= null ) {\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        } else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrServer.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrServer.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrServer.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrServer.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ba0abe4039f82ecf2e5f879913f512e941dde81","date":1412520276,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        handler = cores.getRequestHandler(path);\n        if( handler!= null ) {\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        } else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrServer.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrServer.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin info url\n        if( path.startsWith( \"/admin/info\" ) ) {\n          handler = cores.getInfoHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrServer.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrServer.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"531fe719c7218235a679452eb3d137bfd8fc6af1","date":1415191086,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        handler = cores.getRequestHandler(path);\n        if( handler!= null ) {\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        } else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrServer.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              /*|| path.equals(\"/config\") || path.startsWith(\"/config/\")*/) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrServer.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        handler = cores.getRequestHandler(path);\n        if( handler!= null ) {\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        } else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrServer.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              || path.equals(\"/config\") || path.startsWith(\"/config/\")) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrServer.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d805d691fbf3ca8aafa5397568ec761790b88622","date":1417093891,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        handler = cores.getRequestHandler(path);\n        if( handler!= null ) {\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        } else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrServer.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              /*|| path.equals(\"/config\") || path.startsWith(\"/config/\")*/) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrServer.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down or failed to initialize\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        handler = cores.getRequestHandler(path);\n        if( handler!= null ) {\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        } else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrServer.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              /*|| path.equals(\"/config\") || path.startsWith(\"/config/\")*/) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrServer.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7d72e80cee24be385c713864a9f1f90be3744482","date":1417420925,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        handler = cores.getRequestHandler(path);\n        if( handler!= null ) {\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        } else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrServer.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrServer.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        handler = cores.getRequestHandler(path);\n        if( handler!= null ) {\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        } else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrServer.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n          // Handle /schema/* and /config/* paths via Restlet\n          if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")\n              /*|| path.equals(\"/config\") || path.startsWith(\"/config/\")*/) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrServer.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        handler = cores.getRequestHandler(path);\n        if( handler!= null ) {\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        } else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        handler = cores.getRequestHandler(path);\n        if( handler!= null ) {\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        } else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrServer.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrServer.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fd44bec977a26a118d9e809e2de6f7edb5ca0f39","date":1421673929,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n        // Check for the core admin collections url\n        handler = cores.getRequestHandler(path);\n        if( handler!= null ) {\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        } else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a20a867de92263c94258f9778db64a5efc7956d","date":1424955868,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    //The states of client that is invalid in this request\n    Map<String, Integer> invalidStates = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            invalidStates = checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              if (invalidStates != null) {\n                //it does not make sense to send the request to a remote node\n                throw new SolrException(ErrorCode.INVALID_STATE, new String(ZkStateReader.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));\n              }\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                invalidStates = checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              if(invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da41004e1997059b4d0549fbeb56bf0858d14689","date":1425425090,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    //The states of client that is invalid in this request\n    Map<String, Integer> invalidStates = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // set a request timer which can be reused by requests if needed\n        req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            invalidStates = checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              if (invalidStates != null) {\n                //it does not make sense to send the request to a remote node\n                throw new SolrException(ErrorCode.INVALID_STATE, new String(ZkStateReader.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));\n              }\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                invalidStates = checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              if(invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    //The states of client that is invalid in this request\n    Map<String, Integer> invalidStates = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            invalidStates = checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              if (invalidStates != null) {\n                //it does not make sense to send the request to a remote node\n                throw new SolrException(ErrorCode.INVALID_STATE, new String(ZkStateReader.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));\n              }\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                invalidStates = checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              if(invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dbf528c0e702c5cbd1339b2da1cdc823fd44a925","date":1427230904,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    MDCUtils.clearMDC();\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    //The states of client that is invalid in this request\n    Map<String, Integer> invalidStates = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // set a request timer which can be reused by requests if needed\n        req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n              MDCUtils.setCore(core.getName());\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n              if (core != null)\n                MDCUtils.setCore(core.getName());\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n            MDCUtils.setCore(core.getName());\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            invalidStates = checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              if (invalidStates != null) {\n                //it does not make sense to send the request to a remote node\n                throw new SolrException(ErrorCode.INVALID_STATE, new String(ZkStateReader.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));\n              }\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n            MDCUtils.setCore(core.getName());\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                invalidStates = checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              if(invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    //The states of client that is invalid in this request\n    Map<String, Integer> invalidStates = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // set a request timer which can be reused by requests if needed\n        req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            invalidStates = checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              if (invalidStates != null) {\n                //it does not make sense to send the request to a remote node\n                throw new SolrException(ErrorCode.INVALID_STATE, new String(ZkStateReader.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));\n              }\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                invalidStates = checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              if(invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2aa46adddbe8adfa64897603da43e1551f08734","date":1427319761,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    MDCUtils.clearMDC();\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    //The states of client that is invalid in this request\n    Map<String, Integer> invalidStates = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // set a request timer which can be reused by requests if needed\n        req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n              addMDCValues(cores, core);\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n              if (core != null) {\n                addMDCValues(cores, core);\n              }\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n            addMDCValues(cores, core);\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            invalidStates = checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              if (invalidStates != null) {\n                //it does not make sense to send the request to a remote node\n                throw new SolrException(ErrorCode.INVALID_STATE, new String(ZkStateReader.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));\n              }\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n            addMDCValues(cores, core);\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                invalidStates = checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              if(invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    MDCUtils.clearMDC();\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    //The states of client that is invalid in this request\n    Map<String, Integer> invalidStates = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // set a request timer which can be reused by requests if needed\n        req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n              MDCUtils.setCore(core.getName());\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n              if (core != null)\n                MDCUtils.setCore(core.getName());\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n            MDCUtils.setCore(core.getName());\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            invalidStates = checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              if (invalidStates != null) {\n                //it does not make sense to send the request to a remote node\n                throw new SolrException(ErrorCode.INVALID_STATE, new String(ZkStateReader.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));\n              }\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n            MDCUtils.setCore(core.getName());\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                invalidStates = checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              if(invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee143fc8d2140a611b6993303cabe2c807f668eb","date":1427391184,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    MDCUtils.clearMDC();\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    //The states of client that is invalid in this request\n    Map<String, Integer> invalidStates = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // set a request timer which can be reused by requests if needed\n        req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n              addMDCValues(cores, core);\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n              if (core != null) {\n                addMDCValues(cores, core);\n              }\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n            addMDCValues(cores, core);\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            invalidStates = checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              if (invalidStates != null) {\n                //it does not make sense to send the request to a remote node\n                throw new SolrException(ErrorCode.INVALID_STATE, new String(ZkStateReader.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));\n              }\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n            if (core != null) {\n              addMDCValues(cores, core);\n            }\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                invalidStates = checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              if(invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    MDCUtils.clearMDC();\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    //The states of client that is invalid in this request\n    Map<String, Integer> invalidStates = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // set a request timer which can be reused by requests if needed\n        req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n              addMDCValues(cores, core);\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n              if (core != null) {\n                addMDCValues(cores, core);\n              }\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n            addMDCValues(cores, core);\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            invalidStates = checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              if (invalidStates != null) {\n                //it does not make sense to send the request to a remote node\n                throw new SolrException(ErrorCode.INVALID_STATE, new String(ZkStateReader.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));\n              }\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n            addMDCValues(cores, core);\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                invalidStates = checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              if(invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    MDCUtils.clearMDC();\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    //The states of client that is invalid in this request\n    Map<String, Integer> invalidStates = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // set a request timer which can be reused by requests if needed\n        req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n              addMDCValues(cores, core);\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n              if (core != null) {\n                addMDCValues(cores, core);\n              }\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n            addMDCValues(cores, core);\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            invalidStates = checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              if (invalidStates != null) {\n                //it does not make sense to send the request to a remote node\n                throw new SolrException(ErrorCode.INVALID_STATE, new String(ZkStateReader.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));\n              }\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n            if (core != null) {\n              addMDCValues(cores, core);\n            }\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                invalidStates = checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              if(invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb5af3afeddbb803fb785098176e6e177c34261b","date":1428905393,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    MDCUtils.clearMDC();\n\n    if (this.cores.isZooKeeperAware())  {\n      MDC.put(NODE_NAME_PROP, this.cores.getZkController().getNodeName());\n    }\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    //The states of client that is invalid in this request\n    Map<String, Integer> invalidStates = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // set a request timer which can be reused by requests if needed\n        req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n              addMDCValues(cores, core);\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n              if (core != null) {\n                addMDCValues(cores, core);\n              }\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n            addMDCValues(cores, core);\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            invalidStates = checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              if (invalidStates != null) {\n                //it does not make sense to send the request to a remote node\n                throw new SolrException(ErrorCode.INVALID_STATE, new String(ZkStateReader.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));\n              }\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n            if (core != null) {\n              addMDCValues(cores, core);\n            }\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                invalidStates = checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              if(invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    MDCUtils.clearMDC();\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    //The states of client that is invalid in this request\n    Map<String, Integer> invalidStates = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // set a request timer which can be reused by requests if needed\n        req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n              addMDCValues(cores, core);\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n              if (core != null) {\n                addMDCValues(cores, core);\n              }\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n            addMDCValues(cores, core);\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            invalidStates = checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              if (invalidStates != null) {\n                //it does not make sense to send the request to a remote node\n                throw new SolrException(ErrorCode.INVALID_STATE, new String(ZkStateReader.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));\n              }\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n            if (core != null) {\n              addMDCValues(cores, core);\n            }\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                invalidStates = checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              if(invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe","date":1430750405,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    MDCUtils.clearMDC();\n\n    if (this.cores.isZooKeeperAware())  {\n      MDC.put(NODE_NAME_PROP, this.cores.getZkController().getNodeName());\n    }\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    //The states of client that is invalid in this request\n    Map<String, Integer> invalidStates = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // set a request timer which can be reused by requests if needed\n        req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          solrReq.getContext().put(CoreContainer.class.getName(), cores);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n              addMDCValues(cores, core);\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n              if (core != null) {\n                addMDCValues(cores, core);\n              }\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n            addMDCValues(cores, core);\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            invalidStates = checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              if (invalidStates != null) {\n                //it does not make sense to send the request to a remote node\n                throw new SolrException(ErrorCode.INVALID_STATE, new String(ZkStateReader.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));\n              }\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n            if (core != null) {\n              addMDCValues(cores, core);\n            }\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                invalidStates = checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              if(invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    MDCUtils.clearMDC();\n\n    if (this.cores.isZooKeeperAware())  {\n      MDC.put(NODE_NAME_PROP, this.cores.getZkController().getNodeName());\n    }\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    //The states of client that is invalid in this request\n    Map<String, Integer> invalidStates = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // set a request timer which can be reused by requests if needed\n        req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n              addMDCValues(cores, core);\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n              if (core != null) {\n                addMDCValues(cores, core);\n              }\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n            addMDCValues(cores, core);\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            invalidStates = checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              if (invalidStates != null) {\n                //it does not make sense to send the request to a remote node\n                throw new SolrException(ErrorCode.INVALID_STATE, new String(ZkStateReader.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));\n              }\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n            if (core != null) {\n              addMDCValues(cores, core);\n            }\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                invalidStates = checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              if(invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a760e2135dfe20a04dea360873d4de1c6a0280bb","date":1430762855,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    HttpSolrCall call = new HttpSolrCall(this, cores, (HttpServletRequest) request, (HttpServletResponse) response, retry);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    MDCUtils.clearMDC();\n\n    if (this.cores.isZooKeeperAware())  {\n      MDC.put(NODE_NAME_PROP, this.cores.getZkController().getNodeName());\n    }\n\n    if (abortErrorMessage != null) {\n      sendError((HttpServletResponse) response, 500, abortErrorMessage);\n      return;\n    }\n\n    if (this.cores == null) {\n      sendError((HttpServletResponse) response, 503, \"Server is shutting down or failed to initialize\");\n      return;\n    }\n\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    Aliases aliases = null;\n    //The states of client that is invalid in this request\n    Map<String, Integer> invalidStates = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      String origCorename = null;\n      try {\n        // set a request timer which can be reused by requests if needed\n        req.setAttribute(SolrRequestParsers.REQUEST_TIMER_SERVLET_ATTRIBUTE, new RTimer());\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n\n        boolean usingAliases = false;\n        List<String> collectionsList = null;\n\n        // Check for container handlers\n        handler = cores.getRequestHandler(path);\n        if (handler != null) {\n          solrReq = SolrRequestParsers.DEFAULT.parse(null, path, req);\n          solrReq.getContext().put(CoreContainer.class.getName(), cores);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            \n            // look at aliases\n            if (cores.isZooKeeperAware()) {\n              origCorename = corename;\n              ZkStateReader reader = cores.getZkController().getZkStateReader();\n              aliases = reader.getAliases();\n              if (aliases != null && aliases.collectionAliasSize() > 0) {\n                usingAliases = true;\n                String alias = aliases.getCollectionAlias(corename);\n                if (alias != null) {\n                  collectionsList = StrUtils.splitSmart(alias, \",\", true);\n                  corename = collectionsList.get(0);\n                }\n              }\n            }\n            \n            core = cores.getCore(corename);\n\n            if (core != null) {\n              path = path.substring( idx );\n              addMDCValues(cores, core);\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n              if (core != null) {\n                addMDCValues(cores, core);\n              }\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n            addMDCValues(cores, core);\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename, origCorename);\n            // don't proxy for internal update requests\n            SolrParams queryParams = SolrRequestParsers.parseQueryString(req.getQueryString());\n            invalidStates = checkStateIsValid(cores, queryParams.get(CloudSolrClient.STATE_VERSION));\n            if (coreUrl != null\n                && queryParams\n                    .get(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM) == null) {\n              path = path.substring(idx);\n              if (invalidStates != null) {\n                //it does not make sense to send the request to a remote node\n                throw new SolrException(ErrorCode.INVALID_STATE, new String(ZkStateReader.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));\n              }\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            } else {\n              if (!retry) {\n                // we couldn't find a core to work with, try reloading aliases\n                // TODO: it would be nice if admin ui elements skipped this...\n                ZkStateReader reader = cores.getZkController()\n                    .getZkStateReader();\n                reader.updateAliases();\n                doFilter(request, response, chain, true);\n                return;\n              }\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n            if (core != null) {\n              addMDCValues(cores, core);\n            }\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = config.getRequestParsers();\n\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n\n            if(handler == null){\n              //may be a restlet path\n              // Handle /schema/* paths via Restlet\n              if( path.equals(\"/schema\") || path.startsWith(\"/schema/\")) {\n                solrReq = parser.parse(core, path, req);\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n                if( path.equals(req.getServletPath()) ) {\n                  // avoid endless loop - pass through to Restlet via webapp\n                  chain.doFilter(request, response);\n                } else {\n                  // forward rewritten URI (without path prefix and core/collection name) to Restlet\n                  req.getRequestDispatcher(path).forward(request, response);\n                }\n                return;\n              }\n\n            }\n            // no handler yet but allowed to handle select; let's check\n\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n\n                invalidStates = checkStateIsValid(cores,solrReq.getParams().get(CloudSolrClient.STATE_VERSION));\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            if (usingAliases) {\n              processAliases(solrReq, aliases, collectionsList);\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n                Iterator<Entry<String, String>> headers = solrRsp.httpHeaders();\n                while (headers.hasNext()) {\n                  Entry<String, String> entry = headers.next();\n                  resp.addHeader(entry.getKey(), entry.getValue());\n                }\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              if(invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        // walk the the entire cause chain to search for an Error\n        Throwable t = ex;\n        while (t != null) {\n          if (t instanceof Error)  {\n            if (t != ex)  {\n              log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n            }\n            throw (Error) t;\n          }\n          t = t.getCause();\n        }\n        return;\n      } finally {\n        try {\n          if (solrReq != null) {\n            log.debug(\"Closing out SolrRequest: {}\", solrReq);\n            solrReq.close();\n          }\n        } finally {\n          try {\n            if (core != null) {\n              core.close();\n            }\n          } finally {\n            SolrRequestInfo.clearRequestInfo();\n          }\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":["61d55d0cc95bfc03461b5c355153ca28c49076eb","2339937a3c827aac6c64360f31a9ef0aa19d3183"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cac08ebda61657f2bd130dc94173456fef381a30","date":1431669054,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    \n    // No need to even create the HttpSolrCall object if this path is excluded.\n    if(excludePatterns != null) {\n      String servletPath = ((HttpServletRequest) request).getServletPath().toString();\n      for (Pattern p : excludePatterns) {\n        Matcher matcher = p.matcher(servletPath);\n        if (matcher.lookingAt()) {\n          chain.doFilter(request, response);\n          return;\n        }\n      }\n    }\n    \n    HttpSolrCall call = new HttpSolrCall(this, cores, (HttpServletRequest) request, (HttpServletResponse) response, retry);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    HttpSolrCall call = new HttpSolrCall(this, cores, (HttpServletRequest) request, (HttpServletResponse) response, retry);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n    }\n  }\n\n","bugFix":null,"bugIntro":["9b26da217d39e3ab00cf66ccad07eb82d19d520a","2339937a3c827aac6c64360f31a9ef0aa19d3183"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58b7eb80017f1c5b32035176b965fa0cc0287d04","date":1432069816,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n\n    AtomicReference<ServletRequest> wrappedRequest = new AtomicReference();\n    if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n      return;\n    }\n    if (wrappedRequest.get() != null) {\n      request = wrappedRequest.get();\n    }\n    if (cores.getAuthenticationPlugin() != null) {\n      log.debug(\"User principal: \"+((HttpServletRequest)request).getUserPrincipal());\n    }\n\n    // No need to even create the HttpSolrCall object if this path is excluded.\n    if(excludePatterns != null) {\n      String servletPath = ((HttpServletRequest) request).getServletPath().toString();\n      for (Pattern p : excludePatterns) {\n        Matcher matcher = p.matcher(servletPath);\n        if (matcher.lookingAt()) {\n          chain.doFilter(request, response);\n          return;\n        }\n      }\n    }\n    \n    HttpSolrCall call = new HttpSolrCall(this, cores, (HttpServletRequest) request, (HttpServletResponse) response, retry);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    \n    // No need to even create the HttpSolrCall object if this path is excluded.\n    if(excludePatterns != null) {\n      String servletPath = ((HttpServletRequest) request).getServletPath().toString();\n      for (Pattern p : excludePatterns) {\n        Matcher matcher = p.matcher(servletPath);\n        if (matcher.lookingAt()) {\n          chain.doFilter(request, response);\n          return;\n        }\n      }\n    }\n    \n    HttpSolrCall call = new HttpSolrCall(this, cores, (HttpServletRequest) request, (HttpServletResponse) response, retry);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n    }\n  }\n\n","bugFix":null,"bugIntro":["2339937a3c827aac6c64360f31a9ef0aa19d3183"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6bd1c8ca465374d5739ca9d218fc502055a0af97","date":1433205401,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n\n    AtomicReference<ServletRequest> wrappedRequest = new AtomicReference();\n    if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n      return;\n    }\n    if (wrappedRequest.get() != null) {\n      request = wrappedRequest.get();\n    }\n    if (cores.getAuthenticationPlugin() != null) {\n      log.debug(\"User principal: \"+((HttpServletRequest)request).getUserPrincipal());\n    }\n\n    // No need to even create the HttpSolrCall object if this path is excluded.\n    if(excludePatterns != null) {\n      String servletPath = ((HttpServletRequest) request).getServletPath().toString();\n      for (Pattern p : excludePatterns) {\n        Matcher matcher = p.matcher(servletPath);\n        if (matcher.lookingAt()) {\n          chain.doFilter(request, response);\n          return;\n        }\n      }\n    }\n    \n    HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n\n    AtomicReference<ServletRequest> wrappedRequest = new AtomicReference();\n    if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n      return;\n    }\n    if (wrappedRequest.get() != null) {\n      request = wrappedRequest.get();\n    }\n    if (cores.getAuthenticationPlugin() != null) {\n      log.debug(\"User principal: \"+((HttpServletRequest)request).getUserPrincipal());\n    }\n\n    // No need to even create the HttpSolrCall object if this path is excluded.\n    if(excludePatterns != null) {\n      String servletPath = ((HttpServletRequest) request).getServletPath().toString();\n      for (Pattern p : excludePatterns) {\n        Matcher matcher = p.matcher(servletPath);\n        if (matcher.lookingAt()) {\n          chain.doFilter(request, response);\n          return;\n        }\n      }\n    }\n    \n    HttpSolrCall call = new HttpSolrCall(this, cores, (HttpServletRequest) request, (HttpServletResponse) response, retry);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n    }\n  }\n\n","bugFix":null,"bugIntro":["2339937a3c827aac6c64360f31a9ef0aa19d3183"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"896e12033d56085efdb7b88bd289beb2645361dc","date":1434214735,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n\n    AtomicReference<ServletRequest> wrappedRequest = new AtomicReference();\n    if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n      return;\n    }\n    if (wrappedRequest.get() != null) {\n      request = wrappedRequest.get();\n    }\n    if (cores.getAuthenticationPlugin() != null) {\n      log.debug(\"User principal: {}\", ((HttpServletRequest)request).getUserPrincipal());\n    }\n\n    // No need to even create the HttpSolrCall object if this path is excluded.\n    if(excludePatterns != null) {\n      String servletPath = ((HttpServletRequest) request).getServletPath();\n      for (Pattern p : excludePatterns) {\n        Matcher matcher = p.matcher(servletPath);\n        if (matcher.lookingAt()) {\n          chain.doFilter(request, response);\n          return;\n        }\n      }\n    }\n    \n    HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n\n    AtomicReference<ServletRequest> wrappedRequest = new AtomicReference();\n    if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n      return;\n    }\n    if (wrappedRequest.get() != null) {\n      request = wrappedRequest.get();\n    }\n    if (cores.getAuthenticationPlugin() != null) {\n      log.debug(\"User principal: \"+((HttpServletRequest)request).getUserPrincipal());\n    }\n\n    // No need to even create the HttpSolrCall object if this path is excluded.\n    if(excludePatterns != null) {\n      String servletPath = ((HttpServletRequest) request).getServletPath().toString();\n      for (Pattern p : excludePatterns) {\n        Matcher matcher = p.matcher(servletPath);\n        if (matcher.lookingAt()) {\n          chain.doFilter(request, response);\n          return;\n        }\n      }\n    }\n    \n    HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n    }\n  }\n\n","bugFix":null,"bugIntro":["9b26da217d39e3ab00cf66ccad07eb82d19d520a","2339937a3c827aac6c64360f31a9ef0aa19d3183"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3a34dae868734612eb6329aa0ef754f30bd2036","date":1438783154,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n\n    AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n    if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n      return;\n    }\n    if (wrappedRequest.get() != null) {\n      request = wrappedRequest.get();\n    }\n    if (cores.getAuthenticationPlugin() != null) {\n      log.debug(\"User principal: {}\", ((HttpServletRequest)request).getUserPrincipal());\n    }\n\n    // No need to even create the HttpSolrCall object if this path is excluded.\n    if(excludePatterns != null) {\n      String servletPath = ((HttpServletRequest) request).getServletPath();\n      for (Pattern p : excludePatterns) {\n        Matcher matcher = p.matcher(servletPath);\n        if (matcher.lookingAt()) {\n          chain.doFilter(request, response);\n          return;\n        }\n      }\n    }\n    \n    HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n\n    AtomicReference<ServletRequest> wrappedRequest = new AtomicReference();\n    if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n      return;\n    }\n    if (wrappedRequest.get() != null) {\n      request = wrappedRequest.get();\n    }\n    if (cores.getAuthenticationPlugin() != null) {\n      log.debug(\"User principal: {}\", ((HttpServletRequest)request).getUserPrincipal());\n    }\n\n    // No need to even create the HttpSolrCall object if this path is excluded.\n    if(excludePatterns != null) {\n      String servletPath = ((HttpServletRequest) request).getServletPath();\n      for (Pattern p : excludePatterns) {\n        Matcher matcher = p.matcher(servletPath);\n        if (matcher.lookingAt()) {\n          chain.doFilter(request, response);\n          return;\n        }\n      }\n    }\n    \n    HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n    }\n  }\n\n","bugFix":null,"bugIntro":["2339937a3c827aac6c64360f31a9ef0aa19d3183"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9b26da217d39e3ab00cf66ccad07eb82d19d520a","date":1442427418,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n\n    AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n    if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n      return;\n    }\n    if (wrappedRequest.get() != null) {\n      request = wrappedRequest.get();\n    }\n    if (cores.getAuthenticationPlugin() != null) {\n      log.debug(\"User principal: {}\", ((HttpServletRequest)request).getUserPrincipal());\n    }\n\n    // No need to even create the HttpSolrCall object if this path is excluded.\n    if(excludePatterns != null) {\n      String requestPath = ((HttpServletRequest) request).getServletPath();\n      String extraPath = ((HttpServletRequest)request).getPathInfo();\n      if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for testing \n        requestPath += extraPath;\n      }\n      for (Pattern p : excludePatterns) {\n        Matcher matcher = p.matcher(requestPath);\n        if (matcher.lookingAt()) {\n          chain.doFilter(request, response);\n          return;\n        }\n      }\n    }\n    \n    HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n\n    AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n    if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n      return;\n    }\n    if (wrappedRequest.get() != null) {\n      request = wrappedRequest.get();\n    }\n    if (cores.getAuthenticationPlugin() != null) {\n      log.debug(\"User principal: {}\", ((HttpServletRequest)request).getUserPrincipal());\n    }\n\n    // No need to even create the HttpSolrCall object if this path is excluded.\n    if(excludePatterns != null) {\n      String servletPath = ((HttpServletRequest) request).getServletPath();\n      for (Pattern p : excludePatterns) {\n        Matcher matcher = p.matcher(servletPath);\n        if (matcher.lookingAt()) {\n          chain.doFilter(request, response);\n          return;\n        }\n      }\n    }\n    \n    HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n    }\n  }\n\n","bugFix":["cac08ebda61657f2bd130dc94173456fef381a30","896e12033d56085efdb7b88bd289beb2645361dc"],"bugIntro":["2339937a3c827aac6c64360f31a9ef0aa19d3183"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f6b697a1588b3b4adb153935c183dc17cb878c7","date":1443042766,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n\n    if (cores == null || cores.isShutDown()) {\n      log.error(\"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n    }\n\n    AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n    if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n      return;\n    }\n    if (wrappedRequest.get() != null) {\n      request = wrappedRequest.get();\n    }\n    if (cores.getAuthenticationPlugin() != null) {\n      log.debug(\"User principal: {}\", ((HttpServletRequest)request).getUserPrincipal());\n    }\n\n    // No need to even create the HttpSolrCall object if this path is excluded.\n    if(excludePatterns != null) {\n      String requestPath = ((HttpServletRequest) request).getServletPath();\n      String extraPath = ((HttpServletRequest)request).getPathInfo();\n      if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for testing \n        requestPath += extraPath;\n      }\n      for (Pattern p : excludePatterns) {\n        Matcher matcher = p.matcher(requestPath);\n        if (matcher.lookingAt()) {\n          chain.doFilter(request, response);\n          return;\n        }\n      }\n    }\n    \n    HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n\n    AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n    if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n      return;\n    }\n    if (wrappedRequest.get() != null) {\n      request = wrappedRequest.get();\n    }\n    if (cores.getAuthenticationPlugin() != null) {\n      log.debug(\"User principal: {}\", ((HttpServletRequest)request).getUserPrincipal());\n    }\n\n    // No need to even create the HttpSolrCall object if this path is excluded.\n    if(excludePatterns != null) {\n      String requestPath = ((HttpServletRequest) request).getServletPath();\n      String extraPath = ((HttpServletRequest)request).getPathInfo();\n      if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for testing \n        requestPath += extraPath;\n      }\n      for (Pattern p : excludePatterns) {\n        Matcher matcher = p.matcher(requestPath);\n        if (matcher.lookingAt()) {\n          chain.doFilter(request, response);\n          return;\n        }\n      }\n    }\n    \n    HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n    }\n  }\n\n","bugFix":null,"bugIntro":["2339937a3c827aac6c64360f31a9ef0aa19d3183"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0651b277f58a9bdf13f89735f036e5755dc7b087","date":1450701447,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n\n    if (cores == null || cores.isShutDown()) {\n      log.error(\"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n    }\n\n    AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n    if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n      return;\n    }\n    if (wrappedRequest.get() != null) {\n      request = wrappedRequest.get();\n    }\n    if (cores.getAuthenticationPlugin() != null) {\n      log.debug(\"User principal: {}\", ((HttpServletRequest)request).getUserPrincipal());\n    }\n\n    // No need to even create the HttpSolrCall object if this path is excluded.\n    if(excludePatterns != null) {\n      String requestPath = ((HttpServletRequest) request).getServletPath();\n      String extraPath = ((HttpServletRequest)request).getPathInfo();\n      if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for testing \n        requestPath += extraPath;\n      }\n      for (Pattern p : excludePatterns) {\n        Matcher matcher = p.matcher(requestPath);\n        if (matcher.lookingAt()) {\n          chain.doFilter(request, response);\n          return;\n        }\n      }\n    }\n\n    HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n    ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n      ExecutorUtil.setServerThreadFlag(null);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n\n    if (cores == null || cores.isShutDown()) {\n      log.error(\"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n    }\n\n    AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n    if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n      return;\n    }\n    if (wrappedRequest.get() != null) {\n      request = wrappedRequest.get();\n    }\n    if (cores.getAuthenticationPlugin() != null) {\n      log.debug(\"User principal: {}\", ((HttpServletRequest)request).getUserPrincipal());\n    }\n\n    // No need to even create the HttpSolrCall object if this path is excluded.\n    if(excludePatterns != null) {\n      String requestPath = ((HttpServletRequest) request).getServletPath();\n      String extraPath = ((HttpServletRequest)request).getPathInfo();\n      if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for testing \n        requestPath += extraPath;\n      }\n      for (Pattern p : excludePatterns) {\n        Matcher matcher = p.matcher(requestPath);\n        if (matcher.lookingAt()) {\n          chain.doFilter(request, response);\n          return;\n        }\n      }\n    }\n    \n    HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n    }\n  }\n\n","bugFix":null,"bugIntro":["2339937a3c827aac6c64360f31a9ef0aa19d3183"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2339937a3c827aac6c64360f31a9ef0aa19d3183","date":1455656470,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        log.error(\"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n      }\n\n      AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been\n                                                                     // sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", ((HttpServletRequest) request).getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = ((HttpServletRequest) request).getServletPath();\n        String extraPath = ((HttpServletRequest) request).getPathInfo();\n        if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for\n                                 // testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true);\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully((HttpServletRequest) request);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n\n    if (cores == null || cores.isShutDown()) {\n      log.error(\"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n    }\n\n    AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n    if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n      return;\n    }\n    if (wrappedRequest.get() != null) {\n      request = wrappedRequest.get();\n    }\n    if (cores.getAuthenticationPlugin() != null) {\n      log.debug(\"User principal: {}\", ((HttpServletRequest)request).getUserPrincipal());\n    }\n\n    // No need to even create the HttpSolrCall object if this path is excluded.\n    if(excludePatterns != null) {\n      String requestPath = ((HttpServletRequest) request).getServletPath();\n      String extraPath = ((HttpServletRequest)request).getPathInfo();\n      if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for testing \n        requestPath += extraPath;\n      }\n      for (Pattern p : excludePatterns) {\n        Matcher matcher = p.matcher(requestPath);\n        if (matcher.lookingAt()) {\n          chain.doFilter(request, response);\n          return;\n        }\n      }\n    }\n\n    HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n    ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n    try {\n      Action result = call.call();\n      switch (result) {\n        case PASSTHROUGH:\n          chain.doFilter(request, response);\n          break;\n        case RETRY:\n          doFilter(request, response, chain, true);\n          break;\n        case FORWARD:\n          request.getRequestDispatcher(call.getPath()).forward(request, response);\n          break;\n      }  \n    } finally {\n      call.destroy();\n      ExecutorUtil.setServerThreadFlag(null);\n    }\n  }\n\n","bugFix":["9b26da217d39e3ab00cf66ccad07eb82d19d520a","58b7eb80017f1c5b32035176b965fa0cc0287d04","cac08ebda61657f2bd130dc94173456fef381a30","0651b277f58a9bdf13f89735f036e5755dc7b087","b3a34dae868734612eb6329aa0ef754f30bd2036","6bd1c8ca465374d5739ca9d218fc502055a0af97","896e12033d56085efdb7b88bd289beb2645361dc","3f6b697a1588b3b4adb153935c183dc17cb878c7","a760e2135dfe20a04dea360873d4de1c6a0280bb"],"bugIntro":["61d55d0cc95bfc03461b5c355153ca28c49076eb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"26ab43e1a461b9c1d9db0739ee0eb5caed8bc521","date":1461254038,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        log.error(\"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n      }\n\n      AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been\n                                                                     // sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      request = closeShield(request, retry);\n      response = closeShield(response, retry);\n      \n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", ((HttpServletRequest) request).getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = ((HttpServletRequest) request).getServletPath();\n        String extraPath = ((HttpServletRequest) request).getPathInfo();\n        if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for\n                                 // testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true);\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully((HttpServletRequest) request);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        log.error(\"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n      }\n\n      AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been\n                                                                     // sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", ((HttpServletRequest) request).getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = ((HttpServletRequest) request).getServletPath();\n        String extraPath = ((HttpServletRequest) request).getPathInfo();\n        if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for\n                                 // testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true);\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully((HttpServletRequest) request);\n    }\n  }\n\n","bugFix":null,"bugIntro":["61d55d0cc95bfc03461b5c355153ca28c49076eb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca","date":1461308643,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        log.error(\"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n      }\n\n      AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been\n                                                                     // sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      request = closeShield(request, retry);\n      response = closeShield(response, retry);\n      \n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", ((HttpServletRequest) request).getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = ((HttpServletRequest) request).getServletPath();\n        String extraPath = ((HttpServletRequest) request).getPathInfo();\n        if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for\n                                 // testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true);\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully((HttpServletRequest) request);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        log.error(\"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n      }\n\n      AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been\n                                                                     // sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", ((HttpServletRequest) request).getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = ((HttpServletRequest) request).getServletPath();\n        String extraPath = ((HttpServletRequest) request).getPathInfo();\n        if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for\n                                 // testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true);\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully((HttpServletRequest) request);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6130fcaa36d42a71fc464c80399af8098c42de5a","date":1493878512,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        log.error(\"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n      }\n\n      AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been\n                                                                     // sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      request = closeShield(request, retry);\n      response = closeShield(response, retry);\n      \n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", ((HttpServletRequest) request).getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = ((HttpServletRequest) request).getServletPath();\n        String extraPath = ((HttpServletRequest) request).getPathInfo();\n        if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for\n                                 // testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true);\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully((HttpServletRequest) request);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        log.error(\"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n      }\n\n      AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been\n                                                                     // sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      request = closeShield(request, retry);\n      response = closeShield(response, retry);\n      \n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", ((HttpServletRequest) request).getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = ((HttpServletRequest) request).getServletPath();\n        String extraPath = ((HttpServletRequest) request).getPathInfo();\n        if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for\n                                 // testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true);\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully((HttpServletRequest) request);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"21a62db66942c7fc8183cc7b4d395d759b87dc19","date":1494056847,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been\n                                                                     // sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      request = closeShield(request, retry);\n      response = closeShield(response, retry);\n      \n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", ((HttpServletRequest) request).getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = ((HttpServletRequest) request).getServletPath();\n        String extraPath = ((HttpServletRequest) request).getPathInfo();\n        if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for\n                                 // testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true);\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully((HttpServletRequest) request);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        log.error(\"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n      }\n\n      AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been\n                                                                     // sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      request = closeShield(request, retry);\n      response = closeShield(response, retry);\n      \n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", ((HttpServletRequest) request).getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = ((HttpServletRequest) request).getServletPath();\n        String extraPath = ((HttpServletRequest) request).getPathInfo();\n        if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for\n                                 // testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true);\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully((HttpServletRequest) request);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been\n                                                                     // sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      request = closeShield(request, retry);\n      response = closeShield(response, retry);\n      \n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", ((HttpServletRequest) request).getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = ((HttpServletRequest) request).getServletPath();\n        String extraPath = ((HttpServletRequest) request).getPathInfo();\n        if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for\n                                 // testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true);\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully((HttpServletRequest) request);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        log.error(\"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Error processing the request. CoreContainer is either not initialized or shutting down.\");\n      }\n\n      AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been\n                                                                     // sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      request = closeShield(request, retry);\n      response = closeShield(response, retry);\n      \n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", ((HttpServletRequest) request).getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = ((HttpServletRequest) request).getServletPath();\n        String extraPath = ((HttpServletRequest) request).getPathInfo();\n        if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for\n                                 // testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true);\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully((HttpServletRequest) request);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61d55d0cc95bfc03461b5c355153ca28c49076eb","date":1515469157,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = (HttpServletRequest)_request;\n    HttpServletResponse response = (HttpServletResponse)_response;\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = request.getServletPath();\n        String extraPath = request.getPathInfo();\n        if (extraPath != null) {\n          // In embedded mode, servlet path is empty - include all post-context path here for testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall(closeShield(request, retry), closeShield(response, retry), retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully(request);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been\n                                                                     // sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      request = closeShield(request, retry);\n      response = closeShield(response, retry);\n      \n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", ((HttpServletRequest) request).getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = ((HttpServletRequest) request).getServletPath();\n        String extraPath = ((HttpServletRequest) request).getPathInfo();\n        if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for\n                                 // testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true);\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully((HttpServletRequest) request);\n    }\n  }\n\n","bugFix":["26ab43e1a461b9c1d9db0739ee0eb5caed8bc521","1cfa38e36fa296bb93d77df7d5556257dffa4535","a760e2135dfe20a04dea360873d4de1c6a0280bb","2339937a3c827aac6c64360f31a9ef0aa19d3183"],"bugIntro":["53a927256ae116c84eee4e9b2d92f1530883aa98"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = (HttpServletRequest)_request;\n    HttpServletResponse response = (HttpServletResponse)_response;\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = request.getServletPath();\n        String extraPath = request.getPathInfo();\n        if (extraPath != null) {\n          // In embedded mode, servlet path is empty - include all post-context path here for testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall(closeShield(request, retry), closeShield(response, retry), retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully(request);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(request instanceof HttpServletRequest)) return;\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      AtomicReference<ServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been\n                                                                     // sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      request = closeShield(request, retry);\n      response = closeShield(response, retry);\n      \n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", ((HttpServletRequest) request).getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = ((HttpServletRequest) request).getServletPath();\n        String extraPath = ((HttpServletRequest) request).getPathInfo();\n        if (extraPath != null) { // In embedded mode, servlet path is empty - include all post-context path here for\n                                 // testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall((HttpServletRequest) request, (HttpServletResponse) response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true);\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully((HttpServletRequest) request);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b107346d6f511cbb411725ae85fa167de3cc916","date":1518457408,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = (HttpServletRequest)_request;\n    HttpServletResponse response = (HttpServletResponse)_response;\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = request.getServletPath();\n        String extraPath = request.getPathInfo();\n        if (extraPath != null) {\n          // In embedded mode, servlet path is empty - include all post-context path here for testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall(closeShield(request, retry), closeShield(response, retry), retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully(request);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = (HttpServletRequest)_request;\n    HttpServletResponse response = (HttpServletResponse)_response;\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = request.getServletPath();\n        String extraPath = request.getPathInfo();\n        if (extraPath != null) {\n          // In embedded mode, servlet path is empty - include all post-context path here for testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall(closeShield(request, retry), closeShield(response, retry), retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully(request);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bfcdec9fcf0409223f35c5ec3bc14094314941b4","date":1518533599,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = (HttpServletRequest)_request;\n    HttpServletResponse response = (HttpServletResponse)_response;\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = request.getServletPath();\n        String extraPath = request.getPathInfo();\n        if (extraPath != null) {\n          // In embedded mode, servlet path is empty - include all post-context path here for testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall(closeShield(request, retry), closeShield(response, retry), retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully(request);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = (HttpServletRequest)_request;\n    HttpServletResponse response = (HttpServletResponse)_response;\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = request.getServletPath();\n        String extraPath = request.getPathInfo();\n        if (extraPath != null) {\n          // In embedded mode, servlet path is empty - include all post-context path here for testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall(closeShield(request, retry), closeShield(response, retry), retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully(request);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac35531329b1809368fb0780bcf1e72d0add3c21","date":1525474926,"type":3,"author":"Mark Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = request.getServletPath();\n        String extraPath = request.getPathInfo();\n        if (extraPath != null) {\n          // In embedded mode, servlet path is empty - include all post-context path here for testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully(request);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = (HttpServletRequest)_request;\n    HttpServletResponse response = (HttpServletResponse)_response;\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = request.getServletPath();\n        String extraPath = request.getPathInfo();\n        if (extraPath != null) {\n          // In embedded mode, servlet path is empty - include all post-context path here for testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall(closeShield(request, retry), closeShield(response, retry), retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully(request);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4e5b14c1a3febf27d88acf3083b7551876933aa5","date":1544607443,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = request.getServletPath();\n        String extraPath = request.getPathInfo();\n        if (extraPath != null) {\n          // In embedded mode, servlet path is empty - include all post-context path here for testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully(request);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = request.getServletPath();\n        String extraPath = request.getPathInfo();\n        if (extraPath != null) {\n          // In embedded mode, servlet path is empty - include all post-context path here for testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully(request);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cbaf96cfda5422c42955ce34344f0e01839894ea","date":1559675051,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    Scope scope = null;\n    Span span = null;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      String requestPath = request.getServletPath();\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String extraPath = request.getPathInfo();\n        if (extraPath != null) {\n          // In embedded mode, servlet path is empty - include all post-context path here for testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      SpanContext parentSpan = GlobalTracer.get().extract(request);\n      Tracer tracer = GlobalTracer.getTracer();\n\n      Tracer.SpanBuilder spanBuilder = null;\n      String hostAndPort = request.getServerName() + \"_\" + request.getServerPort();\n      if (parentSpan == null) {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort);\n      } else {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort)\n            .asChildOf(parentSpan);\n      }\n\n      spanBuilder\n          .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n          .withTag(Tags.HTTP_URL.getKey(), request.getRequestURL().toString());\n      span = spanBuilder.start();\n      scope = tracer.scopeManager().activate(span);\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      if (span != null) span.finish();\n      if (scope != null) scope.close();\n\n      GlobalTracer.get().clearContext();\n      consumeInputFully(request);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    \n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String requestPath = request.getServletPath();\n        String extraPath = request.getPathInfo();\n        if (extraPath != null) {\n          // In embedded mode, servlet path is empty - include all post-context path here for testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      consumeInputFully(request);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"de1f4f89cef95d8efa9877bdd893d1b542c9b140","date":1574241654,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    Scope scope = null;\n    Span span = null;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      String requestPath = ServletUtils.getPathAfterContext(request);\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      SpanContext parentSpan = GlobalTracer.get().extract(request);\n      Tracer tracer = GlobalTracer.getTracer();\n\n      Tracer.SpanBuilder spanBuilder = null;\n      String hostAndPort = request.getServerName() + \"_\" + request.getServerPort();\n      if (parentSpan == null) {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort);\n      } else {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort)\n            .asChildOf(parentSpan);\n      }\n\n      spanBuilder\n          .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n          .withTag(Tags.HTTP_URL.getKey(), request.getRequestURL().toString());\n      span = spanBuilder.start();\n      scope = tracer.scopeManager().activate(span);\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      if (span != null) span.finish();\n      if (scope != null) scope.close();\n\n      GlobalTracer.get().clearContext();\n      consumeInputFully(request);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    Scope scope = null;\n    Span span = null;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      String requestPath = request.getServletPath();\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        String extraPath = request.getPathInfo();\n        if (extraPath != null) {\n          // In embedded mode, servlet path is empty - include all post-context path here for testing\n          requestPath += extraPath;\n        }\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      SpanContext parentSpan = GlobalTracer.get().extract(request);\n      Tracer tracer = GlobalTracer.getTracer();\n\n      Tracer.SpanBuilder spanBuilder = null;\n      String hostAndPort = request.getServerName() + \"_\" + request.getServerPort();\n      if (parentSpan == null) {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort);\n      } else {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort)\n            .asChildOf(parentSpan);\n      }\n\n      spanBuilder\n          .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n          .withTag(Tags.HTTP_URL.getKey(), request.getRequestURL().toString());\n      span = spanBuilder.start();\n      scope = tracer.scopeManager().activate(span);\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      if (span != null) span.finish();\n      if (scope != null) scope.close();\n\n      GlobalTracer.get().clearContext();\n      consumeInputFully(request);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"53a927256ae116c84eee4e9b2d92f1530883aa98","date":1582277410,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    Scope scope = null;\n    Span span = null;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      String requestPath = ServletUtils.getPathAfterContext(request);\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      SpanContext parentSpan = GlobalTracer.get().extract(request);\n      Tracer tracer = GlobalTracer.getTracer();\n\n      Tracer.SpanBuilder spanBuilder = null;\n      String hostAndPort = request.getServerName() + \"_\" + request.getServerPort();\n      if (parentSpan == null) {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort);\n      } else {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort)\n            .asChildOf(parentSpan);\n      }\n\n      spanBuilder\n          .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n          .withTag(Tags.HTTP_URL.getKey(), request.getRequestURL().toString());\n      span = spanBuilder.start();\n      scope = tracer.scopeManager().activate(span);\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      if (span != null) span.finish();\n      if (scope != null) scope.close();\n\n      GlobalTracer.get().clearContext();\n      consumeInputFully(request, response);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    Scope scope = null;\n    Span span = null;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      String requestPath = ServletUtils.getPathAfterContext(request);\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      SpanContext parentSpan = GlobalTracer.get().extract(request);\n      Tracer tracer = GlobalTracer.getTracer();\n\n      Tracer.SpanBuilder spanBuilder = null;\n      String hostAndPort = request.getServerName() + \"_\" + request.getServerPort();\n      if (parentSpan == null) {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort);\n      } else {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort)\n            .asChildOf(parentSpan);\n      }\n\n      spanBuilder\n          .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n          .withTag(Tags.HTTP_URL.getKey(), request.getRequestURL().toString());\n      span = spanBuilder.start();\n      scope = tracer.scopeManager().activate(span);\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      if (span != null) span.finish();\n      if (scope != null) scope.close();\n\n      GlobalTracer.get().clearContext();\n      consumeInputFully(request);\n    }\n  }\n\n","bugFix":["61d55d0cc95bfc03461b5c355153ca28c49076eb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54faedfb0e03479a38f5ee82f2dfaeea536e9404","date":1587251295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    Scope scope = null;\n    Span span = null;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      String requestPath = ServletUtils.getPathAfterContext(request);\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      SpanContext parentSpan = GlobalTracer.get().extract(request);\n      Tracer tracer = GlobalTracer.getTracer();\n\n      Tracer.SpanBuilder spanBuilder = null;\n      String hostAndPort = request.getServerName() + \"_\" + request.getServerPort();\n      if (parentSpan == null) {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort);\n      } else {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort)\n            .asChildOf(parentSpan);\n      }\n\n      spanBuilder\n          .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n          .withTag(Tags.HTTP_URL.getKey(), request.getRequestURL().toString());\n      span = spanBuilder.start();\n      scope = tracer.scopeManager().activate(span);\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"User principal: {}\", request.getUserPrincipal());\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      if (span != null) span.finish();\n      if (scope != null) scope.close();\n\n      GlobalTracer.get().clearContext();\n      consumeInputFully(request, response);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    Scope scope = null;\n    Span span = null;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      String requestPath = ServletUtils.getPathAfterContext(request);\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      SpanContext parentSpan = GlobalTracer.get().extract(request);\n      Tracer tracer = GlobalTracer.getTracer();\n\n      Tracer.SpanBuilder spanBuilder = null;\n      String hostAndPort = request.getServerName() + \"_\" + request.getServerPort();\n      if (parentSpan == null) {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort);\n      } else {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort)\n            .asChildOf(parentSpan);\n      }\n\n      spanBuilder\n          .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n          .withTag(Tags.HTTP_URL.getKey(), request.getRequestURL().toString());\n      span = spanBuilder.start();\n      scope = tracer.scopeManager().activate(span);\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        log.debug(\"User principal: {}\", request.getUserPrincipal());\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      if (span != null) span.finish();\n      if (scope != null) scope.close();\n\n      GlobalTracer.get().clearContext();\n      consumeInputFully(request, response);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac5c4637fb06d45efdeaf0f2d262b133ab2de181","date":1590122088,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    Scope scope = null;\n    Span span = null;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      String requestPath = ServletUtils.getPathAfterContext(request);\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      SpanContext parentSpan = GlobalTracer.get().extract(request);\n      Tracer tracer = GlobalTracer.getTracer();\n\n      Tracer.SpanBuilder spanBuilder = null;\n      String hostAndPort = request.getServerName() + \"_\" + request.getServerPort();\n      if (parentSpan == null) {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort);\n      } else {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort)\n            .asChildOf(parentSpan);\n      }\n\n      spanBuilder\n          .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n          .withTag(Tags.HTTP_URL.getKey(), request.getRequestURL().toString());\n      span = spanBuilder.start();\n      scope = tracer.scopeManager().activate(span);\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"User principal: {}\", request.getUserPrincipal());\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      if (span != null) span.finish();\n      if (scope != null) scope.close();\n\n      GlobalTracer.get().clearContext();\n      consumeInputFully(request, response);\n      SolrRequestParsers.cleanupMultipartFiles(request);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    Scope scope = null;\n    Span span = null;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      String requestPath = ServletUtils.getPathAfterContext(request);\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      SpanContext parentSpan = GlobalTracer.get().extract(request);\n      Tracer tracer = GlobalTracer.getTracer();\n\n      Tracer.SpanBuilder spanBuilder = null;\n      String hostAndPort = request.getServerName() + \"_\" + request.getServerPort();\n      if (parentSpan == null) {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort);\n      } else {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort)\n            .asChildOf(parentSpan);\n      }\n\n      spanBuilder\n          .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n          .withTag(Tags.HTTP_URL.getKey(), request.getRequestURL().toString());\n      span = spanBuilder.start();\n      scope = tracer.scopeManager().activate(span);\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"User principal: {}\", request.getUserPrincipal());\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      if (span != null) span.finish();\n      if (scope != null) scope.close();\n\n      GlobalTracer.get().clearContext();\n      consumeInputFully(request, response);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4","date":1592286410,"type":3,"author":"Nazerke Seidan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    Scope scope = null;\n    Span span = null;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      String requestPath = ServletUtils.getPathAfterContext(request);\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      SpanContext parentSpan = GlobalTracer.get().extract(request);\n      Tracer tracer = GlobalTracer.getTracer();\n\n      Tracer.SpanBuilder spanBuilder = null;\n      String hostAndPort = request.getServerName() + \"_\" + request.getServerPort();\n      if (parentSpan == null) {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort);\n      } else {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort)\n            .asChildOf(parentSpan);\n      }\n\n      spanBuilder\n          .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n          .withTag(Tags.HTTP_URL.getKey(), request.getRequestURL().toString());\n      span = spanBuilder.start();\n      scope = tracer.scopeManager().activate(span);\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"User principal: {}\", request.getUserPrincipal());\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      if (span != null) span.finish();\n      if (scope != null) scope.close();\n\n      GlobalTracer.get().clearContext();\n      consumeInputFully(request, response);\n      SolrRequestInfo.reset();\n      SolrRequestParsers.cleanupMultipartFiles(request);\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    Scope scope = null;\n    Span span = null;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      String requestPath = ServletUtils.getPathAfterContext(request);\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      SpanContext parentSpan = GlobalTracer.get().extract(request);\n      Tracer tracer = GlobalTracer.getTracer();\n\n      Tracer.SpanBuilder spanBuilder = null;\n      String hostAndPort = request.getServerName() + \"_\" + request.getServerPort();\n      if (parentSpan == null) {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort);\n      } else {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort)\n            .asChildOf(parentSpan);\n      }\n\n      spanBuilder\n          .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n          .withTag(Tags.HTTP_URL.getKey(), request.getRequestURL().toString());\n      span = spanBuilder.start();\n      scope = tracer.scopeManager().activate(span);\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"User principal: {}\", request.getUserPrincipal());\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      if (span != null) span.finish();\n      if (scope != null) scope.close();\n\n      GlobalTracer.get().clearContext();\n      consumeInputFully(request, response);\n      SolrRequestParsers.cleanupMultipartFiles(request);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c99002731351c8c955238845b0038682148eec53","date":1596830766,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain,boolean).mjava","sourceNew":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    Scope scope = null;\n    Span span = null;\n    boolean accepted = false;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      String requestPath = ServletUtils.getPathAfterContext(request);\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      try {\n        accepted = rateLimitManager.handleRequest(request);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage());\n      }\n\n      if (!accepted) {\n        String errorMessage = \"Too many requests for this request type.\" +\n            \"Please try after some time or increase the quota for this request type\";\n\n        response.sendError(429, errorMessage);\n      }\n\n      SpanContext parentSpan = GlobalTracer.get().extract(request);\n      Tracer tracer = GlobalTracer.getTracer();\n\n      Tracer.SpanBuilder spanBuilder = null;\n      String hostAndPort = request.getServerName() + \"_\" + request.getServerPort();\n      if (parentSpan == null) {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort);\n      } else {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort)\n            .asChildOf(parentSpan);\n      }\n\n      spanBuilder\n          .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n          .withTag(Tags.HTTP_URL.getKey(), request.getRequestURL().toString());\n      span = spanBuilder.start();\n      scope = tracer.scopeManager().activate(span);\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"User principal: {}\", request.getUserPrincipal());\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      if (span != null) span.finish();\n      if (scope != null) scope.close();\n\n      GlobalTracer.get().clearContext();\n      consumeInputFully(request, response);\n      SolrRequestInfo.reset();\n      SolrRequestParsers.cleanupMultipartFiles(request);\n\n      if (accepted) {\n        rateLimitManager.decrementActiveRequests(request);\n      }\n    }\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest _request, ServletResponse _response, FilterChain chain, boolean retry) throws IOException, ServletException {\n    if (!(_request instanceof HttpServletRequest)) return;\n    HttpServletRequest request = closeShield((HttpServletRequest)_request, retry);\n    HttpServletResponse response = closeShield((HttpServletResponse)_response, retry);\n    Scope scope = null;\n    Span span = null;\n    try {\n\n      if (cores == null || cores.isShutDown()) {\n        try {\n          init.await();\n        } catch (InterruptedException e) { //well, no wait then\n        }\n        final String msg = \"Error processing the request. CoreContainer is either not initialized or shutting down.\";\n        if (cores == null || cores.isShutDown()) {\n          log.error(msg);\n          throw new UnavailableException(msg);\n        }\n      }\n\n      String requestPath = ServletUtils.getPathAfterContext(request);\n      // No need to even create the HttpSolrCall object if this path is excluded.\n      if (excludePatterns != null) {\n        for (Pattern p : excludePatterns) {\n          Matcher matcher = p.matcher(requestPath);\n          if (matcher.lookingAt()) {\n            chain.doFilter(request, response);\n            return;\n          }\n        }\n      }\n\n      SpanContext parentSpan = GlobalTracer.get().extract(request);\n      Tracer tracer = GlobalTracer.getTracer();\n\n      Tracer.SpanBuilder spanBuilder = null;\n      String hostAndPort = request.getServerName() + \"_\" + request.getServerPort();\n      if (parentSpan == null) {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort);\n      } else {\n        spanBuilder = tracer.buildSpan(request.getMethod() + \":\" + hostAndPort)\n            .asChildOf(parentSpan);\n      }\n\n      spanBuilder\n          .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)\n          .withTag(Tags.HTTP_URL.getKey(), request.getRequestURL().toString());\n      span = spanBuilder.start();\n      scope = tracer.scopeManager().activate(span);\n\n      AtomicReference<HttpServletRequest> wrappedRequest = new AtomicReference<>();\n      if (!authenticateRequest(request, response, wrappedRequest)) { // the response and status code have already been sent\n        return;\n      }\n      if (wrappedRequest.get() != null) {\n        request = wrappedRequest.get();\n      }\n\n      if (cores.getAuthenticationPlugin() != null) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"User principal: {}\", request.getUserPrincipal());\n        }\n      }\n\n      HttpSolrCall call = getHttpSolrCall(request, response, retry);\n      ExecutorUtil.setServerThreadFlag(Boolean.TRUE);\n      try {\n        Action result = call.call();\n        switch (result) {\n          case PASSTHROUGH:\n            chain.doFilter(request, response);\n            break;\n          case RETRY:\n            doFilter(request, response, chain, true); // RECURSION\n            break;\n          case FORWARD:\n            request.getRequestDispatcher(call.getPath()).forward(request, response);\n            break;\n          case ADMIN:\n          case PROCESS:\n          case REMOTEQUERY:\n          case RETURN:\n            break;\n        }\n      } finally {\n        call.destroy();\n        ExecutorUtil.setServerThreadFlag(null);\n      }\n    } finally {\n      if (span != null) span.finish();\n      if (scope != null) scope.close();\n\n      GlobalTracer.get().clearContext();\n      consumeInputFully(request, response);\n      SolrRequestInfo.reset();\n      SolrRequestParsers.cleanupMultipartFiles(request);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a107a8208e7664c1947b651f804058ec9a4b07a5":["ee1ef27d4745020ed103d5f0ce07b61ce288aa21"],"4764d6a56926c997601171ea05e7a1ddd1ea8e9a":["1cfa38e36fa296bb93d77df7d5556257dffa4535"],"b94236357aaa22b76c10629851fe4e376e0cea82":["21a62db66942c7fc8183cc7b4d395d759b87dc19","61d55d0cc95bfc03461b5c355153ca28c49076eb"],"58b7eb80017f1c5b32035176b965fa0cc0287d04":["cac08ebda61657f2bd130dc94173456fef381a30"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["25bbd8e76cd29f2d4b262a24d6a42c754706b143","b64a893a6d2efaa60e289534b1f8713e4aa2c776"],"1cfa38e36fa296bb93d77df7d5556257dffa4535":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0651b277f58a9bdf13f89735f036e5755dc7b087":["3f6b697a1588b3b4adb153935c183dc17cb878c7"],"3e5ef402099a6d54398ce3ac65c0b7506bbfece5":["a107a8208e7664c1947b651f804058ec9a4b07a5"],"992ee8958a5e702ec8978e61bea29908023389ad":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca","21a62db66942c7fc8183cc7b4d395d759b87dc19"],"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["53a927256ae116c84eee4e9b2d92f1530883aa98"],"d805d691fbf3ca8aafa5397568ec761790b88622":["531fe719c7218235a679452eb3d137bfd8fc6af1"],"b64a893a6d2efaa60e289534b1f8713e4aa2c776":["25bbd8e76cd29f2d4b262a24d6a42c754706b143"],"7b107346d6f511cbb411725ae85fa167de3cc916":["b94236357aaa22b76c10629851fe4e376e0cea82"],"6130fcaa36d42a71fc464c80399af8098c42de5a":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca"],"26ab43e1a461b9c1d9db0739ee0eb5caed8bc521":["2339937a3c827aac6c64360f31a9ef0aa19d3183"],"3f6b697a1588b3b4adb153935c183dc17cb878c7":["9b26da217d39e3ab00cf66ccad07eb82d19d520a"],"6bd1c8ca465374d5739ca9d218fc502055a0af97":["58b7eb80017f1c5b32035176b965fa0cc0287d04"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["a51acc2e27bfb18091f9395494aebe82266f7ce7"],"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca":["2339937a3c827aac6c64360f31a9ef0aa19d3183","26ab43e1a461b9c1d9db0739ee0eb5caed8bc521"],"afb6bf9ce227ab6aac5068547e286ecc958b8b9d":["eba342e8f50703ef6d48ac759b5fd5798b34d669"],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["cb5af3afeddbb803fb785098176e6e177c34261b"],"da41004e1997059b4d0549fbeb56bf0858d14689":["0a20a867de92263c94258f9778db64a5efc7956d"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"21a62db66942c7fc8183cc7b4d395d759b87dc19":["6130fcaa36d42a71fc464c80399af8098c42de5a"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["992ee8958a5e702ec8978e61bea29908023389ad","bc3927f103b45d420c43cf38657662bf275bbf42"],"eba342e8f50703ef6d48ac759b5fd5798b34d669":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"e0571cb12a71d379cc6bd0d3b70fe1d8867a109d":["b64a893a6d2efaa60e289534b1f8713e4aa2c776"],"53a927256ae116c84eee4e9b2d92f1530883aa98":["de1f4f89cef95d8efa9877bdd893d1b542c9b140"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["e0571cb12a71d379cc6bd0d3b70fe1d8867a109d","a51acc2e27bfb18091f9395494aebe82266f7ce7"],"25bbd8e76cd29f2d4b262a24d6a42c754706b143":["4764d6a56926c997601171ea05e7a1ddd1ea8e9a"],"cb5af3afeddbb803fb785098176e6e177c34261b":["ee143fc8d2140a611b6993303cabe2c807f668eb"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["afb6bf9ce227ab6aac5068547e286ecc958b8b9d"],"3333dd7044501b4f20231ea55ab64e688285d153":["e0571cb12a71d379cc6bd0d3b70fe1d8867a109d"],"ac5c4637fb06d45efdeaf0f2d262b133ab2de181":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"9b26da217d39e3ab00cf66ccad07eb82d19d520a":["b3a34dae868734612eb6329aa0ef754f30bd2036"],"2339937a3c827aac6c64360f31a9ef0aa19d3183":["0651b277f58a9bdf13f89735f036e5755dc7b087"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"fd44bec977a26a118d9e809e2de6f7edb5ca0f39":["bafca15d8e408346a67f4282ad1143b88023893b"],"b3a34dae868734612eb6329aa0ef754f30bd2036":["896e12033d56085efdb7b88bd289beb2645361dc"],"bafca15d8e408346a67f4282ad1143b88023893b":["7d72e80cee24be385c713864a9f1f90be3744482"],"bc3927f103b45d420c43cf38657662bf275bbf42":["992ee8958a5e702ec8978e61bea29908023389ad"],"bfcdec9fcf0409223f35c5ec3bc14094314941b4":["b94236357aaa22b76c10629851fe4e376e0cea82","7b107346d6f511cbb411725ae85fa167de3cc916"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["fd44bec977a26a118d9e809e2de6f7edb5ca0f39","ee143fc8d2140a611b6993303cabe2c807f668eb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"896e12033d56085efdb7b88bd289beb2645361dc":["6bd1c8ca465374d5739ca9d218fc502055a0af97"],"d2aa46adddbe8adfa64897603da43e1551f08734":["dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"dd58edae941cd399e58c1bf7f3318a77220e7c79":["bc3927f103b45d420c43cf38657662bf275bbf42"],"ee1ef27d4745020ed103d5f0ce07b61ce288aa21":["3333dd7044501b4f20231ea55ab64e688285d153"],"0a20a867de92263c94258f9778db64a5efc7956d":["fd44bec977a26a118d9e809e2de6f7edb5ca0f39"],"531fe719c7218235a679452eb3d137bfd8fc6af1":["7947ef57ebadfb891b1c694f0772d616987e57c8"],"7d72e80cee24be385c713864a9f1f90be3744482":["d805d691fbf3ca8aafa5397568ec761790b88622"],"cac08ebda61657f2bd130dc94173456fef381a30":["a760e2135dfe20a04dea360873d4de1c6a0280bb"],"ee143fc8d2140a611b6993303cabe2c807f668eb":["d2aa46adddbe8adfa64897603da43e1551f08734"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["37a0f60745e53927c4c876cfe5b5a58170f0646c","e0571cb12a71d379cc6bd0d3b70fe1d8867a109d"],"a760e2135dfe20a04dea360873d4de1c6a0280bb":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"de1f4f89cef95d8efa9877bdd893d1b542c9b140":["cbaf96cfda5422c42955ce34344f0e01839894ea"],"ac35531329b1809368fb0780bcf1e72d0add3c21":["bfcdec9fcf0409223f35c5ec3bc14094314941b4"],"a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4":["ac5c4637fb06d45efdeaf0f2d262b133ab2de181"],"5ba0abe4039f82ecf2e5f879913f512e941dde81":["9279b175e5e66258442d2123a50f052219a9cc1b","7947ef57ebadfb891b1c694f0772d616987e57c8"],"9279b175e5e66258442d2123a50f052219a9cc1b":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"61d55d0cc95bfc03461b5c355153ca28c49076eb":["21a62db66942c7fc8183cc7b4d395d759b87dc19"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["dd58edae941cd399e58c1bf7f3318a77220e7c79"],"cbaf96cfda5422c42955ce34344f0e01839894ea":["4e5b14c1a3febf27d88acf3083b7551876933aa5"],"a51acc2e27bfb18091f9395494aebe82266f7ce7":["3e5ef402099a6d54398ce3ac65c0b7506bbfece5"],"4e5b14c1a3febf27d88acf3083b7551876933aa5":["ac35531329b1809368fb0780bcf1e72d0add3c21"],"c99002731351c8c955238845b0038682148eec53":["a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c99002731351c8c955238845b0038682148eec53"],"dbf528c0e702c5cbd1339b2da1cdc823fd44a925":["da41004e1997059b4d0549fbeb56bf0858d14689"],"7947ef57ebadfb891b1c694f0772d616987e57c8":["9279b175e5e66258442d2123a50f052219a9cc1b"]},"commit2Childs":{"a107a8208e7664c1947b651f804058ec9a4b07a5":["3e5ef402099a6d54398ce3ac65c0b7506bbfece5"],"4764d6a56926c997601171ea05e7a1ddd1ea8e9a":["25bbd8e76cd29f2d4b262a24d6a42c754706b143"],"b94236357aaa22b76c10629851fe4e376e0cea82":["7b107346d6f511cbb411725ae85fa167de3cc916","bfcdec9fcf0409223f35c5ec3bc14094314941b4"],"58b7eb80017f1c5b32035176b965fa0cc0287d04":["6bd1c8ca465374d5739ca9d218fc502055a0af97"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"1cfa38e36fa296bb93d77df7d5556257dffa4535":["4764d6a56926c997601171ea05e7a1ddd1ea8e9a"],"0651b277f58a9bdf13f89735f036e5755dc7b087":["2339937a3c827aac6c64360f31a9ef0aa19d3183"],"3e5ef402099a6d54398ce3ac65c0b7506bbfece5":["a51acc2e27bfb18091f9395494aebe82266f7ce7"],"992ee8958a5e702ec8978e61bea29908023389ad":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","bc3927f103b45d420c43cf38657662bf275bbf42"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["ac5c4637fb06d45efdeaf0f2d262b133ab2de181"],"d805d691fbf3ca8aafa5397568ec761790b88622":["7d72e80cee24be385c713864a9f1f90be3744482"],"b64a893a6d2efaa60e289534b1f8713e4aa2c776":["37a0f60745e53927c4c876cfe5b5a58170f0646c","e0571cb12a71d379cc6bd0d3b70fe1d8867a109d"],"7b107346d6f511cbb411725ae85fa167de3cc916":["bfcdec9fcf0409223f35c5ec3bc14094314941b4"],"6130fcaa36d42a71fc464c80399af8098c42de5a":["21a62db66942c7fc8183cc7b4d395d759b87dc19"],"26ab43e1a461b9c1d9db0739ee0eb5caed8bc521":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca"],"3f6b697a1588b3b4adb153935c183dc17cb878c7":["0651b277f58a9bdf13f89735f036e5755dc7b087"],"6bd1c8ca465374d5739ca9d218fc502055a0af97":["896e12033d56085efdb7b88bd289beb2645361dc"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["eba342e8f50703ef6d48ac759b5fd5798b34d669"],"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca":["e9017cf144952056066919f1ebc7897ff9bd71b1","6130fcaa36d42a71fc464c80399af8098c42de5a"],"afb6bf9ce227ab6aac5068547e286ecc958b8b9d":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["a760e2135dfe20a04dea360873d4de1c6a0280bb"],"da41004e1997059b4d0549fbeb56bf0858d14689":["dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["9279b175e5e66258442d2123a50f052219a9cc1b"],"21a62db66942c7fc8183cc7b4d395d759b87dc19":["b94236357aaa22b76c10629851fe4e376e0cea82","e9017cf144952056066919f1ebc7897ff9bd71b1","61d55d0cc95bfc03461b5c355153ca28c49076eb"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"eba342e8f50703ef6d48ac759b5fd5798b34d669":["afb6bf9ce227ab6aac5068547e286ecc958b8b9d"],"e0571cb12a71d379cc6bd0d3b70fe1d8867a109d":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","3333dd7044501b4f20231ea55ab64e688285d153","3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"53a927256ae116c84eee4e9b2d92f1530883aa98":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"25bbd8e76cd29f2d4b262a24d6a42c754706b143":["37a0f60745e53927c4c876cfe5b5a58170f0646c","b64a893a6d2efaa60e289534b1f8713e4aa2c776"],"cb5af3afeddbb803fb785098176e6e177c34261b":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"3333dd7044501b4f20231ea55ab64e688285d153":["ee1ef27d4745020ed103d5f0ce07b61ce288aa21"],"ac5c4637fb06d45efdeaf0f2d262b133ab2de181":["a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4"],"9b26da217d39e3ab00cf66ccad07eb82d19d520a":["3f6b697a1588b3b4adb153935c183dc17cb878c7"],"2339937a3c827aac6c64360f31a9ef0aa19d3183":["26ab43e1a461b9c1d9db0739ee0eb5caed8bc521","ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["992ee8958a5e702ec8978e61bea29908023389ad"],"fd44bec977a26a118d9e809e2de6f7edb5ca0f39":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0a20a867de92263c94258f9778db64a5efc7956d"],"b3a34dae868734612eb6329aa0ef754f30bd2036":["9b26da217d39e3ab00cf66ccad07eb82d19d520a"],"bafca15d8e408346a67f4282ad1143b88023893b":["fd44bec977a26a118d9e809e2de6f7edb5ca0f39"],"bc3927f103b45d420c43cf38657662bf275bbf42":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","dd58edae941cd399e58c1bf7f3318a77220e7c79"],"bfcdec9fcf0409223f35c5ec3bc14094314941b4":["ac35531329b1809368fb0780bcf1e72d0add3c21"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1cfa38e36fa296bb93d77df7d5556257dffa4535"],"896e12033d56085efdb7b88bd289beb2645361dc":["b3a34dae868734612eb6329aa0ef754f30bd2036"],"d2aa46adddbe8adfa64897603da43e1551f08734":["ee143fc8d2140a611b6993303cabe2c807f668eb"],"ee1ef27d4745020ed103d5f0ce07b61ce288aa21":["a107a8208e7664c1947b651f804058ec9a4b07a5"],"dd58edae941cd399e58c1bf7f3318a77220e7c79":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"531fe719c7218235a679452eb3d137bfd8fc6af1":["d805d691fbf3ca8aafa5397568ec761790b88622"],"0a20a867de92263c94258f9778db64a5efc7956d":["da41004e1997059b4d0549fbeb56bf0858d14689"],"7d72e80cee24be385c713864a9f1f90be3744482":["bafca15d8e408346a67f4282ad1143b88023893b"],"cac08ebda61657f2bd130dc94173456fef381a30":["58b7eb80017f1c5b32035176b965fa0cc0287d04"],"ee143fc8d2140a611b6993303cabe2c807f668eb":["cb5af3afeddbb803fb785098176e6e177c34261b","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"a760e2135dfe20a04dea360873d4de1c6a0280bb":["cac08ebda61657f2bd130dc94173456fef381a30"],"de1f4f89cef95d8efa9877bdd893d1b542c9b140":["53a927256ae116c84eee4e9b2d92f1530883aa98"],"ac35531329b1809368fb0780bcf1e72d0add3c21":["4e5b14c1a3febf27d88acf3083b7551876933aa5"],"a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4":["c99002731351c8c955238845b0038682148eec53"],"5ba0abe4039f82ecf2e5f879913f512e941dde81":[],"9279b175e5e66258442d2123a50f052219a9cc1b":["5ba0abe4039f82ecf2e5f879913f512e941dde81","7947ef57ebadfb891b1c694f0772d616987e57c8"],"61d55d0cc95bfc03461b5c355153ca28c49076eb":["b94236357aaa22b76c10629851fe4e376e0cea82"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"a51acc2e27bfb18091f9395494aebe82266f7ce7":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"cbaf96cfda5422c42955ce34344f0e01839894ea":["de1f4f89cef95d8efa9877bdd893d1b542c9b140"],"4e5b14c1a3febf27d88acf3083b7551876933aa5":["cbaf96cfda5422c42955ce34344f0e01839894ea"],"c99002731351c8c955238845b0038682148eec53":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dbf528c0e702c5cbd1339b2da1cdc823fd44a925":["d2aa46adddbe8adfa64897603da43e1551f08734"],"7947ef57ebadfb891b1c694f0772d616987e57c8":["531fe719c7218235a679452eb3d137bfd8fc6af1","5ba0abe4039f82ecf2e5f879913f512e941dde81"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","c6f080a2ab37c464dd98db173f6cbf10dc74f211","74f45af4339b0daf7a95c820ab88c1aea74fbce0","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","5ba0abe4039f82ecf2e5f879913f512e941dde81","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}