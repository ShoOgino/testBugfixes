{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","commits":[{"id":"c761d502ca1f6c5324aa909468ebc4f761c92c1f","date":1412431978,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new BaseDirectory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        isOpen = false;\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void renameFile(String source, String dest) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock makeLock(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void clearLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bb9a29a5e71a90295f175df8919802993142c9a","date":1412517673,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new BaseDirectory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        isOpen = false;\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void renameFile(String source, String dest) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock makeLock(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void clearLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285cdc737de75b7cc7c284a156b20214deb67bca","date":1415535483,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new Directory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void renameFile(String source, String dest) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock makeLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new BaseDirectory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        isOpen = false;\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void renameFile(String source, String dest) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock makeLock(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void clearLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"618635065f043788c9e034f96ca5cd5cea1b4592","date":1433442044,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new Directory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void renameFile(String source, String dest) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock obtainLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new Directory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void renameFile(String source, String dest) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock makeLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"867e3d9153fb761456b54a9dcce566e1545c5ef6","date":1444903098,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new Directory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void renameFile(String source, String dest) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock obtainLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new Directory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void renameFile(String source, String dest) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock obtainLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new Directory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFiles(Collection<String> name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void renameFile(String source, String dest) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock obtainLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new Directory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void renameFile(String source, String dest) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock obtainLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","date":1454513757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new Directory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void renameFile(String source, String dest) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock obtainLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new Directory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFiles(Collection<String> name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void renameFile(String source, String dest) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock obtainLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"214256b5eeeaba88b8293b37d30460b462b19562","date":1468250146,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new Directory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void rename(String source, String dest) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public void syncMetaData() { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock obtainLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new Directory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void renameFile(String source, String dest) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock obtainLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new Directory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void rename(String source, String dest) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public void syncMetaData() { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock obtainLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new Directory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void renameFile(String source, String dest) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock obtainLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a1daa873da17eb29437c755891f372087a17562","date":1553608605,"type":3,"author":"Henning Andersen","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n\n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n\n    return new Directory() {\n\n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n\n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n\n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n\n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n\n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n\n      @Override\n      public Set<String> getPendingDeletions() throws IOException {\n        return Collections.emptySet();\n      }\n\n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void rename(String source, String dest) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public void syncMetaData() { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock obtainLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n      \n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n      \n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n    \n    return new Directory() {\n      \n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n      \n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n      \n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n      \n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n      \n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n      \n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void rename(String source, String dest) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public void syncMetaData() { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock obtainLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91593ae7fe3dbcea4afa49c2e8133db2822dc800","date":1586956259,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCompoundFormat#getCompoundReader(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public CompoundDirectory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n\n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n\n    return new CompoundDirectory() {\n\n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n\n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n\n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n\n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n\n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n\n      @Override\n      public Set<String> getPendingDeletions() throws IOException {\n        return Collections.emptySet();\n      }\n\n      @Override\n      public void checkIntegrity() throws IOException {\n        // No checksums for SimpleText\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Directory getCompoundReader(Directory dir, SegmentInfo si, IOContext context) throws IOException {\n    String dataFile = IndexFileNames.segmentFileName(si.name, \"\", DATA_EXTENSION);\n    final IndexInput in = dir.openInput(dataFile, context);\n    \n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    // first get to TOC:\n    DecimalFormat df = new DecimalFormat(OFFSETPATTERN, DecimalFormatSymbols.getInstance(Locale.ROOT));\n    long pos = in.length() - TABLEPOS.length - OFFSETPATTERN.length() - 1;\n    in.seek(pos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLEPOS);\n    long tablePos = -1; \n    try {\n      tablePos = df.parse(stripPrefix(scratch, TABLEPOS)).longValue();\n    } catch (ParseException e) {\n      throw new CorruptIndexException(\"can't parse CFS trailer, got: \" + scratch.get().utf8ToString(), in);\n    }\n    \n    // seek to TOC and read it\n    in.seek(tablePos);\n    SimpleTextUtil.readLine(in, scratch);\n    assert StringHelper.startsWith(scratch.get(), TABLE);\n    int numEntries = Integer.parseInt(stripPrefix(scratch, TABLE));\n    \n    final String fileNames[] = new String[numEntries];\n    final long startOffsets[] = new long[numEntries];\n    final long endOffsets[] = new long[numEntries];\n    \n    for (int i = 0; i < numEntries; i++) {\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLENAME);\n      fileNames[i] = si.name + IndexFileNames.stripSegmentName(stripPrefix(scratch, TABLENAME));\n\n      if (i > 0) {\n        // files must be unique and in sorted order\n        assert fileNames[i].compareTo(fileNames[i-1]) > 0;\n      }\n\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLESTART);\n      startOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLESTART));\n\n      SimpleTextUtil.readLine(in, scratch);\n      assert StringHelper.startsWith(scratch.get(), TABLEEND);\n      endOffsets[i] = Long.parseLong(stripPrefix(scratch, TABLEEND));\n    }\n\n    return new Directory() {\n\n      private int getIndex(String name) throws IOException {\n        int index = Arrays.binarySearch(fileNames, name);\n        if (index < 0) {\n          throw new FileNotFoundException(\"No sub-file found (fileName=\" + name + \" files: \" + Arrays.toString(fileNames) + \")\");\n        }\n        return index;\n      }\n\n      @Override\n      public String[] listAll() throws IOException {\n        ensureOpen();\n        return fileNames.clone();\n      }\n\n      @Override\n      public long fileLength(String name) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return endOffsets[index] - startOffsets[index];\n      }\n\n      @Override\n      public IndexInput openInput(String name, IOContext context) throws IOException {\n        ensureOpen();\n        int index = getIndex(name);\n        return in.slice(name, startOffsets[index], endOffsets[index] - startOffsets[index]);\n      }\n\n      @Override\n      public void close() throws IOException {\n        in.close();\n      }\n\n      @Override\n      public Set<String> getPendingDeletions() throws IOException {\n        return Collections.emptySet();\n      }\n\n      // write methods: disabled\n      \n      @Override\n      public IndexOutput createOutput(String name, IOContext context) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void sync(Collection<String> names) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void deleteFile(String name) { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public void rename(String source, String dest) { throw new UnsupportedOperationException(); }\n\n      @Override\n      public void syncMetaData() { throw new UnsupportedOperationException(); }\n      \n      @Override\n      public Lock obtainLock(String name) { throw new UnsupportedOperationException(); }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c761d502ca1f6c5324aa909468ebc4f761c92c1f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"214256b5eeeaba88b8293b37d30460b462b19562":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"285cdc737de75b7cc7c284a156b20214deb67bca":["9bb9a29a5e71a90295f175df8919802993142c9a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["867e3d9153fb761456b54a9dcce566e1545c5ef6","214256b5eeeaba88b8293b37d30460b462b19562"],"91593ae7fe3dbcea4afa49c2e8133db2822dc800":["0a1daa873da17eb29437c755891f372087a17562"],"618635065f043788c9e034f96ca5cd5cea1b4592":["285cdc737de75b7cc7c284a156b20214deb67bca"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"9bb9a29a5e71a90295f175df8919802993142c9a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c761d502ca1f6c5324aa909468ebc4f761c92c1f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"0a1daa873da17eb29437c755891f372087a17562":["214256b5eeeaba88b8293b37d30460b462b19562"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["618635065f043788c9e034f96ca5cd5cea1b4592"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["91593ae7fe3dbcea4afa49c2e8133db2822dc800"]},"commit2Childs":{"c761d502ca1f6c5324aa909468ebc4f761c92c1f":["9bb9a29a5e71a90295f175df8919802993142c9a"],"214256b5eeeaba88b8293b37d30460b462b19562":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0a1daa873da17eb29437c755891f372087a17562"],"285cdc737de75b7cc7c284a156b20214deb67bca":["618635065f043788c9e034f96ca5cd5cea1b4592"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"91593ae7fe3dbcea4afa49c2e8133db2822dc800":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"618635065f043788c9e034f96ca5cd5cea1b4592":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":[],"9bb9a29a5e71a90295f175df8919802993142c9a":["285cdc737de75b7cc7c284a156b20214deb67bca"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c761d502ca1f6c5324aa909468ebc4f761c92c1f","9bb9a29a5e71a90295f175df8919802993142c9a"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["214256b5eeeaba88b8293b37d30460b462b19562","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"0a1daa873da17eb29437c755891f372087a17562":["91593ae7fe3dbcea4afa49c2e8133db2822dc800"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}