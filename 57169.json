{"path":"lucene/src/test/org/apache/lucene/index/FlexTestUtil#testRandomSkips(Random,IndexReader).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/FlexTestUtil#testRandomSkips(Random,IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  private static void testRandomSkips(Random rand, IndexReader r) throws Exception {\n\n    TermEnum termEnum = r.terms();\n    Fields fields = MultiFields.getFields(r);\n    if (fields == null) {\n      return;\n    }\n    FieldsEnum fieldsEnum = fields.iterator();\n    boolean skipNext = false;\n    int[] docs2 = new int[16];\n    int[] freqs2 = new int[16];\n    while(true) {\n      final String field = fieldsEnum.next();\n      if (field == null) {\n        boolean result = termEnum.next();\n        if (result) {\n          System.out.println(\"got unexpected term=\" + termEnum.term() + \" termEnum=\" + termEnum);\n        }\n        assertFalse(result);\n        break;\n      }\n      if (rand.nextInt(3) <= 1) {\n        // Enum the terms\n        //System.out.println(\"TEST:   get terms\");\n        TermsEnum terms = fieldsEnum.terms();\n        final TermPositions termPos = r.termPositions();\n        final TermDocs termDocs = r.termDocs();\n        DocsEnum docs = null;\n        DocsAndPositionsEnum postings = null;\n        while(true) {\n          final BytesRef termRef = terms.next();\n          if (termRef == null) {\n            break;\n          } else {\n            if (skipNext) {\n              skipNext = false;\n            } else {\n              assertTrue(termEnum.next());\n            }\n            Term t = termEnum.term();\n            assertEquals(t.field(), field);\n            assertEquals(t.text(), termRef.utf8ToString());\n            assertEquals(termEnum.docFreq(), terms.docFreq());\n            //allTerms.add(t);\n\n            if (rand.nextInt(3) <= 1) {\n              docs = terms.docs(MultiFields.getDeletedDocs(r), docs);\n              assert !(docs instanceof DocsAndPositionsEnum): \"docs=\" + docs;\n              postings = terms.docsAndPositions(MultiFields.getDeletedDocs(r), postings);\n              final DocsEnum docsEnum;\n              if (postings == null) {\n                docsEnum = docs;\n              } else {\n                docsEnum = postings;\n              }\n              if (rand.nextBoolean()) {\n                // use bulk read API\n                termDocs.seek(t);\n                DocsEnum.BulkReadResult result1 = docs.getBulkResult();\n                int result1Count = 0;\n                int count2 = 0;\n                while(true) {\n                  if (result1Count == 0) {\n                    result1Count = docs.read();\n                  }\n                  if (count2 == 0) {\n                    count2 = termDocs.read(docs2, freqs2);\n                  }\n\n                  if (result1Count == 0 || count2 == 0) {\n                    assertEquals(0, count2);\n                    assertEquals(0, result1Count);\n                    break;\n                  }\n                  final int limit = Math.min(result1Count, count2);\n                  for(int i=0;i<limit;i++) {\n                    assertEquals(result1.docs.ints[i], docs2[i]);\n                    assertEquals(result1.freqs.ints[i], freqs2[i]);\n                  }\n                  if (result1Count > limit) {\n                    // copy down\n                    // TODO: in general I should not muck w/\n                    // the int[]'s returned to me like\n                    // this... this could mess up codecs\n                    // that have persistent RAM storage of\n                    // these int[]'s\n                    System.arraycopy(result1.docs.ints, limit, result1.docs.ints, 0, result1Count-limit);\n                    System.arraycopy(result1.freqs.ints, limit, result1.freqs.ints, 0, result1Count-limit);\n                  }\n                  result1Count -= limit;\n\n                  if (count2 > limit) {\n                    // copy down\n                    System.arraycopy(docs2, limit, docs2, 0, count2-limit);\n                    System.arraycopy(freqs2, limit, freqs2, 0, count2-limit);\n                  }\n                  count2 -= limit;\n                }\n              } else {\n                // Enum the docs one by one\n                //System.out.println(\"TEST:      get docs\");\n                termPos.seek(t);\n                while(true) {\n                  final int doc = docsEnum.nextDoc();\n                  if (doc == DocsEnum.NO_MORE_DOCS) {\n                    assertFalse(termPos.next());\n                    break;\n                  } else {\n                    assertTrue(termPos.next());\n                    assertEquals(termPos.doc(), doc);\n                    assertEquals(termPos.freq(), docsEnum.freq());\n                    //System.out.println(\"TEST:     doc=\" + doc + \" freq=\" + docs.freq());\n                    if (rand.nextInt(3) <= 1) {\n                      // enum the positions\n                      final int freq = docsEnum.freq();\n                      if (postings == null) {\n                        assertEquals(1, termPos.freq());\n                        // Old API did not always do this,\n                        // specifically in the MultiTermPositions\n                        // case when some segs omit positions and\n                        // some don't\n                        //assertEquals(0, termPos.nextPosition());\n                        assertFalse(termPos.isPayloadAvailable());\n                      } else {\n                        // we have positions\n                        for(int i=0;i<freq;i++) {\n                          final int position = postings.nextPosition();\n                          //System.out.println(\"TEST:       pos=\" + position);\n                          assertEquals(position, termPos.nextPosition());\n                          assertEquals(postings.hasPayload(), termPos.isPayloadAvailable());\n                          if (postings.hasPayload()) {\n                            assertEquals(postings.getPayloadLength(), termPos.getPayloadLength());\n                            if (rand.nextInt(3) <= 1) {\n                              BytesRef payload = postings.getPayload();\n                              byte[] b2 = termPos.getPayload(null, 0);\n                              assertNotNull(payload);\n                              assertNotNull(b2);\n                              assertTrue(equals(payload, b2));\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            } else {\n              //System.out.println(\"TEST:      skip docs\");\n            }\n          }\n        }\n      } else {\n        // Skip terms for this field\n        termEnum = r.terms(new Term(field, \"\\uFFFF\"));\n        skipNext = true;\n        //System.out.println(\"TEST:   skip terms; now=\" + termEnum.term());\n      }\n    }\n\n    // seek to before first term in a field\n    // seek to after last term in a field\n    // seek to random terms\n    // enum docs, sometimes skipping\n    // enum positions, sometimes skipping payloads\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5c4531fadbecf73a7716fdf5cd742463e866e84e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5c4531fadbecf73a7716fdf5cd742463e866e84e","date":1273851662,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/FlexTestUtil#testRandomSkips(Random,IndexReader).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/FlexTestUtil#testRandomSkips(Random,IndexReader).mjava","sourceNew":"  private static void testRandomSkips(Random rand, IndexReader r) throws Exception {\n\n    TermEnum termEnum = r.terms();\n    Fields fields = MultiFields.getFields(r);\n    if (fields == null) {\n      return;\n    }\n    FieldsEnum fieldsEnum = fields.iterator();\n    boolean skipNext = false;\n    int[] docs2 = new int[16];\n    int[] freqs2 = new int[16];\n    while(true) {\n      final String field = fieldsEnum.next();\n      if (field == null) {\n        boolean result = termEnum.next();\n        if (result) {\n          System.out.println(\"got unexpected term=\" + termEnum.term() + \" termEnum=\" + termEnum);\n        }\n        assertFalse(result);\n        break;\n      }\n      if (rand.nextInt(3) <= 1) {\n        // Enum the terms\n        //System.out.println(\"TEST:   get terms\");\n        TermsEnum terms = fieldsEnum.terms();\n        final TermPositions termPos = r.termPositions();\n        final TermDocs termDocs = r.termDocs();\n        DocsEnum docs = null;\n        DocsAndPositionsEnum postings = null;\n        while(true) {\n          final BytesRef termRef = terms.next();\n          if (termRef == null) {\n            break;\n          } else {\n            if (skipNext) {\n              skipNext = false;\n            } else {\n              assertTrue(termEnum.next());\n            }\n            Term t = termEnum.term();\n            assertEquals(t.field(), field);\n            assertEquals(t.text(), termRef.utf8ToString());\n            assertEquals(termEnum.docFreq(), terms.docFreq());\n            //allTerms.add(t);\n\n            if (rand.nextInt(3) <= 1) {\n              docs = terms.docs(MultiFields.getDeletedDocs(r), docs);\n              assert !(docs instanceof DocsAndPositionsEnum): \"docs=\" + docs;\n              postings = terms.docsAndPositions(MultiFields.getDeletedDocs(r), postings);\n              final DocsEnum docsEnum;\n              if (postings == null) {\n                docsEnum = docs;\n              } else {\n                docsEnum = postings;\n              }\n              if (rand.nextBoolean()) {\n                // use bulk read API\n                termDocs.seek(t);\n                DocsEnum.BulkReadResult result1 = docs.getBulkResult();\n                int result1Count = 0;\n                int count2 = 0;\n                while(true) {\n                  if (result1Count == 0) {\n                    result1Count = docs.read();\n                  }\n                  if (count2 == 0) {\n                    count2 = termDocs.read(docs2, freqs2);\n                  }\n\n                  if (result1Count == 0 || count2 == 0) {\n                    assertEquals(0, count2);\n                    assertEquals(0, result1Count);\n                    break;\n                  }\n                  final int limit = Math.min(result1Count, count2);\n                  for(int i=0;i<limit;i++) {\n                    assertEquals(result1.docs.ints[i], docs2[i]);\n                    assertEquals(result1.freqs.ints[i], freqs2[i]);\n                  }\n                  if (result1Count > limit) {\n                    // copy down\n                    // TODO: in general I should not muck w/\n                    // the int[]'s returned to me like\n                    // this... this could mess up codecs\n                    // that have persistent RAM storage of\n                    // these int[]'s\n                    System.arraycopy(result1.docs.ints, limit, result1.docs.ints, 0, result1Count-limit);\n                    System.arraycopy(result1.freqs.ints, limit, result1.freqs.ints, 0, result1Count-limit);\n                  }\n                  result1Count -= limit;\n\n                  if (count2 > limit) {\n                    // copy down\n                    System.arraycopy(docs2, limit, docs2, 0, count2-limit);\n                    System.arraycopy(freqs2, limit, freqs2, 0, count2-limit);\n                  }\n                  count2 -= limit;\n                }\n              } else {\n                // Enum the docs one by one\n                //System.out.println(\"TEST:      get docs\");\n                termPos.seek(t);\n                while(true) {\n                  final int doc = docsEnum.nextDoc();\n                  if (doc == DocsEnum.NO_MORE_DOCS) {\n                    assertFalse(termPos.next());\n                    break;\n                  } else {\n                    assertTrue(termPos.next());\n                    assertEquals(termPos.doc(), doc);\n                    assertEquals(termPos.freq(), docsEnum.freq());\n                    //System.out.println(\"TEST:     doc=\" + doc + \" freq=\" + docs.freq());\n                    if (rand.nextInt(3) <= 1) {\n                      // enum the positions\n                      final int freq = docsEnum.freq();\n                      if (postings == null) {\n                        assertEquals(1, termPos.freq());\n                        // Old API did not always do this,\n                        // specifically in the MultiTermPositions\n                        // case when some segs omit positions and\n                        // some don't\n                        //assertEquals(0, termPos.nextPosition());\n                        assertFalse(termPos.isPayloadAvailable());\n                      } else {\n                        // we have positions\n                        for(int i=0;i<freq;i++) {\n                          final int position = postings.nextPosition();\n                          //System.out.println(\"TEST:       pos=\" + position);\n                          assertEquals(position, termPos.nextPosition());\n                          assertEquals(postings.hasPayload(), termPos.isPayloadAvailable());\n                          if (postings.hasPayload()) {\n                            if (rand.nextInt(3) <= 1) {\n                              BytesRef payload = postings.getPayload();\n                              assertEquals(payload.length, termPos.getPayloadLength());\n                              byte[] b2 = termPos.getPayload(null, 0);\n                              assertNotNull(payload);\n                              assertNotNull(b2);\n                              assertTrue(equals(payload, b2));\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            } else {\n              //System.out.println(\"TEST:      skip docs\");\n            }\n          }\n        }\n      } else {\n        // Skip terms for this field\n        termEnum = r.terms(new Term(field, \"\\uFFFF\"));\n        skipNext = true;\n        //System.out.println(\"TEST:   skip terms; now=\" + termEnum.term());\n      }\n    }\n\n    // seek to before first term in a field\n    // seek to after last term in a field\n    // seek to random terms\n    // enum docs, sometimes skipping\n    // enum positions, sometimes skipping payloads\n  }\n\n","sourceOld":"  private static void testRandomSkips(Random rand, IndexReader r) throws Exception {\n\n    TermEnum termEnum = r.terms();\n    Fields fields = MultiFields.getFields(r);\n    if (fields == null) {\n      return;\n    }\n    FieldsEnum fieldsEnum = fields.iterator();\n    boolean skipNext = false;\n    int[] docs2 = new int[16];\n    int[] freqs2 = new int[16];\n    while(true) {\n      final String field = fieldsEnum.next();\n      if (field == null) {\n        boolean result = termEnum.next();\n        if (result) {\n          System.out.println(\"got unexpected term=\" + termEnum.term() + \" termEnum=\" + termEnum);\n        }\n        assertFalse(result);\n        break;\n      }\n      if (rand.nextInt(3) <= 1) {\n        // Enum the terms\n        //System.out.println(\"TEST:   get terms\");\n        TermsEnum terms = fieldsEnum.terms();\n        final TermPositions termPos = r.termPositions();\n        final TermDocs termDocs = r.termDocs();\n        DocsEnum docs = null;\n        DocsAndPositionsEnum postings = null;\n        while(true) {\n          final BytesRef termRef = terms.next();\n          if (termRef == null) {\n            break;\n          } else {\n            if (skipNext) {\n              skipNext = false;\n            } else {\n              assertTrue(termEnum.next());\n            }\n            Term t = termEnum.term();\n            assertEquals(t.field(), field);\n            assertEquals(t.text(), termRef.utf8ToString());\n            assertEquals(termEnum.docFreq(), terms.docFreq());\n            //allTerms.add(t);\n\n            if (rand.nextInt(3) <= 1) {\n              docs = terms.docs(MultiFields.getDeletedDocs(r), docs);\n              assert !(docs instanceof DocsAndPositionsEnum): \"docs=\" + docs;\n              postings = terms.docsAndPositions(MultiFields.getDeletedDocs(r), postings);\n              final DocsEnum docsEnum;\n              if (postings == null) {\n                docsEnum = docs;\n              } else {\n                docsEnum = postings;\n              }\n              if (rand.nextBoolean()) {\n                // use bulk read API\n                termDocs.seek(t);\n                DocsEnum.BulkReadResult result1 = docs.getBulkResult();\n                int result1Count = 0;\n                int count2 = 0;\n                while(true) {\n                  if (result1Count == 0) {\n                    result1Count = docs.read();\n                  }\n                  if (count2 == 0) {\n                    count2 = termDocs.read(docs2, freqs2);\n                  }\n\n                  if (result1Count == 0 || count2 == 0) {\n                    assertEquals(0, count2);\n                    assertEquals(0, result1Count);\n                    break;\n                  }\n                  final int limit = Math.min(result1Count, count2);\n                  for(int i=0;i<limit;i++) {\n                    assertEquals(result1.docs.ints[i], docs2[i]);\n                    assertEquals(result1.freqs.ints[i], freqs2[i]);\n                  }\n                  if (result1Count > limit) {\n                    // copy down\n                    // TODO: in general I should not muck w/\n                    // the int[]'s returned to me like\n                    // this... this could mess up codecs\n                    // that have persistent RAM storage of\n                    // these int[]'s\n                    System.arraycopy(result1.docs.ints, limit, result1.docs.ints, 0, result1Count-limit);\n                    System.arraycopy(result1.freqs.ints, limit, result1.freqs.ints, 0, result1Count-limit);\n                  }\n                  result1Count -= limit;\n\n                  if (count2 > limit) {\n                    // copy down\n                    System.arraycopy(docs2, limit, docs2, 0, count2-limit);\n                    System.arraycopy(freqs2, limit, freqs2, 0, count2-limit);\n                  }\n                  count2 -= limit;\n                }\n              } else {\n                // Enum the docs one by one\n                //System.out.println(\"TEST:      get docs\");\n                termPos.seek(t);\n                while(true) {\n                  final int doc = docsEnum.nextDoc();\n                  if (doc == DocsEnum.NO_MORE_DOCS) {\n                    assertFalse(termPos.next());\n                    break;\n                  } else {\n                    assertTrue(termPos.next());\n                    assertEquals(termPos.doc(), doc);\n                    assertEquals(termPos.freq(), docsEnum.freq());\n                    //System.out.println(\"TEST:     doc=\" + doc + \" freq=\" + docs.freq());\n                    if (rand.nextInt(3) <= 1) {\n                      // enum the positions\n                      final int freq = docsEnum.freq();\n                      if (postings == null) {\n                        assertEquals(1, termPos.freq());\n                        // Old API did not always do this,\n                        // specifically in the MultiTermPositions\n                        // case when some segs omit positions and\n                        // some don't\n                        //assertEquals(0, termPos.nextPosition());\n                        assertFalse(termPos.isPayloadAvailable());\n                      } else {\n                        // we have positions\n                        for(int i=0;i<freq;i++) {\n                          final int position = postings.nextPosition();\n                          //System.out.println(\"TEST:       pos=\" + position);\n                          assertEquals(position, termPos.nextPosition());\n                          assertEquals(postings.hasPayload(), termPos.isPayloadAvailable());\n                          if (postings.hasPayload()) {\n                            assertEquals(postings.getPayloadLength(), termPos.getPayloadLength());\n                            if (rand.nextInt(3) <= 1) {\n                              BytesRef payload = postings.getPayload();\n                              byte[] b2 = termPos.getPayload(null, 0);\n                              assertNotNull(payload);\n                              assertNotNull(b2);\n                              assertTrue(equals(payload, b2));\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            } else {\n              //System.out.println(\"TEST:      skip docs\");\n            }\n          }\n        }\n      } else {\n        // Skip terms for this field\n        termEnum = r.terms(new Term(field, \"\\uFFFF\"));\n        skipNext = true;\n        //System.out.println(\"TEST:   skip terms; now=\" + termEnum.term());\n      }\n    }\n\n    // seek to before first term in a field\n    // seek to after last term in a field\n    // seek to random terms\n    // enum docs, sometimes skipping\n    // enum positions, sometimes skipping payloads\n  }\n\n","bugFix":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28427ef110c4c5bf5b4057731b83110bd1e13724","date":1276701452,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/test/org/apache/lucene/index/FlexTestUtil#testRandomSkips(Random,IndexReader).mjava","sourceNew":null,"sourceOld":"  private static void testRandomSkips(Random rand, IndexReader r) throws Exception {\n\n    TermEnum termEnum = r.terms();\n    Fields fields = MultiFields.getFields(r);\n    if (fields == null) {\n      return;\n    }\n    FieldsEnum fieldsEnum = fields.iterator();\n    boolean skipNext = false;\n    int[] docs2 = new int[16];\n    int[] freqs2 = new int[16];\n    while(true) {\n      final String field = fieldsEnum.next();\n      if (field == null) {\n        boolean result = termEnum.next();\n        if (result) {\n          System.out.println(\"got unexpected term=\" + termEnum.term() + \" termEnum=\" + termEnum);\n        }\n        assertFalse(result);\n        break;\n      }\n      if (rand.nextInt(3) <= 1) {\n        // Enum the terms\n        //System.out.println(\"TEST:   get terms\");\n        TermsEnum terms = fieldsEnum.terms();\n        final TermPositions termPos = r.termPositions();\n        final TermDocs termDocs = r.termDocs();\n        DocsEnum docs = null;\n        DocsAndPositionsEnum postings = null;\n        while(true) {\n          final BytesRef termRef = terms.next();\n          if (termRef == null) {\n            break;\n          } else {\n            if (skipNext) {\n              skipNext = false;\n            } else {\n              assertTrue(termEnum.next());\n            }\n            Term t = termEnum.term();\n            assertEquals(t.field(), field);\n            assertEquals(t.text(), termRef.utf8ToString());\n            assertEquals(termEnum.docFreq(), terms.docFreq());\n            //allTerms.add(t);\n\n            if (rand.nextInt(3) <= 1) {\n              docs = terms.docs(MultiFields.getDeletedDocs(r), docs);\n              assert !(docs instanceof DocsAndPositionsEnum): \"docs=\" + docs;\n              postings = terms.docsAndPositions(MultiFields.getDeletedDocs(r), postings);\n              final DocsEnum docsEnum;\n              if (postings == null) {\n                docsEnum = docs;\n              } else {\n                docsEnum = postings;\n              }\n              if (rand.nextBoolean()) {\n                // use bulk read API\n                termDocs.seek(t);\n                DocsEnum.BulkReadResult result1 = docs.getBulkResult();\n                int result1Count = 0;\n                int count2 = 0;\n                while(true) {\n                  if (result1Count == 0) {\n                    result1Count = docs.read();\n                  }\n                  if (count2 == 0) {\n                    count2 = termDocs.read(docs2, freqs2);\n                  }\n\n                  if (result1Count == 0 || count2 == 0) {\n                    assertEquals(0, count2);\n                    assertEquals(0, result1Count);\n                    break;\n                  }\n                  final int limit = Math.min(result1Count, count2);\n                  for(int i=0;i<limit;i++) {\n                    assertEquals(result1.docs.ints[i], docs2[i]);\n                    assertEquals(result1.freqs.ints[i], freqs2[i]);\n                  }\n                  if (result1Count > limit) {\n                    // copy down\n                    // TODO: in general I should not muck w/\n                    // the int[]'s returned to me like\n                    // this... this could mess up codecs\n                    // that have persistent RAM storage of\n                    // these int[]'s\n                    System.arraycopy(result1.docs.ints, limit, result1.docs.ints, 0, result1Count-limit);\n                    System.arraycopy(result1.freqs.ints, limit, result1.freqs.ints, 0, result1Count-limit);\n                  }\n                  result1Count -= limit;\n\n                  if (count2 > limit) {\n                    // copy down\n                    System.arraycopy(docs2, limit, docs2, 0, count2-limit);\n                    System.arraycopy(freqs2, limit, freqs2, 0, count2-limit);\n                  }\n                  count2 -= limit;\n                }\n              } else {\n                // Enum the docs one by one\n                //System.out.println(\"TEST:      get docs\");\n                termPos.seek(t);\n                while(true) {\n                  final int doc = docsEnum.nextDoc();\n                  if (doc == DocsEnum.NO_MORE_DOCS) {\n                    assertFalse(termPos.next());\n                    break;\n                  } else {\n                    assertTrue(termPos.next());\n                    assertEquals(termPos.doc(), doc);\n                    assertEquals(termPos.freq(), docsEnum.freq());\n                    //System.out.println(\"TEST:     doc=\" + doc + \" freq=\" + docs.freq());\n                    if (rand.nextInt(3) <= 1) {\n                      // enum the positions\n                      final int freq = docsEnum.freq();\n                      if (postings == null) {\n                        assertEquals(1, termPos.freq());\n                        // Old API did not always do this,\n                        // specifically in the MultiTermPositions\n                        // case when some segs omit positions and\n                        // some don't\n                        //assertEquals(0, termPos.nextPosition());\n                        assertFalse(termPos.isPayloadAvailable());\n                      } else {\n                        // we have positions\n                        for(int i=0;i<freq;i++) {\n                          final int position = postings.nextPosition();\n                          //System.out.println(\"TEST:       pos=\" + position);\n                          assertEquals(position, termPos.nextPosition());\n                          assertEquals(postings.hasPayload(), termPos.isPayloadAvailable());\n                          if (postings.hasPayload()) {\n                            if (rand.nextInt(3) <= 1) {\n                              BytesRef payload = postings.getPayload();\n                              assertEquals(payload.length, termPos.getPayloadLength());\n                              byte[] b2 = termPos.getPayload(null, 0);\n                              assertNotNull(payload);\n                              assertNotNull(b2);\n                              assertTrue(equals(payload, b2));\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            } else {\n              //System.out.println(\"TEST:      skip docs\");\n            }\n          }\n        }\n      } else {\n        // Skip terms for this field\n        termEnum = r.terms(new Term(field, \"\\uFFFF\"));\n        skipNext = true;\n        //System.out.println(\"TEST:   skip terms; now=\" + termEnum.term());\n      }\n    }\n\n    // seek to before first term in a field\n    // seek to after last term in a field\n    // seek to random terms\n    // enum docs, sometimes skipping\n    // enum positions, sometimes skipping payloads\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":4,"author":"Michael Busch","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/test/org/apache/lucene/index/FlexTestUtil#testRandomSkips(Random,IndexReader).mjava","sourceNew":null,"sourceOld":"  private static void testRandomSkips(Random rand, IndexReader r) throws Exception {\n\n    TermEnum termEnum = r.terms();\n    Fields fields = MultiFields.getFields(r);\n    if (fields == null) {\n      return;\n    }\n    FieldsEnum fieldsEnum = fields.iterator();\n    boolean skipNext = false;\n    int[] docs2 = new int[16];\n    int[] freqs2 = new int[16];\n    while(true) {\n      final String field = fieldsEnum.next();\n      if (field == null) {\n        boolean result = termEnum.next();\n        if (result) {\n          System.out.println(\"got unexpected term=\" + termEnum.term() + \" termEnum=\" + termEnum);\n        }\n        assertFalse(result);\n        break;\n      }\n      if (rand.nextInt(3) <= 1) {\n        // Enum the terms\n        //System.out.println(\"TEST:   get terms\");\n        TermsEnum terms = fieldsEnum.terms();\n        final TermPositions termPos = r.termPositions();\n        final TermDocs termDocs = r.termDocs();\n        DocsEnum docs = null;\n        DocsAndPositionsEnum postings = null;\n        while(true) {\n          final BytesRef termRef = terms.next();\n          if (termRef == null) {\n            break;\n          } else {\n            if (skipNext) {\n              skipNext = false;\n            } else {\n              assertTrue(termEnum.next());\n            }\n            Term t = termEnum.term();\n            assertEquals(t.field(), field);\n            assertEquals(t.text(), termRef.utf8ToString());\n            assertEquals(termEnum.docFreq(), terms.docFreq());\n            //allTerms.add(t);\n\n            if (rand.nextInt(3) <= 1) {\n              docs = terms.docs(MultiFields.getDeletedDocs(r), docs);\n              assert !(docs instanceof DocsAndPositionsEnum): \"docs=\" + docs;\n              postings = terms.docsAndPositions(MultiFields.getDeletedDocs(r), postings);\n              final DocsEnum docsEnum;\n              if (postings == null) {\n                docsEnum = docs;\n              } else {\n                docsEnum = postings;\n              }\n              if (rand.nextBoolean()) {\n                // use bulk read API\n                termDocs.seek(t);\n                DocsEnum.BulkReadResult result1 = docs.getBulkResult();\n                int result1Count = 0;\n                int count2 = 0;\n                while(true) {\n                  if (result1Count == 0) {\n                    result1Count = docs.read();\n                  }\n                  if (count2 == 0) {\n                    count2 = termDocs.read(docs2, freqs2);\n                  }\n\n                  if (result1Count == 0 || count2 == 0) {\n                    assertEquals(0, count2);\n                    assertEquals(0, result1Count);\n                    break;\n                  }\n                  final int limit = Math.min(result1Count, count2);\n                  for(int i=0;i<limit;i++) {\n                    assertEquals(result1.docs.ints[i], docs2[i]);\n                    assertEquals(result1.freqs.ints[i], freqs2[i]);\n                  }\n                  if (result1Count > limit) {\n                    // copy down\n                    // TODO: in general I should not muck w/\n                    // the int[]'s returned to me like\n                    // this... this could mess up codecs\n                    // that have persistent RAM storage of\n                    // these int[]'s\n                    System.arraycopy(result1.docs.ints, limit, result1.docs.ints, 0, result1Count-limit);\n                    System.arraycopy(result1.freqs.ints, limit, result1.freqs.ints, 0, result1Count-limit);\n                  }\n                  result1Count -= limit;\n\n                  if (count2 > limit) {\n                    // copy down\n                    System.arraycopy(docs2, limit, docs2, 0, count2-limit);\n                    System.arraycopy(freqs2, limit, freqs2, 0, count2-limit);\n                  }\n                  count2 -= limit;\n                }\n              } else {\n                // Enum the docs one by one\n                //System.out.println(\"TEST:      get docs\");\n                termPos.seek(t);\n                while(true) {\n                  final int doc = docsEnum.nextDoc();\n                  if (doc == DocsEnum.NO_MORE_DOCS) {\n                    assertFalse(termPos.next());\n                    break;\n                  } else {\n                    assertTrue(termPos.next());\n                    assertEquals(termPos.doc(), doc);\n                    assertEquals(termPos.freq(), docsEnum.freq());\n                    //System.out.println(\"TEST:     doc=\" + doc + \" freq=\" + docs.freq());\n                    if (rand.nextInt(3) <= 1) {\n                      // enum the positions\n                      final int freq = docsEnum.freq();\n                      if (postings == null) {\n                        assertEquals(1, termPos.freq());\n                        // Old API did not always do this,\n                        // specifically in the MultiTermPositions\n                        // case when some segs omit positions and\n                        // some don't\n                        //assertEquals(0, termPos.nextPosition());\n                        assertFalse(termPos.isPayloadAvailable());\n                      } else {\n                        // we have positions\n                        for(int i=0;i<freq;i++) {\n                          final int position = postings.nextPosition();\n                          //System.out.println(\"TEST:       pos=\" + position);\n                          assertEquals(position, termPos.nextPosition());\n                          assertEquals(postings.hasPayload(), termPos.isPayloadAvailable());\n                          if (postings.hasPayload()) {\n                            if (rand.nextInt(3) <= 1) {\n                              BytesRef payload = postings.getPayload();\n                              assertEquals(payload.length, termPos.getPayloadLength());\n                              byte[] b2 = termPos.getPayload(null, 0);\n                              assertNotNull(payload);\n                              assertNotNull(b2);\n                              assertTrue(equals(payload, b2));\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            } else {\n              //System.out.println(\"TEST:      skip docs\");\n            }\n          }\n        }\n      } else {\n        // Skip terms for this field\n        termEnum = r.terms(new Term(field, \"\\uFFFF\"));\n        skipNext = true;\n        //System.out.println(\"TEST:   skip terms; now=\" + termEnum.term());\n      }\n    }\n\n    // seek to before first term in a field\n    // seek to after last term in a field\n    // seek to random terms\n    // enum docs, sometimes skipping\n    // enum positions, sometimes skipping payloads\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"28427ef110c4c5bf5b4057731b83110bd1e13724":["5c4531fadbecf73a7716fdf5cd742463e866e84e"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5c4531fadbecf73a7716fdf5cd742463e866e84e":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"5f4e87790277826a2aea119328600dfb07761f32":["5c4531fadbecf73a7716fdf5cd742463e866e84e","28427ef110c4c5bf5b4057731b83110bd1e13724"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28427ef110c4c5bf5b4057731b83110bd1e13724"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"28427ef110c4c5bf5b4057731b83110bd1e13724":["5f4e87790277826a2aea119328600dfb07761f32","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5c4531fadbecf73a7716fdf5cd742463e866e84e"],"5c4531fadbecf73a7716fdf5cd742463e866e84e":["28427ef110c4c5bf5b4057731b83110bd1e13724","5f4e87790277826a2aea119328600dfb07761f32"],"5f4e87790277826a2aea119328600dfb07761f32":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5f4e87790277826a2aea119328600dfb07761f32","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}