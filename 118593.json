{"path":"lucene/core/src/java/org/apache/lucene/search/BooleanScorer#scoreWindow(LeafCollector,int,int,int).mjava","commits":[{"id":"251e6911800e3a02e1da3bfd4dc49a914aef9778","date":1423063783,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanScorer#scoreWindow(LeafCollector,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  private void scoreWindow(LeafCollector collector, int windowBase, int windowMin, int windowMax) throws IOException {\n    // Fill 'leads' with all scorers from 'head' that are in the right window\n    leads[0] = head.pop();\n    int maxFreq = 1;\n    while (head.size() > 0 && head.top().next < windowMax) {\n      leads[maxFreq++] = head.pop();\n    }\n\n    while (maxFreq < minShouldMatch && maxFreq + tail.size() >= minShouldMatch) {\n      // a match is still possible\n      final BulkScorerAndDoc candidate = tail.pop();\n      candidate.advance(windowMin);\n      if (candidate.next < windowMax) {\n        leads[maxFreq++] = candidate;\n      } else {\n        head.add(candidate);\n      }\n    }\n\n    if (maxFreq >= minShouldMatch) {\n      // There might be matches in other scorers from the tail too\n      for (int i = 0; i < tail.size(); ++i) {\n        leads[maxFreq++] = tail.get(i);\n      }\n      tail.clear();\n\n      scoreWindow(collector, windowBase, windowMin, windowMax, leads, maxFreq);\n    }\n\n    // Push back scorers into head and tail\n    for (int i = 0; i < maxFreq; ++i) {\n      final BulkScorerAndDoc evicted = head.insertWithOverflow(leads[i]);\n      if (evicted != null) {\n        tail.add(evicted);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanScorer#scoreWindow(LeafCollector,Bits,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanScorer#scoreWindow(LeafCollector,int,int,int).mjava","sourceNew":"  private void scoreWindow(LeafCollector collector, Bits acceptDocs, int windowBase, int windowMin, int windowMax) throws IOException {\n    // Fill 'leads' with all scorers from 'head' that are in the right window\n    leads[0] = head.pop();\n    int maxFreq = 1;\n    while (head.size() > 0 && head.top().next < windowMax) {\n      leads[maxFreq++] = head.pop();\n    }\n\n    while (maxFreq < minShouldMatch && maxFreq + tail.size() >= minShouldMatch) {\n      // a match is still possible\n      final BulkScorerAndDoc candidate = tail.pop();\n      candidate.advance(windowMin);\n      if (candidate.next < windowMax) {\n        leads[maxFreq++] = candidate;\n      } else {\n        head.add(candidate);\n      }\n    }\n\n    if (maxFreq >= minShouldMatch) {\n      // There might be matches in other scorers from the tail too\n      for (int i = 0; i < tail.size(); ++i) {\n        leads[maxFreq++] = tail.get(i);\n      }\n      tail.clear();\n\n      scoreWindow(collector, acceptDocs, windowBase, windowMin, windowMax, leads, maxFreq);\n    }\n\n    // Push back scorers into head and tail\n    for (int i = 0; i < maxFreq; ++i) {\n      final BulkScorerAndDoc evicted = head.insertWithOverflow(leads[i]);\n      if (evicted != null) {\n        tail.add(evicted);\n      }\n    }\n  }\n\n","sourceOld":"  private void scoreWindow(LeafCollector collector, int windowBase, int windowMin, int windowMax) throws IOException {\n    // Fill 'leads' with all scorers from 'head' that are in the right window\n    leads[0] = head.pop();\n    int maxFreq = 1;\n    while (head.size() > 0 && head.top().next < windowMax) {\n      leads[maxFreq++] = head.pop();\n    }\n\n    while (maxFreq < minShouldMatch && maxFreq + tail.size() >= minShouldMatch) {\n      // a match is still possible\n      final BulkScorerAndDoc candidate = tail.pop();\n      candidate.advance(windowMin);\n      if (candidate.next < windowMax) {\n        leads[maxFreq++] = candidate;\n      } else {\n        head.add(candidate);\n      }\n    }\n\n    if (maxFreq >= minShouldMatch) {\n      // There might be matches in other scorers from the tail too\n      for (int i = 0; i < tail.size(); ++i) {\n        leads[maxFreq++] = tail.get(i);\n      }\n      tail.clear();\n\n      scoreWindow(collector, windowBase, windowMin, windowMax, leads, maxFreq);\n    }\n\n    // Push back scorers into head and tail\n    for (int i = 0; i < maxFreq; ++i) {\n      final BulkScorerAndDoc evicted = head.insertWithOverflow(leads[i]);\n      if (evicted != null) {\n        tail.add(evicted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"251e6911800e3a02e1da3bfd4dc49a914aef9778":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["251e6911800e3a02e1da3bfd4dc49a914aef9778"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4464508ee83288c8c4585b533f9faaa93aa314"]},"commit2Childs":{"251e6911800e3a02e1da3bfd4dc49a914aef9778":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["251e6911800e3a02e1da3bfd4dc49a914aef9778"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}