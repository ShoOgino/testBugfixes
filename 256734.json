{"path":"backwards/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","commits":[{"id":"480d01e5b0ef8efb136d51670fec297ae5ae2c9c","date":1268821447,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"backwards/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"/dev/null","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set<byte[]> possibleMatchPayloads = new HashSet<byte[]>();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<byte[]>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection<byte[]> payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList<byte[]>(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backwards/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"backwards/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set<byte[]> possibleMatchPayloads = new HashSet<byte[]>();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<byte[]>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection<byte[]> payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList<byte[]>(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set<byte[]> possibleMatchPayloads = new HashSet<byte[]>();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<byte[]>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection<byte[]> payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList<byte[]>(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"]},"commit2Childs":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}