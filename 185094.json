{"path":"sandbox/contributions/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next().mjava","commits":[{"id":"7c9cc1cf78edc774cdf339bab3ae62f077929607","date":1072205195,"type":0,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"sandbox/contributions/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next().mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     *\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         hanppened in the InputStream\n     *\n     * @see \"http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\"\n     *      for detail\n     */\n    public final Token next() throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        int length = 0;\n\n        /** the position used to create Token */\n        int start = offset;\n\n        while (true) {\n            /** current charactor */\n            char c;\n\n            /** unicode block of current charactor for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = (char) ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                    /** convert  HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN */\n                    int i = (int) c;\n                    i = i - 65248;\n                    c = (char) i;\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == \"double\") {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n                        tokenType = \"single\";\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = \"single\";\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, eg.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = \"double\";\n                    } else {\n                        if (tokenType == \"single\") {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = \"double\";\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return new Token(new String(buffer, 0, length), start, start + length,\n                         tokenType\n                        );\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0291cd5597e313c484c410b94adc8f0172e0306e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"51c37735eb0e74724db8769a2e72869e80a6e3d1","date":1074547408,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"sandbox/contributions/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next().mjava","pathOld":"sandbox/contributions/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next().mjava","sourceNew":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     *\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         hanppened in the InputStream\n     *\n     * @see \"http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\"\n     *      for detail\n     */\n    public final Token next() throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        int length = 0;\n\n        /** the position used to create Token */\n        int start = offset;\n\n        while (true) {\n            /** current charactor */\n            char c;\n\n            /** unicode block of current charactor for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                    /** convert  HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN */\n                    int i = (int) c;\n                    i = i - 65248;\n                    c = (char) i;\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == \"double\") {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n                        tokenType = \"single\";\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = \"single\";\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, eg.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = \"double\";\n                    } else {\n                        if (tokenType == \"single\") {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = \"double\";\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return new Token(new String(buffer, 0, length), start, start + length,\n                         tokenType\n                        );\n    }\n\n","sourceOld":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     *\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         hanppened in the InputStream\n     *\n     * @see \"http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\"\n     *      for detail\n     */\n    public final Token next() throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        int length = 0;\n\n        /** the position used to create Token */\n        int start = offset;\n\n        while (true) {\n            /** current charactor */\n            char c;\n\n            /** unicode block of current charactor for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = (char) ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                    /** convert  HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN */\n                    int i = (int) c;\n                    i = i - 65248;\n                    c = (char) i;\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == \"double\") {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n                        tokenType = \"single\";\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = \"single\";\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, eg.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = \"double\";\n                    } else {\n                        if (tokenType == \"single\") {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = \"double\";\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return new Token(new String(buffer, 0, length), start, start + length,\n                         tokenType\n                        );\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"45f275006082500ab3f3183321dd574cca62dd3e","date":1092825487,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"sandbox/contributions/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next().mjava","pathOld":"sandbox/contributions/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next().mjava","sourceNew":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         hanppened in the InputStream\n     *\n     */\n    public final Token next() throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        int length = 0;\n\n        /** the position used to create Token */\n        int start = offset;\n\n        while (true) {\n            /** current charactor */\n            char c;\n\n            /** unicode block of current charactor for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                    /** convert  HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN */\n                    int i = (int) c;\n                    i = i - 65248;\n                    c = (char) i;\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == \"double\") {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n                        tokenType = \"single\";\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = \"single\";\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, eg.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = \"double\";\n                    } else {\n                        if (tokenType == \"single\") {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = \"double\";\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return new Token(new String(buffer, 0, length), start, start + length,\n                         tokenType\n                        );\n    }\n\n","sourceOld":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     *\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         hanppened in the InputStream\n     *\n     * @see \"http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\"\n     *      for detail\n     */\n    public final Token next() throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        int length = 0;\n\n        /** the position used to create Token */\n        int start = offset;\n\n        while (true) {\n            /** current charactor */\n            char c;\n\n            /** unicode block of current charactor for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                    /** convert  HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN */\n                    int i = (int) c;\n                    i = i - 65248;\n                    c = (char) i;\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == \"double\") {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n                        tokenType = \"single\";\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = \"single\";\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, eg.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = \"double\";\n                    } else {\n                        if (tokenType == \"single\") {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = \"double\";\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return new Token(new String(buffer, 0, length), start, start + length,\n                         tokenType\n                        );\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"043c298cb215f13ba7b9b81d20760704e8f93d66","date":1107566743,"type":5,"author":"Erik Hatcher","isMerge":false,"pathNew":"contrib/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next().mjava","pathOld":"sandbox/contributions/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next().mjava","sourceNew":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         hanppened in the InputStream\n     *\n     */\n    public final Token next() throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        int length = 0;\n\n        /** the position used to create Token */\n        int start = offset;\n\n        while (true) {\n            /** current charactor */\n            char c;\n\n            /** unicode block of current charactor for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                    /** convert  HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN */\n                    int i = (int) c;\n                    i = i - 65248;\n                    c = (char) i;\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == \"double\") {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n                        tokenType = \"single\";\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = \"single\";\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, eg.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = \"double\";\n                    } else {\n                        if (tokenType == \"single\") {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = \"double\";\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return new Token(new String(buffer, 0, length), start, start + length,\n                         tokenType\n                        );\n    }\n\n","sourceOld":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         hanppened in the InputStream\n     *\n     */\n    public final Token next() throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        int length = 0;\n\n        /** the position used to create Token */\n        int start = offset;\n\n        while (true) {\n            /** current charactor */\n            char c;\n\n            /** unicode block of current charactor for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                    /** convert  HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN */\n                    int i = (int) c;\n                    i = i - 65248;\n                    c = (char) i;\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == \"double\") {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n                        tokenType = \"single\";\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = \"single\";\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, eg.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = \"double\";\n                    } else {\n                        if (tokenType == \"single\") {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = \"double\";\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return new Token(new String(buffer, 0, length), start, start + length,\n                         tokenType\n                        );\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"043c298cb215f13ba7b9b81d20760704e8f93d66":["45f275006082500ab3f3183321dd574cca62dd3e"],"51c37735eb0e74724db8769a2e72869e80a6e3d1":["7c9cc1cf78edc774cdf339bab3ae62f077929607"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7c9cc1cf78edc774cdf339bab3ae62f077929607":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"45f275006082500ab3f3183321dd574cca62dd3e":["51c37735eb0e74724db8769a2e72869e80a6e3d1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["043c298cb215f13ba7b9b81d20760704e8f93d66"]},"commit2Childs":{"043c298cb215f13ba7b9b81d20760704e8f93d66":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"51c37735eb0e74724db8769a2e72869e80a6e3d1":["45f275006082500ab3f3183321dd574cca62dd3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7c9cc1cf78edc774cdf339bab3ae62f077929607"],"7c9cc1cf78edc774cdf339bab3ae62f077929607":["51c37735eb0e74724db8769a2e72869e80a6e3d1"],"45f275006082500ab3f3183321dd574cca62dd3e":["043c298cb215f13ba7b9b81d20760704e8f93d66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}