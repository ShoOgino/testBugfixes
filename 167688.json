{"path":"solr/core/src/test/org/apache/solr/search/facet/TestCloudJSONFacetSKGEquiv#testWhiteboxSanitySweepDebug().mjava","commits":[{"id":"2f9e4bd10604489b5817ee29e35ac96a3148cbec","date":1594345357,"type":0,"author":"Michael Gibney","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestCloudJSONFacetSKGEquiv#testWhiteboxSanitySweepDebug().mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Sanity check that our method of varying the <code>{@value RelatednessAgg#SWEEP_COLLECTION}</code> in conjunction with the\n   * <code>method</code> params works and can be verified by inspecting the debug output of basic requests.\n   */\n  public void testWhiteboxSanitySweepDebug() throws Exception {\n    // NOTE: json.facet debugging output can be wonky, particularly when dealing with cloud\n    // so for these queries we keep it simple:\n    // - only one \"top\" facet per request\n    // - no refinement\n    // even with those constraints in place, a single facet can (may/sometimes?) produce multiple debug\n    // blocks - aparently due to shard merging? So...\n    // - only inspect the \"first\" debug NamedList in the results\n    //\n    \n    final SolrParams baseParams = params(\"rows\",\"0\",\n                                         \"debug\",\"true\", // SOLR-14451\n                                         // *:* is the only \"safe\" query for this test,\n                                         // to ensure we always have at least one bucket for every facet\n                                         // so we can be confident in getting the debug we expect...\n                                         \"q\", \"*:*\",\n                                         \"fore\", multiStrField(7)+\":11\",\n                                         \"back\", \"*:*\");\n    \n    // simple individual facet that sorts on an skg stat...\n    //\n    // all results we test should be the same even if there is another 'skg_extra' stat,\n    // it shouldn't be involved in the sweeping at all.\n    for (Facet extra : Arrays.asList(null,  new RelatednessFacet(multiStrField(2)+\":9\", null))) {\n      // choose a single value string so we know both 'dv' (sweep) and 'dvhash' (no sweep) can be specified\n      final TermFacet f = new TermFacet(soloStrField(9), 10, 0, \"skg desc\", null);\n      if (null != extra) {\n        f.subFacets.put(\"skg_extra\", extra);\n      }\n      final Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"str\", f);\n        \n      final SolrParams facetParams\n        = SolrParams.wrapDefaults(params(\"method_val\", \"dv\",\n                                         \"json.facet\", Facet.toJSONFacetParamValue(facets)),\n                                  baseParams);\n      \n      // both default sweep option and explicit sweep should give same results...\n      for (SolrParams sweepParams : Arrays.asList(params(),\n                                                  params(\"sweep_key\", RelatednessAgg.SWEEP_COLLECTION,\n                                                         \"sweep_val\", \"true\"))) {\n        final SolrParams params = SolrParams.wrapDefaults(sweepParams, facetParams);\n        \n        final NamedList<Object> debug = getFacetDebug(params);\n        assertEquals(FacetFieldProcessorByArrayDV.class.getSimpleName(), debug.get(\"processor\"));\n        @SuppressWarnings(\"unchecked\")\n        final NamedList<Object> sweep_debug = (NamedList<Object>) debug.get(SWEEP_COLLECTION_DEBUG_KEY);\n        assertNotNull(sweep_debug);\n        assertEquals(\"count\", sweep_debug.get(\"base\"));\n        assertEquals(Arrays.asList(\"skg!fg\",\"skg!bg\"), sweep_debug.get(\"accs\"));\n        assertEquals(Arrays.asList(\"skg\"), sweep_debug.get(\"mapped\"));\n      }\n      { // 'dv' will always *try* to sweep, but disabling on stat should mean debug is mostly empty...\n        final SolrParams params = SolrParams.wrapDefaults(params(\"sweep_key\", RelatednessAgg.SWEEP_COLLECTION,\n                                                                 \"sweep_val\", \"false\"),\n                                                          facetParams);\n        final NamedList<Object> debug = getFacetDebug(params);\n        assertEquals(FacetFieldProcessorByArrayDV.class.getSimpleName(), debug.get(\"processor\"));\n        @SuppressWarnings(\"unchecked\")\n        final NamedList<Object> sweep_debug = (NamedList<Object>) debug.get(SWEEP_COLLECTION_DEBUG_KEY);\n        assertNotNull(sweep_debug);\n        assertEquals(\"count\", sweep_debug.get(\"base\"));\n        assertEquals(Collections.emptyList(), sweep_debug.get(\"accs\"));\n        assertEquals(Collections.emptyList(), sweep_debug.get(\"mapped\"));\n      }\n      { // if we override 'dv' with 'hashdv' which doesn't sweep, our sweep debug should be empty,\n        // even if the skg stat does ask for sweeping explicitly...\n        final SolrParams params = SolrParams.wrapDefaults(params(\"method_val\", \"dvhash\",\n                                                                 \"sweep_key\", RelatednessAgg.SWEEP_COLLECTION,\n                                                                 \"sweep_val\", \"true\"),\n                                                          facetParams);\n        final NamedList<Object> debug = getFacetDebug(params);\n        assertEquals(FacetFieldProcessorByHashDV.class.getSimpleName(), debug.get(\"processor\"));\n        assertNull(debug.get(SWEEP_COLLECTION_DEBUG_KEY));\n      }\n    }\n\n    // simple facet that sorts on an skg stat but uses prelim_sort on count\n    //\n    // all results we test should be the same even if there is another 'skg_extra' stat,\n    // neither skg should be involved in the sweeping at all.\n    for (Facet extra : Arrays.asList(null,  new RelatednessFacet(multiStrField(2)+\":9\", null))) {\n      // choose a single value string so we know both 'dv' (sweep) and 'dvhash' (no sweep) can be specified\n      final TermFacet f = new TermFacet(soloStrField(9), map(\"limit\", 3, \"overrequest\", 0,\n                                                             \"sort\", \"skg desc\",\n                                                             \"prelim_sort\", \"count asc\"));\n      if (null != extra) {\n        f.subFacets.put(\"skg_extra\", extra);\n      }\n      final Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"str\", f);\n        \n      final SolrParams facetParams\n        = SolrParams.wrapDefaults(params(\"method_val\", \"dv\",\n                                         \"json.facet\", Facet.toJSONFacetParamValue(facets)),\n                                  baseParams);\n\n      // default sweep as well as any explicit sweep=true/false values should give same results: no sweeping\n      for (SolrParams sweepParams : Arrays.asList(params(),\n                                                  params(\"sweep_key\", RelatednessAgg.SWEEP_COLLECTION,\n                                                         \"sweep_val\", \"false\"),\n                                                  params(\"sweep_key\", RelatednessAgg.SWEEP_COLLECTION,\n                                                         \"sweep_val\", \"true\"))) {\n        final SolrParams params = SolrParams.wrapDefaults(sweepParams, facetParams);\n        \n        final NamedList<Object> debug = getFacetDebug(params);\n        assertEquals(FacetFieldProcessorByArrayDV.class.getSimpleName(), debug.get(\"processor\"));\n        @SuppressWarnings(\"unchecked\")\n        final NamedList<Object> sweep_debug = (NamedList<Object>) debug.get(SWEEP_COLLECTION_DEBUG_KEY);\n        assertNotNull(sweep_debug);\n        assertEquals(\"count\", sweep_debug.get(\"base\"));\n        assertEquals(Collections.emptyList(), sweep_debug.get(\"accs\"));\n        assertEquals(Collections.emptyList(), sweep_debug.get(\"mapped\"));\n      }\n    }\n    \n    { // single facet with infinite limit + multiple skgs...\n      // this should trigger MultiAcc collection, causing sweeping on both skg functions\n      //\n      // all results we test should be the same even if there is another 'min' stat,\n      // in each term facet.  it shouldn't affect the sweeping/MultiAcc at all.\n      for (Facet extra : Arrays.asList(null,  new SumFacet(multiIntField(2)))) {\n        final Map<String,TermFacet> facets = new LinkedHashMap<>();\n        final TermFacet facet = new TermFacet(soloStrField(9), -1, 0, \"skg2 desc\", null);\n        facet.subFacets.put(\"skg2\", new RelatednessFacet(multiStrField(2)+\":9\", null));\n        if (null != extra) {\n          facet.subFacets.put(\"sum\", extra);\n        }\n        facets.put(\"str\", facet);\n        final SolrParams facetParams\n          = SolrParams.wrapDefaults(params(\"method_val\", \"dv\",\n                                           \"json.facet\", Facet.toJSONFacetParamValue(facets)),\n                                    baseParams);\n        \n        // both default sweep option and explicit sweep should give same results...\n        for (SolrParams sweepParams : Arrays.asList(params(),\n                                                    params(\"sweep_key\", RelatednessAgg.SWEEP_COLLECTION,\n                                                           \"sweep_val\", \"true\"))) {\n          final SolrParams params = SolrParams.wrapDefaults(sweepParams, facetParams);\n          \n          final NamedList<Object> debug = getFacetDebug(params);\n          assertEquals(FacetFieldProcessorByArrayDV.class.getSimpleName(), debug.get(\"processor\"));\n          @SuppressWarnings(\"unchecked\")\n          final NamedList<Object> sweep_debug = (NamedList<Object>) debug.get(SWEEP_COLLECTION_DEBUG_KEY);\n          assertNotNull(sweep_debug);\n          assertEquals(\"count\", sweep_debug.get(\"base\"));\n          assertEquals(Arrays.asList(\"skg!fg\",\"skg!bg\",\"skg2!fg\",\"skg2!bg\"), sweep_debug.get(\"accs\"));\n          assertEquals(Arrays.asList(\"skg\",\"skg2\"), sweep_debug.get(\"mapped\"));\n        }\n      }\n    }\n    \n    // nested facets that both sort on an skg stat\n    // (set limit + overrequest tiny to keep multishard response managable)\n    //\n    // all results we test should be the same even if there is another 'skg_extra' stat,\n    // in each term facet.  they shouldn't be involved in the sweeping at all.\n    for (Facet extra : Arrays.asList(null,  new RelatednessFacet(multiStrField(2)+\":9\", null))) {\n      // choose single value strings so we know both 'dv' (sweep) and 'dvhash' (no sweep) can be specified\n      // choose 'id' for the parent facet so we are garunteed some child facets\n      final TermFacet parent = new TermFacet(\"id\", 1, 0, \"skg desc\", false);\n      final TermFacet child = new TermFacet(soloStrField(7), 1, 0, \"skg desc\", false);\n      parent.subFacets.put(\"child\", child);\n      if (null != extra) {\n        parent.subFacets.put(\"skg_extra\", extra);\n        child.subFacets.put(\"skg_extra\", extra);\n      }\n      final Map<String,TermFacet> facets = new LinkedHashMap<>();\n      facets.put(\"parent\", parent);\n        \n      final SolrParams facetParams\n        = SolrParams.wrapDefaults(params(\"method_val\", \"dv\",\n                                         \"json.facet\", Facet.toJSONFacetParamValue(facets)),\n                                  baseParams);\n      // both default sweep option and explicit sweep should give same results...\n      for (SolrParams sweepParams : Arrays.asList(params(),\n                                                  params(\"sweep_key\", RelatednessAgg.SWEEP_COLLECTION,\n                                                         \"sweep_val\", \"true\"))) {\n        final SolrParams params = SolrParams.wrapDefaults(sweepParams, facetParams);\n        \n        final NamedList<Object> parentDebug = getFacetDebug(params);\n        assertEquals(\"id\", parentDebug.get(\"field\"));\n        assertNotNull(parentDebug.get(\"sub-facet\"));\n        // may be multiples from diff shards, just use first one\n        @SuppressWarnings(\"unchecked\")\n        final NamedList<Object> childDebug = ((List<NamedList<Object>>)parentDebug.get(\"sub-facet\")).get(0);\n        assertEquals(soloStrField(7), childDebug.get(\"field\"));\n\n        // these should all be true for both the parent and the child debug..\n        for (NamedList<Object> debug : Arrays.asList(parentDebug, childDebug)) {\n          assertEquals(FacetFieldProcessorByArrayDV.class.getSimpleName(), debug.get(\"processor\"));\n          @SuppressWarnings(\"unchecked\")\n          final NamedList<Object> sweep_debug = (NamedList<Object>) debug.get(SWEEP_COLLECTION_DEBUG_KEY);\n          assertNotNull(sweep_debug);\n          assertEquals(\"count\", sweep_debug.get(\"base\"));\n          assertEquals(Arrays.asList(\"skg!fg\",\"skg!bg\"), sweep_debug.get(\"accs\"));\n          assertEquals(Arrays.asList(\"skg\"), sweep_debug.get(\"mapped\"));\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2f9e4bd10604489b5817ee29e35ac96a3148cbec":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2f9e4bd10604489b5817ee29e35ac96a3148cbec"]},"commit2Childs":{"2f9e4bd10604489b5817ee29e35ac96a3148cbec":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2f9e4bd10604489b5817ee29e35ac96a3148cbec"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}