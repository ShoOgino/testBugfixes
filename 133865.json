{"path":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader,boolean[]).mjava","commits":[{"id":"9ce0dc549cffe574c5e49b654c95a60713e0453c","date":1492031850,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader,boolean[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","sourceNew":"  /** Read in a single partition of data, setting isExhausted[0] to true if there are no more items. */\n  int readPartition(ByteSequencesReader reader, boolean[] isExhausted) throws IOException {\n    long start = System.currentTimeMillis();\n    if (valueLength != -1) {\n      int limit = ramBufferSize.bytes / valueLength;\n      for(int i=0;i<limit;i++) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          isExhausted[0] = true;\n          break;\n        }\n        buffer.append(item);\n      }\n    } else {\n      while (true) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          isExhausted[0] = true;\n          break;\n        }\n        buffer.append(item);\n        // Account for the created objects.\n        // (buffer slots do not account to buffer size.) \n        if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n          break;\n        }\n      }\n    }\n    sortInfo.readTime += System.currentTimeMillis() - start;\n    return buffer.size();\n  }\n\n","sourceOld":"  /** Read in a single partition of data */\n  int readPartition(ByteSequencesReader reader) throws IOException {\n    long start = System.currentTimeMillis();\n    if (valueLength != -1) {\n      int limit = ramBufferSize.bytes / valueLength;\n      for(int i=0;i<limit;i++) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          break;\n        }\n        buffer.append(item);\n      }\n    } else {\n      while (true) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          break;\n        }\n        buffer.append(item);\n        // Account for the created objects.\n        // (buffer slots do not account to buffer size.) \n        if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n          break;\n        }\n      }\n    }\n    sortInfo.readTime += System.currentTimeMillis() - start;\n    return buffer.size();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader,boolean[]).mjava","pathOld":"/dev/null","sourceNew":"  /** Read in a single partition of data, setting isExhausted[0] to true if there are no more items. */\n  int readPartition(ByteSequencesReader reader, boolean[] isExhausted) throws IOException {\n    long start = System.currentTimeMillis();\n    if (valueLength != -1) {\n      int limit = ramBufferSize.bytes / valueLength;\n      for(int i=0;i<limit;i++) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          isExhausted[0] = true;\n          break;\n        }\n        buffer.append(item);\n      }\n    } else {\n      while (true) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          isExhausted[0] = true;\n          break;\n        }\n        buffer.append(item);\n        // Account for the created objects.\n        // (buffer slots do not account to buffer size.) \n        if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n          break;\n        }\n      }\n    }\n    sortInfo.readTime += System.currentTimeMillis() - start;\n    return buffer.size();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dcb0432bcb41451b41e9aaaabe99f5d208258fe","date":1493203108,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader,boolean[]).mjava","sourceNew":"  /** Read in a single partition of data, setting isExhausted[0] to true if there are no more items. */\n  Partition readPartition(ByteSequencesReader reader) throws IOException, InterruptedException {\n    if (partitionsInRAM != null) {\n      partitionsInRAM.acquire();\n    }\n    long start = System.currentTimeMillis();\n    SortableBytesRefArray buffer;\n    boolean exhausted = false;\n    int count;\n    if (valueLength != -1) {\n      // fixed length case\n      buffer = new FixedLengthBytesRefArray(valueLength);\n      int limit = ramBufferSize.bytes / valueLength;\n      for(int i=0;i<limit;i++) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          exhausted = true;\n          break;\n        }\n        buffer.append(item);\n      }\n    } else {\n      Counter bufferBytesUsed = Counter.newCounter();\n      buffer = new BytesRefArray(bufferBytesUsed);\n      while (true) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          exhausted = true;\n          break;\n        }\n        buffer.append(item);\n        // Account for the created objects.\n        // (buffer slots do not account to buffer size.) \n        if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n          break;\n        }\n      }\n    }\n    sortInfo.readTimeMS += System.currentTimeMillis() - start;\n\n    return new Partition(buffer, exhausted);\n  }\n\n","sourceOld":"  /** Read in a single partition of data, setting isExhausted[0] to true if there are no more items. */\n  int readPartition(ByteSequencesReader reader, boolean[] isExhausted) throws IOException {\n    long start = System.currentTimeMillis();\n    if (valueLength != -1) {\n      int limit = ramBufferSize.bytes / valueLength;\n      for(int i=0;i<limit;i++) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          isExhausted[0] = true;\n          break;\n        }\n        buffer.append(item);\n      }\n    } else {\n      while (true) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          isExhausted[0] = true;\n          break;\n        }\n        buffer.append(item);\n        // Account for the created objects.\n        // (buffer slots do not account to buffer size.) \n        if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n          break;\n        }\n      }\n    }\n    sortInfo.readTime += System.currentTimeMillis() - start;\n    return buffer.size();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":4,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter#readPartition(ByteSequencesReader,boolean[]).mjava","sourceNew":null,"sourceOld":"  /** Read in a single partition of data, setting isExhausted[0] to true if there are no more items. */\n  int readPartition(ByteSequencesReader reader, boolean[] isExhausted) throws IOException {\n    long start = System.currentTimeMillis();\n    if (valueLength != -1) {\n      int limit = ramBufferSize.bytes / valueLength;\n      for(int i=0;i<limit;i++) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          isExhausted[0] = true;\n          break;\n        }\n        buffer.append(item);\n      }\n    } else {\n      while (true) {\n        BytesRef item = null;\n        try {\n          item = reader.next();\n        } catch (Throwable t) {\n          verifyChecksum(t, reader);\n        }\n        if (item == null) {\n          isExhausted[0] = true;\n          break;\n        }\n        buffer.append(item);\n        // Account for the created objects.\n        // (buffer slots do not account to buffer size.) \n        if (bufferBytesUsed.get() > ramBufferSize.bytes) {\n          break;\n        }\n      }\n    }\n    sortInfo.readTime += System.currentTimeMillis() - start;\n    return buffer.size();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","7dcb0432bcb41451b41e9aaaabe99f5d208258fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9ce0dc549cffe574c5e49b654c95a60713e0453c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7dcb0432bcb41451b41e9aaaabe99f5d208258fe":["9ce0dc549cffe574c5e49b654c95a60713e0453c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7dcb0432bcb41451b41e9aaaabe99f5d208258fe"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","9ce0dc549cffe574c5e49b654c95a60713e0453c"],"9ce0dc549cffe574c5e49b654c95a60713e0453c":["7dcb0432bcb41451b41e9aaaabe99f5d208258fe"],"7dcb0432bcb41451b41e9aaaabe99f5d208258fe":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}