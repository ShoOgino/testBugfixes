{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","commits":[{"id":"f241b963c5bcd6c2293a928059dd2d64988a6042","date":1340296137,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws CorruptIndexException, IOException {\n\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      // Only allow a new merge to be triggered if we are\n      // going to wait for merges:\n      if (doFlush) {\n        flush(waitForMerges, true);\n      } else {\n        docWriter.abort(); // already closed\n      }\n\n      if (waitForMerges)\n        // Give merge scheduler last chance to run, in case\n        // any pending merges are waiting:\n        mergeScheduler.merge(this);\n\n      mergePolicy.close();\n\n      synchronized(this) {\n        finishMerges(waitForMerges);\n        stopMerges = true;\n      }\n      mergeScheduler.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges) throws CorruptIndexException, IOException {\n\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      // Only allow a new merge to be triggered if we are\n      // going to wait for merges:\n      if (!hitOOM) {\n        flush(waitForMerges, true);\n      }\n\n      if (waitForMerges)\n        // Give merge scheduler last chance to run, in case\n        // any pending merges are waiting:\n        mergeScheduler.merge(this);\n\n      mergePolicy.close();\n\n      synchronized(this) {\n        finishMerges(waitForMerges);\n        stopMerges = true;\n      }\n      mergeScheduler.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (!hitOOM) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      // Only allow a new merge to be triggered if we are\n      // going to wait for merges:\n      if (doFlush) {\n        flush(waitForMerges, true);\n      } else {\n        docWriter.abort(); // already closed\n      }\n\n      if (waitForMerges)\n        // Give merge scheduler last chance to run, in case\n        // any pending merges are waiting:\n        mergeScheduler.merge(this);\n\n      mergePolicy.close();\n\n      synchronized(this) {\n        finishMerges(waitForMerges);\n        stopMerges = true;\n      }\n      mergeScheduler.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws CorruptIndexException, IOException {\n\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      // Only allow a new merge to be triggered if we are\n      // going to wait for merges:\n      if (doFlush) {\n        flush(waitForMerges, true);\n      } else {\n        docWriter.abort(); // already closed\n      }\n\n      if (waitForMerges)\n        // Give merge scheduler last chance to run, in case\n        // any pending merges are waiting:\n        mergeScheduler.merge(this);\n\n      mergePolicy.close();\n\n      synchronized(this) {\n        finishMerges(waitForMerges);\n        stopMerges = true;\n      }\n      mergeScheduler.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["f241b963c5bcd6c2293a928059dd2d64988a6042"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      // Only allow a new merge to be triggered if we are\n      // going to wait for merges:\n      if (doFlush) {\n        flush(waitForMerges, true);\n      } else {\n        docWriter.abort(); // already closed\n      }\n\n      if (waitForMerges)\n        // Give merge scheduler last chance to run, in case\n        // any pending merges are waiting:\n        mergeScheduler.merge(this);\n\n      mergePolicy.close();\n\n      synchronized(this) {\n        finishMerges(waitForMerges);\n        stopMerges = true;\n      }\n      mergeScheduler.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9e9b91640bcf21617f742fa506dc0a1495bb7d6","date":1343107563,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = Thread.interrupted();\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      // Only allow a new merge to be triggered if we are\n      // going to wait for merges:\n      if (doFlush) {\n        flush(waitForMerges, true);\n      } else {\n        docWriter.abort(); // already closed\n      }\n\n      if (waitForMerges) {\n        try {\n          // Give merge scheduler last chance to run, in case\n          // any pending merges are waiting:\n          mergeScheduler.merge(this);\n        } catch (ThreadInterruptedException tie) {\n          // ignore any interruption, does not matter\n          interrupted = true;\n        }\n      }\n      \n      mergePolicy.close();\n\n      synchronized(this) {\n        for (;;) {\n          try {\n            finishMerges(waitForMerges && !interrupted);\n            break;\n          } catch (ThreadInterruptedException tie) {\n            // by setting the interrupted status, the\n            // next call to finishMerges will pass false,\n            // so it will not wait\n            interrupted = true;\n          }\n        }\n        stopMerges = true;\n      }\n      \n      // shutdown scheduler and all threads (this call is not interruptible):\n      mergeScheduler.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      // Only allow a new merge to be triggered if we are\n      // going to wait for merges:\n      if (doFlush) {\n        flush(waitForMerges, true);\n      } else {\n        docWriter.abort(); // already closed\n      }\n\n      if (waitForMerges)\n        // Give merge scheduler last chance to run, in case\n        // any pending merges are waiting:\n        mergeScheduler.merge(this);\n\n      mergePolicy.close();\n\n      synchronized(this) {\n        finishMerges(waitForMerges);\n        stopMerges = true;\n      }\n      mergeScheduler.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["b1976f81c88f23b2ce4a5c0f22999f8ed1ec9fc5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"593247e32e5bbafc74e7814ee222c476851649e0","date":1343109920,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = Thread.interrupted();\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed\n        }\n        \n      } finally {\n        // clean up merge scheduler in all cases, although flushing may have failed:\n      \n        if (waitForMerges) {\n          try {\n            // Give merge scheduler last chance to run, in case\n            // any pending merges are waiting:\n            mergeScheduler.merge(this);\n          } catch (ThreadInterruptedException tie) {\n            // ignore any interruption, does not matter\n            interrupted = true;\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n            }\n          }\n        }\n        \n        mergePolicy.close();\n\n        synchronized(this) {\n          for (;;) {\n            try {\n              finishMerges(waitForMerges && !interrupted);\n              break;\n            } catch (ThreadInterruptedException tie) {\n              // by setting the interrupted status, the\n              // next call to finishMerges will pass false,\n              // so it will not wait\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n              }\n            }\n          }\n          stopMerges = true;\n        }\n        \n        // shutdown scheduler and all threads (this call is not interruptible):\n        mergeScheduler.close();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = Thread.interrupted();\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      // Only allow a new merge to be triggered if we are\n      // going to wait for merges:\n      if (doFlush) {\n        flush(waitForMerges, true);\n      } else {\n        docWriter.abort(); // already closed\n      }\n\n      if (waitForMerges) {\n        try {\n          // Give merge scheduler last chance to run, in case\n          // any pending merges are waiting:\n          mergeScheduler.merge(this);\n        } catch (ThreadInterruptedException tie) {\n          // ignore any interruption, does not matter\n          interrupted = true;\n        }\n      }\n      \n      mergePolicy.close();\n\n      synchronized(this) {\n        for (;;) {\n          try {\n            finishMerges(waitForMerges && !interrupted);\n            break;\n          } catch (ThreadInterruptedException tie) {\n            // by setting the interrupted status, the\n            // next call to finishMerges will pass false,\n            // so it will not wait\n            interrupted = true;\n          }\n        }\n        stopMerges = true;\n      }\n      \n      // shutdown scheduler and all threads (this call is not interruptible):\n      mergeScheduler.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":null,"bugIntro":["a4278fc65afbb35739525c37f818cded6fe6e9ae","b1976f81c88f23b2ce4a5c0f22999f8ed1ec9fc5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"485b37078172eeeff573d185377390ded88d99bd","date":1343110799,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed\n        }\n        \n      } finally {\n        // clean up merge scheduler in all cases, although flushing may have failed:\n        interrupted = Thread.interrupted();\n      \n        if (waitForMerges) {\n          try {\n            // Give merge scheduler last chance to run, in case\n            // any pending merges are waiting:\n            mergeScheduler.merge(this);\n          } catch (ThreadInterruptedException tie) {\n            // ignore any interruption, does not matter\n            interrupted = true;\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n            }\n          }\n        }\n        \n        mergePolicy.close();\n\n        synchronized(this) {\n          for (;;) {\n            try {\n              finishMerges(waitForMerges && !interrupted);\n              break;\n            } catch (ThreadInterruptedException tie) {\n              // by setting the interrupted status, the\n              // next call to finishMerges will pass false,\n              // so it will not wait\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n              }\n            }\n          }\n          stopMerges = true;\n        }\n        \n        // shutdown scheduler and all threads (this call is not interruptible):\n        mergeScheduler.close();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = Thread.interrupted();\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed\n        }\n        \n      } finally {\n        // clean up merge scheduler in all cases, although flushing may have failed:\n      \n        if (waitForMerges) {\n          try {\n            // Give merge scheduler last chance to run, in case\n            // any pending merges are waiting:\n            mergeScheduler.merge(this);\n          } catch (ThreadInterruptedException tie) {\n            // ignore any interruption, does not matter\n            interrupted = true;\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n            }\n          }\n        }\n        \n        mergePolicy.close();\n\n        synchronized(this) {\n          for (;;) {\n            try {\n              finishMerges(waitForMerges && !interrupted);\n              break;\n            } catch (ThreadInterruptedException tie) {\n              // by setting the interrupted status, the\n              // next call to finishMerges will pass false,\n              // so it will not wait\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n              }\n            }\n          }\n          stopMerges = true;\n        }\n        \n        // shutdown scheduler and all threads (this call is not interruptible):\n        mergeScheduler.close();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":null,"bugIntro":["b1976f81c88f23b2ce4a5c0f22999f8ed1ec9fc5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b1976f81c88f23b2ce4a5c0f22999f8ed1ec9fc5","date":1343117367,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed\n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed\n        }\n        \n      } finally {\n        // clean up merge scheduler in all cases, although flushing may have failed:\n        interrupted = Thread.interrupted();\n      \n        if (waitForMerges) {\n          try {\n            // Give merge scheduler last chance to run, in case\n            // any pending merges are waiting:\n            mergeScheduler.merge(this);\n          } catch (ThreadInterruptedException tie) {\n            // ignore any interruption, does not matter\n            interrupted = true;\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n            }\n          }\n        }\n        \n        mergePolicy.close();\n\n        synchronized(this) {\n          for (;;) {\n            try {\n              finishMerges(waitForMerges && !interrupted);\n              break;\n            } catch (ThreadInterruptedException tie) {\n              // by setting the interrupted status, the\n              // next call to finishMerges will pass false,\n              // so it will not wait\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n              }\n            }\n          }\n          stopMerges = true;\n        }\n        \n        // shutdown scheduler and all threads (this call is not interruptible):\n        mergeScheduler.close();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":["593247e32e5bbafc74e7814ee222c476851649e0","e9e9b91640bcf21617f742fa506dc0a1495bb7d6","485b37078172eeeff573d185377390ded88d99bd"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","date":1343203827,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed\n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      // Only allow a new merge to be triggered if we are\n      // going to wait for merges:\n      if (doFlush) {\n        flush(waitForMerges, true);\n      } else {\n        docWriter.abort(); // already closed\n      }\n\n      if (waitForMerges)\n        // Give merge scheduler last chance to run, in case\n        // any pending merges are waiting:\n        mergeScheduler.merge(this);\n\n      mergePolicy.close();\n\n      synchronized(this) {\n        finishMerges(waitForMerges);\n        stopMerges = true;\n      }\n      mergeScheduler.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed\n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      // Only allow a new merge to be triggered if we are\n      // going to wait for merges:\n      if (doFlush) {\n        flush(waitForMerges, true);\n      } else {\n        docWriter.abort(); // already closed\n      }\n\n      if (waitForMerges)\n        // Give merge scheduler last chance to run, in case\n        // any pending merges are waiting:\n        mergeScheduler.merge(this);\n\n      mergePolicy.close();\n\n      synchronized(this) {\n        finishMerges(waitForMerges);\n        stopMerges = true;\n      }\n      mergeScheduler.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed\n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      // Only allow a new merge to be triggered if we are\n      // going to wait for merges:\n      if (doFlush) {\n        flush(waitForMerges, true);\n      } else {\n        docWriter.abort(); // already closed\n      }\n\n      if (waitForMerges)\n        // Give merge scheduler last chance to run, in case\n        // any pending merges are waiting:\n        mergeScheduler.merge(this);\n\n      mergePolicy.close();\n\n      synchronized(this) {\n        finishMerges(waitForMerges);\n        stopMerges = true;\n      }\n      mergeScheduler.close();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b47e1512544568a22b82c96169d466fae8a4b79e","date":1354519309,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed\n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed\n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed\n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed\n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal(null);\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4278fc65afbb35739525c37f818cded6fe6e9ae","date":1369132128,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed\n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":["593247e32e5bbafc74e7814ee222c476851649e0"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7af110b00ea8df9429309d83e38e0533d82e144f","date":1376924768,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates() : \"\" +  oldWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"31d4861802ca404d78ca1d15f4550eec415b9199","date":1376947894,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates() : \"\" +  oldWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates() : \"\" +  oldWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666","date":1381263930,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      // Must do this before commitInternal, in case any of\n      // the dropped readers in the pool wrote a new live\n      // docs: \n      synchronized(this) {\n        readerPool.dropAll(true);\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      synchronized(this) {\n        deleter.close();\n      }\n\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n\n      synchronized (this) {\n        docWriter = null;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates() : \"\" +  oldWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n      synchronized(this) {\n        readerPool.dropAll(true);\n        docWriter = null;\n        deleter.close();\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates() : \"\" +  oldWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abf299c3223296f3d69484286b321c8da2dfe3c6","date":1381332681,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      // Must do this before commitInternal, in case any of\n      // the dropped readers in the pool wrote a new live\n      // docs: \n      synchronized(this) {\n        readerPool.dropAll(true);\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      synchronized(this) {\n        deleter.close();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      // Must do this before commitInternal, in case any of\n      // the dropped readers in the pool wrote a new live\n      // docs: \n      synchronized(this) {\n        readerPool.dropAll(true);\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      synchronized(this) {\n        deleter.close();\n      }\n\n      // used by assert below\n      final DocumentsWriter oldWriter = docWriter;\n\n      synchronized (this) {\n        docWriter = null;\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates() : \"\" +  oldWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  oldWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5e40c7b0baa9f015b690f60bacb592b64264ba3d","date":1381610202,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      synchronized(this) {\n        // commitInternal calls ReaderPool.commit, which\n        // writes any pending liveDocs from ReaderPool, so\n        // it's safe to drop all readers now:\n        readerPool.dropAll(true);\n        deleter.close();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      // Must do this before commitInternal, in case any of\n      // the dropped readers in the pool wrote a new live\n      // docs: \n      synchronized(this) {\n        readerPool.dropAll(true);\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      synchronized(this) {\n        deleter.close();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ad5831ce5311e0afb145f4ffafb431feb9ac224","date":1383743871,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      synchronized(this) {\n        // commitInternal calls ReaderPool.commit, which\n        // writes any pending liveDocs from ReaderPool, so\n        // it's safe to drop all readers now:\n        readerPool.dropAll(true);\n        deleter.close();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n      processEvents(false, true);\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      synchronized(this) {\n        // commitInternal calls ReaderPool.commit, which\n        // writes any pending liveDocs from ReaderPool, so\n        // it's safe to drop all readers now:\n        readerPool.dropAll(true);\n        deleter.close();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":null,"bugIntro":["03805a62fcc9481b8a440bacb644519a7035c2d8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"03805a62fcc9481b8a440bacb644519a7035c2d8","date":1387555495,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n      processEvents(false, true);\n      synchronized(this) {\n        // commitInternal calls ReaderPool.commit, which\n        // writes any pending liveDocs from ReaderPool, so\n        // it's safe to drop all readers now:\n        readerPool.dropAll(true);\n        deleter.close();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n\n      synchronized(this) {\n        // commitInternal calls ReaderPool.commit, which\n        // writes any pending liveDocs from ReaderPool, so\n        // it's safe to drop all readers now:\n        readerPool.dropAll(true);\n        deleter.close();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n      processEvents(false, true);\n    }\n  }\n\n","bugFix":["4ad5831ce5311e0afb145f4ffafb431feb9ac224","e82780afe6097066eb5befb86e9432f077667e3d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0fcdcf196523675146a4df3193e91413533857ab","date":1390686560,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n      processEvents(false, true);\n      synchronized(this) {\n        // commitInternal calls ReaderPool.commit, which\n        // writes any pending liveDocs from ReaderPool, so\n        // it's safe to drop all readers now:\n        readerPool.dropAll(true);\n        deleter.close();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n\n      if (writeLock != null) {\n        writeLock.close();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n      processEvents(false, true);\n      synchronized(this) {\n        // commitInternal calls ReaderPool.commit, which\n        // writes any pending liveDocs from ReaderPool, so\n        // it's safe to drop all readers now:\n        readerPool.dropAll(true);\n        deleter.close();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":["2cf040795587947011604327cf9538e12d298d8b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4853751884e55469b8cc1abab8fa0788eab240c9","date":1394565067,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this, MergeTrigger.CLOSING, false);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n      processEvents(false, true);\n      synchronized(this) {\n        // commitInternal calls ReaderPool.commit, which\n        // writes any pending liveDocs from ReaderPool, so\n        // it's safe to drop all readers now:\n        readerPool.dropAll(true);\n        deleter.close();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n\n      if (writeLock != null) {\n        writeLock.close();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n      processEvents(false, true);\n      synchronized(this) {\n        // commitInternal calls ReaderPool.commit, which\n        // writes any pending liveDocs from ReaderPool, so\n        // it's safe to drop all readers now:\n        readerPool.dropAll(true);\n        deleter.close();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n\n      if (writeLock != null) {\n        writeLock.close();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeInternal(boolean,boolean).mjava","sourceNew":null,"sourceOld":"  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {\n    boolean interrupted = false;\n    try {\n\n      if (pendingCommit != null) {\n        throw new IllegalStateException(\"cannot close: prepareCommit was already called with no corresponding call to commit\");\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now flush at close waitForMerges=\" + waitForMerges);\n      }\n\n      docWriter.close();\n\n      try {\n        // Only allow a new merge to be triggered if we are\n        // going to wait for merges:\n        if (doFlush) {\n          flush(waitForMerges, true);\n        } else {\n          docWriter.abort(this); // already closed -- never sync on IW \n        }\n        \n      } finally {\n        try {\n          // clean up merge scheduler in all cases, although flushing may have failed:\n          interrupted = Thread.interrupted();\n        \n          if (waitForMerges) {\n            try {\n              // Give merge scheduler last chance to run, in case\n              // any pending merges are waiting:\n              mergeScheduler.merge(this, MergeTrigger.CLOSING, false);\n            } catch (ThreadInterruptedException tie) {\n              // ignore any interruption, does not matter\n              interrupted = true;\n              if (infoStream.isEnabled(\"IW\")) {\n                infoStream.message(\"IW\", \"interrupted while waiting for final merges\");\n              }\n            }\n          }\n          \n          synchronized(this) {\n            for (;;) {\n              try {\n                finishMerges(waitForMerges && !interrupted);\n                break;\n              } catch (ThreadInterruptedException tie) {\n                // by setting the interrupted status, the\n                // next call to finishMerges will pass false,\n                // so it will not wait\n                interrupted = true;\n                if (infoStream.isEnabled(\"IW\")) {\n                  infoStream.message(\"IW\", \"interrupted while waiting for merges to finish\");\n                }\n              }\n            }\n            stopMerges = true;\n          }\n          \n        } finally {\n          // shutdown policy, scheduler and all threads (this call is not interruptible):\n          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"now call final commit()\");\n      }\n\n      if (doFlush) {\n        commitInternal();\n      }\n      processEvents(false, true);\n      synchronized(this) {\n        // commitInternal calls ReaderPool.commit, which\n        // writes any pending liveDocs from ReaderPool, so\n        // it's safe to drop all readers now:\n        readerPool.dropAll(true);\n        deleter.close();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"at close: \" + segString());\n      }\n\n      if (writeLock != null) {\n        writeLock.close();                          // release write lock\n        writeLock = null;\n      }\n      synchronized(this) {\n        closed = true;\n      }\n      assert docWriter.perThreadPool.numDeactivatedThreadStates() == docWriter.perThreadPool.getMaxThreadStates() : \"\" +  docWriter.perThreadPool.numDeactivatedThreadStates() + \" \" +  docWriter.perThreadPool.getMaxThreadStates();\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"closeInternal\");\n    } finally {\n      synchronized(this) {\n        closing = false;\n        notifyAll();\n        if (!closed) {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"hit exception while closing\");\n          }\n        }\n      }\n      // finally, restore interrupt status:\n      if (interrupted) Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4853751884e55469b8cc1abab8fa0788eab240c9":["0fcdcf196523675146a4df3193e91413533857ab"],"5e40c7b0baa9f015b690f60bacb592b64264ba3d":["abf299c3223296f3d69484286b321c8da2dfe3c6"],"7af110b00ea8df9429309d83e38e0533d82e144f":["a4278fc65afbb35739525c37f818cded6fe6e9ae"],"abf299c3223296f3d69484286b321c8da2dfe3c6":["8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666"],"f241b963c5bcd6c2293a928059dd2d64988a6042":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","b1976f81c88f23b2ce4a5c0f22999f8ed1ec9fc5"],"4ad5831ce5311e0afb145f4ffafb431feb9ac224":["5e40c7b0baa9f015b690f60bacb592b64264ba3d"],"03805a62fcc9481b8a440bacb644519a7035c2d8":["4ad5831ce5311e0afb145f4ffafb431feb9ac224"],"e9e9b91640bcf21617f742fa506dc0a1495bb7d6":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"aba371508186796cc6151d8223a5b4e16d02e26e":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","b1976f81c88f23b2ce4a5c0f22999f8ed1ec9fc5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["4853751884e55469b8cc1abab8fa0788eab240c9"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["f241b963c5bcd6c2293a928059dd2d64988a6042"],"a4278fc65afbb35739525c37f818cded6fe6e9ae":["b47e1512544568a22b82c96169d466fae8a4b79e"],"593247e32e5bbafc74e7814ee222c476851649e0":["e9e9b91640bcf21617f742fa506dc0a1495bb7d6"],"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666":["7af110b00ea8df9429309d83e38e0533d82e144f"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["a4278fc65afbb35739525c37f818cded6fe6e9ae","7af110b00ea8df9429309d83e38e0533d82e144f"],"31d4861802ca404d78ca1d15f4550eec415b9199":["a4278fc65afbb35739525c37f818cded6fe6e9ae","7af110b00ea8df9429309d83e38e0533d82e144f"],"407687e67faf6e1f02a211ca078d8e3eed631027":["b1976f81c88f23b2ce4a5c0f22999f8ed1ec9fc5","b47e1512544568a22b82c96169d466fae8a4b79e"],"485b37078172eeeff573d185377390ded88d99bd":["593247e32e5bbafc74e7814ee222c476851649e0"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["fe33227f6805edab2036cbb80645cc4e2d1fa424","b1976f81c88f23b2ce4a5c0f22999f8ed1ec9fc5"],"0fcdcf196523675146a4df3193e91413533857ab":["03805a62fcc9481b8a440bacb644519a7035c2d8"],"b47e1512544568a22b82c96169d466fae8a4b79e":["b1976f81c88f23b2ce4a5c0f22999f8ed1ec9fc5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"b1976f81c88f23b2ce4a5c0f22999f8ed1ec9fc5":["485b37078172eeeff573d185377390ded88d99bd"]},"commit2Childs":{"4853751884e55469b8cc1abab8fa0788eab240c9":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"5e40c7b0baa9f015b690f60bacb592b64264ba3d":["4ad5831ce5311e0afb145f4ffafb431feb9ac224"],"7af110b00ea8df9429309d83e38e0533d82e144f":["8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"abf299c3223296f3d69484286b321c8da2dfe3c6":["5e40c7b0baa9f015b690f60bacb592b64264ba3d"],"f241b963c5bcd6c2293a928059dd2d64988a6042":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b":[],"4ad5831ce5311e0afb145f4ffafb431feb9ac224":["03805a62fcc9481b8a440bacb644519a7035c2d8"],"03805a62fcc9481b8a440bacb644519a7035c2d8":["0fcdcf196523675146a4df3193e91413533857ab"],"e9e9b91640bcf21617f742fa506dc0a1495bb7d6":["593247e32e5bbafc74e7814ee222c476851649e0"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f241b963c5bcd6c2293a928059dd2d64988a6042","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","e9e9b91640bcf21617f742fa506dc0a1495bb7d6","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"a4278fc65afbb35739525c37f818cded6fe6e9ae":["7af110b00ea8df9429309d83e38e0533d82e144f","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"593247e32e5bbafc74e7814ee222c476851649e0":["485b37078172eeeff573d185377390ded88d99bd"],"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666":["abf299c3223296f3d69484286b321c8da2dfe3c6"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"31d4861802ca404d78ca1d15f4550eec415b9199":[],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"485b37078172eeeff573d185377390ded88d99bd":["b1976f81c88f23b2ce4a5c0f22999f8ed1ec9fc5"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"0fcdcf196523675146a4df3193e91413533857ab":["4853751884e55469b8cc1abab8fa0788eab240c9"],"b47e1512544568a22b82c96169d466fae8a4b79e":["a4278fc65afbb35739525c37f818cded6fe6e9ae","407687e67faf6e1f02a211ca078d8e3eed631027"],"b1976f81c88f23b2ce4a5c0f22999f8ed1ec9fc5":["fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","aba371508186796cc6151d8223a5b4e16d02e26e","407687e67faf6e1f02a211ca078d8e3eed631027","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","b47e1512544568a22b82c96169d466fae8a4b79e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","aba371508186796cc6151d8223a5b4e16d02e26e","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","407687e67faf6e1f02a211ca078d8e3eed631027","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}