{"path":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random, indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random.nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random.nextBoolean()) {\n        // Fixed\n        stringDVType = random.nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random.nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1]));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"int\", Integer.parseInt(data[i][2]), DocValues.Type.VAR_INTS));\n          }\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"float\", Float.parseFloat(data[i][3]), DocValues.Type.FLOAT_32));\n          }\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"string\", new BytesRef(data[i][4]), stringDVType));\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5]));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6]));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7]));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"double\", Double.parseDouble(data[i][8]), DocValues.Type.FLOAT_64));\n          }\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9]));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10]));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11]));\n\n        for(IndexableField f : doc.getFields()) {\n          ((Field) f).setBoost(2.0f);\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    s.setDefaultFieldSortScoring(true, true);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random, indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random.nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random.nextBoolean()) {\n        // Fixed\n        stringDVType = random.nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random.nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1]));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"int\", Integer.parseInt(data[i][2]), DocValues.Type.VAR_INTS));\n          }\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"float\", Float.parseFloat(data[i][3]), DocValues.Type.FLOAT_32));\n          }\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"string\", new BytesRef(data[i][4]), stringDVType));\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5]));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6]));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7]));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"double\", Double.parseDouble(data[i][8]), DocValues.Type.FLOAT_64));\n          }\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9]));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10]));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11]));\n\n        for(IndexableField f : doc.getFields()) {\n          ((Field) f).setBoost(2.0f);\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    s.setDefaultFieldSortScoring(true, true);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1336abe0899b2984e5652903556c1925fbdca9f","date":1329580100,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random, indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random.nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random.nextBoolean()) {\n        // Fixed\n        stringDVType = random.nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random.nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1]));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"int\", Integer.parseInt(data[i][2]), DocValues.Type.VAR_INTS));\n          }\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"float\", Float.parseFloat(data[i][3]), DocValues.Type.FLOAT_32));\n          }\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"string\", new BytesRef(data[i][4]), stringDVType));\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5]));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6]));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7]));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"double\", Double.parseDouble(data[i][8]), DocValues.Type.FLOAT_64));\n          }\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9]));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10]));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11]));\n\n        for(IndexableField f : doc.getFields()) {\n          if (!f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    s.setDefaultFieldSortScoring(true, true);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random, indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random.nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random.nextBoolean()) {\n        // Fixed\n        stringDVType = random.nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random.nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1]));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"int\", Integer.parseInt(data[i][2]), DocValues.Type.VAR_INTS));\n          }\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"float\", Float.parseFloat(data[i][3]), DocValues.Type.FLOAT_32));\n          }\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"string\", new BytesRef(data[i][4]), stringDVType));\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5]));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6]));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7]));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"double\", Double.parseDouble(data[i][8]), DocValues.Type.FLOAT_64));\n          }\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9]));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10]));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11]));\n\n        for(IndexableField f : doc.getFields()) {\n          ((Field) f).setBoost(2.0f);\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    s.setDefaultFieldSortScoring(true, true);\n    return s;\n  }\n\n","bugFix":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1]));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"int\", Integer.parseInt(data[i][2]), DocValues.Type.VAR_INTS));\n          }\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"float\", Float.parseFloat(data[i][3]), DocValues.Type.FLOAT_32));\n          }\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"string\", new BytesRef(data[i][4]), stringDVType));\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5]));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6]));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7]));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"double\", Double.parseDouble(data[i][8]), DocValues.Type.FLOAT_64));\n          }\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9]));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10]));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11]));\n\n        for(IndexableField f : doc.getFields()) {\n          if (!f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    s.setDefaultFieldSortScoring(true, true);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random, indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random.nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random.nextBoolean()) {\n        // Fixed\n        stringDVType = random.nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random.nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1]));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"int\", Integer.parseInt(data[i][2]), DocValues.Type.VAR_INTS));\n          }\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"float\", Float.parseFloat(data[i][3]), DocValues.Type.FLOAT_32));\n          }\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"string\", new BytesRef(data[i][4]), stringDVType));\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5]));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6]));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7]));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"double\", Double.parseDouble(data[i][8]), DocValues.Type.FLOAT_64));\n          }\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9]));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10]));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11]));\n\n        for(IndexableField f : doc.getFields()) {\n          if (!f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    s.setDefaultFieldSortScoring(true, true);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d","date":1336650316,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1]));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2]));\n          if (supportsDocValues) {\n            doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n          }\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3]));\n          if (supportsDocValues) {\n            doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n          }\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4]));\n          if (supportsDocValues) {\n            switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n            }\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5]));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6]));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7]));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8]));\n          if (supportsDocValues) {\n            doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n          }\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9]));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10]));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11]));\n\n        for(IndexableField f : doc.getFields()) {\n          if (!f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    s.setDefaultFieldSortScoring(true, true);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1]));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"int\", Integer.parseInt(data[i][2]), DocValues.Type.VAR_INTS));\n          }\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"float\", Float.parseFloat(data[i][3]), DocValues.Type.FLOAT_32));\n          }\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"string\", new BytesRef(data[i][4]), stringDVType));\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5]));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6]));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7]));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8]));\n          if (supportsDocValues) {\n            doc.add(new DocValuesField(\"double\", Double.parseDouble(data[i][8]), DocValues.Type.FLOAT_64));\n          }\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9]));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10]));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11]));\n\n        for(IndexableField f : doc.getFields()) {\n          if (!f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    s.setDefaultFieldSortScoring(true, true);\n    return s;\n  }\n\n","bugFix":["fa0f44f887719e97183771e977cfc4bfb485b766"],"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb02351ae2b114dd41585916d1e35fb2cff98fb0","date":1337171337,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1]));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2]));\n          if (supportsDocValues) {\n            doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n          }\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3]));\n          if (supportsDocValues) {\n            doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n          }\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4]));\n          if (supportsDocValues) {\n            switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n            }\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5]));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6]));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7]));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8]));\n          if (supportsDocValues) {\n            doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n          }\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9]));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10]));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11]));\n\n        for(IndexableField f : doc.getFields()) {\n          if (!f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1]));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2]));\n          if (supportsDocValues) {\n            doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n          }\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3]));\n          if (supportsDocValues) {\n            doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n          }\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4]));\n          if (supportsDocValues) {\n            switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n            }\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5]));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6]));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7]));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8]));\n          if (supportsDocValues) {\n            doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n          }\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9]));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10]));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11]));\n\n        for(IndexableField f : doc.getFields()) {\n          if (!f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    s.setDefaultFieldSortScoring(true, true);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef0d8a69209261514c5739c770bba706c2308450","date":1337607597,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1]));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2]));\n          if (supportsDocValues) {\n            doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n          }\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3]));\n          if (supportsDocValues) {\n            doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n          }\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4]));\n          if (supportsDocValues) {\n            switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n            }\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5]));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6]));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7]));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8]));\n          if (supportsDocValues) {\n            doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n          }\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9]));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10]));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11]));\n\n        for(IndexableField f : doc.getFields()) {\n          if (!f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1]));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2]));\n          if (supportsDocValues) {\n            doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n          }\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3]));\n          if (supportsDocValues) {\n            doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n          }\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4]));\n          if (supportsDocValues) {\n            switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n            }\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5]));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6]));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7]));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8]));\n          if (supportsDocValues) {\n            doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n          }\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9]));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10]));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11]));\n\n        for(IndexableField f : doc.getFields()) {\n          if (!f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    s.setDefaultFieldSortScoring(true, true);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57ae3024996ccdb3c36c42cb890e1efb37df4ce8","date":1338343651,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1]));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2]));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3]));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4]));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5]));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6]));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7]));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8]));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9]));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10]));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11]));\n\n        for(IndexableField f : doc.getFields()) {\n          if (!f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1]));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2]));\n          if (supportsDocValues) {\n            doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n          }\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3]));\n          if (supportsDocValues) {\n            doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n          }\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4]));\n          if (supportsDocValues) {\n            switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n            }\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5]));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6]));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7]));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8]));\n          if (supportsDocValues) {\n            doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n          }\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9]));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10]));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11]));\n\n        for(IndexableField f : doc.getFields()) {\n          if (!f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (!f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1]));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2]));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3]));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4]));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5]));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6]));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7]));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8]));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9]));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10]));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11]));\n\n        for(IndexableField f : doc.getFields()) {\n          if (!f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","bugFix":["fa0f44f887719e97183771e977cfc4bfb485b766","1509f151d7692d84fae414b2b799ac06ba60fcb4"],"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a3635dad24b0681f0088f2ef680456482cdb451","date":1344025573,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (!f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (!f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (!f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1ed65f3455364344c6d2ff76ea5421aac754eae7","date":1353261762,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    // nocommit remove:\n    ((LogMergePolicy) writer.w.getConfig().getMergePolicy()).setUseCompoundFile(false);\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29f7cc7c185412da66c1d0089d9e75da01329a00","date":1353364851,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    // nocommit remove:\n    ((LogMergePolicy) writer.w.getConfig().getMergePolicy()).setUseCompoundFile(false);\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    // nocommit remove:\n    ((LogMergePolicy) writer.w.getConfig().getMergePolicy()).setUseCompoundFile(false);\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7178a82d1134111f4511f28bb9ad57573a57d93","date":1354112608,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    // nocommit remove:\n    ((LogMergePolicy) writer.w.getConfig().getMergePolicy()).setUseCompoundFile(false);\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e29774db46ad98ca4a8d7fcbfab633ebc01f358","date":1355170812,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex(boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for(int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add(new Field(\"tracer\", data[i][0], ft1));\n        doc.add(new TextField(\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField(\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int_dv\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField(\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float_dv\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField(\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string_dv\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string_dv\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string_dv\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string_dv\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string_dv\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string_dv\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add(new StringField(\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add(new StringField(\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add(new StringField(\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField(\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double_dv\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add(new StringField(\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add(new StringField(\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add(new StringField(\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument(doc);\n      }\n    }\n\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    // nocommit back to newSearcher(true)? problem is this\n    // sometimes uses slow reader wrapper which does not\n    // provide DV 2.0\n    IndexSearcher s = newSearcher(reader, false);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0837ab0472feecb3a54260729d845f839e1cbd72","date":1358283639,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex(boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValuesType stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = DocValuesType.SORTED;\n    } else {\n      if (random().nextBoolean()) {\n        // Index non-sorted\n        stringDVType = DocValuesType.BINARY;\n      } else {\n        // sorted anyway\n        stringDVType = DocValuesType.SORTED;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for(int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add(new Field(\"tracer\", data[i][0], ft1));\n        doc.add(new TextField(\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField(\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int_dv\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField(\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float_dv\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField(\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            case BINARY:\n              doc.add(new BinaryDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add(new StringField(\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add(new StringField(\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add(new StringField(\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField(\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double_dv\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add(new StringField(\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add(new StringField(\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add(new StringField(\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument(doc);\n      }\n    }\n\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    // nocommit back to newSearcher(true)? problem is this\n    // sometimes uses slow reader wrapper which does not\n    // provide DV 2.0\n    IndexSearcher s = newSearcher(reader, false);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex(boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for(int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add(new Field(\"tracer\", data[i][0], ft1));\n        doc.add(new TextField(\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField(\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int_dv\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField(\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float_dv\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField(\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string_dv\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string_dv\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string_dv\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string_dv\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string_dv\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string_dv\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add(new StringField(\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add(new StringField(\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add(new StringField(\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField(\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double_dv\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add(new StringField(\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add(new StringField(\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add(new StringField(\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument(doc);\n      }\n    }\n\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    // nocommit back to newSearcher(true)? problem is this\n    // sometimes uses slow reader wrapper which does not\n    // provide DV 2.0\n    IndexSearcher s = newSearcher(reader, false);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"47b9e6cdfa7e1fc15944550d1007780d96b4dcb6","date":1358785685,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex(boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValuesType stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = DocValuesType.SORTED;\n    } else {\n      if (random().nextBoolean()) {\n        // Index non-sorted\n        stringDVType = DocValuesType.BINARY;\n      } else {\n        // sorted anyway\n        stringDVType = DocValuesType.SORTED;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for(int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add(new Field(\"tracer\", data[i][0], ft1));\n        doc.add(new TextField(\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField(\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int_dv\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField(\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float_dv\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField(\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            case BINARY:\n              doc.add(new BinaryDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add(new StringField(\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add(new StringField(\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add(new StringField(\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField(\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double_dv\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add(new StringField(\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add(new StringField(\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add(new StringField(\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument(doc);\n      }\n    }\n\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex(boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValuesType stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = DocValuesType.SORTED;\n    } else {\n      if (random().nextBoolean()) {\n        // Index non-sorted\n        stringDVType = DocValuesType.BINARY;\n      } else {\n        // sorted anyway\n        stringDVType = DocValuesType.SORTED;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for(int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add(new Field(\"tracer\", data[i][0], ft1));\n        doc.add(new TextField(\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField(\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int_dv\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField(\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float_dv\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField(\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            case BINARY:\n              doc.add(new BinaryDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add(new StringField(\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add(new StringField(\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add(new StringField(\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField(\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double_dv\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add(new StringField(\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add(new StringField(\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add(new StringField(\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument(doc);\n      }\n    }\n\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    // nocommit back to newSearcher(true)? problem is this\n    // sometimes uses slow reader wrapper which does not\n    // provide DV 2.0\n    IndexSearcher s = newSearcher(reader, false);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"423d89a2b3cc419b647c07c2b3fdbc54311d07f9","date":1358836612,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex(boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValuesType stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = DocValuesType.SORTED;\n    } else {\n      if (random().nextBoolean()) {\n        // Index non-sorted\n        stringDVType = DocValuesType.BINARY;\n      } else {\n        // sorted anyway\n        stringDVType = DocValuesType.SORTED;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for(int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add(new Field(\"tracer\", data[i][0], ft1));\n        doc.add(new TextField(\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField(\"int\", data[i][2], Field.Store.NO));\n          doc.add(new NumericDocValuesField(\"int_dv\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField(\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float_dv\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField(\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case SORTED:\n              doc.add(new SortedDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            case BINARY:\n              doc.add(new BinaryDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add(new StringField(\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add(new StringField(\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add(new StringField(\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField(\"double\", data[i][8], Field.Store.NO));\n          doc.add(new NumericDocValuesField(\"double_dv\", Double.doubleToRawLongBits(Double.parseDouble(data[i][8]))));\n        }\n        if (data[i][9] != null) doc.add(new StringField(\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add(new StringField(\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add(new StringField(\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument(doc);\n      }\n    }\n\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex(boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValuesType stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = DocValuesType.SORTED;\n    } else {\n      if (random().nextBoolean()) {\n        // Index non-sorted\n        stringDVType = DocValuesType.BINARY;\n      } else {\n        // sorted anyway\n        stringDVType = DocValuesType.SORTED;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for(int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add(new Field(\"tracer\", data[i][0], ft1));\n        doc.add(new TextField(\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField(\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int_dv\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField(\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float_dv\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField(\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            case BINARY:\n              doc.add(new BinaryDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add(new StringField(\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add(new StringField(\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add(new StringField(\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField(\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double_dv\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add(new StringField(\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add(new StringField(\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add(new StringField(\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument(doc);\n      }\n    }\n\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fa76f8dbaa3ae60d6dd32c1d415f882e392b8826","date":1359066233,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex(boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValuesType stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = DocValuesType.SORTED;\n    } else {\n      if (random().nextBoolean()) {\n        // Index non-sorted\n        stringDVType = DocValuesType.BINARY;\n      } else {\n        // sorted anyway\n        stringDVType = DocValuesType.SORTED;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for(int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add(new Field(\"tracer\", data[i][0], ft1));\n        doc.add(new TextField(\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField(\"int\", data[i][2], Field.Store.NO));\n          doc.add(new NumericDocValuesField(\"int_dv\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField(\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float_dv\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField(\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case SORTED:\n              doc.add(new SortedDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            case BINARY:\n              doc.add(new BinaryDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        } else {\n          switch(stringDVType) {\n            case SORTED:\n              doc.add(new SortedDocValuesField(\"string_dv\", new BytesRef()));\n              break;\n            case BINARY:\n              doc.add(new BinaryDocValuesField(\"string_dv\", new BytesRef()));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add(new StringField(\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add(new StringField(\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add(new StringField(\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField(\"double\", data[i][8], Field.Store.NO));\n          doc.add(new NumericDocValuesField(\"double_dv\", Double.doubleToRawLongBits(Double.parseDouble(data[i][8]))));\n        }\n        if (data[i][9] != null) doc.add(new StringField(\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add(new StringField(\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add(new StringField(\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument(doc);\n      }\n    }\n\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex(boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValuesType stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = DocValuesType.SORTED;\n    } else {\n      if (random().nextBoolean()) {\n        // Index non-sorted\n        stringDVType = DocValuesType.BINARY;\n      } else {\n        // sorted anyway\n        stringDVType = DocValuesType.SORTED;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for(int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add(new Field(\"tracer\", data[i][0], ft1));\n        doc.add(new TextField(\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField(\"int\", data[i][2], Field.Store.NO));\n          doc.add(new NumericDocValuesField(\"int_dv\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField(\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float_dv\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField(\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case SORTED:\n              doc.add(new SortedDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            case BINARY:\n              doc.add(new BinaryDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add(new StringField(\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add(new StringField(\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add(new StringField(\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField(\"double\", data[i][8], Field.Store.NO));\n          doc.add(new NumericDocValuesField(\"double_dv\", Double.doubleToRawLongBits(Double.parseDouble(data[i][8]))));\n        }\n        if (data[i][9] != null) doc.add(new StringField(\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add(new StringField(\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add(new StringField(\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument(doc);\n      }\n    }\n\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex(boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValuesType stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = DocValuesType.SORTED;\n    } else {\n      if (random().nextBoolean()) {\n        // Index non-sorted\n        stringDVType = DocValuesType.BINARY;\n      } else {\n        // sorted anyway\n        stringDVType = DocValuesType.SORTED;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for(int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add(new Field(\"tracer\", data[i][0], ft1));\n        doc.add(new TextField(\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField(\"int\", data[i][2], Field.Store.NO));\n          doc.add(new NumericDocValuesField(\"int_dv\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField(\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float_dv\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField(\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case SORTED:\n              doc.add(new SortedDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            case BINARY:\n              doc.add(new BinaryDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        } else {\n          switch(stringDVType) {\n            case SORTED:\n              doc.add(new SortedDocValuesField(\"string_dv\", new BytesRef()));\n              break;\n            case BINARY:\n              doc.add(new BinaryDocValuesField(\"string_dv\", new BytesRef()));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add(new StringField(\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add(new StringField(\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add(new StringField(\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField(\"double\", data[i][8], Field.Store.NO));\n          doc.add(new NumericDocValuesField(\"double_dv\", Double.doubleToRawLongBits(Double.parseDouble(data[i][8]))));\n        }\n        if (data[i][9] != null) doc.add(new StringField(\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add(new StringField(\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add(new StringField(\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument(doc);\n      }\n    }\n\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex (boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValues.Type stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_SORTED : DocValues.Type.BYTES_FIXED_SORTED;\n    } else {\n      // Index non-sorted\n      if (random().nextBoolean()) {\n        // Fixed\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_FIXED_STRAIGHT : DocValues.Type.BYTES_FIXED_DEREF;\n      } else {\n        // Var\n        stringDVType = random().nextBoolean() ? DocValues.Type.BYTES_VAR_STRAIGHT : DocValues.Type.BYTES_VAR_DEREF;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for (int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add (new Field (\"tracer\", data[i][0], ft1));\n        doc.add (new TextField (\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField (\"int\", data[i][2], Field.Store.NO));\n          doc.add(new PackedLongDocValuesField(\"int\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField (\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField (\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case BYTES_FIXED_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_SORTED:\n              doc.add(new SortedBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_STRAIGHT:\n              doc.add(new StraightBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            case BYTES_FIXED_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), true));\n              break;\n            case BYTES_VAR_DEREF:\n              doc.add(new DerefBytesDocValuesField(\"string\", new BytesRef(data[i][4]), false));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add (new StringField (\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add (new StringField (\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add (new StringField (\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField (\"double\", data[i][8], Field.Store.NO));\n          doc.add(new DoubleDocValuesField(\"double\", Double.parseDouble(data[i][8])));\n        }\n        if (data[i][9] != null) doc.add (new StringField (\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add (new StringField (\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add (new StringField (\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument (doc);\n      }\n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","bugFix":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d","629c38c4ae4e303d0617e05fbfe508140b32f0a3","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","ab9633cb67e3c0aec3c066147a23a957d6e7ad8c","04f07771a2a7dd3a395700665ed839c3dae2def2","28088b0a688977b79dec2cc9119cff2fb4aab7ee","63bc3238545c6012bd44f5d294077997f236bc4e","7e4db59c6b6c10e25322cfb41c4c19d78b4298bd","57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f183729ece15402db94402d482f29ebac4f7f54","date":1360963151,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":null,"sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex(boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValuesType stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = DocValuesType.SORTED;\n    } else {\n      if (random().nextBoolean()) {\n        // Index non-sorted\n        stringDVType = DocValuesType.BINARY;\n      } else {\n        // sorted anyway\n        stringDVType = DocValuesType.SORTED;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for(int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add(new Field(\"tracer\", data[i][0], ft1));\n        doc.add(new TextField(\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField(\"int\", data[i][2], Field.Store.NO));\n          doc.add(new NumericDocValuesField(\"int_dv\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField(\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float_dv\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField(\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case SORTED:\n              doc.add(new SortedDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            case BINARY:\n              doc.add(new BinaryDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        } else {\n          switch(stringDVType) {\n            case SORTED:\n              doc.add(new SortedDocValuesField(\"string_dv\", new BytesRef()));\n              break;\n            case BINARY:\n              doc.add(new BinaryDocValuesField(\"string_dv\", new BytesRef()));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add(new StringField(\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add(new StringField(\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add(new StringField(\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField(\"double\", data[i][8], Field.Store.NO));\n          doc.add(new NumericDocValuesField(\"double_dv\", Double.doubleToRawLongBits(Double.parseDouble(data[i][8]))));\n        }\n        if (data[i][9] != null) doc.add(new StringField(\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add(new StringField(\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add(new StringField(\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument(doc);\n      }\n    }\n\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"95303ff3749680c743b9425f9cf99e6e4065e8a8","date":1361061922,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#getIndex(boolean,boolean).mjava","sourceNew":null,"sourceOld":"  // create an index of all the documents, or just the x, or just the y documents\n  private IndexSearcher getIndex(boolean even, boolean odd)\n  throws IOException {\n    Directory indexStore = newDirectory();\n    dirs.add(indexStore);\n    RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n\n    final DocValuesType stringDVType;\n    if (dvStringSorted) {\n      // Index sorted\n      stringDVType = DocValuesType.SORTED;\n    } else {\n      if (random().nextBoolean()) {\n        // Index non-sorted\n        stringDVType = DocValuesType.BINARY;\n      } else {\n        // sorted anyway\n        stringDVType = DocValuesType.SORTED;\n      }\n    }\n\n    FieldType ft1 = new FieldType();\n    ft1.setStored(true);\n    FieldType ft2 = new FieldType();\n    ft2.setIndexed(true);\n    for(int i=0; i<data.length; ++i) {\n      if (((i%2)==0 && even) || ((i%2)==1 && odd)) {\n        Document doc = new Document();\n        doc.add(new Field(\"tracer\", data[i][0], ft1));\n        doc.add(new TextField(\"contents\", data[i][1], Field.Store.NO));\n        if (data[i][2] != null) {\n          doc.add(new StringField(\"int\", data[i][2], Field.Store.NO));\n          doc.add(new NumericDocValuesField(\"int_dv\", Integer.parseInt(data[i][2])));\n        }\n        if (data[i][3] != null) {\n          doc.add(new StringField(\"float\", data[i][3], Field.Store.NO));\n          doc.add(new FloatDocValuesField(\"float_dv\", Float.parseFloat(data[i][3])));\n        }\n        if (data[i][4] != null) {\n          doc.add(new StringField(\"string\", data[i][4], Field.Store.NO));\n          switch(stringDVType) {\n            case SORTED:\n              doc.add(new SortedDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            case BINARY:\n              doc.add(new BinaryDocValuesField(\"string_dv\", new BytesRef(data[i][4])));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        } else {\n          switch(stringDVType) {\n            case SORTED:\n              doc.add(new SortedDocValuesField(\"string_dv\", new BytesRef()));\n              break;\n            case BINARY:\n              doc.add(new BinaryDocValuesField(\"string_dv\", new BytesRef()));\n              break;\n            default:\n              throw new IllegalStateException(\"unknown type \" + stringDVType);\n          }\n        }\n        if (data[i][5] != null) doc.add(new StringField(\"custom\",   data[i][5], Field.Store.NO));\n        if (data[i][6] != null) doc.add(new StringField(\"i18n\",     data[i][6], Field.Store.NO));\n        if (data[i][7] != null) doc.add(new StringField(\"long\",     data[i][7], Field.Store.NO));\n        if (data[i][8] != null) {\n          doc.add(new StringField(\"double\", data[i][8], Field.Store.NO));\n          doc.add(new NumericDocValuesField(\"double_dv\", Double.doubleToRawLongBits(Double.parseDouble(data[i][8]))));\n        }\n        if (data[i][9] != null) doc.add(new StringField(\"short\",     data[i][9], Field.Store.NO));\n        if (data[i][10] != null) doc.add(new StringField(\"byte\",     data[i][10], Field.Store.NO));\n        if (data[i][11] != null) doc.add(new StringField(\"parser\",     data[i][11], Field.Store.NO));\n\n        for(IndexableField f : doc.getFields()) {\n          if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {\n            ((Field) f).setBoost(2.0f);\n          }\n        }\n\n        writer.addDocument(doc);\n      }\n    }\n\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    IndexSearcher s = newSearcher(reader);\n    return s;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fa76f8dbaa3ae60d6dd32c1d415f882e392b8826":["423d89a2b3cc419b647c07c2b3fdbc54311d07f9"],"29f7cc7c185412da66c1d0089d9e75da01329a00":["1ed65f3455364344c6d2ff76ea5421aac754eae7"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f7178a82d1134111f4511f28bb9ad57573a57d93":["29f7cc7c185412da66c1d0089d9e75da01329a00"],"1ed65f3455364344c6d2ff76ea5421aac754eae7":["3a3635dad24b0681f0088f2ef680456482cdb451"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["04f07771a2a7dd3a395700665ed839c3dae2def2","3a3635dad24b0681f0088f2ef680456482cdb451"],"3a3635dad24b0681f0088f2ef680456482cdb451":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"3e29774db46ad98ca4a8d7fcbfab633ebc01f358":["f7178a82d1134111f4511f28bb9ad57573a57d93"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"fb02351ae2b114dd41585916d1e35fb2cff98fb0":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"5f183729ece15402db94402d482f29ebac4f7f54":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["3a3635dad24b0681f0088f2ef680456482cdb451","fa76f8dbaa3ae60d6dd32c1d415f882e392b8826"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":["d4d69c535930b5cce125cff868d40f6373dc27d4","5f183729ece15402db94402d482f29ebac4f7f54"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d1336abe0899b2984e5652903556c1925fbdca9f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["04f07771a2a7dd3a395700665ed839c3dae2def2","3a3635dad24b0681f0088f2ef680456482cdb451"],"0837ab0472feecb3a54260729d845f839e1cbd72":["3e29774db46ad98ca4a8d7fcbfab633ebc01f358"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["d1336abe0899b2984e5652903556c1925fbdca9f"],"423d89a2b3cc419b647c07c2b3fdbc54311d07f9":["47b9e6cdfa7e1fc15944550d1007780d96b4dcb6"],"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"ef0d8a69209261514c5739c770bba706c2308450":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d","fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5f183729ece15402db94402d482f29ebac4f7f54"],"47b9e6cdfa7e1fc15944550d1007780d96b4dcb6":["0837ab0472feecb3a54260729d845f839e1cbd72"]},"commit2Childs":{"fa76f8dbaa3ae60d6dd32c1d415f882e392b8826":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"29f7cc7c185412da66c1d0089d9e75da01329a00":["f7178a82d1134111f4511f28bb9ad57573a57d93"],"1ed65f3455364344c6d2ff76ea5421aac754eae7":["29f7cc7c185412da66c1d0089d9e75da01329a00"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d1336abe0899b2984e5652903556c1925fbdca9f"],"f7178a82d1134111f4511f28bb9ad57573a57d93":["3e29774db46ad98ca4a8d7fcbfab633ebc01f358"],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"3a3635dad24b0681f0088f2ef680456482cdb451":["1ed65f3455364344c6d2ff76ea5421aac754eae7","8fd5be977c105554c6a7b68afcdbc511439723ab","d4d69c535930b5cce125cff868d40f6373dc27d4","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"3e29774db46ad98ca4a8d7fcbfab633ebc01f358":["0837ab0472feecb3a54260729d845f839e1cbd72"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["8fd5be977c105554c6a7b68afcdbc511439723ab","3a3635dad24b0681f0088f2ef680456482cdb451","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"fb02351ae2b114dd41585916d1e35fb2cff98fb0":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8","ef0d8a69209261514c5739c770bba706c2308450"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"5f183729ece15402db94402d482f29ebac4f7f54":["95303ff3749680c743b9425f9cf99e6e4065e8a8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["5f183729ece15402db94402d482f29ebac4f7f54","95303ff3749680c743b9425f9cf99e6e4065e8a8"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d1336abe0899b2984e5652903556c1925fbdca9f":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"0837ab0472feecb3a54260729d845f839e1cbd72":["47b9e6cdfa7e1fc15944550d1007780d96b4dcb6"],"423d89a2b3cc419b647c07c2b3fdbc54311d07f9":["fa76f8dbaa3ae60d6dd32c1d415f882e392b8826"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d":["fb02351ae2b114dd41585916d1e35fb2cff98fb0","ef0d8a69209261514c5739c770bba706c2308450"],"ef0d8a69209261514c5739c770bba706c2308450":[],"47b9e6cdfa7e1fc15944550d1007780d96b4dcb6":["423d89a2b3cc419b647c07c2b3fdbc54311d07f9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8fd5be977c105554c6a7b68afcdbc511439723ab","95303ff3749680c743b9425f9cf99e6e4065e8a8","d6f074e73200c07d54f242d3880a8da5a35ff97b","ef0d8a69209261514c5739c770bba706c2308450","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}