{"path":"lucene/core/src/test/org/apache/lucene/store/TestMultiMMap#testSliceOfSlice().mjava","commits":[{"id":"f986320666d675a260eb4529a0c3c40595731441","date":1401729997,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestMultiMMap#testSliceOfSlice().mjava","pathOld":"/dev/null","sourceNew":"  public void testSliceOfSlice() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(createTempDir(\"testSliceOfSlice\"), null, 1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", newIOContext(random()));\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random().nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", newIOContext(random()));\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      ii.close();\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      IndexInput outerSlicer = mmapDir.openInput(\"bytes\", newIOContext(random()));\n      final int outerSliceStart = random().nextInt(bytes.length / 2);\n      final int outerSliceLength = random().nextInt(bytes.length - outerSliceStart);\n      IndexInput innerSlicer = outerSlicer.slice(\"parentBytesSlice\", outerSliceStart, outerSliceLength);\n      for (int sliceStart = 0; sliceStart < outerSliceLength; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < outerSliceLength - sliceStart; sliceLength++) {\n          assertSlice(bytes, innerSlicer, outerSliceStart, sliceStart, sliceLength);\n        }\n      }\n      innerSlicer.close();\n      outerSlicer.close();\n      mmapDir.close();\n    }    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285cdc737de75b7cc7c284a156b20214deb67bca","date":1415535483,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestMultiMMap#testSliceOfSlice().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/store/TestMultiMMap#testSliceOfSlice().mjava","sourceNew":"  public void testSliceOfSlice() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(createTempDir(\"testSliceOfSlice\"), 1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", newIOContext(random()));\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random().nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", newIOContext(random()));\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      ii.close();\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      IndexInput outerSlicer = mmapDir.openInput(\"bytes\", newIOContext(random()));\n      final int outerSliceStart = random().nextInt(bytes.length / 2);\n      final int outerSliceLength = random().nextInt(bytes.length - outerSliceStart);\n      IndexInput innerSlicer = outerSlicer.slice(\"parentBytesSlice\", outerSliceStart, outerSliceLength);\n      for (int sliceStart = 0; sliceStart < outerSliceLength; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < outerSliceLength - sliceStart; sliceLength++) {\n          assertSlice(bytes, innerSlicer, outerSliceStart, sliceStart, sliceLength);\n        }\n      }\n      innerSlicer.close();\n      outerSlicer.close();\n      mmapDir.close();\n    }    \n  }\n\n","sourceOld":"  public void testSliceOfSlice() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(createTempDir(\"testSliceOfSlice\"), null, 1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", newIOContext(random()));\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random().nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", newIOContext(random()));\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      ii.close();\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      IndexInput outerSlicer = mmapDir.openInput(\"bytes\", newIOContext(random()));\n      final int outerSliceStart = random().nextInt(bytes.length / 2);\n      final int outerSliceLength = random().nextInt(bytes.length - outerSliceStart);\n      IndexInput innerSlicer = outerSlicer.slice(\"parentBytesSlice\", outerSliceStart, outerSliceLength);\n      for (int sliceStart = 0; sliceStart < outerSliceLength; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < outerSliceLength - sliceStart; sliceLength++) {\n          assertSlice(bytes, innerSlicer, outerSliceStart, sliceStart, sliceLength);\n        }\n      }\n      innerSlicer.close();\n      outerSlicer.close();\n      mmapDir.close();\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4208ed8e426ae5f75a41d8b4ae53f4587e413061","date":1580475454,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestMultiMMap#testSliceOfSlice().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/store/TestMultiMMap#testSliceOfSlice().mjava","sourceNew":"  public void testSliceOfSlice() throws Exception {\n    int upto = TEST_NIGHTLY ? 10 : 8;\n    for (int i = 0; i < upto; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(createTempDir(\"testSliceOfSlice\"), 1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", newIOContext(random()));\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random().nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", newIOContext(random()));\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      ii.close();\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      IndexInput outerSlicer = mmapDir.openInput(\"bytes\", newIOContext(random()));\n      final int outerSliceStart = random().nextInt(bytes.length / 2);\n      final int outerSliceLength = random().nextInt(bytes.length - outerSliceStart);\n      IndexInput innerSlicer = outerSlicer.slice(\"parentBytesSlice\", outerSliceStart, outerSliceLength);\n      for (int sliceStart = 0; sliceStart < outerSliceLength; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < outerSliceLength - sliceStart; sliceLength++) {\n          assertSlice(bytes, innerSlicer, outerSliceStart, sliceStart, sliceLength);\n        }\n      }\n      innerSlicer.close();\n      outerSlicer.close();\n      mmapDir.close();\n    }    \n  }\n\n","sourceOld":"  public void testSliceOfSlice() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(createTempDir(\"testSliceOfSlice\"), 1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", newIOContext(random()));\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random().nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", newIOContext(random()));\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      ii.close();\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      IndexInput outerSlicer = mmapDir.openInput(\"bytes\", newIOContext(random()));\n      final int outerSliceStart = random().nextInt(bytes.length / 2);\n      final int outerSliceLength = random().nextInt(bytes.length - outerSliceStart);\n      IndexInput innerSlicer = outerSlicer.slice(\"parentBytesSlice\", outerSliceStart, outerSliceLength);\n      for (int sliceStart = 0; sliceStart < outerSliceLength; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < outerSliceLength - sliceStart; sliceLength++) {\n          assertSlice(bytes, innerSlicer, outerSliceStart, sliceStart, sliceLength);\n        }\n      }\n      innerSlicer.close();\n      outerSlicer.close();\n      mmapDir.close();\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"285cdc737de75b7cc7c284a156b20214deb67bca":["f986320666d675a260eb4529a0c3c40595731441"],"f986320666d675a260eb4529a0c3c40595731441":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["285cdc737de75b7cc7c284a156b20214deb67bca"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"]},"commit2Childs":{"285cdc737de75b7cc7c284a156b20214deb67bca":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"f986320666d675a260eb4529a0c3c40595731441":["285cdc737de75b7cc7c284a156b20214deb67bca"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f986320666d675a260eb4529a0c3c40595731441"],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}