{"path":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","commits":[{"id":"5cad50ed6659649a0edef71b8cf56280b0bdadd7","date":1385496862,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/cl2o/TestCharBlockArray#testArray().mjava","sourceNew":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = _TestUtil.getTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","sourceOld":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = _TestUtil.getTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/cl2o/TestCharBlockArray#testArray().mjava","sourceNew":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = _TestUtil.getTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","sourceOld":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = _TestUtil.getTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","sourceNew":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = TestUtil.getTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","sourceOld":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = _TestUtil.getTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0d579490a72f2e6297eaa648940611234c57cf1","date":1395917140,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","sourceNew":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = TestUtil.createTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","sourceOld":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = TestUtil.getTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7d89d7e4e5101347833eea558851bf4209218619","date":1396265641,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","sourceNew":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = TestUtil.getTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","sourceOld":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = TestUtil.getTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","sourceNew":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = TestUtil.createTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","sourceOld":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = TestUtil.createTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c","date":1396633078,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","sourceNew":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = createTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","sourceOld":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = TestUtil.createTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a0f5bb79c600763ffe7b8141df59a3169d31e48","date":1396689440,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","sourceNew":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = createTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","sourceOld":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = TestUtil.getTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cbc3688252d4a8045d69a164236b2cf87b721f17","date":1409846185,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","sourceNew":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = createTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n  }\n\n","sourceOld":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = createTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n    f.delete();\n  }\n\n","bugFix":["89f15687f60bd49cd3d9de427e85c17fd9397d61"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","sourceNew":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    Path tempDir = createTempDir(\"growingchararray\");\n    Path f = tempDir.resolve(\"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(Files.newInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n  }\n\n","sourceOld":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    File tempDir = createTempDir(\"growingchararray\");\n    File f = new File(tempDir, \"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e430cf88123e0394b7d708f818a380712d63f395","date":1504099386,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","sourceNew":"  public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    Path tempDir = createTempDir(\"growingchararray\");\n    Path f = tempDir.resolve(\"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(Files.newInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n  }\n\n","sourceOld":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    Path tempDir = createTempDir(\"growingchararray\");\n    Path f = tempDir.resolve(\"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(Files.newInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6028626aa0f7c266ef725110257eed11e5b3d1d7","date":1504104056,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","sourceNew":"  public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    Path tempDir = createTempDir(\"growingchararray\");\n    Path f = tempDir.resolve(\"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(Files.newInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n  }\n\n","sourceOld":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    Path tempDir = createTempDir(\"growingchararray\");\n    Path f = tempDir.resolve(\"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(Files.newInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","sourceNew":"  public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    Path tempDir = createTempDir(\"growingchararray\");\n    Path f = tempDir.resolve(\"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(Files.newInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n  }\n\n","sourceOld":"  @Test public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    Path tempDir = createTempDir(\"growingchararray\");\n    Path f = tempDir.resolve(\"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(Files.newInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acb8730dbbbb0f88bb8db80769aa6e9b29d817b","date":1583461779,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCharBlockArray#testArray().mjava","sourceNew":"  public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n;\n    if (TEST_NIGHTLY) {\n      n = 100 * 1000;\n    } else {\n      n = 1000;\n    }\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    Path tempDir = createTempDir(\"growingchararray\");\n    Path f = tempDir.resolve(\"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(Files.newInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n  }\n\n","sourceOld":"  public void testArray() throws Exception {\n    CharBlockArray array = new CharBlockArray();\n    StringBuilder builder = new StringBuilder();\n\n    final int n = 100 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append(s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      array.append((CharSequence)s);\n      builder.append(s);\n    }\n\n    for (int i = 0; i < n; i++) {\n      random().nextBytes(buffer);\n      int size = 1 + random().nextInt(50);\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      String s = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      for (int j = 0; j < s.length(); j++) {\n        array.append(s.charAt(j));\n      }\n      builder.append(s);\n    }\n\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch.\", builder, array);\n\n    Path tempDir = createTempDir(\"growingchararray\");\n    Path f = tempDir.resolve(\"GrowingCharArrayTest.tmp\");\n    BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(f));\n    array.flush(out);\n    out.flush();\n    out.close();\n\n    BufferedInputStream in = new BufferedInputStream(Files.newInputStream(f));\n    array = CharBlockArray.open(in);\n    assertEqualsInternal(\"GrowingCharArray<->StringBuilder mismatch after flush/load.\", builder, array);\n    in.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["d0d579490a72f2e6297eaa648940611234c57cf1","7d89d7e4e5101347833eea558851bf4209218619"],"e430cf88123e0394b7d708f818a380712d63f395":["f4abec28b874149a7223e32cc7a01704c27790de"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["7d89d7e4e5101347833eea558851bf4209218619","a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"6028626aa0f7c266ef725110257eed11e5b3d1d7":["f4abec28b874149a7223e32cc7a01704c27790de","e430cf88123e0394b7d708f818a380712d63f395"],"6613659748fe4411a7dcf85266e55db1f95f7315":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"f4abec28b874149a7223e32cc7a01704c27790de":["cbc3688252d4a8045d69a164236b2cf87b721f17"],"7d89d7e4e5101347833eea558851bf4209218619":["6613659748fe4411a7dcf85266e55db1f95f7315"],"d0d579490a72f2e6297eaa648940611234c57cf1":["6613659748fe4411a7dcf85266e55db1f95f7315"],"cbc3688252d4a8045d69a164236b2cf87b721f17":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["f4abec28b874149a7223e32cc7a01704c27790de","6028626aa0f7c266ef725110257eed11e5b3d1d7"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["5eb2511ababf862ea11e10761c70ee560cd84510"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5cad50ed6659649a0edef71b8cf56280b0bdadd7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5cad50ed6659649a0edef71b8cf56280b0bdadd7"],"5acb8730dbbbb0f88bb8db80769aa6e9b29d817b":["6028626aa0f7c266ef725110257eed11e5b3d1d7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5acb8730dbbbb0f88bb8db80769aa6e9b29d817b"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":["a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"e430cf88123e0394b7d708f818a380712d63f395":["6028626aa0f7c266ef725110257eed11e5b3d1d7"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["cbc3688252d4a8045d69a164236b2cf87b721f17"],"6028626aa0f7c266ef725110257eed11e5b3d1d7":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","5acb8730dbbbb0f88bb8db80769aa6e9b29d817b"],"6613659748fe4411a7dcf85266e55db1f95f7315":["7d89d7e4e5101347833eea558851bf4209218619","d0d579490a72f2e6297eaa648940611234c57cf1"],"d0d579490a72f2e6297eaa648940611234c57cf1":["5eb2511ababf862ea11e10761c70ee560cd84510"],"7d89d7e4e5101347833eea558851bf4209218619":["5eb2511ababf862ea11e10761c70ee560cd84510","2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"f4abec28b874149a7223e32cc7a01704c27790de":["e430cf88123e0394b7d708f818a380712d63f395","6028626aa0f7c266ef725110257eed11e5b3d1d7","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"cbc3688252d4a8045d69a164236b2cf87b721f17":["f4abec28b874149a7223e32cc7a01704c27790de"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5cad50ed6659649a0edef71b8cf56280b0bdadd7","3cc728b07df73b197e6d940d27f9b08b63918f13"],"5cad50ed6659649a0edef71b8cf56280b0bdadd7":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["6613659748fe4411a7dcf85266e55db1f95f7315"],"5acb8730dbbbb0f88bb8db80769aa6e9b29d817b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}