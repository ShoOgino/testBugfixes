{"path":"lucene/contrib/analyzers/stempel/src/java/org/egothor/stemmer/Compile#main(java.lang.String[]).mjava","commits":[{"id":"67748b41458c73d49a48168362cc7f4c960a2542","date":1272890662,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/analyzers/stempel/src/java/org/egothor/stemmer/Compile#main(java.lang.String[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Entry point to the Compile application.\n   * <p>\n   * This program takes any number of arguments: the first is the name of the\n   * desired stemming algorithm to use (a list is available in the package\n   * description) , all of the rest should be the path or paths to a file or\n   * files containing a stemmer table to compile.\n   * \n   * @param args the command line arguments\n   */\n  public static void main(java.lang.String[] args) {\n    if (args.length < 1) {\n      return;\n    }\n    \n    args[0].toUpperCase();\n    \n    backward = args[0].charAt(0) == '-';\n    int qq = (backward) ? 1 : 0;\n    boolean storeorig = false;\n    \n    if (args[0].charAt(qq) == '0') {\n      storeorig = true;\n      qq++;\n    }\n    \n    multi = args[0].charAt(qq) == 'M';\n    if (multi) {\n      qq++;\n    }\n    \n    String charset = System.getProperty(\"egothor.stemmer.charset\", \"UTF-8\");\n    \n    char optimizer[] = new char[args[0].length() - qq];\n    for (int i = 0; i < optimizer.length; i++) {\n      optimizer[i] = args[0].charAt(qq + i);\n    }\n    \n    for (int i = 1; i < args.length; i++) {\n      LineNumberReader in;\n      // System.out.println(\"[\" + args[i] + \"]\");\n      Diff diff = new Diff();\n      try {\n        int stems = 0;\n        int words = 0;\n        \n        allocTrie();\n        \n        System.out.println(args[i]);\n        in = new LineNumberReader(new BufferedReader(new InputStreamReader(\n            new FileInputStream(args[i]), charset)));\n        for (String line = in.readLine(); line != null; line = in.readLine()) {\n          try {\n            line = line.toLowerCase();\n            StringTokenizer st = new StringTokenizer(line);\n            String stem = st.nextToken();\n            if (storeorig) {\n              trie.add(stem, \"-a\");\n              words++;\n            }\n            while (st.hasMoreTokens()) {\n              String token = st.nextToken();\n              if (token.equals(stem) == false) {\n                trie.add(token, diff.exec(token, stem));\n                words++;\n              }\n            }\n          } catch (java.util.NoSuchElementException x) {\n            // no base token (stem) on a line\n          }\n        }\n        \n        Optimizer o = new Optimizer();\n        Optimizer2 o2 = new Optimizer2();\n        Lift l = new Lift(true);\n        Lift e = new Lift(false);\n        Gener g = new Gener();\n        \n        for (int j = 0; j < optimizer.length; j++) {\n          String prefix;\n          switch (optimizer[j]) {\n            case 'G':\n              trie = trie.reduce(g);\n              prefix = \"G: \";\n              break;\n            case 'L':\n              trie = trie.reduce(l);\n              prefix = \"L: \";\n              break;\n            case 'E':\n              trie = trie.reduce(e);\n              prefix = \"E: \";\n              break;\n            case '2':\n              trie = trie.reduce(o2);\n              prefix = \"2: \";\n              break;\n            case '1':\n              trie = trie.reduce(o);\n              prefix = \"1: \";\n              break;\n            default:\n              continue;\n          }\n          trie.printInfo(prefix + \" \");\n        }\n               \n        DataOutputStream os = new DataOutputStream(new BufferedOutputStream(\n            new FileOutputStream(args[i] + \".out\")));\n        os.writeUTF(args[0]);\n        trie.store(os);\n        os.close();\n        \n      } catch (FileNotFoundException x) {\n        x.printStackTrace();\n      } catch (IOException x) {\n        x.printStackTrace();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["2f6156e2f0d1d529001873677c1cc6a22d6b9f9a","28289db63ed90bbf9506cc2dccfa1f45b3b0e501"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f080986da691a3bba7b757f43ab72cdc82b57ce","date":1273069619,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/stempel/src/java/org/egothor/stemmer/Compile#main(java.lang.String[]).mjava","pathOld":"lucene/contrib/analyzers/stempel/src/java/org/egothor/stemmer/Compile#main(java.lang.String[]).mjava","sourceNew":"  /**\n   * Entry point to the Compile application.\n   * <p>\n   * This program takes any number of arguments: the first is the name of the\n   * desired stemming algorithm to use (a list is available in the package\n   * description) , all of the rest should be the path or paths to a file or\n   * files containing a stemmer table to compile.\n   * \n   * @param args the command line arguments\n   */\n  public static void main(java.lang.String[] args) {\n    if (args.length < 1) {\n      return;\n    }\n    \n    args[0].toUpperCase();\n    \n    backward = args[0].charAt(0) == '-';\n    int qq = (backward) ? 1 : 0;\n    boolean storeorig = false;\n    \n    if (args[0].charAt(qq) == '0') {\n      storeorig = true;\n      qq++;\n    }\n    \n    multi = args[0].charAt(qq) == 'M';\n    if (multi) {\n      qq++;\n    }\n    \n    String charset = System.getProperty(\"egothor.stemmer.charset\", \"UTF-8\");\n    \n    char optimizer[] = new char[args[0].length() - qq];\n    for (int i = 0; i < optimizer.length; i++) {\n      optimizer[i] = args[0].charAt(qq + i);\n    }\n    \n    for (int i = 1; i < args.length; i++) {\n      LineNumberReader in;\n      // System.out.println(\"[\" + args[i] + \"]\");\n      Diff diff = new Diff();\n      try {\n        int stems = 0;\n        int words = 0;\n        \n        allocTrie();\n        \n        System.out.println(args[i]);\n        in = new LineNumberReader(new BufferedReader(new InputStreamReader(\n            new FileInputStream(args[i]), charset)));\n        for (String line = in.readLine(); line != null; line = in.readLine()) {\n          try {\n            line = line.toLowerCase();\n            StringTokenizer st = new StringTokenizer(line);\n            String stem = st.nextToken();\n            if (storeorig) {\n              trie.add(stem, \"-a\");\n              words++;\n            }\n            while (st.hasMoreTokens()) {\n              String token = st.nextToken();\n              if (token.equals(stem) == false) {\n                trie.add(token, diff.exec(token, stem));\n                words++;\n              }\n            }\n          } catch (java.util.NoSuchElementException x) {\n            // no base token (stem) on a line\n          }\n        }\n        \n        Optimizer o = new Optimizer();\n        Optimizer2 o2 = new Optimizer2();\n        Lift l = new Lift(true);\n        Lift e = new Lift(false);\n        Gener g = new Gener();\n        \n        for (int j = 0; j < optimizer.length; j++) {\n          String prefix;\n          switch (optimizer[j]) {\n            case 'G':\n              trie = trie.reduce(g);\n              prefix = \"G: \";\n              break;\n            case 'L':\n              trie = trie.reduce(l);\n              prefix = \"L: \";\n              break;\n            case 'E':\n              trie = trie.reduce(e);\n              prefix = \"E: \";\n              break;\n            case '2':\n              trie = trie.reduce(o2);\n              prefix = \"2: \";\n              break;\n            case '1':\n              trie = trie.reduce(o);\n              prefix = \"1: \";\n              break;\n            default:\n              continue;\n          }\n          trie.printInfo(prefix + \" \");\n        }\n               \n        DataOutputStream os = new DataOutputStream(new BufferedOutputStream(\n            new FileOutputStream(args[i] + \".out\")));\n        os.writeUTF(args[0]);\n        trie.store(os);\n        os.close();\n        \n      } catch (FileNotFoundException x) {\n        x.printStackTrace();\n      } catch (IOException x) {\n        x.printStackTrace();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Entry point to the Compile application.\n   * <p>\n   * This program takes any number of arguments: the first is the name of the\n   * desired stemming algorithm to use (a list is available in the package\n   * description) , all of the rest should be the path or paths to a file or\n   * files containing a stemmer table to compile.\n   * \n   * @param args the command line arguments\n   */\n  public static void main(java.lang.String[] args) {\n    if (args.length < 1) {\n      return;\n    }\n    \n    args[0].toUpperCase();\n    \n    backward = args[0].charAt(0) == '-';\n    int qq = (backward) ? 1 : 0;\n    boolean storeorig = false;\n    \n    if (args[0].charAt(qq) == '0') {\n      storeorig = true;\n      qq++;\n    }\n    \n    multi = args[0].charAt(qq) == 'M';\n    if (multi) {\n      qq++;\n    }\n    \n    String charset = System.getProperty(\"egothor.stemmer.charset\", \"UTF-8\");\n    \n    char optimizer[] = new char[args[0].length() - qq];\n    for (int i = 0; i < optimizer.length; i++) {\n      optimizer[i] = args[0].charAt(qq + i);\n    }\n    \n    for (int i = 1; i < args.length; i++) {\n      LineNumberReader in;\n      // System.out.println(\"[\" + args[i] + \"]\");\n      Diff diff = new Diff();\n      try {\n        int stems = 0;\n        int words = 0;\n        \n        allocTrie();\n        \n        System.out.println(args[i]);\n        in = new LineNumberReader(new BufferedReader(new InputStreamReader(\n            new FileInputStream(args[i]), charset)));\n        for (String line = in.readLine(); line != null; line = in.readLine()) {\n          try {\n            line = line.toLowerCase();\n            StringTokenizer st = new StringTokenizer(line);\n            String stem = st.nextToken();\n            if (storeorig) {\n              trie.add(stem, \"-a\");\n              words++;\n            }\n            while (st.hasMoreTokens()) {\n              String token = st.nextToken();\n              if (token.equals(stem) == false) {\n                trie.add(token, diff.exec(token, stem));\n                words++;\n              }\n            }\n          } catch (java.util.NoSuchElementException x) {\n            // no base token (stem) on a line\n          }\n        }\n        \n        Optimizer o = new Optimizer();\n        Optimizer2 o2 = new Optimizer2();\n        Lift l = new Lift(true);\n        Lift e = new Lift(false);\n        Gener g = new Gener();\n        \n        for (int j = 0; j < optimizer.length; j++) {\n          String prefix;\n          switch (optimizer[j]) {\n            case 'G':\n              trie = trie.reduce(g);\n              prefix = \"G: \";\n              break;\n            case 'L':\n              trie = trie.reduce(l);\n              prefix = \"L: \";\n              break;\n            case 'E':\n              trie = trie.reduce(e);\n              prefix = \"E: \";\n              break;\n            case '2':\n              trie = trie.reduce(o2);\n              prefix = \"2: \";\n              break;\n            case '1':\n              trie = trie.reduce(o);\n              prefix = \"1: \";\n              break;\n            default:\n              continue;\n          }\n          trie.printInfo(prefix + \" \");\n        }\n               \n        DataOutputStream os = new DataOutputStream(new BufferedOutputStream(\n            new FileOutputStream(args[i] + \".out\")));\n        os.writeUTF(args[0]);\n        trie.store(os);\n        os.close();\n        \n      } catch (FileNotFoundException x) {\n        x.printStackTrace();\n      } catch (IOException x) {\n        x.printStackTrace();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"67748b41458c73d49a48168362cc7f4c960a2542":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0f080986da691a3bba7b757f43ab72cdc82b57ce":["67748b41458c73d49a48168362cc7f4c960a2542"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f080986da691a3bba7b757f43ab72cdc82b57ce"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["67748b41458c73d49a48168362cc7f4c960a2542"],"67748b41458c73d49a48168362cc7f4c960a2542":["0f080986da691a3bba7b757f43ab72cdc82b57ce"],"0f080986da691a3bba7b757f43ab72cdc82b57ce":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}