{"path":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","commits":[{"id":"15fdb1d84f9e74320d318f682fd2b7d370398857","date":1355194688,"type":1,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String).mjava","sourceNew":"  /**\n   * Override for more efficient moves.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    if (fromDir instanceof FSDirectory && toDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) fromDir).getDirectory();\n      File dir2 = ((FSDirectory) toDir).getDirectory();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","sourceOld":"  /**\n   * Override for more efficient moves.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  public void move(Directory fromDir, Directory toDir, String fileName)\n      throws IOException {\n    if (fromDir instanceof FSDirectory && toDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) fromDir).getDirectory();\n      File dir2 = ((FSDirectory) toDir).getDirectory();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Override for more efficient moves.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    if (fromDir instanceof FSDirectory && toDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) fromDir).getDirectory();\n      File dir2 = ((FSDirectory) toDir).getDirectory();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38186799b39019eb8ae92e6ee46a91668cac69d3","date":1360978077,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","sourceNew":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * This implementation works with two wrappers:\n   * NRTCachingDirectory and RateLimitedDirectoryWrapper.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(fromDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) baseFromDir).getDirectory();\n      File dir2 = ((FSDirectory) baseToDir).getDirectory();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","sourceOld":"  /**\n   * Override for more efficient moves.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    if (fromDir instanceof FSDirectory && toDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) fromDir).getDirectory();\n      File dir2 = ((FSDirectory) toDir).getDirectory();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","bugFix":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"bugIntro":["43e5779eeb016d5b6980fbf3437f3e8ff4dbf1d6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"95303ff3749680c743b9425f9cf99e6e4065e8a8","date":1361061922,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","sourceNew":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * This implementation works with two wrappers:\n   * NRTCachingDirectory and RateLimitedDirectoryWrapper.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(fromDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) baseFromDir).getDirectory();\n      File dir2 = ((FSDirectory) baseToDir).getDirectory();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","sourceOld":"  /**\n   * Override for more efficient moves.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    if (fromDir instanceof FSDirectory && toDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) fromDir).getDirectory();\n      File dir2 = ((FSDirectory) toDir).getDirectory();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43e5779eeb016d5b6980fbf3437f3e8ff4dbf1d6","date":1361552322,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","sourceNew":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * This implementation works with two wrappers:\n   * NRTCachingDirectory and RateLimitedDirectoryWrapper.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(toDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) baseFromDir).getDirectory();\n      File dir2 = ((FSDirectory) baseToDir).getDirectory();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","sourceOld":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * This implementation works with two wrappers:\n   * NRTCachingDirectory and RateLimitedDirectoryWrapper.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(fromDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) baseFromDir).getDirectory();\n      File dir2 = ((FSDirectory) baseToDir).getDirectory();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","bugFix":["38186799b39019eb8ae92e6ee46a91668cac69d3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","sourceNew":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * This implementation works with two wrappers:\n   * NRTCachingDirectory and RateLimitedDirectoryWrapper.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(toDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) baseFromDir).getDirectory().toFile();\n      File dir2 = ((FSDirectory) baseToDir).getDirectory().toFile();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","sourceOld":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * This implementation works with two wrappers:\n   * NRTCachingDirectory and RateLimitedDirectoryWrapper.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(toDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) baseFromDir).getDirectory();\n      File dir2 = ((FSDirectory) baseToDir).getDirectory();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","sourceNew":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * This implementation works with NRTCachingDirectory.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(toDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) baseFromDir).getDirectory().toFile();\n      File dir2 = ((FSDirectory) baseToDir).getDirectory().toFile();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","sourceOld":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * This implementation works with two wrappers:\n   * NRTCachingDirectory and RateLimitedDirectoryWrapper.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(toDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) baseFromDir).getDirectory().toFile();\n      File dir2 = ((FSDirectory) baseToDir).getDirectory().toFile();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e8d09252b7166ff0bd05d6fec79092faa640ac9","date":1482969140,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","sourceNew":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(toDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) baseFromDir).getDirectory().toFile();\n      File dir2 = ((FSDirectory) baseToDir).getDirectory().toFile();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","sourceOld":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * This implementation works with NRTCachingDirectory.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(toDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) baseFromDir).getDirectory().toFile();\n      File dir2 = ((FSDirectory) baseToDir).getDirectory().toFile();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"deb456b595295c63d69cf86cae60ed80dfc9c411","date":1483007391,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","sourceNew":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(toDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n  \n      Path path1 = ((FSDirectory) baseFromDir).getDirectory().toAbsolutePath();\n      Path path2 = ((FSDirectory) baseFromDir).getDirectory().toAbsolutePath();\n      \n      try {\n        Files.move(path1.resolve(fileName), path2.resolve(fileName), StandardCopyOption.ATOMIC_MOVE);\n      } catch (AtomicMoveNotSupportedException e) {\n        Files.move(path1.resolve(fileName), path2.resolve(fileName));\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","sourceOld":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(toDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) baseFromDir).getDirectory().toFile();\n      File dir2 = ((FSDirectory) baseToDir).getDirectory().toFile();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","sourceNew":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(toDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n  \n      Path path1 = ((FSDirectory) baseFromDir).getDirectory().toAbsolutePath();\n      Path path2 = ((FSDirectory) baseFromDir).getDirectory().toAbsolutePath();\n      \n      try {\n        Files.move(path1.resolve(fileName), path2.resolve(fileName), StandardCopyOption.ATOMIC_MOVE);\n      } catch (AtomicMoveNotSupportedException e) {\n        Files.move(path1.resolve(fileName), path2.resolve(fileName));\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","sourceOld":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * This implementation works with NRTCachingDirectory.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(toDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n      File dir1 = ((FSDirectory) baseFromDir).getDirectory().toFile();\n      File dir2 = ((FSDirectory) baseToDir).getDirectory().toFile();\n      File indexFileInTmpDir = new File(dir1, fileName);\n      File indexFileInIndex = new File(dir2, fileName);\n      boolean success = indexFileInTmpDir.renameTo(indexFileInIndex);\n      if (success) {\n        return;\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bf64676696541c2ef81b84e7f96e7f75355d188a","date":1483888975,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","sourceNew":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(toDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n  \n      Path path1 = ((FSDirectory) baseFromDir).getDirectory().toAbsolutePath();\n      Path path2 = ((FSDirectory) baseToDir).getDirectory().toAbsolutePath();\n      \n      try {\n        Files.move(path1.resolve(fileName), path2.resolve(fileName), StandardCopyOption.ATOMIC_MOVE);\n      } catch (AtomicMoveNotSupportedException e) {\n        Files.move(path1.resolve(fileName), path2.resolve(fileName));\n      }\n      return;\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","sourceOld":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(toDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n  \n      Path path1 = ((FSDirectory) baseFromDir).getDirectory().toAbsolutePath();\n      Path path2 = ((FSDirectory) baseFromDir).getDirectory().toAbsolutePath();\n      \n      try {\n        Files.move(path1.resolve(fileName), path2.resolve(fileName), StandardCopyOption.ATOMIC_MOVE);\n      } catch (AtomicMoveNotSupportedException e) {\n        Files.move(path1.resolve(fileName), path2.resolve(fileName));\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/StandardDirectoryFactory#move(Directory,Directory,String,IOContext).mjava","sourceNew":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(toDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n  \n      Path path1 = ((FSDirectory) baseFromDir).getDirectory().toAbsolutePath();\n      Path path2 = ((FSDirectory) baseToDir).getDirectory().toAbsolutePath();\n      \n      try {\n        Files.move(path1.resolve(fileName), path2.resolve(fileName), StandardCopyOption.ATOMIC_MOVE);\n      } catch (AtomicMoveNotSupportedException e) {\n        Files.move(path1.resolve(fileName), path2.resolve(fileName));\n      }\n      return;\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","sourceOld":"  /**\n   * Override for more efficient moves.\n   * \n   * Intended for use with replication - use\n   * carefully - some Directory wrappers will\n   * cache files for example.\n   * \n   * You should first {@link Directory#sync(java.util.Collection)} any file that will be \n   * moved or avoid cached files through settings.\n   * \n   * @throws IOException\n   *           If there is a low-level I/O error.\n   */\n  @Override\n  public void move(Directory fromDir, Directory toDir, String fileName, IOContext ioContext)\n      throws IOException {\n    \n    Directory baseFromDir = getBaseDir(fromDir);\n    Directory baseToDir = getBaseDir(toDir);\n    \n    if (baseFromDir instanceof FSDirectory && baseToDir instanceof FSDirectory) {\n  \n      Path path1 = ((FSDirectory) baseFromDir).getDirectory().toAbsolutePath();\n      Path path2 = ((FSDirectory) baseFromDir).getDirectory().toAbsolutePath();\n      \n      try {\n        Files.move(path1.resolve(fileName), path2.resolve(fileName), StandardCopyOption.ATOMIC_MOVE);\n      } catch (AtomicMoveNotSupportedException e) {\n        Files.move(path1.resolve(fileName), path2.resolve(fileName));\n      }\n    }\n\n    super.move(fromDir, toDir, fileName, ioContext);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"15fdb1d84f9e74320d318f682fd2b7d370398857":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","15fdb1d84f9e74320d318f682fd2b7d370398857"],"38186799b39019eb8ae92e6ee46a91668cac69d3":["15fdb1d84f9e74320d318f682fd2b7d370398857"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["f03e4bed5023ec3ef93a771b8888cae991cf448d","bf64676696541c2ef81b84e7f96e7f75355d188a"],"0e8d09252b7166ff0bd05d6fec79092faa640ac9":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"f4abec28b874149a7223e32cc7a01704c27790de":["43e5779eeb016d5b6980fbf3437f3e8ff4dbf1d6"],"deb456b595295c63d69cf86cae60ed80dfc9c411":["0e8d09252b7166ff0bd05d6fec79092faa640ac9"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["5faf65b6692f15cca0f87bf8666c87899afc619f","deb456b595295c63d69cf86cae60ed80dfc9c411"],"bf64676696541c2ef81b84e7f96e7f75355d188a":["deb456b595295c63d69cf86cae60ed80dfc9c411"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":["15fdb1d84f9e74320d318f682fd2b7d370398857","38186799b39019eb8ae92e6ee46a91668cac69d3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5faf65b6692f15cca0f87bf8666c87899afc619f":["f4abec28b874149a7223e32cc7a01704c27790de"],"43e5779eeb016d5b6980fbf3437f3e8ff4dbf1d6":["38186799b39019eb8ae92e6ee46a91668cac69d3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bf64676696541c2ef81b84e7f96e7f75355d188a"]},"commit2Childs":{"15fdb1d84f9e74320d318f682fd2b7d370398857":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","38186799b39019eb8ae92e6ee46a91668cac69d3","95303ff3749680c743b9425f9cf99e6e4065e8a8"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"38186799b39019eb8ae92e6ee46a91668cac69d3":["95303ff3749680c743b9425f9cf99e6e4065e8a8","43e5779eeb016d5b6980fbf3437f3e8ff4dbf1d6"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"0e8d09252b7166ff0bd05d6fec79092faa640ac9":["deb456b595295c63d69cf86cae60ed80dfc9c411"],"f4abec28b874149a7223e32cc7a01704c27790de":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"deb456b595295c63d69cf86cae60ed80dfc9c411":["f03e4bed5023ec3ef93a771b8888cae991cf448d","bf64676696541c2ef81b84e7f96e7f75355d188a"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"bf64676696541c2ef81b84e7f96e7f75355d188a":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["15fdb1d84f9e74320d318f682fd2b7d370398857","d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["0e8d09252b7166ff0bd05d6fec79092faa640ac9","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"43e5779eeb016d5b6980fbf3437f3e8ff4dbf1d6":["f4abec28b874149a7223e32cc7a01704c27790de"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","95303ff3749680c743b9425f9cf99e6e4065e8a8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}