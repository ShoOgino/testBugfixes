{"path":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","commits":[{"id":"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","date":1399816179,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(PostingsFormat.forName(\"Lucene41WithOrds\"));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    AtomicReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(AtomicReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(PostingsFormat.forName(\"Lucene41WithOrds\"));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    AtomicReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(AtomicReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(PostingsFormat.forName(\"Lucene41WithOrds\"));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    AtomicReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(AtomicReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(PostingsFormat.forName(\"Lucene41WithOrds\"));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    AtomicReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(AtomicReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(PostingsFormat.forName(\"Lucene41WithOrds\"));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    AtomicReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(AtomicReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(PostingsFormat.forName(\"Lucene41WithOrds\"));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    AtomicReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(AtomicReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(PostingsFormat.forName(\"Lucene41WithOrds\"));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    AtomicReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(AtomicReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(PostingsFormat.forName(\"Lucene41WithOrds\"));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    AtomicReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(AtomicReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(PostingsFormat.forName(\"Lucene41WithOrds\"));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    AtomicReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(AtomicReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(PostingsFormat.forName(\"Lucene41WithOrds\"));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.shutdown();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    AtomicReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(AtomicReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(PostingsFormat.forName(\"Lucene41WithOrds\"));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(PostingsFormat.forName(\"Lucene41WithOrds\"));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    AtomicReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(AtomicReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99eb4a732d1a908f4636ace52928876136bf1896","date":1413829552,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(PostingsFormat.forName(\"Lucene41WithOrds\"));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(PostingsFormat.forName(\"Lucene41WithOrds\"));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7249bf663236743660155abfc0941aebf4245391","date":1433953380,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new IntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a076c3c721f685b7559308fdc2cd72d91bba67e5","date":1464168992,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e121d43b5a10f2df530f406f935102656e9c4e8","date":1464198131,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83870855d82aba6819217abeff5a40779dbb28b4","date":1464291012,"type":5,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":5,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestDocTermOrds#testRandomWithPrefix().mjava","sourceNew":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomWithPrefix() throws Exception {\n    Directory dir = newDirectory();\n\n    final Set<String> prefixes = new HashSet<>();\n    final int numPrefix = TestUtil.nextInt(random(), 2, 7);\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numPrefix + \" prefixes\");\n    }\n    while(prefixes.size() < numPrefix) {\n      prefixes.add(TestUtil.randomRealisticUnicodeString(random()));\n      //prefixes.add(_TestUtil.randomSimpleString(random));\n    }\n    final String[] prefixesArray = prefixes.toArray(new String[prefixes.size()]);\n\n    final int NUM_TERMS = atLeast(20);\n    final Set<BytesRef> terms = new HashSet<>();\n    while(terms.size() < NUM_TERMS) {\n      final String s = prefixesArray[random().nextInt(prefixesArray.length)] + TestUtil.randomRealisticUnicodeString(random());\n      //final String s = prefixesArray[random.nextInt(prefixesArray.length)] + _TestUtil.randomSimpleString(random);\n      if (s.length() > 0) {\n        terms.add(new BytesRef(s));\n      }\n    }\n    final BytesRef[] termsArray = terms.toArray(new BytesRef[terms.size()]);\n    Arrays.sort(termsArray);\n    \n    final int NUM_DOCS = atLeast(100);\n\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n\n    // Sometimes swap in codec that impls ord():\n    if (random().nextInt(10) == 7) {\n      Codec codec = TestUtil.alwaysPostingsFormat(TestUtil.getPostingsFormatWithOrds(random()));\n      conf.setCodec(codec);\n    }\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, conf);\n\n    final int[][] idToOrds = new int[NUM_DOCS][];\n    final Set<Integer> ordsForDocSet = new HashSet<>();\n\n    for(int id=0;id<NUM_DOCS;id++) {\n      Document doc = new Document();\n\n      doc.add(new LegacyIntField(\"id\", id, Field.Store.YES));\n      \n      final int termCount = TestUtil.nextInt(random(), 0, 20 * RANDOM_MULTIPLIER);\n      while(ordsForDocSet.size() < termCount) {\n        ordsForDocSet.add(random().nextInt(termsArray.length));\n      }\n      final int[] ordsForDoc = new int[termCount];\n      int upto = 0;\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n      }\n      for(int ord : ordsForDocSet) {\n        ordsForDoc[upto++] = ord;\n        Field field = newStringField(\"field\", termsArray[ord].utf8ToString(), Field.Store.NO);\n        if (VERBOSE) {\n          System.out.println(\"  f=\" + termsArray[ord].utf8ToString());\n        }\n        doc.add(field);\n      }\n      ordsForDocSet.clear();\n      Arrays.sort(ordsForDoc);\n      idToOrds[id] = ordsForDoc;\n      w.addDocument(doc);\n    }\n    \n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    \n    LeafReader slowR = SlowCompositeReaderWrapper.wrap(r);\n    TestUtil.checkReader(slowR);\n    for(String prefix : prefixesArray) {\n\n      final BytesRef prefixRef = prefix == null ? null : new BytesRef(prefix);\n\n      final int[][] idToOrdsPrefix = new int[NUM_DOCS][];\n      for(int id=0;id<NUM_DOCS;id++) {\n        final int[] docOrds = idToOrds[id];\n        final List<Integer> newOrds = new ArrayList<>();\n        for(int ord : idToOrds[id]) {\n          if (StringHelper.startsWith(termsArray[ord], prefixRef)) {\n            newOrds.add(ord);\n          }\n        }\n        final int[] newOrdsArray = new int[newOrds.size()];\n        int upto = 0;\n        for(int ord : newOrds) {\n          newOrdsArray[upto++] = ord;\n        }\n        idToOrdsPrefix[id] = newOrdsArray;\n      }\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: sub=\" + ctx.reader());\n        }\n        verify(ctx.reader(), idToOrdsPrefix, termsArray, prefixRef);\n      }\n\n      // Also test top-level reader: its enum does not support\n      // ord, so this forces the OrdWrapper to run:\n      if (VERBOSE) {\n        System.out.println(\"TEST: top reader\");\n      }\n      verify(slowR, idToOrdsPrefix, termsArray, prefixRef);\n    }\n\n    FieldCache.DEFAULT.purgeByCacheKey(slowR.getCoreCacheKey());\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"99eb4a732d1a908f4636ace52928876136bf1896":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"a076c3c721f685b7559308fdc2cd72d91bba67e5":["770342641f7b505eaa8dccdc666158bff2419109"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["770342641f7b505eaa8dccdc666158bff2419109","a076c3c721f685b7559308fdc2cd72d91bba67e5"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"83870855d82aba6819217abeff5a40779dbb28b4":["770342641f7b505eaa8dccdc666158bff2419109","0e121d43b5a10f2df530f406f935102656e9c4e8"],"56572ec06f1407c066d6b7399413178b33176cd8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","93dd449115a9247533e44bab47e8429e5dccbc6d"],"770342641f7b505eaa8dccdc666158bff2419109":["7249bf663236743660155abfc0941aebf4245391"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["770342641f7b505eaa8dccdc666158bff2419109","0e121d43b5a10f2df530f406f935102656e9c4e8"],"7249bf663236743660155abfc0941aebf4245391":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["c9fb5f46e264daf5ba3860defe623a89d202dd87","99eb4a732d1a908f4636ace52928876136bf1896"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0e121d43b5a10f2df530f406f935102656e9c4e8"]},"commit2Childs":{"99eb4a732d1a908f4636ace52928876136bf1896":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"a076c3c721f685b7559308fdc2cd72d91bba67e5":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"83870855d82aba6819217abeff5a40779dbb28b4":[],"56572ec06f1407c066d6b7399413178b33176cd8":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["99eb4a732d1a908f4636ace52928876136bf1896","db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"770342641f7b505eaa8dccdc666158bff2419109":["a076c3c721f685b7559308fdc2cd72d91bba67e5","0e121d43b5a10f2df530f406f935102656e9c4e8","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"93dd449115a9247533e44bab47e8429e5dccbc6d":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","56572ec06f1407c066d6b7399413178b33176cd8"],"7249bf663236743660155abfc0941aebf4245391":["770342641f7b505eaa8dccdc666158bff2419109"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["7249bf663236743660155abfc0941aebf4245391"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["83870855d82aba6819217abeff5a40779dbb28b4","56572ec06f1407c066d6b7399413178b33176cd8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}