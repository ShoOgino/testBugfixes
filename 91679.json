{"path":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","commits":[{"id":"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef","date":1458928975,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public UpdateRequestProcessor getInstance(SolrQueryRequest req, SolrQueryResponse rsp, UpdateRequestProcessor next) {\n\n    assert informed : \"inform(SolrCore) never called?\";\n    \n    // short circut if we're a replica processing commands from our leader\n    DistribPhase distribPhase = DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n    if (DistribPhase.FROMLEADER.equals(distribPhase)) {\n      return next;\n    }\n\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist(req, MAX_ERRORS_PARAM);\n    int maxErrors = req.getParams().getInt(MAX_ERRORS_PARAM, defaultMaxErrors);\n    if (maxErrors < -1) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'\"+MAX_ERRORS_PARAM + \"' must either be non-negative, or -1 to indicate 'unlimiited': \" + maxErrors);\n    }\n\n    // NOTE: even if 0==maxErrors, we still inject processor into chain so respones has expected header info\n    return new TolerantUpdateProcessor(req, rsp, next, maxErrors, distribPhase);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9f4251f14d2db68330fc1e6f0495c053a905d560"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9f4251f14d2db68330fc1e6f0495c053a905d560","date":1537116380,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","sourceNew":"  @Override\n  public UpdateRequestProcessor getInstance(SolrQueryRequest req, SolrQueryResponse rsp, UpdateRequestProcessor next) {\n\n    assert informed : \"inform(SolrCore) never called?\";\n    \n    // short circut if we're a replica processing commands from our leader\n    DistribPhase distribPhase = DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n    if (DistribPhase.FROMLEADER.equals(distribPhase)) {\n      return next;\n    }\n\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist(req, MAX_ERRORS_PARAM);\n    int maxErrors = req.getParams().getInt(MAX_ERRORS_PARAM, defaultMaxErrors);\n    if (maxErrors < -1) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'\"+MAX_ERRORS_PARAM + \"' must either be non-negative, or -1 to indicate 'unlimiited': \" + maxErrors);\n    }\n\n    // NOTE: even if 0==maxErrors, we still inject processor into chain so responses has expected header info\n    return new TolerantUpdateProcessor(req, rsp, next, maxErrors, distribPhase);\n  }\n\n","sourceOld":"  @Override\n  public UpdateRequestProcessor getInstance(SolrQueryRequest req, SolrQueryResponse rsp, UpdateRequestProcessor next) {\n\n    assert informed : \"inform(SolrCore) never called?\";\n    \n    // short circut if we're a replica processing commands from our leader\n    DistribPhase distribPhase = DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n    if (DistribPhase.FROMLEADER.equals(distribPhase)) {\n      return next;\n    }\n\n    DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist(req, MAX_ERRORS_PARAM);\n    int maxErrors = req.getParams().getInt(MAX_ERRORS_PARAM, defaultMaxErrors);\n    if (maxErrors < -1) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'\"+MAX_ERRORS_PARAM + \"' must either be non-negative, or -1 to indicate 'unlimiited': \" + maxErrors);\n    }\n\n    // NOTE: even if 0==maxErrors, we still inject processor into chain so respones has expected header info\n    return new TolerantUpdateProcessor(req, rsp, next, maxErrors, distribPhase);\n  }\n\n","bugFix":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9f4251f14d2db68330fc1e6f0495c053a905d560":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9f4251f14d2db68330fc1e6f0495c053a905d560"]},"commit2Childs":{"9f4251f14d2db68330fc1e6f0495c053a905d560":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["9f4251f14d2db68330fc1e6f0495c053a905d560"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}