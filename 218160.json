{"path":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","commits":[{"id":"78513ec977dc489ecf0d3dbce84ebd18ff7a43c1","date":1340873819,"type":0,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes ParseException without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes ParseException without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cdb67100dc016748799a77218aa409478372d79","date":1353699950,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","sourceNew":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n  }\n\n","sourceOld":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes ParseException without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","sourceNew":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n  }\n\n","sourceOld":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes ParseException without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60997f5d1d0f634df710a5a770d57903c4b0d38b","date":1366644664,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","sourceNew":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"id\"),\n        \"*[count(//doc)=3]\");\n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"text\"),\n        \"*[count(//doc)=3]\");    \n    \n  }\n\n","sourceOld":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","sourceNew":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"id\"),\n        \"*[count(//doc)=3]\");\n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"text\"),\n        \"*[count(//doc)=3]\");    \n    \n  }\n\n","sourceOld":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"id\"),\n        \"*[count(//doc)=3]\");\n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"text\"),\n        \"*[count(//doc)=3]\");    \n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","sourceNew":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"id\"),\n        \"*[count(//doc)=3]\");\n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"text\"),\n        \"*[count(//doc)=3]\");    \n    \n  }\n\n","sourceOld":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"id\"),\n        \"*[count(//doc)=3]\");\n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"text\"),\n        \"*[count(//doc)=3]\");    \n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e55782fb51a6e9789542818eb2161a3247f39ace","date":1489707707,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","sourceNew":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"id\"),\n        \"*[count(//doc)=3]\");\n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"text_sw\"),\n        \"*[count(//doc)=3]\");    \n    \n  }\n\n","sourceOld":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"id\"),\n        \"*[count(//doc)=3]\");\n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"text\"),\n        \"*[count(//doc)=3]\");    \n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c03778630c4604270d88c148afb8c7de35b51d3c","date":1490280010,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","sourceNew":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"id\"),\n        \"*[count(//doc)=3]\");\n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"text_sw\"),\n        \"*[count(//doc)=3]\");    \n    \n  }\n\n","sourceOld":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"id\"),\n        \"*[count(//doc)=3]\");\n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"text\"),\n        \"*[count(//doc)=3]\");    \n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b360a3d5b9d443b4e880d2c92724cffd7def8db","date":1490740768,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","sourceNew":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"id\"),\n        \"*[count(//doc)=3]\");\n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"text\"),\n        \"*[count(//doc)=3]\");    \n    \n  }\n\n","sourceOld":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"id\"),\n        \"*[count(//doc)=3]\");\n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"text_sw\"),\n        \"*[count(//doc)=3]\");    \n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36d81030ef9ff5ae6820e560c0833127181c7a2c","date":1490873946,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testEscapingOfReservedCharacters().mjava","sourceNew":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"id\"),\n        \"*[count(//doc)=3]\");\n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"text\"),\n        \"*[count(//doc)=3]\");    \n    \n  }\n\n","sourceOld":"  /**\n   * verify that all reserved characters are properly escaped when being set in\n   * {@link org.apache.solr.search.ExtendedDismaxQParser.Clause#val}.\n   *\n   * @see ExtendedDismaxQParser#splitIntoClauses(String, boolean)\n   */\n  @Test\n  public void testEscapingOfReservedCharacters() throws Exception {\n    // create a document that contains all reserved characters\n    String allReservedCharacters = \"!():^[]{}~*?\\\"+-\\\\|&/\";\n\n    assertU(adoc(\"id\", \"reservedChars\",\n                 \"name\", allReservedCharacters,\n                 \"cat_s\", \"foo/\"));\n    assertU(commit());\n\n    // the backslash needs to be manually escaped (the query parser sees the raw backslash as an escape the subsequent\n    // character)\n    String query = allReservedCharacters.replace(\"\\\\\", \"\\\\\\\\\");\n\n    // query for all those reserved characters. This will fail to parse in the initial parse, meaning that the escaped\n    // query will then be used\n    assertQ(\"Escaping reserved characters\",\n        req(\"q\", query,\n            \"qf\", \"name\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    // Query string field 'cat_s' for special char / - causes SyntaxError without patch SOLR-3467\n    assertQ(\"Escaping string with reserved / character\",\n        req(\"q\", \"foo/\",\n            \"qf\", \"cat_s\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n    \n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"id\"),\n        \"*[count(//doc)=3]\");\n    assertQ(\n        \"Might be double-escaping a client-escaped colon\", \n        req(\"q\", \"text_sw:(theos OR thistokenhasa\\\\:preescapedcolon OR theou)\", \"defType\", \"edismax\", \"qf\", \"text_sw\"),\n        \"*[count(//doc)=3]\");    \n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8b360a3d5b9d443b4e880d2c92724cffd7def8db":["e55782fb51a6e9789542818eb2161a3247f39ace"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["60997f5d1d0f634df710a5a770d57903c4b0d38b","19275ba31e621f6da1b83bf13af75233876fd3d4"],"3cdb67100dc016748799a77218aa409478372d79":["78513ec977dc489ecf0d3dbce84ebd18ff7a43c1"],"407687e67faf6e1f02a211ca078d8e3eed631027":["78513ec977dc489ecf0d3dbce84ebd18ff7a43c1","3cdb67100dc016748799a77218aa409478372d79"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["60997f5d1d0f634df710a5a770d57903c4b0d38b"],"36d81030ef9ff5ae6820e560c0833127181c7a2c":["c03778630c4604270d88c148afb8c7de35b51d3c"],"c03778630c4604270d88c148afb8c7de35b51d3c":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"e55782fb51a6e9789542818eb2161a3247f39ace":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"78513ec977dc489ecf0d3dbce84ebd18ff7a43c1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"60997f5d1d0f634df710a5a770d57903c4b0d38b":["3cdb67100dc016748799a77218aa409478372d79"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","78513ec977dc489ecf0d3dbce84ebd18ff7a43c1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8b360a3d5b9d443b4e880d2c92724cffd7def8db"]},"commit2Childs":{"8b360a3d5b9d443b4e880d2c92724cffd7def8db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"3cdb67100dc016748799a77218aa409478372d79":["407687e67faf6e1f02a211ca078d8e3eed631027","60997f5d1d0f634df710a5a770d57903c4b0d38b"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"19275ba31e621f6da1b83bf13af75233876fd3d4":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","c03778630c4604270d88c148afb8c7de35b51d3c","e55782fb51a6e9789542818eb2161a3247f39ace"],"36d81030ef9ff5ae6820e560c0833127181c7a2c":[],"c03778630c4604270d88c148afb8c7de35b51d3c":["36d81030ef9ff5ae6820e560c0833127181c7a2c"],"e55782fb51a6e9789542818eb2161a3247f39ace":["8b360a3d5b9d443b4e880d2c92724cffd7def8db"],"78513ec977dc489ecf0d3dbce84ebd18ff7a43c1":["3cdb67100dc016748799a77218aa409478372d79","407687e67faf6e1f02a211ca078d8e3eed631027","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"60997f5d1d0f634df710a5a770d57903c4b0d38b":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","19275ba31e621f6da1b83bf13af75233876fd3d4"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["78513ec977dc489ecf0d3dbce84ebd18ff7a43c1","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","407687e67faf6e1f02a211ca078d8e3eed631027","36d81030ef9ff5ae6820e560c0833127181c7a2c","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}