{"path":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#decompress(DataInput,int,byte[],int).mjava","commits":[{"id":"5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69","date":1352818449,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#decompress(DataInput,int,byte[],int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/LZ4#decompress(DataInput,int,byte[],int).mjava","sourceNew":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into\n   * <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large\n   * enough to be able to hold <b>all</b> decompressed data (meaning that you\n   * need to know the total decompressed length).\n   */\n  public static int decompress(DataInput compressed, int decompressedLen, byte[] dest, int dOff) throws IOException {\n    final int destEnd = dest.length;\n\n    do {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = ((matchLen - 1) & 0xFFFFFFF8) + 8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    } while (dOff < decompressedLen);\n\n    return dOff;\n  }\n\n","sourceOld":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into\n   * <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large\n   * enough to be able to hold <b>all</b> decompressed data (meaning that you\n   * need to know the total decompressed length).\n   */\n  public static int decompress(DataInput compressed, int decompressedLen, byte[] dest, int dOff) throws IOException {\n    final int destEnd = dest.length;\n\n    do {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = ((matchLen - 1) & 0xFFFFFFF8) + 8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    } while (dOff < decompressedLen);\n\n    return dOff;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c3c76aa202009a206735eb7501d52a87ccaba79","date":1354660681,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#decompress(DataInput,int,byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#decompress(DataInput,int,byte[],int).mjava","sourceNew":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into\n   * <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large\n   * enough to be able to hold <b>all</b> decompressed data (meaning that you\n   * need to know the total decompressed length).\n   */\n  public static int decompress(DataInput compressed, int decompressedLen, byte[] dest, int dOff) throws IOException {\n    final int destEnd = dest.length;\n\n    do {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = (matchLen + 7) & 0xFFFFFFF8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    } while (dOff < decompressedLen);\n\n    return dOff;\n  }\n\n","sourceOld":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into\n   * <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large\n   * enough to be able to hold <b>all</b> decompressed data (meaning that you\n   * need to know the total decompressed length).\n   */\n  public static int decompress(DataInput compressed, int decompressedLen, byte[] dest, int dOff) throws IOException {\n    final int destEnd = dest.length;\n\n    do {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = ((matchLen - 1) & 0xFFFFFFF8) + 8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    } while (dOff < decompressedLen);\n\n    return dOff;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#decompress(DataInput,int,byte[],int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into\n   * <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large\n   * enough to be able to hold <b>all</b> decompressed data (meaning that you\n   * need to know the total decompressed length).\n   */\n  public static int decompress(DataInput compressed, int decompressedLen, byte[] dest, int dOff) throws IOException {\n    final int destEnd = dest.length;\n\n    do {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = (matchLen + 7) & 0xFFFFFFF8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    } while (dOff < decompressedLen);\n\n    return dOff;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9407318969e8504257b4c5764c65755a043e5404","date":1579873617,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/compress/LZ4#decompress(DataInput,int,byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#decompress(DataInput,int,byte[],int).mjava","sourceNew":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into\n   * <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large\n   * enough to be able to hold <b>all</b> decompressed data (meaning that you\n   * need to know the total decompressed length).\n   */\n  public static int decompress(DataInput compressed, int decompressedLen, byte[] dest, int dOff) throws IOException {\n    final int destEnd = dest.length;\n\n    do {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = (matchLen + 7) & 0xFFFFFFF8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    } while (dOff < decompressedLen);\n\n    return dOff;\n  }\n\n","sourceOld":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into\n   * <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large\n   * enough to be able to hold <b>all</b> decompressed data (meaning that you\n   * need to know the total decompressed length).\n   */\n  public static int decompress(DataInput compressed, int decompressedLen, byte[] dest, int dOff) throws IOException {\n    final int destEnd = dest.length;\n\n    do {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = (matchLen + 7) & 0xFFFFFFF8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    } while (dOff < decompressedLen);\n\n    return dOff;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0c3c76aa202009a206735eb7501d52a87ccaba79"],"9407318969e8504257b4c5764c65755a043e5404":["0c3c76aa202009a206735eb7501d52a87ccaba79"],"0c3c76aa202009a206735eb7501d52a87ccaba79":["5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9407318969e8504257b4c5764c65755a043e5404"]},"commit2Childs":{"5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69":["0c3c76aa202009a206735eb7501d52a87ccaba79"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69","407687e67faf6e1f02a211ca078d8e3eed631027"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"9407318969e8504257b4c5764c65755a043e5404":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0c3c76aa202009a206735eb7501d52a87ccaba79":["407687e67faf6e1f02a211ca078d8e3eed631027","9407318969e8504257b4c5764c65755a043e5404"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}