{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],LightAutomaton,FST[Pair[Long,BytesRef]]).mjava","commits":[{"id":"75ac8571c2d82c574e446c3729251b994c69a55c","date":1402523781,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],LightAutomaton,FST[Pair[Long,BytesRef]]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","sourceNew":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       LightAutomaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    LightAutomaton levA = convertAutomaton(toLevenshteinAutomata(lookupAutomaton));\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","sourceOld":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       Automaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    Automaton levA = convertAutomaton(toLevenshteinAutomata(lookupAutomaton));\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],Automaton,FST[Pair[Long,BytesRef]]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#getFullPrefixPaths(List[FSTUtil.Path[Pair[Long,BytesRef]]],LightAutomaton,FST[Pair[Long,BytesRef]]).mjava","sourceNew":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       Automaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    Automaton levA = convertAutomaton(toLevenshteinAutomata(lookupAutomaton));\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","sourceOld":"  @Override\n  protected List<FSTUtil.Path<Pair<Long,BytesRef>>> getFullPrefixPaths(List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths,\n                                                                       LightAutomaton lookupAutomaton,\n                                                                       FST<Pair<Long,BytesRef>> fst)\n    throws IOException {\n\n    // TODO: right now there's no penalty for fuzzy/edits,\n    // ie a completion whose prefix matched exactly what the\n    // user typed gets no boost over completions that\n    // required an edit, which get no boost over completions\n    // requiring two edits.  I suspect a multiplicative\n    // factor is appropriate (eg, say a fuzzy match must be at\n    // least 2X better weight than the non-fuzzy match to\n    // \"compete\") ... in which case I think the wFST needs\n    // to be log weights or something ...\n\n    LightAutomaton levA = convertAutomaton(toLevenshteinAutomata(lookupAutomaton));\n    /*\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      w.write(levA.toDot());\n      w.close();\n      System.out.println(\"Wrote LevA to out.dot\");\n    */\n    return FSTUtil.intersectPrefixPaths(levA, fst);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"75ac8571c2d82c574e446c3729251b994c69a55c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["75ac8571c2d82c574e446c3729251b994c69a55c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"75ac8571c2d82c574e446c3729251b994c69a55c":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["75ac8571c2d82c574e446c3729251b994c69a55c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}