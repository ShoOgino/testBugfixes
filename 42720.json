{"path":"solr/core/src/test/org/apache/solr/cloud/ReindexCollectionTest#testAbort().mjava","commits":[{"id":"dad6a48950aafc9c2f5dc54740f8c6ab81304203","date":1552999379,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReindexCollectionTest#testAbort().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testAbort() throws Exception {\n    final String sourceCollection = \"abortReindexing\";\n    final String targetCollection = \"abortReindexingTarget\";\n    createCollection(sourceCollection, \"conf1\", 2, 1);\n\n    TestInjection.reindexLatch = new CountDownLatch(1);\n    CollectionAdminRequest.ReindexCollection req = CollectionAdminRequest.reindexCollection(sourceCollection)\n        .setTarget(targetCollection);\n    String asyncId = req.processAsync(solrClient);\n    // wait for the source collection to be put in readOnly mode\n    CloudTestUtils.waitForState(cloudManager, \"source collection didn't become readOnly\",\n        sourceCollection, (liveNodes, coll) -> coll.isReadOnly());\n\n    req = CollectionAdminRequest.reindexCollection(sourceCollection);\n    req.setCommand(\"abort\");\n    CollectionAdminResponse rsp = req.process(solrClient);\n    Map<String, Object> status = (Map<String, Object>)rsp.getResponse().get(ReindexCollectionCmd.REINDEX_STATUS);\n    assertNotNull(rsp.toString(), status);\n    assertEquals(status.toString(), \"aborting\", status.get(\"state\"));\n\n    CloudTestUtils.waitForState(cloudManager, \"incorrect collection state\", sourceCollection,\n        ((liveNodes, collectionState) ->\n            collectionState.isReadOnly() &&\n            getState(sourceCollection) == ReindexCollectionCmd.State.ABORTED));\n\n    // verify status\n    req.setCommand(\"status\");\n    rsp = req.process(solrClient);\n    status = (Map<String, Object>)rsp.getResponse().get(ReindexCollectionCmd.REINDEX_STATUS);\n    assertNotNull(rsp.toString(), status);\n    assertEquals(status.toString(), \"aborted\", status.get(\"state\"));\n    // let the process continue\n    TestInjection.reindexLatch.countDown();\n    CloudTestUtils.waitForState(cloudManager, \"source collection is in wrong state\",\n        sourceCollection, (liveNodes, docCollection) -> !docCollection.isReadOnly() && getState(sourceCollection) == null);\n    // verify the response\n    rsp = CollectionAdminRequest.requestStatus(asyncId).process(solrClient);\n    status = (Map<String, Object>)rsp.getResponse().get(ReindexCollectionCmd.REINDEX_STATUS);\n    assertNotNull(rsp.toString(), status);\n    assertEquals(status.toString(), \"aborted\", status.get(\"state\"));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReindexCollectionTest#testAbort().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReindexCollectionTest#testAbort().mjava","sourceNew":"  @Test\n  public void testAbort() throws Exception {\n    final String sourceCollection = \"abortReindexing\";\n    final String targetCollection = \"abortReindexingTarget\";\n    createCollection(sourceCollection, \"conf1\", 2, 1);\n\n    TestInjection.reindexLatch = new CountDownLatch(1);\n    CollectionAdminRequest.ReindexCollection req = CollectionAdminRequest.reindexCollection(sourceCollection)\n        .setTarget(targetCollection);\n    String asyncId = req.processAsync(solrClient);\n    // wait for the source collection to be put in readOnly mode\n    CloudUtil.waitForState(cloudManager, \"source collection didn't become readOnly\",\n        sourceCollection, (liveNodes, coll) -> coll.isReadOnly());\n\n    req = CollectionAdminRequest.reindexCollection(sourceCollection);\n    req.setCommand(\"abort\");\n    CollectionAdminResponse rsp = req.process(solrClient);\n    Map<String, Object> status = (Map<String, Object>)rsp.getResponse().get(ReindexCollectionCmd.REINDEX_STATUS);\n    assertNotNull(rsp.toString(), status);\n    assertEquals(status.toString(), \"aborting\", status.get(\"state\"));\n\n    CloudUtil.waitForState(cloudManager, \"incorrect collection state\", sourceCollection,\n        ((liveNodes, collectionState) ->\n            collectionState.isReadOnly() &&\n            getState(sourceCollection) == ReindexCollectionCmd.State.ABORTED));\n\n    // verify status\n    req.setCommand(\"status\");\n    rsp = req.process(solrClient);\n    status = (Map<String, Object>)rsp.getResponse().get(ReindexCollectionCmd.REINDEX_STATUS);\n    assertNotNull(rsp.toString(), status);\n    assertEquals(status.toString(), \"aborted\", status.get(\"state\"));\n    // let the process continue\n    TestInjection.reindexLatch.countDown();\n    CloudUtil.waitForState(cloudManager, \"source collection is in wrong state\",\n        sourceCollection, (liveNodes, docCollection) -> !docCollection.isReadOnly() && getState(sourceCollection) == null);\n    // verify the response\n    rsp = CollectionAdminRequest.requestStatus(asyncId).process(solrClient);\n    status = (Map<String, Object>)rsp.getResponse().get(ReindexCollectionCmd.REINDEX_STATUS);\n    assertNotNull(rsp.toString(), status);\n    assertEquals(status.toString(), \"aborted\", status.get(\"state\"));\n  }\n\n","sourceOld":"  @Test\n  public void testAbort() throws Exception {\n    final String sourceCollection = \"abortReindexing\";\n    final String targetCollection = \"abortReindexingTarget\";\n    createCollection(sourceCollection, \"conf1\", 2, 1);\n\n    TestInjection.reindexLatch = new CountDownLatch(1);\n    CollectionAdminRequest.ReindexCollection req = CollectionAdminRequest.reindexCollection(sourceCollection)\n        .setTarget(targetCollection);\n    String asyncId = req.processAsync(solrClient);\n    // wait for the source collection to be put in readOnly mode\n    CloudTestUtils.waitForState(cloudManager, \"source collection didn't become readOnly\",\n        sourceCollection, (liveNodes, coll) -> coll.isReadOnly());\n\n    req = CollectionAdminRequest.reindexCollection(sourceCollection);\n    req.setCommand(\"abort\");\n    CollectionAdminResponse rsp = req.process(solrClient);\n    Map<String, Object> status = (Map<String, Object>)rsp.getResponse().get(ReindexCollectionCmd.REINDEX_STATUS);\n    assertNotNull(rsp.toString(), status);\n    assertEquals(status.toString(), \"aborting\", status.get(\"state\"));\n\n    CloudTestUtils.waitForState(cloudManager, \"incorrect collection state\", sourceCollection,\n        ((liveNodes, collectionState) ->\n            collectionState.isReadOnly() &&\n            getState(sourceCollection) == ReindexCollectionCmd.State.ABORTED));\n\n    // verify status\n    req.setCommand(\"status\");\n    rsp = req.process(solrClient);\n    status = (Map<String, Object>)rsp.getResponse().get(ReindexCollectionCmd.REINDEX_STATUS);\n    assertNotNull(rsp.toString(), status);\n    assertEquals(status.toString(), \"aborted\", status.get(\"state\"));\n    // let the process continue\n    TestInjection.reindexLatch.countDown();\n    CloudTestUtils.waitForState(cloudManager, \"source collection is in wrong state\",\n        sourceCollection, (liveNodes, docCollection) -> !docCollection.isReadOnly() && getState(sourceCollection) == null);\n    // verify the response\n    rsp = CollectionAdminRequest.requestStatus(asyncId).process(solrClient);\n    status = (Map<String, Object>)rsp.getResponse().get(ReindexCollectionCmd.REINDEX_STATUS);\n    assertNotNull(rsp.toString(), status);\n    assertEquals(status.toString(), \"aborted\", status.get(\"state\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReindexCollectionTest#testAbort().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReindexCollectionTest#testAbort().mjava","sourceNew":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testAbort() throws Exception {\n    final String sourceCollection = \"abortReindexing\";\n    final String targetCollection = \"abortReindexingTarget\";\n    createCollection(sourceCollection, \"conf1\", 2, 1);\n\n    TestInjection.reindexLatch = new CountDownLatch(1);\n    CollectionAdminRequest.ReindexCollection req = CollectionAdminRequest.reindexCollection(sourceCollection)\n        .setTarget(targetCollection);\n    String asyncId = req.processAsync(solrClient);\n    // wait for the source collection to be put in readOnly mode\n    CloudUtil.waitForState(cloudManager, \"source collection didn't become readOnly\",\n        sourceCollection, (liveNodes, coll) -> coll.isReadOnly());\n\n    req = CollectionAdminRequest.reindexCollection(sourceCollection);\n    req.setCommand(\"abort\");\n    CollectionAdminResponse rsp = req.process(solrClient);\n    Map<String, Object> status = (Map<String, Object>)rsp.getResponse().get(ReindexCollectionCmd.REINDEX_STATUS);\n    assertNotNull(rsp.toString(), status);\n    assertEquals(status.toString(), \"aborting\", status.get(\"state\"));\n\n    CloudUtil.waitForState(cloudManager, \"incorrect collection state\", sourceCollection,\n        ((liveNodes, collectionState) ->\n            collectionState.isReadOnly() &&\n            getState(sourceCollection) == ReindexCollectionCmd.State.ABORTED));\n\n    // verify status\n    req.setCommand(\"status\");\n    rsp = req.process(solrClient);\n    status = (Map<String, Object>)rsp.getResponse().get(ReindexCollectionCmd.REINDEX_STATUS);\n    assertNotNull(rsp.toString(), status);\n    assertEquals(status.toString(), \"aborted\", status.get(\"state\"));\n    // let the process continue\n    TestInjection.reindexLatch.countDown();\n    CloudUtil.waitForState(cloudManager, \"source collection is in wrong state\",\n        sourceCollection, (liveNodes, docCollection) -> !docCollection.isReadOnly() && getState(sourceCollection) == null);\n    // verify the response\n    rsp = CollectionAdminRequest.requestStatus(asyncId).process(solrClient);\n    status = (Map<String, Object>)rsp.getResponse().get(ReindexCollectionCmd.REINDEX_STATUS);\n    assertNotNull(rsp.toString(), status);\n    assertEquals(status.toString(), \"aborted\", status.get(\"state\"));\n  }\n\n","sourceOld":"  @Test\n  public void testAbort() throws Exception {\n    final String sourceCollection = \"abortReindexing\";\n    final String targetCollection = \"abortReindexingTarget\";\n    createCollection(sourceCollection, \"conf1\", 2, 1);\n\n    TestInjection.reindexLatch = new CountDownLatch(1);\n    CollectionAdminRequest.ReindexCollection req = CollectionAdminRequest.reindexCollection(sourceCollection)\n        .setTarget(targetCollection);\n    String asyncId = req.processAsync(solrClient);\n    // wait for the source collection to be put in readOnly mode\n    CloudUtil.waitForState(cloudManager, \"source collection didn't become readOnly\",\n        sourceCollection, (liveNodes, coll) -> coll.isReadOnly());\n\n    req = CollectionAdminRequest.reindexCollection(sourceCollection);\n    req.setCommand(\"abort\");\n    CollectionAdminResponse rsp = req.process(solrClient);\n    Map<String, Object> status = (Map<String, Object>)rsp.getResponse().get(ReindexCollectionCmd.REINDEX_STATUS);\n    assertNotNull(rsp.toString(), status);\n    assertEquals(status.toString(), \"aborting\", status.get(\"state\"));\n\n    CloudUtil.waitForState(cloudManager, \"incorrect collection state\", sourceCollection,\n        ((liveNodes, collectionState) ->\n            collectionState.isReadOnly() &&\n            getState(sourceCollection) == ReindexCollectionCmd.State.ABORTED));\n\n    // verify status\n    req.setCommand(\"status\");\n    rsp = req.process(solrClient);\n    status = (Map<String, Object>)rsp.getResponse().get(ReindexCollectionCmd.REINDEX_STATUS);\n    assertNotNull(rsp.toString(), status);\n    assertEquals(status.toString(), \"aborted\", status.get(\"state\"));\n    // let the process continue\n    TestInjection.reindexLatch.countDown();\n    CloudUtil.waitForState(cloudManager, \"source collection is in wrong state\",\n        sourceCollection, (liveNodes, docCollection) -> !docCollection.isReadOnly() && getState(sourceCollection) == null);\n    // verify the response\n    rsp = CollectionAdminRequest.requestStatus(asyncId).process(solrClient);\n    status = (Map<String, Object>)rsp.getResponse().get(ReindexCollectionCmd.REINDEX_STATUS);\n    assertNotNull(rsp.toString(), status);\n    assertEquals(status.toString(), \"aborted\", status.get(\"state\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"dad6a48950aafc9c2f5dc54740f8c6ab81304203":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["dad6a48950aafc9c2f5dc54740f8c6ab81304203"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"]},"commit2Childs":{"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dad6a48950aafc9c2f5dc54740f8c6ab81304203":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dad6a48950aafc9c2f5dc54740f8c6ab81304203"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}