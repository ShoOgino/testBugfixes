{"path":"solr/core/src/test/org/apache/solr/update/TestNestedUpdateProcessor.RandomNestedDocModel#buildRandomDoc(SolrInputDocument,List[String],int).mjava","commits":[{"id":"0b5e0da3b576580fb2128e87467fa5f579ca2c33","date":1599081383,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestNestedUpdateProcessor.RandomNestedDocModel#buildRandomDoc(SolrInputDocument,List[String],int).mjava","pathOld":"/dev/null","sourceNew":"    private synchronized SolrInputDocument buildRandomDoc(SolrInputDocument parent,\n                                                          List<String> test_path,\n                                                          int maxDepthAndBreadth) {\n      final String path_string = joinPath(test_path);\n      final String id = \"\" + (++idCounter);\n      maxDepthAndBreadth--;\n      final SolrInputDocument doc = sdoc\n        (\"id\", id,\n         // may change, but we want it 0 even if we never add any\n         \"num_direct_kids_s\", \"0\", \n         // conceptually matches _nest_path_ but should be easier to make assertions about (no inline position #s)\n         \"test_path_s\", path_string);\n      if (null != parent) {\n        // order matters: if we add the Collection first, SolrInputDocument will try to reuse it\n        doc.addField(\"ancestor_ids_ss\", parent.getFieldValue(\"id\"));\n        if (parent.containsKey(\"ancestor_ids_ss\")) { // sigh: getFieldValues returns null, not empty collection\n          doc.addField(\"ancestor_ids_ss\", parent.getFieldValues(\"ancestor_ids_ss\"));\n        }\n      }\n      \n      for (int i = 0; i < test_path.size(); i++) {\n        // NOTE: '<' not '<=\" .. we only includes paths we are descendents of, not our full path...\n        numDocsDescendentFromPath.merge(joinPath(test_path.subList(0, i)), 1, Math::addExact);\n      }\n      \n      if (0 < maxDepthAndBreadth) {\n        final int numDirectKids = TestUtil.nextInt(random(), 0, Math.min(4, maxDepthAndBreadth));\n        doc.setField(\"num_direct_kids_s\", \"\" + numDirectKids);\n        if (0 < numDirectKids) {\n          numDocsWithPathWithKids.merge(path_string, 1, Math::addExact);\n        }\n        maxDepthAndBreadth -= numDirectKids;\n        for (int i = 0; i < numDirectKids; i++) {\n          final String kidType = PATH_ELEMENTS.get(random().nextInt(PATH_ELEMENTS.size()));\n          final List<String> kid_path = new ArrayList<>(test_path);\n          kid_path.add(kidType);\n          final SolrInputDocument kid = buildRandomDoc(doc, kid_path, maxDepthAndBreadth);\n          doc.addField(kidType, kid);\n          // order matters: if we add the Collection first, SolrInputDocument will try to reuse it\n          doc.addField(\"descendent_ids_ss\", kid.getFieldValue(\"id\"));\n          if (kid.containsKey(\"descendent_ids_ss\")) {  // sigh: getFieldValues returns null, not empty collection\n            doc.addField(\"descendent_ids_ss\", kid.getFieldValues(\"descendent_ids_ss\"));\n          }\n        }\n      }\n      allDocs.put(id, doc);\n      return doc;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0b5e0da3b576580fb2128e87467fa5f579ca2c33"],"0b5e0da3b576580fb2128e87467fa5f579ca2c33":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0b5e0da3b576580fb2128e87467fa5f579ca2c33"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"0b5e0da3b576580fb2128e87467fa5f579ca2c33":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}