{"path":"solr/core/src/java/org/apache/solr/cloud/CloudUtil#clusterShape(int,int,boolean,boolean).mjava","commits":[{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/CloudUtil#clusterShape(int,int,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CloudTestUtils#clusterShape(int,int,boolean,boolean).mjava","sourceNew":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.info(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.info(\"-- wrong number of slices for collection {}, expected={}, found={}: {}\", collectionState.getName(), expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.info(\"-- wrong number of active replicas for collection {} in slice {}, expected={}, found={}\", collectionState.getName(), slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.info(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.info(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.info(\"-- wrong number of slices for collection {}, expected={}, found={}: {}\", collectionState.getName(), expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.info(\"-- wrong number of active replicas for collection {} in slice {}, expected={}, found={}\", collectionState.getName(), slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.info(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d80c1ad9241ae005a167d7ee8ac473601b0e57c","date":1559036097,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/CloudUtil#clusterShape(int,int,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/CloudUtil#clusterShape(int,int,boolean,boolean).mjava","sourceNew":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas per shard\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.info(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.info(\"-- wrong number of slices for collection {}, expected={}, found={}: {}\", collectionState.getName(), expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.info(\"-- wrong number of active replicas for collection {} in slice {}, expected={}, found={}\", collectionState.getName(), slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.info(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.info(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.info(\"-- wrong number of slices for collection {}, expected={}, found={}: {}\", collectionState.getName(), expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.info(\"-- wrong number of active replicas for collection {} in slice {}, expected={}, found={}\", collectionState.getName(), slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.info(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7aeb53916301ea6a5fedff4fdc9617b257cbc7d","date":1571856490,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/CloudUtil#clusterShape(int,int,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/CloudUtil#clusterShape(int,int,boolean,boolean).mjava","sourceNew":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas per shard\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.debug(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.debug(\"-- wrong number of slices for collection {}, expected={}, found={}: {}\", collectionState.getName(), expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.debug(\"-- wrong number of active replicas for collection {} in slice {}, expected={}, found={}\", collectionState.getName(), slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.info(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas per shard\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.info(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.info(\"-- wrong number of slices for collection {}, expected={}, found={}: {}\", collectionState.getName(), expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.info(\"-- wrong number of active replicas for collection {} in slice {}, expected={}, found={}\", collectionState.getName(), slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.info(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad4957cde742defe6db19689abdc267c5d948066","date":1587990850,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/CloudUtil#clusterShape(int,int,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/CloudUtil#clusterShape(int,int,boolean,boolean).mjava","sourceNew":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas per shard\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.debug(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"-- wrong number of slices for collection {}, expected={}, found={}: {}\", collectionState.getName(), expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        }\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"-- wrong number of active replicas for collection {} in slice {}, expected={}, found={}\", collectionState.getName(), slice.getName(), expectedReplicas, activeReplicas);\n          }\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.info(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas per shard\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.debug(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        log.debug(\"-- wrong number of slices for collection {}, expected={}, found={}: {}\", collectionState.getName(), expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          log.debug(\"-- wrong number of active replicas for collection {} in slice {}, expected={}, found={}\", collectionState.getName(), slice.getName(), expectedReplicas, activeReplicas);\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.info(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/CloudUtil#clusterShape(int,int,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/CloudUtil#clusterShape(int,int,boolean,boolean).mjava","sourceNew":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas per shard\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.debug(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"-- wrong number of slices for collection {}, expected={}, found={}: {}\", collectionState.getName(), expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        }\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"-- wrong number of active replicas for collection {} in slice {}, expected={}, found={}\", collectionState.getName(), slice.getName(), expectedReplicas, activeReplicas);\n          }\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.info(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Return a {@link CollectionStatePredicate} that returns true if a collection has the expected\n   * number of shards and replicas.\n   * <p>Note: for shards marked as inactive the current Solr behavior is that replicas remain active.\n   * {@link org.apache.solr.cloud.autoscaling.sim.SimCloudManager} follows this behavior.</p>\n   * @param expectedShards expected number of shards\n   * @param expectedReplicas expected number of active replicas per shard\n   * @param withInactive if true then count also inactive shards\n   * @param requireLeaders if true then require that each shard has a leader\n   */\n  public static CollectionStatePredicate clusterShape(int expectedShards, int expectedReplicas, boolean withInactive,\n                                                      boolean requireLeaders) {\n    return (liveNodes, collectionState) -> {\n      if (collectionState == null) {\n        log.debug(\"-- null collection\");\n        return false;\n      }\n      Collection<Slice> slices = withInactive ? collectionState.getSlices() : collectionState.getActiveSlices();\n      if (slices.size() != expectedShards) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"-- wrong number of slices for collection {}, expected={}, found={}: {}\", collectionState.getName(), expectedShards, collectionState.getSlices().size(), collectionState.getSlices());\n        }\n        return false;\n      }\n      Set<String> leaderless = new HashSet<>();\n      for (Slice slice : slices) {\n        int activeReplicas = 0;\n        if (requireLeaders && slice.getState() != Slice.State.INACTIVE && slice.getLeader() == null) {\n          leaderless.add(slice.getName());\n          continue;\n        }\n        // skip other checks, we're going to fail anyway\n        if (!leaderless.isEmpty()) {\n          continue;\n        }\n        for (Replica replica : slice) {\n          if (replica.isActive(liveNodes))\n            activeReplicas++;\n        }\n        if (activeReplicas != expectedReplicas) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"-- wrong number of active replicas for collection {} in slice {}, expected={}, found={}\", collectionState.getName(), slice.getName(), expectedReplicas, activeReplicas);\n          }\n          return false;\n        }\n      }\n      if (leaderless.isEmpty()) {\n        return true;\n      } else {\n        log.info(\"-- shards without leaders: {}\", leaderless);\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f504512a03d978990cbff30db0522b354e846db":["ad4957cde742defe6db19689abdc267c5d948066"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad4957cde742defe6db19689abdc267c5d948066":["a7aeb53916301ea6a5fedff4fdc9617b257cbc7d"],"2d80c1ad9241ae005a167d7ee8ac473601b0e57c":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"a7aeb53916301ea6a5fedff4fdc9617b257cbc7d":["2d80c1ad9241ae005a167d7ee8ac473601b0e57c"]},"commit2Childs":{"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"ad4957cde742defe6db19689abdc267c5d948066":["3f504512a03d978990cbff30db0522b354e846db"],"2d80c1ad9241ae005a167d7ee8ac473601b0e57c":["a7aeb53916301ea6a5fedff4fdc9617b257cbc7d"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["2d80c1ad9241ae005a167d7ee8ac473601b0e57c"],"a7aeb53916301ea6a5fedff4fdc9617b257cbc7d":["ad4957cde742defe6db19689abdc267c5d948066"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}