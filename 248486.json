{"path":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doBaseAdvanceScoring(Collector,DocsEnum[][],Collector[]).mjava","commits":[{"id":"21d36d0db865f7b84026b447bec653469a6e66df","date":1385495602,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doBaseAdvanceScoring(Collector,DocsEnum[][],Collector[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleDrillSidewaysScorer#doBaseAdvanceScoring(Collector,DocsEnum[][],Collector[]).mjava","sourceNew":"  /** Used when base query is highly constraining vs the\n   *  drilldowns; in this case we just .next() on base and\n   *  .advance() on the dims. */\n  private void doBaseAdvanceScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doBaseAdvanceScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    final int numDims = dims.length;\n\n    nextDoc: while (docID != NO_MORE_DOCS) {\n      int failedDim = -1;\n      for(int dim=0;dim<numDims;dim++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        boolean found = false;\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          if (docsEnum.docID() < docID) {\n            docsEnum.advance(docID);\n          }\n          if (docsEnum.docID() == docID) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          if (failedDim != -1) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedDim = dim;\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedDim == -1) {\n        collectHit(collector, sidewaysCollectors);\n      } else {\n        collectNearMiss(sidewaysCollectors, failedDim);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","sourceOld":"  /** Used when base query is highly constraining vs the\n   *  drilldowns; in this case we just .next() on base and\n   *  .advance() on the dims. */\n  private void doBaseAdvanceScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doBaseAdvanceScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    final int numDims = dims.length;\n\n    nextDoc: while (docID != NO_MORE_DOCS) {\n      int failedDim = -1;\n      for(int dim=0;dim<numDims;dim++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        boolean found = false;\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          if (docsEnum.docID() < docID) {\n            docsEnum.advance(docID);\n          }\n          if (docsEnum.docID() == docID) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          if (failedDim != -1) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedDim = dim;\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedDim == -1) {\n        collectHit(collector, sidewaysCollectors);\n      } else {\n        collectNearMiss(sidewaysCollectors, failedDim);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doBaseAdvanceScoring(Collector,DocsEnum[][],Collector[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#doBaseAdvanceScoring(Collector,DocsEnum[][],Collector[]).mjava","sourceNew":"  /** Used when base query is highly constraining vs the\n   *  drilldowns; in this case we just .next() on base and\n   *  .advance() on the dims. */\n  private void doBaseAdvanceScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doBaseAdvanceScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    final int numDims = dims.length;\n\n    nextDoc: while (docID != NO_MORE_DOCS) {\n      int failedDim = -1;\n      for(int dim=0;dim<numDims;dim++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        boolean found = false;\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          if (docsEnum.docID() < docID) {\n            docsEnum.advance(docID);\n          }\n          if (docsEnum.docID() == docID) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          if (failedDim != -1) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedDim = dim;\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedDim == -1) {\n        collectHit(collector, sidewaysCollectors);\n      } else {\n        collectNearMiss(sidewaysCollectors, failedDim);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","sourceOld":"  /** Used when base query is highly constraining vs the\n   *  drilldowns; in this case we just .next() on base and\n   *  .advance() on the dims. */\n  private void doBaseAdvanceScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doBaseAdvanceScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    final int numDims = dims.length;\n\n    nextDoc: while (docID != NO_MORE_DOCS) {\n      int failedDim = -1;\n      for(int dim=0;dim<numDims;dim++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        boolean found = false;\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          if (docsEnum.docID() < docID) {\n            docsEnum.advance(docID);\n          }\n          if (docsEnum.docID() == docID) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          if (failedDim != -1) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedDim = dim;\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedDim == -1) {\n        collectHit(collector, sidewaysCollectors);\n      } else {\n        collectNearMiss(sidewaysCollectors, failedDim);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40640359164f629dd440a47df2e145d084ce9645","date":1391711808,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doBaseAdvanceScoring(Collector,DocsEnum[][],Collector[]).mjava","sourceNew":null,"sourceOld":"  /** Used when base query is highly constraining vs the\n   *  drilldowns; in this case we just .next() on base and\n   *  .advance() on the dims. */\n  private void doBaseAdvanceScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doBaseAdvanceScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    final int numDims = dims.length;\n\n    nextDoc: while (docID != NO_MORE_DOCS) {\n      int failedDim = -1;\n      for(int dim=0;dim<numDims;dim++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        boolean found = false;\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          if (docsEnum.docID() < docID) {\n            docsEnum.advance(docID);\n          }\n          if (docsEnum.docID() == docID) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          if (failedDim != -1) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedDim = dim;\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedDim == -1) {\n        collectHit(collector, sidewaysCollectors);\n      } else {\n        collectNearMiss(sidewaysCollectors, failedDim);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"21d36d0db865f7b84026b447bec653469a6e66df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","21d36d0db865f7b84026b447bec653469a6e66df"],"40640359164f629dd440a47df2e145d084ce9645":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["40640359164f629dd440a47df2e145d084ce9645"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["21d36d0db865f7b84026b447bec653469a6e66df","3cc728b07df73b197e6d940d27f9b08b63918f13"],"21d36d0db865f7b84026b447bec653469a6e66df":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["40640359164f629dd440a47df2e145d084ce9645"],"40640359164f629dd440a47df2e145d084ce9645":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}