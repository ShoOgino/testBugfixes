{"path":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersDataInput#sliceBufferList(List[ByteBuffer],long,long).mjava","commits":[{"id":"fad01f81cc24b33263ccec7dbff3fb907702f91e","date":1535461373,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersDataInput#sliceBufferList(List[ByteBuffer],long,long).mjava","pathOld":"/dev/null","sourceNew":"  private static List<ByteBuffer> sliceBufferList(List<ByteBuffer> buffers, long offset, long length) {\n    ensureAssumptions(buffers);\n\n    if (buffers.size() == 1) {\n      ByteBuffer cloned = buffers.get(0).asReadOnlyBuffer();\n      cloned.position(Math.toIntExact(cloned.position() + offset));\n      cloned.limit(Math.toIntExact(length + cloned.position()));\n      return Arrays.asList(cloned);\n    } else {\n      long absStart = buffers.get(0).position() + offset;\n      long absEnd = Math.toIntExact(absStart + length);\n\n      int blockBytes = ByteBuffersDataInput.determineBlockPage(buffers);\n      int blockBits = Integer.numberOfTrailingZeros(blockBytes);\n      int blockMask = (1 << blockBits) - 1;\n\n      int endOffset = (int) absEnd & blockMask;\n\n      ArrayList<ByteBuffer> cloned = \n        buffers.subList(Math.toIntExact(absStart / blockBytes), \n                        Math.toIntExact(absEnd / blockBytes + (endOffset == 0 ? 0 : 1)))\n          .stream()\n          .map(buf -> buf.asReadOnlyBuffer())\n          .collect(Collectors.toCollection(ArrayList::new));\n\n      if (endOffset == 0) {\n        cloned.add(ByteBuffer.allocate(0));\n      }\n\n      cloned.get(0).position((int) absStart & blockMask);\n      cloned.get(cloned.size() - 1).limit(endOffset);\n      return cloned;\n    }\n  }  \n\n","sourceOld":null,"bugFix":null,"bugIntro":["04ba6c272391bbabfb2e302e10e51bc9c3c4963b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04ba6c272391bbabfb2e302e10e51bc9c3c4963b","date":1545995448,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersDataInput#sliceBufferList(List[ByteBuffer],long,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersDataInput#sliceBufferList(List[ByteBuffer],long,long).mjava","sourceNew":"  private static List<ByteBuffer> sliceBufferList(List<ByteBuffer> buffers, long offset, long length) {\n    ensureAssumptions(buffers);\n\n    if (buffers.size() == 1) {\n      ByteBuffer cloned = buffers.get(0).asReadOnlyBuffer();\n      cloned.position(Math.toIntExact(cloned.position() + offset));\n      cloned.limit(Math.toIntExact(cloned.position() + length));\n      return Arrays.asList(cloned);\n    } else {\n      long absStart = buffers.get(0).position() + offset;\n      long absEnd = absStart + length;\n\n      int blockBytes = ByteBuffersDataInput.determineBlockPage(buffers);\n      int blockBits = Integer.numberOfTrailingZeros(blockBytes);\n      long blockMask = (1L << blockBits) - 1;\n\n      int endOffset = Math.toIntExact(absEnd & blockMask);\n\n      ArrayList<ByteBuffer> cloned = \n        buffers.subList(Math.toIntExact(absStart / blockBytes), \n                        Math.toIntExact(absEnd / blockBytes + (endOffset == 0 ? 0 : 1)))\n          .stream()\n          .map(buf -> buf.asReadOnlyBuffer())\n          .collect(Collectors.toCollection(ArrayList::new));\n\n      if (endOffset == 0) {\n        cloned.add(ByteBuffer.allocate(0));\n      }\n\n      cloned.get(0).position(Math.toIntExact(absStart & blockMask));\n      cloned.get(cloned.size() - 1).limit(endOffset);\n      return cloned;\n    }\n  }  \n\n","sourceOld":"  private static List<ByteBuffer> sliceBufferList(List<ByteBuffer> buffers, long offset, long length) {\n    ensureAssumptions(buffers);\n\n    if (buffers.size() == 1) {\n      ByteBuffer cloned = buffers.get(0).asReadOnlyBuffer();\n      cloned.position(Math.toIntExact(cloned.position() + offset));\n      cloned.limit(Math.toIntExact(length + cloned.position()));\n      return Arrays.asList(cloned);\n    } else {\n      long absStart = buffers.get(0).position() + offset;\n      long absEnd = Math.toIntExact(absStart + length);\n\n      int blockBytes = ByteBuffersDataInput.determineBlockPage(buffers);\n      int blockBits = Integer.numberOfTrailingZeros(blockBytes);\n      int blockMask = (1 << blockBits) - 1;\n\n      int endOffset = (int) absEnd & blockMask;\n\n      ArrayList<ByteBuffer> cloned = \n        buffers.subList(Math.toIntExact(absStart / blockBytes), \n                        Math.toIntExact(absEnd / blockBytes + (endOffset == 0 ? 0 : 1)))\n          .stream()\n          .map(buf -> buf.asReadOnlyBuffer())\n          .collect(Collectors.toCollection(ArrayList::new));\n\n      if (endOffset == 0) {\n        cloned.add(ByteBuffer.allocate(0));\n      }\n\n      cloned.get(0).position((int) absStart & blockMask);\n      cloned.get(cloned.size() - 1).limit(endOffset);\n      return cloned;\n    }\n  }  \n\n","bugFix":["fad01f81cc24b33263ccec7dbff3fb907702f91e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"04ba6c272391bbabfb2e302e10e51bc9c3c4963b":["fad01f81cc24b33263ccec7dbff3fb907702f91e"],"fad01f81cc24b33263ccec7dbff3fb907702f91e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["04ba6c272391bbabfb2e302e10e51bc9c3c4963b"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fad01f81cc24b33263ccec7dbff3fb907702f91e"],"04ba6c272391bbabfb2e302e10e51bc9c3c4963b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fad01f81cc24b33263ccec7dbff3fb907702f91e":["04ba6c272391bbabfb2e302e10e51bc9c3c4963b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}