{"path":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#advanceRepeats(PhrasePositions,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#advanceRepeats(PhrasePositions,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#advanceRepeats(PhrasePositions,int).mjava","sourceNew":"  /**\n   * Advance repeating pps of an input (non-repeating) pp.\n   * Return a modified 'end' in case pp or its repeats exceeds original 'end'.\n   * \"Dirty\" trick: when there are repeats, modifies pp's position to that of \n   * least repeater of pp (needed when due to holes repeaters' positions are \"back\").\n   */\n  private int advanceRepeats(PhrasePositions pp, int end) throws IOException {\n    int repeatsEnd = end;\n    if (pp.position > repeatsEnd) {\n      repeatsEnd = pp.position;\n    }\n    if (!hasRepeats) {\n      return repeatsEnd;\n    }\n    int tpPos = tpPos(pp);\n    for (PhrasePositions pp2=pp.nextRepeating; pp2!=null; pp2=pp2.nextRepeating) {\n      while (tpPos(pp2) <= tpPos) {\n        if (!pp2.nextPosition()) {\n          return Integer.MIN_VALUE;\n        }\n      }\n      tpPos = tpPos(pp2);\n      if (pp2.position > repeatsEnd) {\n        repeatsEnd = pp2.position;\n      }\n      // \"dirty\" trick: with holes, given a pp, its repeating pp2 might have smaller position.\n      // so in order to have the right \"start\" in matchLength computation we fake pp.position.\n      // this relies on pp.nextPosition() not using pp.position.\n      if (pp2.position < pp.position) { \n        pp.position = pp2.position;     \n      }\n    }\n    return repeatsEnd;\n  }\n\n","sourceOld":"  /**\n   * Advance repeating pps of an input (non-repeating) pp.\n   * Return a modified 'end' in case pp or its repeats exceeds original 'end'.\n   * \"Dirty\" trick: when there are repeats, modifies pp's position to that of \n   * least repeater of pp (needed when due to holes repeaters' positions are \"back\").\n   */\n  private int advanceRepeats(PhrasePositions pp, int end) throws IOException {\n    int repeatsEnd = end;\n    if (pp.position > repeatsEnd) {\n      repeatsEnd = pp.position;\n    }\n    if (!hasRepeats) {\n      return repeatsEnd;\n    }\n    int tpPos = tpPos(pp);\n    for (PhrasePositions pp2=pp.nextRepeating; pp2!=null; pp2=pp2.nextRepeating) {\n      while (tpPos(pp2) <= tpPos) {\n        if (!pp2.nextPosition()) {\n          return Integer.MIN_VALUE;\n        }\n      }\n      tpPos = tpPos(pp2);\n      if (pp2.position > repeatsEnd) {\n        repeatsEnd = pp2.position;\n      }\n      // \"dirty\" trick: with holes, given a pp, its repeating pp2 might have smaller position.\n      // so in order to have the right \"start\" in matchLength computation we fake pp.position.\n      // this relies on pp.nextPosition() not using pp.position.\n      if (pp2.position < pp.position) { \n        pp.position = pp2.position;     \n      }\n    }\n    return repeatsEnd;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2eaa5d4d2618a012373ae4574ebb6563933aa9f6","date":1331337973,"type":4,"author":"Doron Cohen","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#advanceRepeats(PhrasePositions,int).mjava","sourceNew":null,"sourceOld":"  /**\n   * Advance repeating pps of an input (non-repeating) pp.\n   * Return a modified 'end' in case pp or its repeats exceeds original 'end'.\n   * \"Dirty\" trick: when there are repeats, modifies pp's position to that of \n   * least repeater of pp (needed when due to holes repeaters' positions are \"back\").\n   */\n  private int advanceRepeats(PhrasePositions pp, int end) throws IOException {\n    int repeatsEnd = end;\n    if (pp.position > repeatsEnd) {\n      repeatsEnd = pp.position;\n    }\n    if (!hasRepeats) {\n      return repeatsEnd;\n    }\n    int tpPos = tpPos(pp);\n    for (PhrasePositions pp2=pp.nextRepeating; pp2!=null; pp2=pp2.nextRepeating) {\n      while (tpPos(pp2) <= tpPos) {\n        if (!pp2.nextPosition()) {\n          return Integer.MIN_VALUE;\n        }\n      }\n      tpPos = tpPos(pp2);\n      if (pp2.position > repeatsEnd) {\n        repeatsEnd = pp2.position;\n      }\n      // \"dirty\" trick: with holes, given a pp, its repeating pp2 might have smaller position.\n      // so in order to have the right \"start\" in matchLength computation we fake pp.position.\n      // this relies on pp.nextPosition() not using pp.position.\n      if (pp2.position < pp.position) { \n        pp.position = pp2.position;     \n      }\n    }\n    return repeatsEnd;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":4,"author":"Ryan McKinley","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer#advanceRepeats(PhrasePositions,int).mjava","sourceNew":null,"sourceOld":"  /**\n   * Advance repeating pps of an input (non-repeating) pp.\n   * Return a modified 'end' in case pp or its repeats exceeds original 'end'.\n   * \"Dirty\" trick: when there are repeats, modifies pp's position to that of \n   * least repeater of pp (needed when due to holes repeaters' positions are \"back\").\n   */\n  private int advanceRepeats(PhrasePositions pp, int end) throws IOException {\n    int repeatsEnd = end;\n    if (pp.position > repeatsEnd) {\n      repeatsEnd = pp.position;\n    }\n    if (!hasRepeats) {\n      return repeatsEnd;\n    }\n    int tpPos = tpPos(pp);\n    for (PhrasePositions pp2=pp.nextRepeating; pp2!=null; pp2=pp2.nextRepeating) {\n      while (tpPos(pp2) <= tpPos) {\n        if (!pp2.nextPosition()) {\n          return Integer.MIN_VALUE;\n        }\n      }\n      tpPos = tpPos(pp2);\n      if (pp2.position > repeatsEnd) {\n        repeatsEnd = pp2.position;\n      }\n      // \"dirty\" trick: with holes, given a pp, its repeating pp2 might have smaller position.\n      // so in order to have the right \"start\" in matchLength computation we fake pp.position.\n      // this relies on pp.nextPosition() not using pp.position.\n      if (pp2.position < pp.position) { \n        pp.position = pp2.position;     \n      }\n    }\n    return repeatsEnd;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","2eaa5d4d2618a012373ae4574ebb6563933aa9f6"],"2eaa5d4d2618a012373ae4574ebb6563933aa9f6":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2eaa5d4d2618a012373ae4574ebb6563933aa9f6"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"2eaa5d4d2618a012373ae4574ebb6563933aa9f6":["38e3b736c7ca086d61b7dbb841c905ee115490da","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["38e3b736c7ca086d61b7dbb841c905ee115490da","2eaa5d4d2618a012373ae4574ebb6563933aa9f6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}