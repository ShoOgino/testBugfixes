{"path":"solr/core/src/java/org/apache/solr/util/hll/HLL#addRaw(long).mjava","commits":[{"id":"6d8714f9ceaaff94f0968d1c2d037978c3fde569","date":1437042727,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/HLL#addRaw(long).mjava","pathOld":"/dev/null","sourceNew":"    // ========================================================================\n    // Add\n    /**\n     * Adds <code>rawValue</code> directly to the HLL.\n     *\n     * @param  rawValue the value to be added. It is very important that this\n     *         value <em>already be hashed</em> with a strong (but not\n     *         necessarily cryptographic) hash function. For instance, the\n     *         Murmur3 implementation in\n     *         <a href=\"http://guava-libraries.googlecode.com/git/guava/src/com/google/common/hash/Murmur3_128HashFunction.java\">\n     *         Google's Guava</a> library is an excellent hash function for this\n     *         purpose and, for seeds greater than zero, matches the output\n     *         of the hash provided in the PostgreSQL implementation.\n     */\n    public void addRaw(final long rawValue) {\n        switch(type) {\n            case EMPTY: {\n                // NOTE:  EMPTY type is always promoted on #addRaw()\n                if(explicitThreshold > 0) {\n                    initializeStorage(HLLType.EXPLICIT);\n                    explicitStorage.add(rawValue);\n                } else if(!sparseOff) {\n                    initializeStorage(HLLType.SPARSE);\n                    addRawSparseProbabilistic(rawValue);\n                } else {\n                    initializeStorage(HLLType.FULL);\n                    addRawProbabilistic(rawValue);\n                }\n                return;\n            }\n            case EXPLICIT: {\n                explicitStorage.add(rawValue);\n\n                // promotion, if necessary\n                if(explicitStorage.size() > explicitThreshold) {\n                    if(!sparseOff) {\n                        initializeStorage(HLLType.SPARSE);\n                        for (LongCursor c : explicitStorage) {\n                            addRawSparseProbabilistic(c.value);\n                        }\n                    } else {\n                        initializeStorage(HLLType.FULL);\n                        for (LongCursor c : explicitStorage) {\n                            addRawProbabilistic(c.value);\n                        }\n                    }\n                    explicitStorage = null;\n                }\n                return;\n            }\n            case SPARSE: {\n                addRawSparseProbabilistic(rawValue);\n\n                // promotion, if necessary\n                if(sparseProbabilisticStorage.size() > sparseThreshold) {\n                    initializeStorage(HLLType.FULL);\n                    for(IntByteCursor c : sparseProbabilisticStorage) {\n                        final int registerIndex = c.key;\n                        final byte registerValue = c.value;\n                        probabilisticStorage.setMaxRegister(registerIndex, registerValue);\n                    }\n                    sparseProbabilisticStorage = null;\n                }\n                return;\n            }\n            case FULL:\n                addRawProbabilistic(rawValue);\n                return;\n            default:\n                throw new RuntimeException(\"Unsupported HLL type \" + type);\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b5ee4c66244bdfcc4796a114519d47701b2c026","date":1437132013,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/HLL#addRaw(long).mjava","pathOld":"/dev/null","sourceNew":"    // ========================================================================\n    // Add\n    /**\n     * Adds <code>rawValue</code> directly to the HLL.\n     *\n     * @param  rawValue the value to be added. It is very important that this\n     *         value <em>already be hashed</em> with a strong (but not\n     *         necessarily cryptographic) hash function. For instance, the\n     *         Murmur3 implementation in\n     *         <a href=\"http://guava-libraries.googlecode.com/git/guava/src/com/google/common/hash/Murmur3_128HashFunction.java\">\n     *         Google's Guava</a> library is an excellent hash function for this\n     *         purpose and, for seeds greater than zero, matches the output\n     *         of the hash provided in the PostgreSQL implementation.\n     */\n    public void addRaw(final long rawValue) {\n        switch(type) {\n            case EMPTY: {\n                // NOTE:  EMPTY type is always promoted on #addRaw()\n                if(explicitThreshold > 0) {\n                    initializeStorage(HLLType.EXPLICIT);\n                    explicitStorage.add(rawValue);\n                } else if(!sparseOff) {\n                    initializeStorage(HLLType.SPARSE);\n                    addRawSparseProbabilistic(rawValue);\n                } else {\n                    initializeStorage(HLLType.FULL);\n                    addRawProbabilistic(rawValue);\n                }\n                return;\n            }\n            case EXPLICIT: {\n                explicitStorage.add(rawValue);\n\n                // promotion, if necessary\n                if(explicitStorage.size() > explicitThreshold) {\n                    if(!sparseOff) {\n                        initializeStorage(HLLType.SPARSE);\n                        for (LongCursor c : explicitStorage) {\n                            addRawSparseProbabilistic(c.value);\n                        }\n                    } else {\n                        initializeStorage(HLLType.FULL);\n                        for (LongCursor c : explicitStorage) {\n                            addRawProbabilistic(c.value);\n                        }\n                    }\n                    explicitStorage = null;\n                }\n                return;\n            }\n            case SPARSE: {\n                addRawSparseProbabilistic(rawValue);\n\n                // promotion, if necessary\n                if(sparseProbabilisticStorage.size() > sparseThreshold) {\n                    initializeStorage(HLLType.FULL);\n                    for(IntByteCursor c : sparseProbabilisticStorage) {\n                        final int registerIndex = c.key;\n                        final byte registerValue = c.value;\n                        probabilisticStorage.setMaxRegister(registerIndex, registerValue);\n                    }\n                    sparseProbabilisticStorage = null;\n                }\n                return;\n            }\n            case FULL:\n                addRawProbabilistic(rawValue);\n                return;\n            default:\n                throw new RuntimeException(\"Unsupported HLL type \" + type);\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3b5ee4c66244bdfcc4796a114519d47701b2c026"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b5ee4c66244bdfcc4796a114519d47701b2c026","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}