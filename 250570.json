{"path":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","commits":[{"id":"ea469eab8fd0f3032f4fcde1c644a721e8309d3b","date":1320301582,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","sourceNew":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator();\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator();\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","sourceOld":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator();\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator();\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea12b2546032c4f36b75a21b68c0b64334e31e88","date":1321433791,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","sourceNew":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    ensureOpen();\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator();\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator();\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","sourceOld":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator();\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator();\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","sourceNew":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    ensureOpen();\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator(null);\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator(null);\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","sourceOld":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    ensureOpen();\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator();\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator();\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"872cff1d3a554e0cd64014cd97f88d3002b0f491","date":1323024658,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","sourceNew":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    ensureOpen();\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator(null);\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator(null);\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde, false);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","sourceOld":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    ensureOpen();\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator(null);\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator(null);\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b65b350ca9588f9fc76ce7d6804160d06c45ff42","date":1323026297,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","sourceNew":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    ensureOpen();\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator(null);\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator(null);\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde, false);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","sourceOld":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    ensureOpen();\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator(null);\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator(null);\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e26e3b5080bfb6fcabdc46d0072efe441de1a21b","date":1329396896,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","sourceNew":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    ensureOpen();\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator(null);\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = DirectoryReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator(null);\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde, false);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","sourceOld":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    ensureOpen();\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator(null);\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator(null);\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde, false);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","bugFix":["89f15687f60bd49cd3d9de427e85c17fd9397d61"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","sourceNew":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    ensureOpen();\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator(null);\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = DirectoryReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator(null);\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde, false);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","sourceOld":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    ensureOpen();\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator(null);\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = DirectoryReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator(null);\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde, false);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ea12b2546032c4f36b75a21b68c0b64334e31e88":["ea469eab8fd0f3032f4fcde1c644a721e8309d3b"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["e26e3b5080bfb6fcabdc46d0072efe441de1a21b"],"ea469eab8fd0f3032f4fcde1c644a721e8309d3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b65b350ca9588f9fc76ce7d6804160d06c45ff42":["3cc749c053615f5871f3b95715fe292f34e70a53","872cff1d3a554e0cd64014cd97f88d3002b0f491"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc749c053615f5871f3b95715fe292f34e70a53":["ea12b2546032c4f36b75a21b68c0b64334e31e88"],"872cff1d3a554e0cd64014cd97f88d3002b0f491":["3cc749c053615f5871f3b95715fe292f34e70a53"],"e26e3b5080bfb6fcabdc46d0072efe441de1a21b":["872cff1d3a554e0cd64014cd97f88d3002b0f491"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"ea12b2546032c4f36b75a21b68c0b64334e31e88":["3cc749c053615f5871f3b95715fe292f34e70a53"],"ea469eab8fd0f3032f4fcde1c644a721e8309d3b":["ea12b2546032c4f36b75a21b68c0b64334e31e88"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b65b350ca9588f9fc76ce7d6804160d06c45ff42":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ea469eab8fd0f3032f4fcde1c644a721e8309d3b"],"3cc749c053615f5871f3b95715fe292f34e70a53":["b65b350ca9588f9fc76ce7d6804160d06c45ff42","872cff1d3a554e0cd64014cd97f88d3002b0f491"],"872cff1d3a554e0cd64014cd97f88d3002b0f491":["b65b350ca9588f9fc76ce7d6804160d06c45ff42","e26e3b5080bfb6fcabdc46d0072efe441de1a21b"],"e26e3b5080bfb6fcabdc46d0072efe441de1a21b":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b65b350ca9588f9fc76ce7d6804160d06c45ff42","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}