{"path":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","commits":[{"id":"6d6338c87060be5f66757a94945975f3bbd377a9","date":1189278234,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param name the unique name of the core (null is accepted)\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    this.name = checkName(name);\n    this.solrConfig = config;\n    // compatibility code with pre-solr215-patch in case some custom code relies on SolrConfig.config existence.\n    if (this.name == null) SolrConfig.config = config;\n    if (dataDir ==null)\n      dataDir = solrConfig.get(\"dataDir\",solrConfig.getInstanceDir()+\"data\");\n\n    if (schema==null)\n      this.schema = new IndexSchema(config, \"schema.xml\");\n    else\n      this.schema = schema;\n    \n      this.dataDir = dataDir;\n    if (name == null)\n      this.index_path = dataDir + \"/index\";\n    else\n      this.index_path = dataDir  + \"/index-\" + name;\n\n    log.info(\"Opening new SolrCore at \" + solrConfig.getInstanceDir() + \", dataDir=\"+dataDir + \", indexPath=\" + index_path);\n    \n    booleanQueryMaxClauseCount();\n    this.maxWarmingSearchers = solrConfig.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      parseListeners();\n\n      initIndex();\n      \n      initWriters();\n      \n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n\n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n    highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n              solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    // register this core\n    synchronized(cores) {\n      SolrCore previous = cores.get(name);\n      if (previous != null) {\n        previous.close();\n      }\n      cores.put(name, this);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7","date":1189312484,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param name the unique name of the core (null is accepted)\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    this.name = checkName(name);\n    this.solrConfig = config;\n    // compatibility code with pre-solr215-patch in case some custom code relies on SolrConfig.config existence.\n    if (this.name == null) SolrConfig.config = config;\n    if (dataDir ==null)\n      dataDir = solrConfig.get(\"dataDir\",solrConfig.getInstanceDir()+\"data\");\n\n    if (schema==null)\n      this.schema = new IndexSchema(config, \"schema.xml\");\n    else\n      this.schema = schema;\n    \n    this.dataDir = dataDir;\n    if (name == null)\n      this.index_path = dataDir + \"/index\";\n    else\n      this.index_path = dataDir  + \"/index-\" + name;\n\n    log.info(\"Opening new SolrCore at \" + solrConfig.getInstanceDir() + \", dataDir=\"+dataDir + \", indexPath=\" + index_path);\n    \n    booleanQueryMaxClauseCount();\n    this.maxWarmingSearchers = solrConfig.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n    parseListeners();\n\n    initIndex();\n    \n    initWriters();\n    \n    // Processors initialized before the handlers\n    updateProcessors = loadUpdateProcessors();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    // TODO? could select the highlighter implementation\n    highlighter = new SolrHighlighter();\n    highlighter.initalize( solrConfig );\n    \n    try {\n      // Open the searcher *before* the handler so we don't end up opening\n      // one in the middle.\n      getSearcher(false,false,null);\n\n      updateHandler = createUpdateHandler(\n            solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n      );\n\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    // register this core\n    synchronized(cores) {\n      SolrCore previous = cores.get(name);\n      if (previous != null) {\n        previous.close();\n      }\n      cores.put(name, this);\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param name the unique name of the core (null is accepted)\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    this.name = checkName(name);\n    this.solrConfig = config;\n    // compatibility code with pre-solr215-patch in case some custom code relies on SolrConfig.config existence.\n    if (this.name == null) SolrConfig.config = config;\n    if (dataDir ==null)\n      dataDir = solrConfig.get(\"dataDir\",solrConfig.getInstanceDir()+\"data\");\n\n    if (schema==null)\n      this.schema = new IndexSchema(config, \"schema.xml\");\n    else\n      this.schema = schema;\n    \n      this.dataDir = dataDir;\n    if (name == null)\n      this.index_path = dataDir + \"/index\";\n    else\n      this.index_path = dataDir  + \"/index-\" + name;\n\n    log.info(\"Opening new SolrCore at \" + solrConfig.getInstanceDir() + \", dataDir=\"+dataDir + \", indexPath=\" + index_path);\n    \n    booleanQueryMaxClauseCount();\n    this.maxWarmingSearchers = solrConfig.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      parseListeners();\n\n      initIndex();\n      \n      initWriters();\n      \n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n\n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n    highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n\n        updateHandler = createUpdateHandler(\n              solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    // register this core\n    synchronized(cores) {\n      SolrCore previous = cores.get(name);\n      if (previous != null) {\n        previous.close();\n      }\n      cores.put(name, this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fe3c163c8df3fb3e4248c30f8ae8034cc786589","date":1189317596,"type":4,"author":"Ryan McKinley","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","sourceNew":null,"sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param name the unique name of the core (null is accepted)\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    this.name = checkName(name);\n    this.solrConfig = config;\n    // compatibility code with pre-solr215-patch in case some custom code relies on SolrConfig.config existence.\n    if (this.name == null) SolrConfig.config = config;\n    if (dataDir ==null)\n      dataDir = solrConfig.get(\"dataDir\",solrConfig.getInstanceDir()+\"data\");\n\n    if (schema==null)\n      this.schema = new IndexSchema(config, \"schema.xml\");\n    else\n      this.schema = schema;\n    \n    this.dataDir = dataDir;\n    if (name == null)\n      this.index_path = dataDir + \"/index\";\n    else\n      this.index_path = dataDir  + \"/index-\" + name;\n\n    log.info(\"Opening new SolrCore at \" + solrConfig.getInstanceDir() + \", dataDir=\"+dataDir + \", indexPath=\" + index_path);\n    \n    booleanQueryMaxClauseCount();\n    this.maxWarmingSearchers = solrConfig.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n    parseListeners();\n\n    initIndex();\n    \n    initWriters();\n    \n    // Processors initialized before the handlers\n    updateProcessors = loadUpdateProcessors();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n    // TODO? could select the highlighter implementation\n    highlighter = new SolrHighlighter();\n    highlighter.initalize( solrConfig );\n    \n    try {\n      // Open the searcher *before* the handler so we don't end up opening\n      // one in the middle.\n      getSearcher(false,false,null);\n\n      updateHandler = createUpdateHandler(\n            solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n      );\n\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    // register this core\n    synchronized(cores) {\n      SolrCore previous = cores.get(name);\n      if (previous != null) {\n        previous.close();\n      }\n      cores.put(name, this);\n    }\n  }\n\n","bugFix":null,"bugIntro":["47d1e1ec1b59a7953de3afd6b310bac5c76017f4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"048361614025800e582bfc7a7b0329dc6fd6a95e","date":1196999392,"type":1,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.name = name;\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir ==null) {\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"[\"+name+\"] Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, \"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n    \n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir ==null) {\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, \"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n      this.solrConfig = config;\n\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68f896937cecbd003415d5fd0616436eaa1fb336","date":1197098869,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.name = name;\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir ==null) {\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"[\"+name+\"] Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, \"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.name = name;\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir ==null) {\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"[\"+name+\"] Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, \"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b46f0ccfb6b63c307ea901d48482630e3689042c","date":1198805331,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir ==null) {\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data\");\n      }\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, \"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.name = name;\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir ==null) {\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data\");\n      }\n\n      log.info(\"[\"+name+\"] Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, \"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1833c624d42634c14299628650e0a70626349a71","date":1204207883,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir ==null) {\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data\");\n      }\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, \"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir ==null) {\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data\");\n      }\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, \"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6dc6ab6902f8f70ae43365947ccf44c25986906d","date":1204603577,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n      else\n        dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir ==null) {\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data\");\n      }\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, \"schema.xml\");\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.index_path = dataDir + \"/\" + \"index\";\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"69328f2c55f60766682d6b63430c74e48e508447","date":1204837311,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n      else\n        dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"303b28b90016c2de1b5870759794476dbf4fd6ce","date":1206052767,"type":3,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      // TODO? could select the highlighter implementation\n      highlighter = new SolrHighlighter();\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af9eaa0ea32c76c51438440b908d759cb5413fa9","date":1208429088,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n      \n      // execute firstSearcher event\n      //TODO: It may not always be the case that this is the only time the first searcher event needs to fire.\n      doFirstSearcherEvent(getSearcher().get());\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n    }\n  }\n\n","bugFix":null,"bugIntro":["47d1e1ec1b59a7953de3afd6b310bac5c76017f4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c","date":1208435858,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n\n      // execute firstSearcher event\n      //TODO: It may not always be the case that this is the only time the first searcher event needs to fire.\n      doFirstSearcherEvent(getSearcher().get());\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n      \n      // execute firstSearcher event\n      //TODO: It may not always be the case that this is the only time the first searcher event needs to fire.\n      doFirstSearcherEvent(getSearcher().get());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"47d1e1ec1b59a7953de3afd6b310bac5c76017f4","date":1209829568,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n      \n      try {\n        // Open the searcher *before* the handler so we don't end up opening\n        // one in the middle.\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n      } \n      catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // Finally tell anyone who wants to know\n      loader.inform( loader );\n      loader.inform( this );\n\n      // execute firstSearcher event\n      //TODO: It may not always be the case that this is the only time the first searcher event needs to fire.\n      doFirstSearcherEvent(getSearcher().get());\n    }\n  }\n\n","bugFix":["fcf52a7da226d8d3756cc8bf9f3ae1f39952b014","af9eaa0ea32c76c51438440b908d759cb5413fa9","8fe3c163c8df3fb3e4248c30f8ae8034cc786589"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5151046764fb8d9662e02d6c5381b2adb69f96d","date":1216394962,"type":5,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {\n    synchronized (SolrCore.class) {\n      coreDescriptor = cd;\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {\n    synchronized (SolrCore.class) {\n      // this is for backward compatibility (and also the reason\n      // the sync block is needed)\n      instance = this;   // set singleton\n      this.setName( name );\n      SolrResourceLoader loader = config.getResourceLoader();\n      if (dataDir == null)\n        dataDir = config.get(\"dataDir\",loader.getInstanceDir()+\"data/\");\n\n      dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n      log.info(logid+\"Opening new SolrCore at \" + loader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n      if (schema==null) {\n        schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n      }\n\n      this.schema = schema;\n      this.dataDir = dataDir;\n      this.solrConfig = config;\n      this.startTime = System.currentTimeMillis();\n      this.maxWarmingSearchers = config.getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n      booleanQueryMaxClauseCount();\n  \n      parseListeners();\n  \n      initIndex();\n      \n      initWriters();\n      initQParsers();\n      initValueSourceParsers();\n      \n      this.searchComponents = loadSearchComponents( config );\n\n      // Processors initialized before the handlers\n      updateProcessors = loadUpdateProcessors();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig( solrConfig );\n  \n      highlighter = createHighlighter(\n    \t\t  solrConfig.get(\"highlighting/@class\", DefaultSolrHighlighter.class.getName())\n      );\n      highlighter.initalize( solrConfig );\n\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      try {\n        // cause the executor to stall so firstSearcher events won't fire\n        // until after inform() has been called for all components.\n        // searchExecutor must be single-threaded for this to work\n        searcherExecutor.submit(new Callable() {\n          public Object call() throws Exception {\n            latch.await();\n            return null;\n          }\n        });\n\n        // Open the searcher *before* the update handler so we don't end up opening\n        // one in the middle.\n        // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n        getSearcher(false,false,null);\n  \n        updateHandler = createUpdateHandler(\n          solrConfig.get(\"updateHandler/@class\", DirectUpdateHandler.class.getName())\n        );\n\n\n        // Finally tell anyone who wants to know\n        loader.inform( loader );\n        loader.inform( this );\n\n      } catch (IOException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      } finally {\n        // allow firstSearcher events to fire\n        latch.countDown();\n      }\n    } // end synchronized\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6d6338c87060be5f66757a94945975f3bbd377a9":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"d5151046764fb8d9662e02d6c5381b2adb69f96d":["47d1e1ec1b59a7953de3afd6b310bac5c76017f4"],"6dc6ab6902f8f70ae43365947ccf44c25986906d":["1833c624d42634c14299628650e0a70626349a71"],"8fe3c163c8df3fb3e4248c30f8ae8034cc786589":["94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"69328f2c55f60766682d6b63430c74e48e508447":["6dc6ab6902f8f70ae43365947ccf44c25986906d"],"af9eaa0ea32c76c51438440b908d759cb5413fa9":["303b28b90016c2de1b5870759794476dbf4fd6ce"],"b46f0ccfb6b63c307ea901d48482630e3689042c":["68f896937cecbd003415d5fd0616436eaa1fb336"],"303b28b90016c2de1b5870759794476dbf4fd6ce":["69328f2c55f60766682d6b63430c74e48e508447"],"ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c":["af9eaa0ea32c76c51438440b908d759cb5413fa9"],"048361614025800e582bfc7a7b0329dc6fd6a95e":["8fe3c163c8df3fb3e4248c30f8ae8034cc786589"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68f896937cecbd003415d5fd0616436eaa1fb336":["048361614025800e582bfc7a7b0329dc6fd6a95e"],"47d1e1ec1b59a7953de3afd6b310bac5c76017f4":["ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c"],"1833c624d42634c14299628650e0a70626349a71":["b46f0ccfb6b63c307ea901d48482630e3689042c"],"94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7":["6d6338c87060be5f66757a94945975f3bbd377a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"6d6338c87060be5f66757a94945975f3bbd377a9":["94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7"],"d5151046764fb8d9662e02d6c5381b2adb69f96d":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["6d6338c87060be5f66757a94945975f3bbd377a9"],"6dc6ab6902f8f70ae43365947ccf44c25986906d":["69328f2c55f60766682d6b63430c74e48e508447"],"8fe3c163c8df3fb3e4248c30f8ae8034cc786589":["048361614025800e582bfc7a7b0329dc6fd6a95e"],"69328f2c55f60766682d6b63430c74e48e508447":["303b28b90016c2de1b5870759794476dbf4fd6ce"],"af9eaa0ea32c76c51438440b908d759cb5413fa9":["ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c"],"b46f0ccfb6b63c307ea901d48482630e3689042c":["1833c624d42634c14299628650e0a70626349a71"],"303b28b90016c2de1b5870759794476dbf4fd6ce":["af9eaa0ea32c76c51438440b908d759cb5413fa9"],"ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c":["47d1e1ec1b59a7953de3afd6b310bac5c76017f4"],"048361614025800e582bfc7a7b0329dc6fd6a95e":["68f896937cecbd003415d5fd0616436eaa1fb336"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"68f896937cecbd003415d5fd0616436eaa1fb336":["b46f0ccfb6b63c307ea901d48482630e3689042c"],"47d1e1ec1b59a7953de3afd6b310bac5c76017f4":["d5151046764fb8d9662e02d6c5381b2adb69f96d"],"1833c624d42634c14299628650e0a70626349a71":["6dc6ab6902f8f70ae43365947ccf44c25986906d"],"94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7":["8fe3c163c8df3fb3e4248c30f8ae8034cc786589"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d5151046764fb8d9662e02d6c5381b2adb69f96d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}