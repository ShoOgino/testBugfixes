{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<SortedIntSet.FrozenIntSet>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<SortedIntSet.FrozenIntSet,State>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<SortedIntSet.FrozenIntSet>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<SortedIntSet.FrozenIntSet,State>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2df02448d26cde9cb7149b3eacb1c2352972839f","date":1335143056,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<SortedIntSet.FrozenIntSet>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<SortedIntSet.FrozenIntSet,State>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<SortedIntSet.FrozenIntSet>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<SortedIntSet.FrozenIntSet,State>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<SortedIntSet.FrozenIntSet>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<SortedIntSet.FrozenIntSet,State>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f4ef381bf0c2d618c6db830d3dd668c6901c05a","date":1402592253,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","sourceNew":null,"sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static Automaton determinize(Automaton a) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    int newStateUpto = 0;\n    int[] newStatesArray = new int[5];\n    newStatesArray[newStateUpto] = 0;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["2df02448d26cde9cb7149b3eacb1c2352972839f"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2df02448d26cde9cb7149b3eacb1c2352972839f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7f4ef381bf0c2d618c6db830d3dd668c6901c05a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"5c84485629d80d203608e8975a1139de9933cc38":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","7f4ef381bf0c2d618c6db830d3dd668c6901c05a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5c84485629d80d203608e8975a1139de9933cc38"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7f4ef381bf0c2d618c6db830d3dd668c6901c05a","5c84485629d80d203608e8975a1139de9933cc38"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["2df02448d26cde9cb7149b3eacb1c2352972839f"],"2df02448d26cde9cb7149b3eacb1c2352972839f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7f4ef381bf0c2d618c6db830d3dd668c6901c05a":["5c84485629d80d203608e8975a1139de9933cc38"],"5c84485629d80d203608e8975a1139de9933cc38":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}