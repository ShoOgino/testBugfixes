{"path":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String,UUID).mjava","commits":[{"id":"1fc1087854af39c9b439f47d913fd3ac1d85ac5c","date":1599523122,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String,UUID).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @throws SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   * @see SolrCore#close()\n   */\n  public SolrCore getCore(String name, UUID id) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true, id);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded. Here's where moving the\n    // waitAddPendingCoreOps to createFromDescriptor would introduce a race condition.\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"938fe8fd4d30ae70161827366f67c2382985e446","date":1600050178,"type":4,"author":"noblepaul","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String,UUID).mjava","sourceNew":null,"sourceOld":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @throws SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   * @see SolrCore#close()\n   */\n  public SolrCore getCore(String name, UUID id) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true, id);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded. Here's where moving the\n    // waitAddPendingCoreOps to createFromDescriptor would introduce a race condition.\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e451e492cce54699988e2ce0aea55e3ff170cb0","date":1600305561,"type":0,"author":"noblepaul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#getCore(String,UUID).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Gets a core by name and increase its refcount.\n   *\n   * @param name the core name\n   * @return the core if found, null if a SolrCore by this name does not exist\n   * @throws SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n   * @see SolrCore#close()\n   */\n  public SolrCore getCore(String name, UUID id) {\n\n    // Do this in two phases since we don't want to lock access to the cores over a load.\n    SolrCore core = solrCores.getCoreFromAnyList(name, true, id);\n\n    // If a core is loaded, we're done just return it.\n    if (core != null) {\n      return core;\n    }\n\n    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n\n    // if there was an error initializing this core, throw a 500\n    // error with the details for clients attempting to access it.\n    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n    if (null != loadFailure) {\n      throw new SolrCoreInitializationException(name, loadFailure.exception);\n    }\n    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n    // TestLazyCores\n    if (desc == null || zkSys.getZkController() != null) return null;\n\n    // This will put an entry in pending core ops if the core isn't loaded. Here's where moving the\n    // waitAddPendingCoreOps to createFromDescriptor would introduce a race condition.\n    core = solrCores.waitAddPendingCoreOps(name);\n\n    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n    // the wait as a consequence of shutting down.\n    try {\n      if (core == null) {\n        if (zkSys.getZkController() != null) {\n          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n        }\n        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n      }\n      core.open();\n    } finally {\n      solrCores.removeFromPendingOps(name);\n    }\n\n    return core;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1fc1087854af39c9b439f47d913fd3ac1d85ac5c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"938fe8fd4d30ae70161827366f67c2382985e446":["1fc1087854af39c9b439f47d913fd3ac1d85ac5c"],"0e451e492cce54699988e2ce0aea55e3ff170cb0":["938fe8fd4d30ae70161827366f67c2382985e446"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0e451e492cce54699988e2ce0aea55e3ff170cb0"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1fc1087854af39c9b439f47d913fd3ac1d85ac5c"],"1fc1087854af39c9b439f47d913fd3ac1d85ac5c":["938fe8fd4d30ae70161827366f67c2382985e446"],"938fe8fd4d30ae70161827366f67c2382985e446":["0e451e492cce54699988e2ce0aea55e3ff170cb0"],"0e451e492cce54699988e2ce0aea55e3ff170cb0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}