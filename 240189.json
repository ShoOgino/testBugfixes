{"path":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","commits":[{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","pathOld":"/dev/null","sourceNew":"  private void docValuesUpdateTest() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((int) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = random().nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, random()); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, random()); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (random().nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["08807474e48bac766abf10459c3c25e4a5e4d7cc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","pathOld":"/dev/null","sourceNew":"  private void docValuesUpdateTest() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((int) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = random().nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, random()); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, random()); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (random().nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5048c558f8802f1689d38203111379406b171418","date":1486467652,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","sourceNew":"  private void docValuesUpdateTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((int) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = random().nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, random()); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, random()); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (random().nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n  }\n\n","sourceOld":"  private void docValuesUpdateTest() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((int) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = random().nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, random()); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, random()); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (random().nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461","date":1487476295,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","sourceNew":"  private void docValuesUpdateTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((int) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","sourceOld":"  private void docValuesUpdateTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((int) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = random().nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, random()); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, random()); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (random().nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4958642f967bfbd6f083ddf50f141bcde89b9ec1","date":1489572234,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","sourceNew":"  private void docValuesUpdateTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((Integer) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","sourceOld":"  private void docValuesUpdateTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((int) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bca83a747f8e297ee4412c0d18bdd3a98c09df3b","date":1489651910,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","sourceNew":"  private void docValuesUpdateTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((Integer) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","sourceOld":"  private void docValuesUpdateTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((int) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"839de995c26f3afed8712b3fca3d2def58c0e8a3","date":1489976334,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","sourceNew":"  private void docValuesUpdateTest() throws Exception {\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((Integer) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","sourceOld":"  private void docValuesUpdateTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((Integer) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","sourceNew":"  private void docValuesUpdateTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((Integer) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","sourceOld":"  private void docValuesUpdateTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((int) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"983c22877c7901fb6640270165b9ec8d5b629adf","date":1490280012,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","sourceNew":"  private void docValuesUpdateTest() throws Exception {\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((Integer) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","sourceOld":"  private void docValuesUpdateTest() throws Exception {\n    clearIndex();\n    commit();\n\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((Integer) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02dfe884e3d07476d8a6a68ed8b3671d9258a4b0","date":1490749780,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","sourceNew":"  private void docValuesUpdateTest() throws Exception {\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    int numDocs = atLeast(100);\n    if (onlyLeaderIndexes) numDocs = TestUtil.nextInt(random(), 10, 50);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((Integer) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","sourceOld":"  private void docValuesUpdateTest() throws Exception {\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((Integer) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08807474e48bac766abf10459c3c25e4a5e4d7cc","date":1490873946,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","sourceNew":"  private void docValuesUpdateTest() throws Exception {\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    int numDocs = atLeast(100);\n    if (onlyLeaderIndexes) numDocs = TestUtil.nextInt(random(), 10, 50);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((Integer) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","sourceOld":"  private void docValuesUpdateTest() throws Exception {\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    final int numDocs = atLeast(100);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((Integer) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","bugFix":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9c14208216474e190dcec6327766fd749b8aa965","date":1563380115,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","sourceNew":"  private void docValuesUpdateTest() throws Exception {\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    int numDocs = atLeast(100);\n    if (onlyLeaderIndexes) numDocs = TestUtil.nextInt(random(), 10, 50);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Number> valuesList = new ArrayList<>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((Integer) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, \"inplace_updatable_float\", valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, \"inplace_updatable_float\", valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = (float)valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, \"inplace_updatable_float\", valuesList);\n\n    log.info(\"Updating the documents with new field...\");\n    Collections.shuffle(ids, r);\n    for (int id : ids) {\n      final int val = random().nextInt(20);\n      valuesList.set(id, val);\n      index(\"id\", id, \"inplace_updatable_int\", map((random().nextBoolean()?\"inc\": \"set\"), val));\n    }\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n        (\"inplace_for_first_field_update\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_int:[* TO *]\",\n            \"fq\", \"id:[0 TO *]\"),\n            params),\n            luceneDocids, \"inplace_updatable_int\", valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","sourceOld":"  private void docValuesUpdateTest() throws Exception {\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    int numDocs = atLeast(100);\n    if (onlyLeaderIndexes) numDocs = TestUtil.nextInt(random(), 10, 50);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Float> valuesList = new ArrayList<Float>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((Integer) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#docValuesUpdateTest().mjava","sourceNew":"  private void docValuesUpdateTest() throws Exception {\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    int numDocs = atLeast(100);\n    if (onlyLeaderIndexes) numDocs = TestUtil.nextInt(random(), 10, 50);\n    log.info(\"Trying num docs = {}\", numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Number> valuesList = new ArrayList<>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((Integer) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: {}\", results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, \"inplace_updatable_float\", valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: {}\", valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, \"inplace_updatable_float\", valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = (float)valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, \"inplace_updatable_float\", valuesList);\n\n    log.info(\"Updating the documents with new field...\");\n    Collections.shuffle(ids, r);\n    for (int id : ids) {\n      final int val = random().nextInt(20);\n      valuesList.set(id, val);\n      index(\"id\", id, \"inplace_updatable_int\", map((random().nextBoolean()?\"inc\": \"set\"), val));\n    }\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n        (\"inplace_for_first_field_update\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_int:[* TO *]\",\n            \"fq\", \"id:[0 TO *]\"),\n            params),\n            luceneDocids, \"inplace_updatable_int\", valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","sourceOld":"  private void docValuesUpdateTest() throws Exception {\n    // number of docs we're testing (0 <= id), index may contain additional random docs (id < 0)\n    int numDocs = atLeast(100);\n    if (onlyLeaderIndexes) numDocs = TestUtil.nextInt(random(), 10, 50);\n    log.info(\"Trying num docs = \" + numDocs);\n    final List<Integer> ids = new ArrayList<Integer>(numDocs);\n    for (int id = 0; id < numDocs; id++) {\n      ids.add(id);\n    }\n      \n    buildRandomIndex(101.0F, ids);\n    \n    List<Integer> luceneDocids = new ArrayList<>(numDocs);\n    List<Number> valuesList = new ArrayList<>(numDocs);\n    SolrParams params = params(\"q\", \"id:[0 TO *]\", \"fl\", \"*,[docid]\", \"rows\", String.valueOf(numDocs), \"sort\", \"id_i asc\");\n    SolrDocumentList results = LEADER.query(params).getResults();\n    assertEquals(numDocs, results.size());\n    for (SolrDocument doc : results) {\n      luceneDocids.add((Integer) doc.get(\"[docid]\"));\n      valuesList.add((Float) doc.get(\"inplace_updatable_float\"));\n    }\n    log.info(\"Initial results: \"+results);\n    \n    // before we do any atomic operations, sanity check our results against all clients\n    assertDocIdsAndValuesAgainstAllClients(\"sanitycheck\", params, luceneDocids, \"inplace_updatable_float\", valuesList);\n\n    // now we're going to overwrite the value for all of our testing docs\n    // giving them a value between -5 and +5\n    for (int id : ids) {\n      // NOTE: in rare cases, this may be setting the value to 0, on a doc that\n      // already had an init value of 0 -- which is an interesting edge case, so we don't exclude it\n      final float multiplier = r.nextBoolean() ? -5.0F : 5.0F;\n      final float value = r.nextFloat() * multiplier;\n      assert -5.0F <= value && value <= 5.0F;\n      valuesList.set(id, value);\n    }\n    log.info(\"inplace_updatable_float: \" + valuesList);\n    \n    // update doc w/ set\n    Collections.shuffle(ids, r); // so updates aren't applied in index order\n    for (int id : ids) {\n      index(\"id\", id, \"inplace_updatable_float\", map(\"set\", valuesList.get(id)));\n    }\n\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n      (\"set\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_float:[-5.0 TO 5.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, \"inplace_updatable_float\", valuesList);\n      \n    // update doc, w/increment\n    log.info(\"Updating the documents...\");\n    Collections.shuffle(ids, r); // so updates aren't applied in the same order as our 'set'\n    for (int id : ids) {\n      // all incremements will use some value X such that 20 < abs(X)\n      // thus ensuring that after all incrememnts are done, there should be\n      // 0 test docs matching the query inplace_updatable_float:[-10 TO 10]\n      final float inc = (r.nextBoolean() ? -1.0F : 1.0F) * (r.nextFloat() + (float)atLeast(20));\n      assert 20 < Math.abs(inc);\n      final float value = (float)valuesList.get(id) + inc;\n      assert value < -10 || 10 < value;\n        \n      valuesList.set(id, value);\n      index(\"id\", id, \"inplace_updatable_float\", map(\"inc\", inc));\n    }\n    commit();\n    \n    assertDocIdsAndValuesAgainstAllClients\n      (\"inc\", SolrParams.wrapDefaults(params(\"q\", \"-inplace_updatable_float:[-10.0 TO 10.0]\",\n                                             \"fq\", \"id:[0 TO *]\"),\n                                      // existing sort & fl that we want...\n                                      params),\n       luceneDocids, \"inplace_updatable_float\", valuesList);\n\n    log.info(\"Updating the documents with new field...\");\n    Collections.shuffle(ids, r);\n    for (int id : ids) {\n      final int val = random().nextInt(20);\n      valuesList.set(id, val);\n      index(\"id\", id, \"inplace_updatable_int\", map((random().nextBoolean()?\"inc\": \"set\"), val));\n    }\n    commit();\n\n    assertDocIdsAndValuesAgainstAllClients\n        (\"inplace_for_first_field_update\", SolrParams.wrapDefaults(params(\"q\", \"inplace_updatable_int:[* TO *]\",\n            \"fq\", \"id:[0 TO *]\"),\n            params),\n            luceneDocids, \"inplace_updatable_int\", valuesList);\n    log.info(\"docValuesUpdateTest: This test passed fine...\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4958642f967bfbd6f083ddf50f141bcde89b9ec1":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","415bbbe7da8065dd3c477bdc3c703c6425622998"],"02dfe884e3d07476d8a6a68ed8b3671d9258a4b0":["839de995c26f3afed8712b3fca3d2def58c0e8a3"],"5048c558f8802f1689d38203111379406b171418":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["9c14208216474e190dcec6327766fd749b8aa965"],"08807474e48bac766abf10459c3c25e4a5e4d7cc":["983c22877c7901fb6640270165b9ec8d5b629adf"],"983c22877c7901fb6640270165b9ec8d5b629adf":["ab68488225b6a6c357dda72ed11dedca9914a192"],"839de995c26f3afed8712b3fca3d2def58c0e8a3":["4958642f967bfbd6f083ddf50f141bcde89b9ec1"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["5048c558f8802f1689d38203111379406b171418"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9c14208216474e190dcec6327766fd749b8aa965":["02dfe884e3d07476d8a6a68ed8b3671d9258a4b0"],"bca83a747f8e297ee4412c0d18bdd3a98c09df3b":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"ab68488225b6a6c357dda72ed11dedca9914a192":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461","bca83a747f8e297ee4412c0d18bdd3a98c09df3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","5048c558f8802f1689d38203111379406b171418"],"4958642f967bfbd6f083ddf50f141bcde89b9ec1":["839de995c26f3afed8712b3fca3d2def58c0e8a3"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"02dfe884e3d07476d8a6a68ed8b3671d9258a4b0":["9c14208216474e190dcec6327766fd749b8aa965"],"5048c558f8802f1689d38203111379406b171418":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"08807474e48bac766abf10459c3c25e4a5e4d7cc":[],"983c22877c7901fb6640270165b9ec8d5b629adf":["08807474e48bac766abf10459c3c25e4a5e4d7cc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["4958642f967bfbd6f083ddf50f141bcde89b9ec1","bca83a747f8e297ee4412c0d18bdd3a98c09df3b","ab68488225b6a6c357dda72ed11dedca9914a192"],"839de995c26f3afed8712b3fca3d2def58c0e8a3":["02dfe884e3d07476d8a6a68ed8b3671d9258a4b0"],"9c14208216474e190dcec6327766fd749b8aa965":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"bca83a747f8e297ee4412c0d18bdd3a98c09df3b":["ab68488225b6a6c357dda72ed11dedca9914a192"],"ab68488225b6a6c357dda72ed11dedca9914a192":["983c22877c7901fb6640270165b9ec8d5b629adf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","08807474e48bac766abf10459c3c25e4a5e4d7cc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}