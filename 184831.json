{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","commits":[{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super( props==null ? props = new HashMap<String,Object>() : props);\n    this.znodeVersion = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super( props==null ? props = new HashMap<String,Object>() : props);\n    this.version = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super( props==null ? props = new HashMap<String,Object>() : props);\n    this.version = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super( props==null ? props = new HashMap<String,Object>() : props);\n    this.znodeVersion = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<String,Object>() : props);\n    this.znodeVersion = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    Object replicationFactorObject = (Object) props.get(ZkStateReader.REPLICATION_FACTOR);\n    if (replicationFactorObject != null) {\n      this.replicationFactor = Integer.parseInt(replicationFactorObject.toString());\n    } else {\n      this.replicationFactor = null;\n    }\n    Object maxShardsPerNodeObject = (Object) props.get(ZkStateReader.MAX_SHARDS_PER_NODE);\n    if (maxShardsPerNodeObject != null) {\n      this.maxShardsPerNode = Integer.parseInt(maxShardsPerNodeObject.toString());\n    } else {\n      this.maxShardsPerNode = null;\n    }\n    Object autoAddReplicasObject = (Object) props.get(ZkStateReader.AUTO_ADD_REPLICAS);\n    if (autoAddReplicasObject != null) {\n      this.autoAddReplicas = Boolean.parseBoolean(autoAddReplicasObject.toString());\n    } else {\n      this.autoAddReplicas = false;\n    }\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super( props==null ? props = new HashMap<String,Object>() : props);\n    this.version = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    Object replicationFactorObject = (Object) props.get(ZkStateReader.REPLICATION_FACTOR);\n    if (replicationFactorObject != null) {\n      this.replicationFactor = Integer.parseInt(replicationFactorObject.toString());\n    } else {\n      this.replicationFactor = null;\n    }\n    Object maxShardsPerNodeObject = (Object) props.get(ZkStateReader.MAX_SHARDS_PER_NODE);\n    if (maxShardsPerNodeObject != null) {\n      this.maxShardsPerNode = Integer.parseInt(maxShardsPerNodeObject.toString());\n    } else {\n      this.maxShardsPerNode = null;\n    }\n    Object autoAddReplicasObject = (Object) props.get(ZkStateReader.AUTO_ADD_REPLICAS);\n    if (autoAddReplicasObject != null) {\n      this.autoAddReplicas = Boolean.parseBoolean(autoAddReplicasObject.toString());\n    } else {\n      this.autoAddReplicas = false;\n    }\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","date":1427866967,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<String,Object>() : props);\n    this.znodeVersion = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    Object replicationFactorObject = (Object) props.get(ZkStateReader.REPLICATION_FACTOR);\n    if (replicationFactorObject != null) {\n      this.replicationFactor = Integer.parseInt(replicationFactorObject.toString());\n    } else {\n      this.replicationFactor = null;\n    }\n    Object maxShardsPerNodeObject = (Object) props.get(ZkStateReader.MAX_SHARDS_PER_NODE);\n    if (maxShardsPerNodeObject != null) {\n      this.maxShardsPerNode = Integer.parseInt(maxShardsPerNodeObject.toString());\n    } else {\n      this.maxShardsPerNode = null;\n    }\n    Object autoAddReplicasObject = (Object) props.get(ZkStateReader.AUTO_ADD_REPLICAS);\n    if (autoAddReplicasObject != null) {\n      this.autoAddReplicas = Boolean.parseBoolean(autoAddReplicasObject.toString());\n    } else {\n      this.autoAddReplicas = false;\n    }\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE)\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<String,Object>() : props);\n    this.znodeVersion = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    Object replicationFactorObject = (Object) props.get(ZkStateReader.REPLICATION_FACTOR);\n    if (replicationFactorObject != null) {\n      this.replicationFactor = Integer.parseInt(replicationFactorObject.toString());\n    } else {\n      this.replicationFactor = null;\n    }\n    Object maxShardsPerNodeObject = (Object) props.get(ZkStateReader.MAX_SHARDS_PER_NODE);\n    if (maxShardsPerNodeObject != null) {\n      this.maxShardsPerNode = Integer.parseInt(maxShardsPerNodeObject.toString());\n    } else {\n      this.maxShardsPerNode = null;\n    }\n    Object autoAddReplicasObject = (Object) props.get(ZkStateReader.AUTO_ADD_REPLICAS);\n    if (autoAddReplicasObject != null) {\n      this.autoAddReplicas = Boolean.parseBoolean(autoAddReplicasObject.toString());\n    } else {\n      this.autoAddReplicas = false;\n    }\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":["08e881a61d5dffc3a403f2892fb747aca86bab0c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0c924d4069ef5a5bc479a493befe0121aada6896","date":1427901860,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<String,Object>() : props);\n    this.znodeVersion = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    Object replicationFactorObject = (Object) props.get(ZkStateReader.REPLICATION_FACTOR);\n    if (replicationFactorObject != null) {\n      this.replicationFactor = Integer.parseInt(replicationFactorObject.toString());\n    } else {\n      this.replicationFactor = null;\n    }\n    Object maxShardsPerNodeObject = (Object) props.get(ZkStateReader.MAX_SHARDS_PER_NODE);\n    if (maxShardsPerNodeObject != null) {\n      this.maxShardsPerNode = Integer.parseInt(maxShardsPerNodeObject.toString());\n    } else {\n      this.maxShardsPerNode = null;\n    }\n    Object autoAddReplicasObject = (Object) props.get(ZkStateReader.AUTO_ADD_REPLICAS);\n    if (autoAddReplicasObject != null) {\n      this.autoAddReplicas = Boolean.parseBoolean(autoAddReplicasObject.toString());\n    } else {\n      this.autoAddReplicas = false;\n    }\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE)\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<String,Object>() : props);\n    this.znodeVersion = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    Object replicationFactorObject = (Object) props.get(ZkStateReader.REPLICATION_FACTOR);\n    if (replicationFactorObject != null) {\n      this.replicationFactor = Integer.parseInt(replicationFactorObject.toString());\n    } else {\n      this.replicationFactor = null;\n    }\n    Object maxShardsPerNodeObject = (Object) props.get(ZkStateReader.MAX_SHARDS_PER_NODE);\n    if (maxShardsPerNodeObject != null) {\n      this.maxShardsPerNode = Integer.parseInt(maxShardsPerNodeObject.toString());\n    } else {\n      this.maxShardsPerNode = null;\n    }\n    Object autoAddReplicasObject = (Object) props.get(ZkStateReader.AUTO_ADD_REPLICAS);\n    if (autoAddReplicasObject != null) {\n      this.autoAddReplicas = Boolean.parseBoolean(autoAddReplicasObject.toString());\n    } else {\n      this.autoAddReplicas = false;\n    }\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState().equals(Slice.ACTIVE))\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8","date":1431966199,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<String,Object>() : props);\n    this.znodeVersion = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE)\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<String,Object>() : props);\n    this.znodeVersion = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    Object replicationFactorObject = (Object) props.get(ZkStateReader.REPLICATION_FACTOR);\n    if (replicationFactorObject != null) {\n      this.replicationFactor = Integer.parseInt(replicationFactorObject.toString());\n    } else {\n      this.replicationFactor = null;\n    }\n    Object maxShardsPerNodeObject = (Object) props.get(ZkStateReader.MAX_SHARDS_PER_NODE);\n    if (maxShardsPerNodeObject != null) {\n      this.maxShardsPerNode = Integer.parseInt(maxShardsPerNodeObject.toString());\n    } else {\n      this.maxShardsPerNode = null;\n    }\n    Object autoAddReplicasObject = (Object) props.get(ZkStateReader.AUTO_ADD_REPLICAS);\n    if (autoAddReplicasObject != null) {\n      this.autoAddReplicas = Boolean.parseBoolean(autoAddReplicasObject.toString());\n    } else {\n      this.autoAddReplicas = false;\n    }\n\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE)\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3eaf6502248c2d6fadda33bfd9feb21a08caade","date":1462405599,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE)\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<String,Object>() : props);\n    this.znodeVersion = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE)\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6175144692be4091fc67973ba8a04b866ae7eca","date":1462405702,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE)\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE)\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73450c0955930295d34703e7ddbfc6973b7a121a","date":1462431925,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE)\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<String,Object>() : props);\n    this.znodeVersion = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE)\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc08f02757dd10637b16a5c65eaaef839a91a9a","date":1462455462,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE)\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<String,Object>() : props);\n    this.znodeVersion = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE)\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE)\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<String,Object>() : props);\n    this.znodeVersion = zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE)\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08e881a61d5dffc3a403f2892fb747aca86bab0c","date":1479199723,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE)\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"21019aa828c8c9b0153877543a8b3f200bf2ca19","date":1479224450,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE)\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    Integer realtimeReplicas = (Integer) verifyProp(props, REALTIME_REPLICAS);\n    this.realtimeReplicas = realtimeReplicas == null ? -1 : realtimeReplicas;\n    if (this.realtimeReplicas != -1 && this.realtimeReplicas != 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid realtimeReplicas must be 1 or -1, found:\" + this.realtimeReplicas);\n    }\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    Integer realtimeReplicas = (Integer) verifyProp(props, REALTIME_REPLICAS);\n    this.realtimeReplicas = realtimeReplicas == null ? -1 : realtimeReplicas;\n    if (this.realtimeReplicas != -1 && this.realtimeReplicas != 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid realtimeReplicas must be 1 or -1, found:\" + this.realtimeReplicas);\n    }\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4958642f967bfbd6f083ddf50f141bcde89b9ec1","date":1489572234,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    Integer realtimeReplicas = (Integer) verifyProp(props, REALTIME_REPLICAS);\n    this.realtimeReplicas = realtimeReplicas == null ? -1 : realtimeReplicas;\n    if (this.realtimeReplicas != -1 && this.realtimeReplicas != 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid realtimeReplicas must be 1 or -1, found:\" + this.realtimeReplicas);\n    }\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    Integer realtimeReplicas = (Integer) verifyProp(props, REALTIME_REPLICAS);\n    this.realtimeReplicas = realtimeReplicas == null ? -1 : realtimeReplicas;\n    if (this.realtimeReplicas != -1 && this.realtimeReplicas != 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid realtimeReplicas must be 1 or -1, found:\" + this.realtimeReplicas);\n    }\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bca83a747f8e297ee4412c0d18bdd3a98c09df3b","date":1489651910,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    Integer realtimeReplicas = (Integer) verifyProp(props, REALTIME_REPLICAS);\n    this.realtimeReplicas = realtimeReplicas == null ? -1 : realtimeReplicas;\n    if (this.realtimeReplicas != -1 && this.realtimeReplicas != 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid realtimeReplicas must be 1 or -1, found:\" + this.realtimeReplicas);\n    }\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    Integer realtimeReplicas = (Integer) verifyProp(props, REALTIME_REPLICAS);\n    this.realtimeReplicas = realtimeReplicas == null ? -1 : realtimeReplicas;\n    if (this.realtimeReplicas != -1 && this.realtimeReplicas != 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid realtimeReplicas must be 1 or -1, found:\" + this.realtimeReplicas);\n    }\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    Integer realtimeReplicas = (Integer) verifyProp(props, REALTIME_REPLICAS);\n    this.realtimeReplicas = realtimeReplicas == null ? -1 : realtimeReplicas;\n    if (this.realtimeReplicas != -1 && this.realtimeReplicas != 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid realtimeReplicas must be 1 or -1, found:\" + this.realtimeReplicas);\n    }\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? false : autoAddReplicas;\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    Integer realtimeReplicas = (Integer) verifyProp(props, REALTIME_REPLICAS);\n    this.realtimeReplicas = realtimeReplicas == null ? -1 : realtimeReplicas;\n    if (this.realtimeReplicas != -1 && this.realtimeReplicas != 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid realtimeReplicas must be 1 or -1, found:\" + this.realtimeReplicas);\n    }\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d118ef896fa37a21d831f7e8ffcb8c44b9afc13b","date":1496237185,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74aea047dff7f7c38a2d766827bd20d356f98c6a","date":1496721416,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    Integer realtimeReplicas = (Integer) verifyProp(props, REALTIME_REPLICAS);\n    this.realtimeReplicas = realtimeReplicas == null ? -1 : realtimeReplicas;\n    if (this.realtimeReplicas != -1 && this.realtimeReplicas != 1) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid realtimeReplicas must be 1 or -1, found:\" + this.realtimeReplicas);\n    }\n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c84df91ca6a2e8d6f26f185663112546a27f6b45","date":1536077760,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.activeSlicesArr = activeSlices.values().toArray(new Slice[activeSlices.size()]);\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS, 0);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS, 0);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS, 0);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.activeSlicesArr = activeSlices.values().toArray(new Slice[activeSlices.size()]);\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.activeSlicesArr = activeSlices.values().toArray(new Slice[activeSlices.size()]);\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":["61c45e99cf6676da48f19d7511c73712ad39402b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e","date":1551802585,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS, 0);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS, 0);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS, 0);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    Boolean readOnly = (Boolean) verifyProp(props, READ_ONLY);\n    this.readOnly = readOnly == null ? Boolean.FALSE : readOnly;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.activeSlicesArr = activeSlices.values().toArray(new Slice[activeSlices.size()]);\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS, 0);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS, 0);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS, 0);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.activeSlicesArr = activeSlices.values().toArray(new Slice[activeSlices.size()]);\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":5,"author":"murblanc","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection#DocCollection(String,Map[String,Slice],Map[String,Object],DocRouter,int,String).mjava","sourceNew":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   * @param zkVersion The version of the Collection node in Zookeeper (used for conditional updates).\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS, 0);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS, 0);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS, 0);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    Boolean readOnly = (Boolean) verifyProp(props, READ_ONLY);\n    this.readOnly = readOnly == null ? Boolean.FALSE : readOnly;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.activeSlicesArr = activeSlices.values().toArray(new Slice[activeSlices.size()]);\n    this.router = router;\n    assert name != null && slices != null;\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the collection\n   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.\n   * @param props  The properties of the slice.  This is used directly and a copy is not made.\n   */\n  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {\n    super(props==null ? props = new HashMap<>() : props);\n    // -1 means any version in ZK CAS, so we choose Integer.MAX_VALUE instead to avoid accidental overwrites\n    this.znodeVersion = zkVersion == -1 ? Integer.MAX_VALUE : zkVersion;\n    this.name = name;\n\n    this.slices = slices;\n    this.activeSlices = new HashMap<>();\n    this.nodeNameLeaderReplicas = new HashMap<>();\n    this.nodeNameReplicas = new HashMap<>();\n    this.replicationFactor = (Integer) verifyProp(props, REPLICATION_FACTOR);\n    this.numNrtReplicas = (Integer) verifyProp(props, NRT_REPLICAS, 0);\n    this.numTlogReplicas = (Integer) verifyProp(props, TLOG_REPLICAS, 0);\n    this.numPullReplicas = (Integer) verifyProp(props, PULL_REPLICAS, 0);\n    this.maxShardsPerNode = (Integer) verifyProp(props, MAX_SHARDS_PER_NODE);\n    Boolean autoAddReplicas = (Boolean) verifyProp(props, AUTO_ADD_REPLICAS);\n    this.policy = (String) props.get(Policy.POLICY);\n    this.autoAddReplicas = autoAddReplicas == null ? Boolean.FALSE : autoAddReplicas;\n    Boolean readOnly = (Boolean) verifyProp(props, READ_ONLY);\n    this.readOnly = readOnly == null ? Boolean.FALSE : readOnly;\n    \n    verifyProp(props, RULE);\n    verifyProp(props, SNITCH);\n    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();\n\n    while (iter.hasNext()) {\n      Map.Entry<String, Slice> slice = iter.next();\n      if (slice.getValue().getState() == Slice.State.ACTIVE) {\n        this.activeSlices.put(slice.getKey(), slice.getValue());\n      }\n      for (Replica replica : slice.getValue()) {\n        addNodeNameReplica(replica);\n      }\n    }\n    this.activeSlicesArr = activeSlices.values().toArray(new Slice[activeSlices.size()]);\n    this.router = router;\n    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;\n    assert name != null && slices != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c84df91ca6a2e8d6f26f185663112546a27f6b45":["28288370235ed02234a64753cdbf0c6ec096304a"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["c84df91ca6a2e8d6f26f185663112546a27f6b45"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["9279b175e5e66258442d2123a50f052219a9cc1b"],"0c924d4069ef5a5bc479a493befe0121aada6896":["9279b175e5e66258442d2123a50f052219a9cc1b","d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"08e881a61d5dffc3a403f2892fb747aca86bab0c":["73450c0955930295d34703e7ddbfc6973b7a121a"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["ab68488225b6a6c357dda72ed11dedca9914a192","74aea047dff7f7c38a2d766827bd20d356f98c6a"],"b6175144692be4091fc67973ba8a04b866ae7eca":["e3eaf6502248c2d6fadda33bfd9feb21a08caade"],"74aea047dff7f7c38a2d766827bd20d356f98c6a":["61c45e99cf6676da48f19d7511c73712ad39402b","d118ef896fa37a21d831f7e8ffcb8c44b9afc13b"],"07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8","73450c0955930295d34703e7ddbfc6973b7a121a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bca83a747f8e297ee4412c0d18bdd3a98c09df3b":["f996f8177b9204bdc92f7164460c6cefad9ac99a"],"be320990bdc77e643388fa801e75017f19289c42":["08e881a61d5dffc3a403f2892fb747aca86bab0c"],"ab68488225b6a6c357dda72ed11dedca9914a192":["08e881a61d5dffc3a403f2892fb747aca86bab0c","bca83a747f8e297ee4412c0d18bdd3a98c09df3b"],"4958642f967bfbd6f083ddf50f141bcde89b9ec1":["be320990bdc77e643388fa801e75017f19289c42"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e"],"61c45e99cf6676da48f19d7511c73712ad39402b":["4958642f967bfbd6f083ddf50f141bcde89b9ec1"],"73450c0955930295d34703e7ddbfc6973b7a121a":["07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8","b6175144692be4091fc67973ba8a04b866ae7eca"],"e3eaf6502248c2d6fadda33bfd9feb21a08caade":["07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8","73450c0955930295d34703e7ddbfc6973b7a121a"],"21019aa828c8c9b0153877543a8b3f200bf2ca19":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","08e881a61d5dffc3a403f2892fb747aca86bab0c"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"d118ef896fa37a21d831f7e8ffcb8c44b9afc13b":["61c45e99cf6676da48f19d7511c73712ad39402b"],"28288370235ed02234a64753cdbf0c6ec096304a":["61c45e99cf6676da48f19d7511c73712ad39402b","74aea047dff7f7c38a2d766827bd20d356f98c6a"],"9279b175e5e66258442d2123a50f052219a9cc1b":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["08e881a61d5dffc3a403f2892fb747aca86bab0c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"]},"commit2Childs":{"c84df91ca6a2e8d6f26f185663112546a27f6b45":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["0c924d4069ef5a5bc479a493befe0121aada6896","07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8"],"0c924d4069ef5a5bc479a493befe0121aada6896":[],"08e881a61d5dffc3a403f2892fb747aca86bab0c":["be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192","21019aa828c8c9b0153877543a8b3f200bf2ca19","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"b6175144692be4091fc67973ba8a04b866ae7eca":["73450c0955930295d34703e7ddbfc6973b7a121a"],"74aea047dff7f7c38a2d766827bd20d356f98c6a":["e9017cf144952056066919f1ebc7897ff9bd71b1","28288370235ed02234a64753cdbf0c6ec096304a"],"07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","73450c0955930295d34703e7ddbfc6973b7a121a","e3eaf6502248c2d6fadda33bfd9feb21a08caade","7dc08f02757dd10637b16a5c65eaaef839a91a9a"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"bca83a747f8e297ee4412c0d18bdd3a98c09df3b":["ab68488225b6a6c357dda72ed11dedca9914a192"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"be320990bdc77e643388fa801e75017f19289c42":["4958642f967bfbd6f083ddf50f141bcde89b9ec1"],"4958642f967bfbd6f083ddf50f141bcde89b9ec1":["61c45e99cf6676da48f19d7511c73712ad39402b"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"61c45e99cf6676da48f19d7511c73712ad39402b":["74aea047dff7f7c38a2d766827bd20d356f98c6a","d118ef896fa37a21d831f7e8ffcb8c44b9afc13b","28288370235ed02234a64753cdbf0c6ec096304a"],"73450c0955930295d34703e7ddbfc6973b7a121a":["08e881a61d5dffc3a403f2892fb747aca86bab0c","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","7dc08f02757dd10637b16a5c65eaaef839a91a9a"],"e3eaf6502248c2d6fadda33bfd9feb21a08caade":["b6175144692be4091fc67973ba8a04b866ae7eca"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["21019aa828c8c9b0153877543a8b3f200bf2ca19"],"21019aa828c8c9b0153877543a8b3f200bf2ca19":[],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["9279b175e5e66258442d2123a50f052219a9cc1b"],"d118ef896fa37a21d831f7e8ffcb8c44b9afc13b":["74aea047dff7f7c38a2d766827bd20d356f98c6a"],"28288370235ed02234a64753cdbf0c6ec096304a":["c84df91ca6a2e8d6f26f185663112546a27f6b45"],"9279b175e5e66258442d2123a50f052219a9cc1b":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","0c924d4069ef5a5bc479a493befe0121aada6896"],"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["bca83a747f8e297ee4412c0d18bdd3a98c09df3b"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0c924d4069ef5a5bc479a493befe0121aada6896","e9017cf144952056066919f1ebc7897ff9bd71b1","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","21019aa828c8c9b0153877543a8b3f200bf2ca19","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}