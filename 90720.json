{"path":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","commits":[{"id":"aa2fc2eb37a1f19e90850f787d9e085950ebfa04","date":1291597075,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    ValuesField valField = new ValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n          valField.setInt(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          valField.setFloat(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        valField.setBytes(bytesRef, value);\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    ValuesField valField = new ValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n          valField.setInt(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          valField.setFloat(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        valField.setBytes(bytesRef, value);\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    ValuesField valField = new ValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n          valField.setInt(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          valField.setFloat(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        valField.setBytes(bytesRef, value);\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    ValuesField valField = new ValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n          valField.setInt(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          valField.setFloat(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        valField.setBytes(bytesRef, value);\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a465ec8e22527bb8add54f75551ee9557a56de25","date":1295309224,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new DocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    DocValuesField valField = new DocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n          valField.setInt(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          valField.setFloat(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    ValuesField valField = new ValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n          valField.setInt(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          valField.setFloat(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        valField.setBytes(bytesRef, value);\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":["fa0f44f887719e97183771e977cfc4bfb485b766","fa0f44f887719e97183771e977cfc4bfb485b766","fa0f44f887719e97183771e977cfc4bfb485b766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"85130289d2ed101fcc2d8798511c7c5b020ffab4","date":1297239859,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new DocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    DocValuesField valField = new DocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n        case FLOAT_64:\n          valField.setFloat(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new DocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    DocValuesField valField = new DocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n          valField.setInt(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          valField.setFloat(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"39d51e9acac1e629cffe47855e85dc6dedc4754d","date":1305711497,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new DocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    DocValuesField valField = new DocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n        case FLOAT_64:\n          valField.setFloat(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new DocValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    DocValuesField valField = new DocValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case INTS:\n          valField.setInt(i);\n          break;\n        case FLOAT_32:\n        case FLOAT_64:\n          valField.setFloat(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize(true);\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","date":1323449025,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    DocValuesField valField = new DocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    IndexDocValuesField valField = new IndexDocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d638301ad1cfcae567b681b893bc8781f0ee48a5","date":1323801546,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,ValueType,List[ValueType],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    DocValuesField valField = new DocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, ValueType value,\n      List<ValueType> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    IndexDocValuesField valField = new IndexDocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          ValueType val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    DocValuesField valField = new DocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    DocValuesField valField = new DocValuesField(value.name());\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case VAR_INTS:\n          valField.setInt((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setInt((short)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_32:\n          valField.setInt(i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_64:\n          valField.setInt((long)i, random.nextInt(10) != 0);\n          break;\n        case FIXED_INTS_8:\n          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);\n          break;\n        case FLOAT_32:\n          valField.setFloat(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setFloat(2.0d * i);\n          break;\n       \n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytes(bytesRef, value);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, StringField.TYPE_STORED));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random.nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"39d51e9acac1e629cffe47855e85dc6dedc4754d":["85130289d2ed101fcc2d8798511c7c5b020ffab4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["aa2fc2eb37a1f19e90850f787d9e085950ebfa04","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"85130289d2ed101fcc2d8798511c7c5b020ffab4":["a465ec8e22527bb8add54f75551ee9557a56de25"],"aa2fc2eb37a1f19e90850f787d9e085950ebfa04":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"a465ec8e22527bb8add54f75551ee9557a56de25":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"]},"commit2Childs":{"39d51e9acac1e629cffe47855e85dc6dedc4754d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","ab5cb6a74aefb78aa0569857970b9151dfe2e787","aa2fc2eb37a1f19e90850f787d9e085950ebfa04","d638301ad1cfcae567b681b893bc8781f0ee48a5"],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["a465ec8e22527bb8add54f75551ee9557a56de25"],"85130289d2ed101fcc2d8798511c7c5b020ffab4":["39d51e9acac1e629cffe47855e85dc6dedc4754d"],"aa2fc2eb37a1f19e90850f787d9e085950ebfa04":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"a465ec8e22527bb8add54f75551ee9557a56de25":["85130289d2ed101fcc2d8798511c7c5b020ffab4"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["39d51e9acac1e629cffe47855e85dc6dedc4754d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}