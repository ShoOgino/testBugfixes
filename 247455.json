{"path":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","commits":[{"id":"60b45f127b5537b5bf62181784ef28b52f4b6a08","date":1529595959,"type":0,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Test that the Tracking Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Nightly\n  @Test\n  public void testSliceRouting() throws Exception {\n    String configName = TimeRoutedAliasUpdateProcessorTest.configName + getTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias, new SolrInputDocument(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards);\n    waitCol(\"2017-10-24\", numShards);\n    waitCol(\"2017-10-25\", numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    try {\n      TrackingUpdateProcessorFactory.startRecording(getTestName());\n\n      // cause some collections to be created\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + getTestName());\n      assertUpdateResponse(add(alias, Arrays.asList(\n          sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n          sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n          sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\")),\n          params));\n    } finally {\n      TrackingUpdateProcessorFactory.stopRecording(getTestName());\n    }\n\n    try (CloudSolrClient cloudSolrClient = getCloudSolrClient(cluster)) {\n      ClusterStateProvider clusterStateProvider = cloudSolrClient.getClusterStateProvider();\n      clusterStateProvider.connect();\n      Set<String> leaders = getLeaderCoreNames(clusterStateProvider.getClusterState());\n      assertEquals(\"should have \" + 3 * numShards + \" leaders, \" + numShards + \" per collection\", 3 * numShards, leaders.size());\n\n      List<UpdateCommand> updateCommands = TrackingUpdateProcessorFactory.commandsForGroup(getTestName());\n      assertEquals(3, updateCommands.size());\n      for (UpdateCommand updateCommand : updateCommands) {\n        String node = (String) updateCommand.getReq().getContext().get(TrackingUpdateProcessorFactory.REQUEST_NODE);\n        assertTrue(\"Update was not routed to a leader (\" + node + \" not in list of leaders\" + leaders, leaders.contains(node));\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Test that the Tracking Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Nightly\n  @Test\n  public void testSliceRouting() throws Exception {\n    String configName = TimeRoutedAliasUpdateProcessorTest.configName + getTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias, new SolrInputDocument(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards);\n    waitCol(\"2017-10-24\", numShards);\n    waitCol(\"2017-10-25\", numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    try {\n      TrackingUpdateProcessorFactory.startRecording(getTestName());\n\n      // cause some collections to be created\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + getTestName());\n      assertUpdateResponse(add(alias, Arrays.asList(\n          sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n          sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n          sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\")),\n          params));\n    } finally {\n      TrackingUpdateProcessorFactory.stopRecording(getTestName());\n    }\n\n    try (CloudSolrClient cloudSolrClient = getCloudSolrClient(cluster)) {\n      ClusterStateProvider clusterStateProvider = cloudSolrClient.getClusterStateProvider();\n      clusterStateProvider.connect();\n      Set<String> leaders = getLeaderCoreNames(clusterStateProvider.getClusterState());\n      assertEquals(\"should have \" + 3 * numShards + \" leaders, \" + numShards + \" per collection\", 3 * numShards, leaders.size());\n\n      List<UpdateCommand> updateCommands = TrackingUpdateProcessorFactory.commandsForGroup(getTestName());\n      assertEquals(3, updateCommands.size());\n      for (UpdateCommand updateCommand : updateCommands) {\n        String node = (String) updateCommand.getReq().getContext().get(TrackingUpdateProcessorFactory.REQUEST_NODE);\n        assertTrue(\"Update was not routed to a leader (\" + node + \" not in list of leaders\" + leaders, leaders.contains(node));\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Test that the Tracking Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Nightly\n  @Test\n  public void testSliceRouting() throws Exception {\n    String configName = TimeRoutedAliasUpdateProcessorTest.configName + getTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias, new SolrInputDocument(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards);\n    waitCol(\"2017-10-24\", numShards);\n    waitCol(\"2017-10-25\", numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    try {\n      TrackingUpdateProcessorFactory.startRecording(getTestName());\n\n      // cause some collections to be created\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + getTestName());\n      assertUpdateResponse(add(alias, Arrays.asList(\n          sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n          sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n          sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\")),\n          params));\n    } finally {\n      TrackingUpdateProcessorFactory.stopRecording(getTestName());\n    }\n\n    try (CloudSolrClient cloudSolrClient = getCloudSolrClient(cluster)) {\n      ClusterStateProvider clusterStateProvider = cloudSolrClient.getClusterStateProvider();\n      clusterStateProvider.connect();\n      Set<String> leaders = getLeaderCoreNames(clusterStateProvider.getClusterState());\n      assertEquals(\"should have \" + 3 * numShards + \" leaders, \" + numShards + \" per collection\", 3 * numShards, leaders.size());\n\n      List<UpdateCommand> updateCommands = TrackingUpdateProcessorFactory.commandsForGroup(getTestName());\n      assertEquals(3, updateCommands.size());\n      for (UpdateCommand updateCommand : updateCommands) {\n        String node = (String) updateCommand.getReq().getContext().get(TrackingUpdateProcessorFactory.REQUEST_NODE);\n        assertTrue(\"Update was not routed to a leader (\" + node + \" not in list of leaders\" + leaders, leaders.contains(node));\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"849083f8095b1ffaff05a66e0b1e024617b9968d","date":1536291524,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","sourceNew":"  /**\n   * Test that the Tracking Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Test\n  @LogLevel(\"org.apache.solr.update.processor.TrackingUpdateProcessorFactory=DEBUG\")\n  public void testSliceRouting() throws Exception {\n    String configName = TimeRoutedAliasUpdateProcessorTest.configName + getTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias, new SolrInputDocument(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards);\n    waitCol(\"2017-10-24\", numShards);\n    waitCol(\"2017-10-25\", numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    final String trackGroupName = getTrackUpdatesGroupName();\n    final List<UpdateCommand> updateCommands;\n    try {\n      TrackingUpdateProcessorFactory.startRecording(trackGroupName);\n\n      // cause some collections to be created\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + getTestName());\n      assertUpdateResponse(add(alias, Arrays.asList(\n          sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n          sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n          sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\")),\n          params));\n    } finally {\n      updateCommands = TrackingUpdateProcessorFactory.stopRecording(trackGroupName);\n    }\n\n    try (CloudSolrClient cloudSolrClient = getCloudSolrClient(cluster)) {\n      ClusterStateProvider clusterStateProvider = cloudSolrClient.getClusterStateProvider();\n      clusterStateProvider.connect();\n      Set<String> leaders = getLeaderCoreNames(clusterStateProvider.getClusterState());\n      assertEquals(\"should have \" + 3 * numShards + \" leaders, \" + numShards + \" per collection\", 3 * numShards, leaders.size());\n\n      assertEquals(3, updateCommands.size());\n      for (UpdateCommand updateCommand : updateCommands) {\n        String node = (String) updateCommand.getReq().getContext().get(TrackingUpdateProcessorFactory.REQUEST_NODE);\n        assertTrue(\"Update was not routed to a leader (\" + node + \" not in list of leaders\" + leaders, leaders.contains(node));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Test that the Tracking Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Nightly\n  @Test\n  public void testSliceRouting() throws Exception {\n    String configName = TimeRoutedAliasUpdateProcessorTest.configName + getTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias, new SolrInputDocument(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards);\n    waitCol(\"2017-10-24\", numShards);\n    waitCol(\"2017-10-25\", numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    try {\n      TrackingUpdateProcessorFactory.startRecording(getTestName());\n\n      // cause some collections to be created\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + getTestName());\n      assertUpdateResponse(add(alias, Arrays.asList(\n          sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n          sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n          sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\")),\n          params));\n    } finally {\n      TrackingUpdateProcessorFactory.stopRecording(getTestName());\n    }\n\n    try (CloudSolrClient cloudSolrClient = getCloudSolrClient(cluster)) {\n      ClusterStateProvider clusterStateProvider = cloudSolrClient.getClusterStateProvider();\n      clusterStateProvider.connect();\n      Set<String> leaders = getLeaderCoreNames(clusterStateProvider.getClusterState());\n      assertEquals(\"should have \" + 3 * numShards + \" leaders, \" + numShards + \" per collection\", 3 * numShards, leaders.size());\n\n      List<UpdateCommand> updateCommands = TrackingUpdateProcessorFactory.commandsForGroup(getTestName());\n      assertEquals(3, updateCommands.size());\n      for (UpdateCommand updateCommand : updateCommands) {\n        String node = (String) updateCommand.getReq().getContext().get(TrackingUpdateProcessorFactory.REQUEST_NODE);\n        assertTrue(\"Update was not routed to a leader (\" + node + \" not in list of leaders\" + leaders, leaders.contains(node));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","sourceNew":"  /**\n   * Test that the Tracking Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Test\n  @LogLevel(\"org.apache.solr.update.processor.TrackingUpdateProcessorFactory=DEBUG\")\n  public void testSliceRouting() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias, new SolrInputDocument(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards);\n    waitCol(\"2017-10-24\", numShards);\n    waitCol(\"2017-10-25\", numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    final String trackGroupName = getTrackUpdatesGroupName();\n    final List<UpdateCommand> updateCommands;\n    try {\n      TrackingUpdateProcessorFactory.startRecording(trackGroupName);\n\n      // cause some collections to be created\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + trackGroupName);\n      assertUpdateResponse(add(alias, Arrays.asList(\n          sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n          sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n          sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\")),\n          params));\n    } finally {\n      updateCommands = TrackingUpdateProcessorFactory.stopRecording(trackGroupName);\n    }\n\n    try (CloudSolrClient cloudSolrClient = getCloudSolrClient(cluster)) {\n      ClusterStateProvider clusterStateProvider = cloudSolrClient.getClusterStateProvider();\n      clusterStateProvider.connect();\n      Set<String> leaders = getLeaderCoreNames(clusterStateProvider.getClusterState());\n      assertEquals(\"should have \" + 3 * numShards + \" leaders, \" + numShards + \" per collection\", 3 * numShards, leaders.size());\n\n      assertEquals(3, updateCommands.size());\n      for (UpdateCommand updateCommand : updateCommands) {\n        String node = (String) updateCommand.getReq().getContext().get(TrackingUpdateProcessorFactory.REQUEST_NODE);\n        assertTrue(\"Update was not routed to a leader (\" + node + \" not in list of leaders\" + leaders, leaders.contains(node));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Test that the Tracking Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Test\n  @LogLevel(\"org.apache.solr.update.processor.TrackingUpdateProcessorFactory=DEBUG\")\n  public void testSliceRouting() throws Exception {\n    String configName = TimeRoutedAliasUpdateProcessorTest.configName + getTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias, new SolrInputDocument(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards);\n    waitCol(\"2017-10-24\", numShards);\n    waitCol(\"2017-10-25\", numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    final String trackGroupName = getTrackUpdatesGroupName();\n    final List<UpdateCommand> updateCommands;\n    try {\n      TrackingUpdateProcessorFactory.startRecording(trackGroupName);\n\n      // cause some collections to be created\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + getTestName());\n      assertUpdateResponse(add(alias, Arrays.asList(\n          sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n          sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n          sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\")),\n          params));\n    } finally {\n      updateCommands = TrackingUpdateProcessorFactory.stopRecording(trackGroupName);\n    }\n\n    try (CloudSolrClient cloudSolrClient = getCloudSolrClient(cluster)) {\n      ClusterStateProvider clusterStateProvider = cloudSolrClient.getClusterStateProvider();\n      clusterStateProvider.connect();\n      Set<String> leaders = getLeaderCoreNames(clusterStateProvider.getClusterState());\n      assertEquals(\"should have \" + 3 * numShards + \" leaders, \" + numShards + \" per collection\", 3 * numShards, leaders.size());\n\n      assertEquals(3, updateCommands.size());\n      for (UpdateCommand updateCommand : updateCommands) {\n        String node = (String) updateCommand.getReq().getContext().get(TrackingUpdateProcessorFactory.REQUEST_NODE);\n        assertTrue(\"Update was not routed to a leader (\" + node + \" not in list of leaders\" + leaders, leaders.contains(node));\n      }\n    }\n  }\n\n","bugFix":["60b45f127b5537b5bf62181784ef28b52f4b6a08"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6","date":1547236077,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","sourceNew":"  /**\n   * Test that the Tracking Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Test\n  @LogLevel(\"org.apache.solr.update.processor.TrackingUpdateProcessorFactory=DEBUG\")\n  public void testSliceRouting() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias, new SolrInputDocument(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitColAndAlias(\"2017-10-23\", numShards, alias);\n    waitColAndAlias(\"2017-10-24\", numShards, alias);\n    waitColAndAlias(\"2017-10-25\", numShards, alias);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    final String trackGroupName = getTrackUpdatesGroupName();\n    final List<UpdateCommand> updateCommands;\n    try {\n      TrackingUpdateProcessorFactory.startRecording(trackGroupName);\n\n      // cause some collections to be created\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + trackGroupName);\n      assertUpdateResponse(add(alias, Arrays.asList(\n          sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n          sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n          sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\")),\n          params));\n    } finally {\n      updateCommands = TrackingUpdateProcessorFactory.stopRecording(trackGroupName);\n    }\n\n    try (CloudSolrClient cloudSolrClient = getCloudSolrClient(cluster)) {\n      ClusterStateProvider clusterStateProvider = cloudSolrClient.getClusterStateProvider();\n      clusterStateProvider.connect();\n      Set<String> leaders = getLeaderCoreNames(clusterStateProvider.getClusterState());\n      assertEquals(\"should have \" + 3 * numShards + \" leaders, \" + numShards + \" per collection\", 3 * numShards, leaders.size());\n\n      assertEquals(3, updateCommands.size());\n      for (UpdateCommand updateCommand : updateCommands) {\n        String node = (String) updateCommand.getReq().getContext().get(TrackingUpdateProcessorFactory.REQUEST_NODE);\n        assertTrue(\"Update was not routed to a leader (\" + node + \" not in list of leaders\" + leaders, leaders.contains(node));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Test that the Tracking Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Test\n  @LogLevel(\"org.apache.solr.update.processor.TrackingUpdateProcessorFactory=DEBUG\")\n  public void testSliceRouting() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias, new SolrInputDocument(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitCol(\"2017-10-23\", numShards);\n    waitCol(\"2017-10-24\", numShards);\n    waitCol(\"2017-10-25\", numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    final String trackGroupName = getTrackUpdatesGroupName();\n    final List<UpdateCommand> updateCommands;\n    try {\n      TrackingUpdateProcessorFactory.startRecording(trackGroupName);\n\n      // cause some collections to be created\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + trackGroupName);\n      assertUpdateResponse(add(alias, Arrays.asList(\n          sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n          sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n          sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\")),\n          params));\n    } finally {\n      updateCommands = TrackingUpdateProcessorFactory.stopRecording(trackGroupName);\n    }\n\n    try (CloudSolrClient cloudSolrClient = getCloudSolrClient(cluster)) {\n      ClusterStateProvider clusterStateProvider = cloudSolrClient.getClusterStateProvider();\n      clusterStateProvider.connect();\n      Set<String> leaders = getLeaderCoreNames(clusterStateProvider.getClusterState());\n      assertEquals(\"should have \" + 3 * numShards + \" leaders, \" + numShards + \" per collection\", 3 * numShards, leaders.size());\n\n      assertEquals(3, updateCommands.size());\n      for (UpdateCommand updateCommand : updateCommands) {\n        String node = (String) updateCommand.getReq().getContext().get(TrackingUpdateProcessorFactory.REQUEST_NODE);\n        assertTrue(\"Update was not routed to a leader (\" + node + \" not in list of leaders\" + leaders, leaders.contains(node));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b627755385655c7cd3fb296f17593658805cf4d5","date":1552455143,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","sourceNew":"  /**\n   * Test that the Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Test\n  @LogLevel(\"org.apache.solr.update.processor.TrackingUpdateProcessorFactory=DEBUG\")\n  public void testSliceRouting() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias, new SolrInputDocument(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitColAndAlias(alias, \"_\", \"2017-10-23\", numShards);\n    waitColAndAlias(alias, \"_\", \"2017-10-24\", numShards);\n    waitColAndAlias(alias, \"_\", \"2017-10-25\", numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    final String trackGroupName = getTrackUpdatesGroupName();\n    final List<UpdateCommand> updateCommands;\n    try {\n      TrackingUpdateProcessorFactory.startRecording(trackGroupName);\n\n      // cause some collections to be created\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + trackGroupName);\n      assertUpdateResponse(add(alias, Arrays.asList(\n          sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n          sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n          sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\")),\n          params));\n    } finally {\n      updateCommands = TrackingUpdateProcessorFactory.stopRecording(trackGroupName);\n    }\n\n    assertRouting(numShards, updateCommands);\n  }\n\n","sourceOld":"  /**\n   * Test that the Tracking Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Test\n  @LogLevel(\"org.apache.solr.update.processor.TrackingUpdateProcessorFactory=DEBUG\")\n  public void testSliceRouting() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", timeField,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias, new SolrInputDocument(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitColAndAlias(\"2017-10-23\", numShards, alias);\n    waitColAndAlias(\"2017-10-24\", numShards, alias);\n    waitColAndAlias(\"2017-10-25\", numShards, alias);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    final String trackGroupName = getTrackUpdatesGroupName();\n    final List<UpdateCommand> updateCommands;\n    try {\n      TrackingUpdateProcessorFactory.startRecording(trackGroupName);\n\n      // cause some collections to be created\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + trackGroupName);\n      assertUpdateResponse(add(alias, Arrays.asList(\n          sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n          sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n          sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\")),\n          params));\n    } finally {\n      updateCommands = TrackingUpdateProcessorFactory.stopRecording(trackGroupName);\n    }\n\n    try (CloudSolrClient cloudSolrClient = getCloudSolrClient(cluster)) {\n      ClusterStateProvider clusterStateProvider = cloudSolrClient.getClusterStateProvider();\n      clusterStateProvider.connect();\n      Set<String> leaders = getLeaderCoreNames(clusterStateProvider.getClusterState());\n      assertEquals(\"should have \" + 3 * numShards + \" leaders, \" + numShards + \" per collection\", 3 * numShards, leaders.size());\n\n      assertEquals(3, updateCommands.size());\n      for (UpdateCommand updateCommand : updateCommands) {\n        String node = (String) updateCommand.getReq().getContext().get(TrackingUpdateProcessorFactory.REQUEST_NODE);\n        assertTrue(\"Update was not routed to a leader (\" + node + \" not in list of leaders\" + leaders, leaders.contains(node));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"105e345cf3c0abed3cb6c109274a379cb2655adc","date":1561038472,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","sourceNew":"  /**\n   * Test that the Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Test\n  @LogLevel(\"org.apache.solr.update.processor.TrackingUpdateProcessorFactory=DEBUG\")\n  public void testSliceRouting() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias, new SolrInputDocument(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitColAndAlias(alias, TRA, \"2017-10-23\", numShards);\n    waitColAndAlias(alias, TRA, \"2017-10-24\", numShards);\n    waitColAndAlias(alias, TRA, \"2017-10-25\", numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    final String trackGroupName = getTrackUpdatesGroupName();\n    final List<UpdateCommand> updateCommands;\n    try {\n      TrackingUpdateProcessorFactory.startRecording(trackGroupName);\n\n      // cause some collections to be created\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + trackGroupName);\n      assertUpdateResponse(add(alias, Arrays.asList(\n          sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n          sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n          sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\")),\n          params));\n    } finally {\n      updateCommands = TrackingUpdateProcessorFactory.stopRecording(trackGroupName);\n    }\n\n    assertRouting(numShards, updateCommands);\n  }\n\n","sourceOld":"  /**\n   * Test that the Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Test\n  @LogLevel(\"org.apache.solr.update.processor.TrackingUpdateProcessorFactory=DEBUG\")\n  public void testSliceRouting() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias, new SolrInputDocument(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitColAndAlias(alias, \"_\", \"2017-10-23\", numShards);\n    waitColAndAlias(alias, \"_\", \"2017-10-24\", numShards);\n    waitColAndAlias(alias, \"_\", \"2017-10-25\", numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    final String trackGroupName = getTrackUpdatesGroupName();\n    final List<UpdateCommand> updateCommands;\n    try {\n      TrackingUpdateProcessorFactory.startRecording(trackGroupName);\n\n      // cause some collections to be created\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + trackGroupName);\n      assertUpdateResponse(add(alias, Arrays.asList(\n          sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n          sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n          sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\")),\n          params));\n    } finally {\n      updateCommands = TrackingUpdateProcessorFactory.stopRecording(trackGroupName);\n    }\n\n    assertRouting(numShards, updateCommands);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","sourceNew":"  /**\n   * Test that the Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Test\n  @LogLevel(\"org.apache.solr.update.processor.TrackingUpdateProcessorFactory=DEBUG\")\n  public void testSliceRouting() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias, new SolrInputDocument(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitColAndAlias(alias, TRA, \"2017-10-23\", numShards);\n    waitColAndAlias(alias, TRA, \"2017-10-24\", numShards);\n    waitColAndAlias(alias, TRA, \"2017-10-25\", numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    final String trackGroupName = getTrackUpdatesGroupName();\n    final List<UpdateCommand> updateCommands;\n    try {\n      TrackingUpdateProcessorFactory.startRecording(trackGroupName);\n\n      // cause some collections to be created\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + trackGroupName);\n      assertUpdateResponse(add(alias, Arrays.asList(\n          sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n          sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n          sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\")),\n          params));\n    } finally {\n      updateCommands = TrackingUpdateProcessorFactory.stopRecording(trackGroupName);\n    }\n\n    assertRouting(numShards, updateCommands);\n  }\n\n","sourceOld":"  /**\n   * Test that the Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Test\n  @LogLevel(\"org.apache.solr.update.processor.TrackingUpdateProcessorFactory=DEBUG\")\n  public void testSliceRouting() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(alias, new SolrInputDocument(\"id\",\"1\",\"timestamp_dt\", \"2017-10-25T00:00:00Z\")));\n    assertUpdateResponse(solrClient.commit(alias));\n\n    // wait for all the collections to exist...\n    waitColAndAlias(alias, TRA, \"2017-10-23\", numShards);\n    waitColAndAlias(alias, TRA, \"2017-10-24\", numShards);\n    waitColAndAlias(alias, TRA, \"2017-10-25\", numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    final String trackGroupName = getTrackUpdatesGroupName();\n    final List<UpdateCommand> updateCommands;\n    try {\n      TrackingUpdateProcessorFactory.startRecording(trackGroupName);\n\n      // cause some collections to be created\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + trackGroupName);\n      assertUpdateResponse(add(alias, Arrays.asList(\n          sdoc(\"id\", \"2\", \"timestamp_dt\", \"2017-10-24T00:00:00Z\"),\n          sdoc(\"id\", \"3\", \"timestamp_dt\", \"2017-10-25T00:00:00Z\"),\n          sdoc(\"id\", \"4\", \"timestamp_dt\", \"2017-10-23T00:00:00Z\")),\n          params));\n    } finally {\n      updateCommands = TrackingUpdateProcessorFactory.stopRecording(trackGroupName);\n    }\n\n    assertRouting(numShards, updateCommands);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"105e345cf3c0abed3cb6c109274a379cb2655adc":["b627755385655c7cd3fb296f17593658805cf4d5"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","60b45f127b5537b5bf62181784ef28b52f4b6a08"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["849083f8095b1ffaff05a66e0b1e024617b9968d"],"849083f8095b1ffaff05a66e0b1e024617b9968d":["60b45f127b5537b5bf62181784ef28b52f4b6a08"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b627755385655c7cd3fb296f17593658805cf4d5":["11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6"],"60b45f127b5537b5bf62181784ef28b52f4b6a08":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["105e345cf3c0abed3cb6c109274a379cb2655adc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","60b45f127b5537b5bf62181784ef28b52f4b6a08"]},"commit2Childs":{"105e345cf3c0abed3cb6c109274a379cb2655adc":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","60b45f127b5537b5bf62181784ef28b52f4b6a08","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"849083f8095b1ffaff05a66e0b1e024617b9968d":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"b627755385655c7cd3fb296f17593658805cf4d5":["105e345cf3c0abed3cb6c109274a379cb2655adc"],"60b45f127b5537b5bf62181784ef28b52f4b6a08":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","849083f8095b1ffaff05a66e0b1e024617b9968d","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6":["b627755385655c7cd3fb296f17593658805cf4d5"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}