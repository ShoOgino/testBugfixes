{"path":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","sourceNew":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = _TestUtil.nextInt(random, 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newField(\"content\", \"aaa \" + (i%4), TextField.TYPE_UNSTORED));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = _TestUtil.nextInt(random, 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = _TestUtil.nextInt(random, 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newField(\"content\", \"aaa \" + (i%4), TextField.TYPE_UNSTORED));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = _TestUtil.nextInt(random, 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","sourceNew":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = _TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newField(\"content\", \"aaa \" + (i%4), TextField.TYPE_UNSTORED));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = _TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = _TestUtil.nextInt(random, 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newField(\"content\", \"aaa \" + (i%4), TextField.TYPE_UNSTORED));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = _TestUtil.nextInt(random, 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","sourceNew":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = _TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = _TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = _TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newField(\"content\", \"aaa \" + (i%4), TextField.TYPE_UNSTORED));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = _TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","bugFix":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","sourceNew":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = _TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = _TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","sourceNew":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.shutdown();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","sourceNew":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.shutdown();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.shutdown();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","sourceNew":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.shutdown();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56fb5e4e4b239474721e13b4cd9542ea2d215451","date":1529091182,"type":3,"author":"Erick","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","sourceNew":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n\n      final long max125Pct = (long) ((tmp.getMaxMergedSegmentMB() * 1024.0 * 1024.0) * 1.25);\n      // Other than in the case where the target count is 1 we can't say much except no segment should be > 125% of max seg size.\n      if (targetCount == 1) {\n        assertEquals(\"Should have merged down to one segment\", targetCount, w.getSegmentCount());\n      } else {\n        // why can't we say much? Well...\n        // 1> the random numbers generated above mean we could have 10 segments and a target max count of, say, 9. we\n        //    could get there by combining only 2 segments. So tests like \"no pair of segments should total less than\n        //    125% max segment size\" aren't valid.\n        //\n        // 2> We could have 10 segments and a target count of 2. In that case there could be 5 segments resulting.\n        //    as long as they're all < 125% max seg size, that's valid.\n        Iterator<SegmentCommitInfo> iterator = w.segmentInfos.iterator();\n        while (iterator.hasNext()) {\n          SegmentCommitInfo info = iterator.next();\n          assertTrue(\"No segment should be more than 125% of max segment size \",\n              max125Pct >= info.sizeInBytes());\n        }\n      }\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["631ea3d1607299c59f33edef140ffc19a81f07a0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","sourceNew":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n\n      final long max125Pct = (long) ((tmp.getMaxMergedSegmentMB() * 1024.0 * 1024.0) * 1.25);\n      // Other than in the case where the target count is 1 we can't say much except no segment should be > 125% of max seg size.\n      if (targetCount == 1) {\n        assertEquals(\"Should have merged down to one segment\", targetCount, w.getSegmentCount());\n      } else {\n        // why can't we say much? Well...\n        // 1> the random numbers generated above mean we could have 10 segments and a target max count of, say, 9. we\n        //    could get there by combining only 2 segments. So tests like \"no pair of segments should total less than\n        //    125% max segment size\" aren't valid.\n        //\n        // 2> We could have 10 segments and a target count of 2. In that case there could be 5 segments resulting.\n        //    as long as they're all < 125% max seg size, that's valid.\n        Iterator<SegmentCommitInfo> iterator = w.segmentInfos.iterator();\n        while (iterator.hasNext()) {\n          SegmentCommitInfo info = iterator.next();\n          assertTrue(\"No segment should be more than 125% of max segment size \",\n              max125Pct >= info.sizeInBytes());\n        }\n      }\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","sourceNew":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n\n      final long max125Pct = (long) ((tmp.getMaxMergedSegmentMB() * 1024.0 * 1024.0) * 1.25);\n      // Other than in the case where the target count is 1 we can't say much except no segment should be > 125% of max seg size.\n      if (targetCount == 1) {\n        assertEquals(\"Should have merged down to one segment\", targetCount, w.getSegmentCount());\n      } else {\n        // why can't we say much? Well...\n        // 1> the random numbers generated above mean we could have 10 segments and a target max count of, say, 9. we\n        //    could get there by combining only 2 segments. So tests like \"no pair of segments should total less than\n        //    125% max segment size\" aren't valid.\n        //\n        // 2> We could have 10 segments and a target count of 2. In that case there could be 5 segments resulting.\n        //    as long as they're all < 125% max seg size, that's valid.\n        Iterator<SegmentCommitInfo> iterator = w.segmentInfos.iterator();\n        while (iterator.hasNext()) {\n          SegmentCommitInfo info = iterator.next();\n          assertTrue(\"No segment should be more than 125% of max segment size \",\n              max125Pct >= info.sizeInBytes());\n        }\n      }\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n      assertEquals(targetCount, w.getSegmentCount());\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"631ea3d1607299c59f33edef140ffc19a81f07a0","date":1532450367,"type":3,"author":"Nhat Nguyen","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","sourceNew":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n\n      final long max125Pct = (long) ((tmp.getMaxMergedSegmentMB() * 1024.0 * 1024.0) * 1.25);\n      // Other than in the case where the target count is 1 we can't say much except no segment should be > 125% of max seg size.\n      if (targetCount == 1) {\n        assertEquals(\"Should have merged down to one segment\", targetCount, w.getSegmentCount());\n      } else {\n        // why can't we say much? Well...\n        // 1> the random numbers generated above mean we could have 10 segments and a target max count of, say, 9. we\n        //    could get there by combining only 2 segments. So tests like \"no pair of segments should total less than\n        //    125% max segment size\" aren't valid.\n        //\n        // 2> We could have 10 segments and a target count of 2. In that case there could be 5 segments resulting.\n        //    as long as they're all < 125% max seg size, that's valid.\n        Iterator<SegmentCommitInfo> iterator = w.cloneSegmentInfos().iterator();\n        while (iterator.hasNext()) {\n          SegmentCommitInfo info = iterator.next();\n          assertTrue(\"No segment should be more than 125% of max segment size \",\n              max125Pct >= info.sizeInBytes());\n        }\n      }\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n\n      final long max125Pct = (long) ((tmp.getMaxMergedSegmentMB() * 1024.0 * 1024.0) * 1.25);\n      // Other than in the case where the target count is 1 we can't say much except no segment should be > 125% of max seg size.\n      if (targetCount == 1) {\n        assertEquals(\"Should have merged down to one segment\", targetCount, w.getSegmentCount());\n      } else {\n        // why can't we say much? Well...\n        // 1> the random numbers generated above mean we could have 10 segments and a target max count of, say, 9. we\n        //    could get there by combining only 2 segments. So tests like \"no pair of segments should total less than\n        //    125% max segment size\" aren't valid.\n        //\n        // 2> We could have 10 segments and a target count of 2. In that case there could be 5 segments resulting.\n        //    as long as they're all < 125% max seg size, that's valid.\n        Iterator<SegmentCommitInfo> iterator = w.segmentInfos.iterator();\n        while (iterator.hasNext()) {\n          SegmentCommitInfo info = iterator.next();\n          assertTrue(\"No segment should be more than 125% of max segment size \",\n              max125Pct >= info.sizeInBytes());\n        }\n      }\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","bugFix":["56fb5e4e4b239474721e13b4cd9542ea2d215451"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5610a9ef907504527655e3fd8720426a73414a64","date":1544617266,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#testPartialMerge().mjava","sourceNew":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n\n      final double maxSegmentSize = Math.max(tmp.getMaxMergedSegmentMB(), tmp.getFloorSegmentMB());\n      final long max125Pct = (long) ((maxSegmentSize * 1024.0 * 1024.0) * 1.25);\n      // Other than in the case where the target count is 1 we can't say much except no segment should be > 125% of max seg size.\n      if (targetCount == 1) {\n        assertEquals(\"Should have merged down to one segment\", targetCount, w.getSegmentCount());\n      } else {\n        // why can't we say much? Well...\n        // 1> the random numbers generated above mean we could have 10 segments and a target max count of, say, 9. we\n        //    could get there by combining only 2 segments. So tests like \"no pair of segments should total less than\n        //    125% max segment size\" aren't valid.\n        //\n        // 2> We could have 10 segments and a target count of 2. In that case there could be 5 segments resulting.\n        //    as long as they're all < 125% max seg size, that's valid.\n        Iterator<SegmentCommitInfo> iterator = w.cloneSegmentInfos().iterator();\n        while (iterator.hasNext()) {\n          SegmentCommitInfo info = iterator.next();\n          assertTrue(\"No segment should be more than 125% of max segment size \",\n              max125Pct >= info.sizeInBytes());\n        }\n      }\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testPartialMerge() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      Directory dir = newDirectory();\n      IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n      conf.setMergeScheduler(new SerialMergeScheduler());\n      TieredMergePolicy tmp = newTieredMergePolicy();\n      conf.setMergePolicy(tmp);\n      conf.setMaxBufferedDocs(2);\n      tmp.setMaxMergeAtOnce(3);\n      tmp.setSegmentsPerTier(6);\n\n      IndexWriter w = new IndexWriter(dir, conf);\n      int maxCount = 0;\n      final int numDocs = TestUtil.nextInt(random(), 20, 100);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(newTextField(\"content\", \"aaa \" + (i%4), Field.Store.NO));\n        w.addDocument(doc);\n        int count = w.getSegmentCount();\n        maxCount = Math.max(count, maxCount);\n        assertTrue(\"count=\" + count + \" maxCount=\" + maxCount, count >= maxCount-3);\n      }\n\n      w.flush(true, true);\n\n      int segmentCount = w.getSegmentCount();\n      int targetCount = TestUtil.nextInt(random(), 1, segmentCount);\n      if (VERBOSE) {\n        System.out.println(\"TEST: merge to \" + targetCount + \" segs (current count=\" + segmentCount + \")\");\n      }\n      w.forceMerge(targetCount);\n\n      final long max125Pct = (long) ((tmp.getMaxMergedSegmentMB() * 1024.0 * 1024.0) * 1.25);\n      // Other than in the case where the target count is 1 we can't say much except no segment should be > 125% of max seg size.\n      if (targetCount == 1) {\n        assertEquals(\"Should have merged down to one segment\", targetCount, w.getSegmentCount());\n      } else {\n        // why can't we say much? Well...\n        // 1> the random numbers generated above mean we could have 10 segments and a target max count of, say, 9. we\n        //    could get there by combining only 2 segments. So tests like \"no pair of segments should total less than\n        //    125% max segment size\" aren't valid.\n        //\n        // 2> We could have 10 segments and a target count of 2. In that case there could be 5 segments resulting.\n        //    as long as they're all < 125% max seg size, that's valid.\n        Iterator<SegmentCommitInfo> iterator = w.cloneSegmentInfos().iterator();\n        while (iterator.hasNext()) {\n          SegmentCommitInfo info = iterator.next();\n          assertTrue(\"No segment should be more than 125% of max segment size \",\n              max125Pct >= info.sizeInBytes());\n        }\n      }\n\n      w.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"6613659748fe4411a7dcf85266e55db1f95f7315":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5610a9ef907504527655e3fd8720426a73414a64":["631ea3d1607299c59f33edef140ffc19a81f07a0"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["d0ef034a4f10871667ae75181537775ddcf8ade4","56fb5e4e4b239474721e13b4cd9542ea2d215451"],"56fb5e4e4b239474721e13b4cd9542ea2d215451":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"631ea3d1607299c59f33edef140ffc19a81f07a0":["56fb5e4e4b239474721e13b4cd9542ea2d215451"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["6613659748fe4411a7dcf85266e55db1f95f7315"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5610a9ef907504527655e3fd8720426a73414a64"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["d0ef034a4f10871667ae75181537775ddcf8ade4","56fb5e4e4b239474721e13b4cd9542ea2d215451"]},"commit2Childs":{"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"6613659748fe4411a7dcf85266e55db1f95f7315":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"5610a9ef907504527655e3fd8720426a73414a64":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["6613659748fe4411a7dcf85266e55db1f95f7315"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"56fb5e4e4b239474721e13b4cd9542ea2d215451":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","631ea3d1607299c59f33edef140ffc19a81f07a0","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"631ea3d1607299c59f33edef140ffc19a81f07a0":["5610a9ef907504527655e3fd8720426a73414a64"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","56fb5e4e4b239474721e13b4cd9542ea2d215451","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}