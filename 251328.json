{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doVersionAdd(AddUpdateCommand,long,boolean,boolean,boolean,VersionBucket).mjava","commits":[{"id":"9b3824fcbd3256db359391630ae05b3917ab369a","date":1556656304,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doVersionAdd(AddUpdateCommand,long,boolean,boolean,boolean,VersionBucket).mjava","pathOld":"/dev/null","sourceNew":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      // just in case anyone is waiting let them know that we have a new update\n      // we obtain the version when synchronized and then do the add so we can ensure that\n      // if version1 < version2 then version1 is actually added before version2.\n\n      // even if we don't store the version field, synchronizing on the bucket\n      // will enable us to know what version happened first, and thus enable\n      // realtime-get to work reliably.\n      // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n      // there may be other reasons in the future for a version on the commands\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            // forwarded from a collection but we are not buffering so strip original version and apply our own\n            // see SOLR-5308\n            log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n              // specified it must exist (versionOnUpdate==1) and it does.\n            } else {\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          // The leader forwarded us this update.\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n              // So we shouldn't be here, unless what must've happened is:\n              // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n              // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version\n              // from the deleted list (which might be older than the prev update!)\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                    + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                // Newer document was fetched from the leader. Apply that document instead of this current in-place\n                // update.\n                log.info(\n                    \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                    idBytes.utf8ToString(), fetchedFromLeader);\n\n                // Make this update to become a non-inplace update containing the full document obtained from the\n                // leader\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                // inplace update. Drop this update\n                log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                    + \". Dropping current update.\");\n                return true;\n              } else {\n                // We're good, we should apply this update. First, update the bucket's highest.\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update. we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered. We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      // TODO: possibly set checkDeleteByQueries as a flag on the command?\n      doLocalAdd(cmd);\n\n      // if the update updates a doc that is part of a nested structure,\n      // force open a realTimeSearcher to trigger a ulog cache refresh.\n      // This refresh makes RTG handler aware of this update.q\n      if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n        ulog.openRealtimeSearcher();\n      }\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09c68c39b2c63d90387c861e51185c9568c50611","date":1557206402,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doVersionAdd(AddUpdateCommand,long,boolean,boolean,boolean,VersionBucket).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doVersionAdd(AddUpdateCommand,long,boolean,boolean,boolean,VersionBucket).mjava","sourceNew":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      // just in case anyone is waiting let them know that we have a new update\n      // we obtain the version when synchronized and then do the add so we can ensure that\n      // if version1 < version2 then version1 is actually added before version2.\n\n      // even if we don't store the version field, synchronizing on the bucket\n      // will enable us to know what version happened first, and thus enable\n      // realtime-get to work reliably.\n      // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n      // there may be other reasons in the future for a version on the commands\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            // forwarded from a collection but we are not buffering so strip original version and apply our own\n            // see SOLR-5308\n            log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n              // specified it must exist (versionOnUpdate==1) and it does.\n            } else {\n              if(cmd.getReq().getParams().getBool(CommonParams.FAIL_ON_VERSION_CONFLICTS, true) == false) {\n                return true;\n              }\n\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          // The leader forwarded us this update.\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n              // So we shouldn't be here, unless what must've happened is:\n              // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n              // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version\n              // from the deleted list (which might be older than the prev update!)\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                    + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                // Newer document was fetched from the leader. Apply that document instead of this current in-place\n                // update.\n                log.info(\n                    \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                    idBytes.utf8ToString(), fetchedFromLeader);\n\n                // Make this update to become a non-inplace update containing the full document obtained from the\n                // leader\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                // inplace update. Drop this update\n                log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                    + \". Dropping current update.\");\n                return true;\n              } else {\n                // We're good, we should apply this update. First, update the bucket's highest.\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update. we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered. We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      // TODO: possibly set checkDeleteByQueries as a flag on the command?\n      doLocalAdd(cmd);\n\n      // if the update updates a doc that is part of a nested structure,\n      // force open a realTimeSearcher to trigger a ulog cache refresh.\n      // This refresh makes RTG handler aware of this update.q\n      if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n        ulog.openRealtimeSearcher();\n      }\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n\n","sourceOld":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      // just in case anyone is waiting let them know that we have a new update\n      // we obtain the version when synchronized and then do the add so we can ensure that\n      // if version1 < version2 then version1 is actually added before version2.\n\n      // even if we don't store the version field, synchronizing on the bucket\n      // will enable us to know what version happened first, and thus enable\n      // realtime-get to work reliably.\n      // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n      // there may be other reasons in the future for a version on the commands\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            // forwarded from a collection but we are not buffering so strip original version and apply our own\n            // see SOLR-5308\n            log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n              // specified it must exist (versionOnUpdate==1) and it does.\n            } else {\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          // The leader forwarded us this update.\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n              // So we shouldn't be here, unless what must've happened is:\n              // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n              // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version\n              // from the deleted list (which might be older than the prev update!)\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                    + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                // Newer document was fetched from the leader. Apply that document instead of this current in-place\n                // update.\n                log.info(\n                    \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                    idBytes.utf8ToString(), fetchedFromLeader);\n\n                // Make this update to become a non-inplace update containing the full document obtained from the\n                // leader\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                // inplace update. Drop this update\n                log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                    + \". Dropping current update.\");\n                return true;\n              } else {\n                // We're good, we should apply this update. First, update the bucket's highest.\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update. we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered. We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      // TODO: possibly set checkDeleteByQueries as a flag on the command?\n      doLocalAdd(cmd);\n\n      // if the update updates a doc that is part of a nested structure,\n      // force open a realTimeSearcher to trigger a ulog cache refresh.\n      // This refresh makes RTG handler aware of this update.q\n      if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n        ulog.openRealtimeSearcher();\n      }\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doVersionAdd(AddUpdateCommand,long,boolean,boolean,boolean,VersionBucket).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doVersionAdd(AddUpdateCommand,long,boolean,boolean,boolean,VersionBucket).mjava","sourceNew":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      // just in case anyone is waiting let them know that we have a new update\n      // we obtain the version when synchronized and then do the add so we can ensure that\n      // if version1 < version2 then version1 is actually added before version2.\n\n      // even if we don't store the version field, synchronizing on the bucket\n      // will enable us to know what version happened first, and thus enable\n      // realtime-get to work reliably.\n      // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n      // there may be other reasons in the future for a version on the commands\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            // forwarded from a collection but we are not buffering so strip original version and apply our own\n            // see SOLR-5308\n            if (log.isInfoEnabled()) {\n              log.info(\"Removing version field from doc: {}\", cmd.getPrintableId());\n            }\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            if (log.isInfoEnabled()) {\n              log.info(\"Leader logic applied but update log is buffering: {}\", cmd.getPrintableId());\n            }\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n              // specified it must exist (versionOnUpdate==1) and it does.\n            } else {\n              if(cmd.getReq().getParams().getBool(CommonParams.FAIL_ON_VERSION_CONFLICTS, true) == false) {\n                return true;\n              }\n\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          // The leader forwarded us this update.\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n              // So we shouldn't be here, unless what must've happened is:\n              // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n              // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version\n              // from the deleted list (which might be older than the prev update!)\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                if (log.isInfoEnabled()) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                }\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                // Newer document was fetched from the leader. Apply that document instead of this current in-place\n                // update.\n                if (log.isInfoEnabled()) {\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n                }\n                // Make this update to become a non-inplace update containing the full document obtained from the\n                // leader\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                // inplace update. Drop this update\n                log.info(\"Update was applied on version: {}, but last version I have is: {}. Dropping current update\"\n                    , prev, lastVersion);\n                return true;\n              } else {\n                // We're good, we should apply this update. First, update the bucket's highest.\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update. we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered. We need to drop this update.\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                }\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      // TODO: possibly set checkDeleteByQueries as a flag on the command?\n      doLocalAdd(cmd);\n\n      // if the update updates a doc that is part of a nested structure,\n      // force open a realTimeSearcher to trigger a ulog cache refresh.\n      // This refresh makes RTG handler aware of this update.q\n      if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n        ulog.openRealtimeSearcher();\n      }\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n\n","sourceOld":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      // just in case anyone is waiting let them know that we have a new update\n      // we obtain the version when synchronized and then do the add so we can ensure that\n      // if version1 < version2 then version1 is actually added before version2.\n\n      // even if we don't store the version field, synchronizing on the bucket\n      // will enable us to know what version happened first, and thus enable\n      // realtime-get to work reliably.\n      // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n      // there may be other reasons in the future for a version on the commands\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            // forwarded from a collection but we are not buffering so strip original version and apply our own\n            // see SOLR-5308\n            log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n              // specified it must exist (versionOnUpdate==1) and it does.\n            } else {\n              if(cmd.getReq().getParams().getBool(CommonParams.FAIL_ON_VERSION_CONFLICTS, true) == false) {\n                return true;\n              }\n\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          // The leader forwarded us this update.\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n              // So we shouldn't be here, unless what must've happened is:\n              // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n              // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version\n              // from the deleted list (which might be older than the prev update!)\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                    + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                // Newer document was fetched from the leader. Apply that document instead of this current in-place\n                // update.\n                log.info(\n                    \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                    idBytes.utf8ToString(), fetchedFromLeader);\n\n                // Make this update to become a non-inplace update containing the full document obtained from the\n                // leader\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                // inplace update. Drop this update\n                log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                    + \". Dropping current update.\");\n                return true;\n              } else {\n                // We're good, we should apply this update. First, update the bucket's highest.\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update. we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered. We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      // TODO: possibly set checkDeleteByQueries as a flag on the command?\n      doLocalAdd(cmd);\n\n      // if the update updates a doc that is part of a nested structure,\n      // force open a realTimeSearcher to trigger a ulog cache refresh.\n      // This refresh makes RTG handler aware of this update.q\n      if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n        ulog.openRealtimeSearcher();\n      }\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doVersionAdd(AddUpdateCommand,long,boolean,boolean,boolean,VersionBucket).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doVersionAdd(AddUpdateCommand,long,boolean,boolean,boolean,VersionBucket).mjava","sourceNew":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      // just in case anyone is waiting let them know that we have a new update\n      // we obtain the version when synchronized and then do the add so we can ensure that\n      // if version1 < version2 then version1 is actually added before version2.\n\n      // even if we don't store the version field, synchronizing on the bucket\n      // will enable us to know what version happened first, and thus enable\n      // realtime-get to work reliably.\n      // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n      // there may be other reasons in the future for a version on the commands\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            // forwarded from a collection but we are not buffering so strip original version and apply our own\n            // see SOLR-5308\n            if (log.isInfoEnabled()) {\n              log.info(\"Removing version field from doc: {}\", cmd.getPrintableId());\n            }\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            if (log.isInfoEnabled()) {\n              log.info(\"Leader logic applied but update log is buffering: {}\", cmd.getPrintableId());\n            }\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n              // specified it must exist (versionOnUpdate==1) and it does.\n            } else {\n              if(cmd.getReq().getParams().getBool(CommonParams.FAIL_ON_VERSION_CONFLICTS, true) == false) {\n                return true;\n              }\n\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          // The leader forwarded us this update.\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n              // So we shouldn't be here, unless what must've happened is:\n              // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n              // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version\n              // from the deleted list (which might be older than the prev update!)\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                if (log.isInfoEnabled()) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document was deleted at the leader subsequently.\"\n                      , idBytes.utf8ToString());\n                }\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                // Newer document was fetched from the leader. Apply that document instead of this current in-place\n                // update.\n                if (log.isInfoEnabled()) {\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n                }\n                // Make this update to become a non-inplace update containing the full document obtained from the\n                // leader\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                // inplace update. Drop this update\n                log.info(\"Update was applied on version: {}, but last version I have is: {}. Dropping current update\"\n                    , prev, lastVersion);\n                return true;\n              } else {\n                // We're good, we should apply this update. First, update the bucket's highest.\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update. we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered. We need to drop this update.\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                }\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      // TODO: possibly set checkDeleteByQueries as a flag on the command?\n      doLocalAdd(cmd);\n\n      // if the update updates a doc that is part of a nested structure,\n      // force open a realTimeSearcher to trigger a ulog cache refresh.\n      // This refresh makes RTG handler aware of this update.q\n      if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n        ulog.openRealtimeSearcher();\n      }\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n\n","sourceOld":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      // just in case anyone is waiting let them know that we have a new update\n      // we obtain the version when synchronized and then do the add so we can ensure that\n      // if version1 < version2 then version1 is actually added before version2.\n\n      // even if we don't store the version field, synchronizing on the bucket\n      // will enable us to know what version happened first, and thus enable\n      // realtime-get to work reliably.\n      // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n      // there may be other reasons in the future for a version on the commands\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            // forwarded from a collection but we are not buffering so strip original version and apply our own\n            // see SOLR-5308\n            if (log.isInfoEnabled()) {\n              log.info(\"Removing version field from doc: {}\", cmd.getPrintableId());\n            }\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            if (log.isInfoEnabled()) {\n              log.info(\"Leader logic applied but update log is buffering: {}\", cmd.getPrintableId());\n            }\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n              // specified it must exist (versionOnUpdate==1) and it does.\n            } else {\n              if(cmd.getReq().getParams().getBool(CommonParams.FAIL_ON_VERSION_CONFLICTS, true) == false) {\n                return true;\n              }\n\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          // The leader forwarded us this update.\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n              // So we shouldn't be here, unless what must've happened is:\n              // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n              // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version\n              // from the deleted list (which might be older than the prev update!)\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                if (log.isInfoEnabled()) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                }\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                // Newer document was fetched from the leader. Apply that document instead of this current in-place\n                // update.\n                if (log.isInfoEnabled()) {\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n                }\n                // Make this update to become a non-inplace update containing the full document obtained from the\n                // leader\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                // inplace update. Drop this update\n                log.info(\"Update was applied on version: {}, but last version I have is: {}. Dropping current update\"\n                    , prev, lastVersion);\n                return true;\n              } else {\n                // We're good, we should apply this update. First, update the bucket's highest.\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update. we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered. We need to drop this update.\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                }\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      // TODO: possibly set checkDeleteByQueries as a flag on the command?\n      doLocalAdd(cmd);\n\n      // if the update updates a doc that is part of a nested structure,\n      // force open a realTimeSearcher to trigger a ulog cache refresh.\n      // This refresh makes RTG handler aware of this update.q\n      if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n        ulog.openRealtimeSearcher();\n      }\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9b3824fcbd3256db359391630ae05b3917ab369a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"740d649f013f07efbeb73ca854f106c60166e7c0":["09c68c39b2c63d90387c861e51185c9568c50611"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"575e66bd4b2349209027f6801184da7fc3cba13f":["740d649f013f07efbeb73ca854f106c60166e7c0"],"09c68c39b2c63d90387c861e51185c9568c50611":["9b3824fcbd3256db359391630ae05b3917ab369a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"]},"commit2Childs":{"9b3824fcbd3256db359391630ae05b3917ab369a":["09c68c39b2c63d90387c861e51185c9568c50611"],"740d649f013f07efbeb73ca854f106c60166e7c0":["575e66bd4b2349209027f6801184da7fc3cba13f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9b3824fcbd3256db359391630ae05b3917ab369a"],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"09c68c39b2c63d90387c861e51185c9568c50611":["740d649f013f07efbeb73ca854f106c60166e7c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}