{"path":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testCodePointCount().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testCodePointCount().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestUnicodeUtil#testCodePointCount().mjava","sourceNew":"  public void testCodePointCount() {\n    BytesRef utf8 = new BytesRef(20);\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = _TestUtil.randomUnicodeString(random);\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      assertEquals(s.codePointCount(0, s.length()),\n                   UnicodeUtil.codePointCount(utf8));\n    }\n  }\n\n","sourceOld":"  public void testCodePointCount() {\n    BytesRef utf8 = new BytesRef(20);\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = _TestUtil.randomUnicodeString(random);\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      assertEquals(s.codePointCount(0, s.length()),\n                   UnicodeUtil.codePointCount(utf8));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testCodePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testCodePointCount().mjava","sourceNew":"  public void testCodePointCount() {\n    BytesRef utf8 = new BytesRef(20);\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = _TestUtil.randomUnicodeString(random());\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      assertEquals(s.codePointCount(0, s.length()),\n                   UnicodeUtil.codePointCount(utf8));\n    }\n  }\n\n","sourceOld":"  public void testCodePointCount() {\n    BytesRef utf8 = new BytesRef(20);\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = _TestUtil.randomUnicodeString(random);\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      assertEquals(s.codePointCount(0, s.length()),\n                   UnicodeUtil.codePointCount(utf8));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb445c22e37e9fe48d0efed781537ca5cc5696d","date":1364460154,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testCodePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testCodePointCount().mjava","sourceNew":"  public void testCodePointCount() {\n    // Check invalid codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0x80, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc0 - 1, 'z', 'z', 'z'));\n    // Check 5-byte and longer sequences.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf8, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xfc, 'z', 'z', 'z'));\n    // Check improperly terminated codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2, 0x82));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4, 0xad));\n\n    // Check some typical examples (multibyte).\n    assertEquals(0, UnicodeUtil.codePointCount(new BytesRef(asByteArray())));\n    assertEquals(3, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 'z', 'z'))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xc2, 0xa2))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xe2, 0x82, 0xac))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xf0, 0xa4, 0xad, 0xa2))));\n\n    // And do some random stuff.\n    BytesRef utf8 = new BytesRef(20);\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = _TestUtil.randomUnicodeString(random());\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      assertEquals(s.codePointCount(0, s.length()),\n                   UnicodeUtil.codePointCount(utf8));\n    }\n  }\n\n","sourceOld":"  public void testCodePointCount() {\n    BytesRef utf8 = new BytesRef(20);\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = _TestUtil.randomUnicodeString(random());\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      assertEquals(s.codePointCount(0, s.length()),\n                   UnicodeUtil.codePointCount(utf8));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testCodePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testCodePointCount().mjava","sourceNew":"  public void testCodePointCount() {\n    // Check invalid codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0x80, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc0 - 1, 'z', 'z', 'z'));\n    // Check 5-byte and longer sequences.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf8, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xfc, 'z', 'z', 'z'));\n    // Check improperly terminated codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2, 0x82));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4, 0xad));\n\n    // Check some typical examples (multibyte).\n    assertEquals(0, UnicodeUtil.codePointCount(new BytesRef(asByteArray())));\n    assertEquals(3, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 'z', 'z'))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xc2, 0xa2))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xe2, 0x82, 0xac))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xf0, 0xa4, 0xad, 0xa2))));\n\n    // And do some random stuff.\n    BytesRef utf8 = new BytesRef(20);\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      assertEquals(s.codePointCount(0, s.length()),\n                   UnicodeUtil.codePointCount(utf8));\n    }\n  }\n\n","sourceOld":"  public void testCodePointCount() {\n    // Check invalid codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0x80, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc0 - 1, 'z', 'z', 'z'));\n    // Check 5-byte and longer sequences.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf8, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xfc, 'z', 'z', 'z'));\n    // Check improperly terminated codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2, 0x82));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4, 0xad));\n\n    // Check some typical examples (multibyte).\n    assertEquals(0, UnicodeUtil.codePointCount(new BytesRef(asByteArray())));\n    assertEquals(3, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 'z', 'z'))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xc2, 0xa2))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xe2, 0x82, 0xac))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xf0, 0xa4, 0xad, 0xa2))));\n\n    // And do some random stuff.\n    BytesRef utf8 = new BytesRef(20);\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = _TestUtil.randomUnicodeString(random());\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      assertEquals(s.codePointCount(0, s.length()),\n                   UnicodeUtil.codePointCount(utf8));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testCodePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testCodePointCount().mjava","sourceNew":"  public void testCodePointCount() {\n    // Check invalid codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0x80, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc0 - 1, 'z', 'z', 'z'));\n    // Check 5-byte and longer sequences.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf8, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xfc, 'z', 'z', 'z'));\n    // Check improperly terminated codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2, 0x82));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4, 0xad));\n\n    // Check some typical examples (multibyte).\n    assertEquals(0, UnicodeUtil.codePointCount(new BytesRef(asByteArray())));\n    assertEquals(3, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 'z', 'z'))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xc2, 0xa2))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xe2, 0x82, 0xac))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xf0, 0xa4, 0xad, 0xa2))));\n\n    // And do some random stuff.\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[s.length() * UnicodeUtil.MAX_UTF8_BYTES_PER_CHAR];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      assertEquals(s.codePointCount(0, s.length()),\n                   UnicodeUtil.codePointCount(new BytesRef(utf8, 0, utf8Len)));\n    }\n  }\n\n","sourceOld":"  public void testCodePointCount() {\n    // Check invalid codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0x80, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc0 - 1, 'z', 'z', 'z'));\n    // Check 5-byte and longer sequences.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf8, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xfc, 'z', 'z', 'z'));\n    // Check improperly terminated codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2, 0x82));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4, 0xad));\n\n    // Check some typical examples (multibyte).\n    assertEquals(0, UnicodeUtil.codePointCount(new BytesRef(asByteArray())));\n    assertEquals(3, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 'z', 'z'))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xc2, 0xa2))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xe2, 0x82, 0xac))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xf0, 0xa4, 0xad, 0xa2))));\n\n    // And do some random stuff.\n    BytesRef utf8 = new BytesRef(20);\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      assertEquals(s.codePointCount(0, s.length()),\n                   UnicodeUtil.codePointCount(utf8));\n    }\n  }\n\n","bugFix":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"bugIntro":["c49ea3d4279fbc211c84a5d81ff591b5f8d18e83"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c49ea3d4279fbc211c84a5d81ff591b5f8d18e83","date":1478775068,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testCodePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testCodePointCount().mjava","sourceNew":"  public void testCodePointCount() {\n    // Check invalid codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0x80, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc0 - 1, 'z', 'z', 'z'));\n    // Check 5-byte and longer sequences.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf8, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xfc, 'z', 'z', 'z'));\n    // Check improperly terminated codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2, 0x82));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4, 0xad));\n\n    // Check some typical examples (multibyte).\n    assertEquals(0, UnicodeUtil.codePointCount(new BytesRef(asByteArray())));\n    assertEquals(3, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 'z', 'z'))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xc2, 0xa2))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xe2, 0x82, 0xac))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xf0, 0xa4, 0xad, 0xa2))));\n\n    // And do some random stuff.\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[UnicodeUtil.maxUTF8Length(s.length())];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      assertEquals(s.codePointCount(0, s.length()),\n                   UnicodeUtil.codePointCount(new BytesRef(utf8, 0, utf8Len)));\n    }\n  }\n\n","sourceOld":"  public void testCodePointCount() {\n    // Check invalid codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0x80, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc0 - 1, 'z', 'z', 'z'));\n    // Check 5-byte and longer sequences.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf8, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xfc, 'z', 'z', 'z'));\n    // Check improperly terminated codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2, 0x82));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4, 0xad));\n\n    // Check some typical examples (multibyte).\n    assertEquals(0, UnicodeUtil.codePointCount(new BytesRef(asByteArray())));\n    assertEquals(3, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 'z', 'z'))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xc2, 0xa2))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xe2, 0x82, 0xac))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xf0, 0xa4, 0xad, 0xa2))));\n\n    // And do some random stuff.\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[s.length() * UnicodeUtil.MAX_UTF8_BYTES_PER_CHAR];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      assertEquals(s.codePointCount(0, s.length()),\n                   UnicodeUtil.codePointCount(new BytesRef(utf8, 0, utf8Len)));\n    }\n  }\n\n","bugFix":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testCodePointCount().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testCodePointCount().mjava","sourceNew":"  public void testCodePointCount() {\n    // Check invalid codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0x80, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc0 - 1, 'z', 'z', 'z'));\n    // Check 5-byte and longer sequences.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf8, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xfc, 'z', 'z', 'z'));\n    // Check improperly terminated codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2, 0x82));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4, 0xad));\n\n    // Check some typical examples (multibyte).\n    assertEquals(0, UnicodeUtil.codePointCount(new BytesRef(asByteArray())));\n    assertEquals(3, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 'z', 'z'))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xc2, 0xa2))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xe2, 0x82, 0xac))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xf0, 0xa4, 0xad, 0xa2))));\n\n    // And do some random stuff.\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[UnicodeUtil.maxUTF8Length(s.length())];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      assertEquals(s.codePointCount(0, s.length()),\n                   UnicodeUtil.codePointCount(new BytesRef(utf8, 0, utf8Len)));\n    }\n  }\n\n","sourceOld":"  public void testCodePointCount() {\n    // Check invalid codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0x80, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc0 - 1, 'z', 'z', 'z'));\n    // Check 5-byte and longer sequences.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf8, 'z', 'z', 'z'));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xfc, 'z', 'z', 'z'));\n    // Check improperly terminated codepoints.\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xc2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xe2, 0x82));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4));\n    assertcodePointCountThrowsAssertionOn(asByteArray('z', 0xf0, 0xa4, 0xad));\n\n    // Check some typical examples (multibyte).\n    assertEquals(0, UnicodeUtil.codePointCount(new BytesRef(asByteArray())));\n    assertEquals(3, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 'z', 'z'))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xc2, 0xa2))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xe2, 0x82, 0xac))));\n    assertEquals(2, UnicodeUtil.codePointCount(new BytesRef(asByteArray('z', 0xf0, 0xa4, 0xad, 0xa2))));\n\n    // And do some random stuff.\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[s.length() * UnicodeUtil.MAX_UTF8_BYTES_PER_CHAR];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      assertEquals(s.codePointCount(0, s.length()),\n                   UnicodeUtil.codePointCount(new BytesRef(utf8, 0, utf8Len)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb445c22e37e9fe48d0efed781537ca5cc5696d":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"c49ea3d4279fbc211c84a5d81ff591b5f8d18e83":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"6613659748fe4411a7dcf85266e55db1f95f7315":["5eb445c22e37e9fe48d0efed781537ca5cc5696d"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","c49ea3d4279fbc211c84a5d81ff591b5f8d18e83"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["6613659748fe4411a7dcf85266e55db1f95f7315"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c49ea3d4279fbc211c84a5d81ff591b5f8d18e83"]},"commit2Childs":{"5eb445c22e37e9fe48d0efed781537ca5cc5696d":["6613659748fe4411a7dcf85266e55db1f95f7315"],"c49ea3d4279fbc211c84a5d81ff591b5f8d18e83":["199dfa410f1fdbfd3294106b04096cce5ed34b21","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6613659748fe4411a7dcf85266e55db1f95f7315":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["5eb445c22e37e9fe48d0efed781537ca5cc5696d"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["c49ea3d4279fbc211c84a5d81ff591b5f8d18e83","199dfa410f1fdbfd3294106b04096cce5ed34b21"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["199dfa410f1fdbfd3294106b04096cce5ed34b21","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}