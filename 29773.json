{"path":"lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch#assertSubsetOfSameScores(Query,TopDocs,TopDocs).mjava","commits":[{"id":"af549b45614d869371e17e0b5b4ca47535d552c0","date":1344595563,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch#assertSubsetOfSameScores(Query,TopDocs,TopDocs).mjava","pathOld":"/dev/null","sourceNew":"    private void assertSubsetOfSameScores(Query q, TopDocs top1, TopDocs top2) {\n      // The constrained query\n      // should be a subset to the unconstrained query.\n      if (top2.totalHits > top1.totalHits) {\n        fail(\"Constrained results not a subset:\\n\"\n                      + CheckHits.topdocsString(top1,0,0)\n                      + CheckHits.topdocsString(top2,0,0)\n                      + \"for query:\" + q.toString());\n      }\n\n      for (int hit=0; hit<top2.totalHits; hit++) {\n        int id = top2.scoreDocs[hit].doc;\n        float score = top2.scoreDocs[hit].score;\n        boolean found=false;\n        // find this doc in other hits\n        for (int other=0; other<top1.totalHits; other++) {\n          if (top1.scoreDocs[other].doc == id) {\n            found=true;\n            float otherScore = top1.scoreDocs[other].score;\n            // check if scores match\n            assertEquals(\"Doc \" + id + \" scores don't match\\n\"\n                + CheckHits.topdocsString(top1,0,0)\n                + CheckHits.topdocsString(top2,0,0)\n                + \"for query:\" + q.toString(),\n                score, otherScore, CheckHits.explainToleranceDelta(score, otherScore));\n          }\n        }\n\n        // check if subset\n        if (!found) fail(\"Doc \" + id + \" not found\\n\"\n              + CheckHits.topdocsString(top1,0,0)\n              + CheckHits.topdocsString(top2,0,0)\n              + \"for query:\" + q.toString());\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch#assertSubsetOfSameScores(Query,TopDocs,TopDocs).mjava","pathOld":"/dev/null","sourceNew":"    private void assertSubsetOfSameScores(Query q, TopDocs top1, TopDocs top2) {\n      // The constrained query\n      // should be a subset to the unconstrained query.\n      if (top2.totalHits > top1.totalHits) {\n        fail(\"Constrained results not a subset:\\n\"\n                      + CheckHits.topdocsString(top1,0,0)\n                      + CheckHits.topdocsString(top2,0,0)\n                      + \"for query:\" + q.toString());\n      }\n\n      for (int hit=0; hit<top2.totalHits; hit++) {\n        int id = top2.scoreDocs[hit].doc;\n        float score = top2.scoreDocs[hit].score;\n        boolean found=false;\n        // find this doc in other hits\n        for (int other=0; other<top1.totalHits; other++) {\n          if (top1.scoreDocs[other].doc == id) {\n            found=true;\n            float otherScore = top1.scoreDocs[other].score;\n            // check if scores match\n            assertEquals(\"Doc \" + id + \" scores don't match\\n\"\n                + CheckHits.topdocsString(top1,0,0)\n                + CheckHits.topdocsString(top2,0,0)\n                + \"for query:\" + q.toString(),\n                score, otherScore, CheckHits.explainToleranceDelta(score, otherScore));\n          }\n        }\n\n        // check if subset\n        if (!found) fail(\"Doc \" + id + \" not found\\n\"\n              + CheckHits.topdocsString(top1,0,0)\n              + CheckHits.topdocsString(top2,0,0)\n              + \"for query:\" + q.toString());\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","date":1344867506,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch#assertSubsetOfSameScores(Query,TopDocs,TopDocs).mjava","pathOld":"/dev/null","sourceNew":"    private void assertSubsetOfSameScores(Query q, TopDocs top1, TopDocs top2) {\n      // The constrained query\n      // should be a subset to the unconstrained query.\n      if (top2.totalHits > top1.totalHits) {\n        fail(\"Constrained results not a subset:\\n\"\n                      + CheckHits.topdocsString(top1,0,0)\n                      + CheckHits.topdocsString(top2,0,0)\n                      + \"for query:\" + q.toString());\n      }\n\n      for (int hit=0; hit<top2.totalHits; hit++) {\n        int id = top2.scoreDocs[hit].doc;\n        float score = top2.scoreDocs[hit].score;\n        boolean found=false;\n        // find this doc in other hits\n        for (int other=0; other<top1.totalHits; other++) {\n          if (top1.scoreDocs[other].doc == id) {\n            found=true;\n            float otherScore = top1.scoreDocs[other].score;\n            // check if scores match\n            assertEquals(\"Doc \" + id + \" scores don't match\\n\"\n                + CheckHits.topdocsString(top1,0,0)\n                + CheckHits.topdocsString(top2,0,0)\n                + \"for query:\" + q.toString(),\n                score, otherScore, CheckHits.explainToleranceDelta(score, otherScore));\n          }\n        }\n\n        // check if subset\n        if (!found) fail(\"Doc \" + id + \" not found\\n\"\n              + CheckHits.topdocsString(top1,0,0)\n              + CheckHits.topdocsString(top2,0,0)\n              + \"for query:\" + q.toString());\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7732a106554be0db3e03ac5211e46f6e0c285b8","date":1511975378,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch#assertSubsetOfSameScores(Query,TopDocs,TopDocs).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch#assertSubsetOfSameScores(Query,TopDocs,TopDocs).mjava","sourceNew":"    private void assertSubsetOfSameScores(Query q, TopDocs top1, TopDocs top2) {\n      // The constrained query\n      // should be a subset to the unconstrained query.\n      if (top2.totalHits > top1.totalHits) {\n        fail(\"Constrained results not a subset:\\n\"\n                      + CheckHits.topdocsString(top1,0,0)\n                      + CheckHits.topdocsString(top2,0,0)\n                      + \"for query:\" + q.toString());\n      }\n\n      for (int hit=0; hit<top2.totalHits; hit++) {\n        int id = top2.scoreDocs[hit].doc;\n        float score = top2.scoreDocs[hit].score;\n        boolean found=false;\n        // find this doc in other hits\n        for (int other=0; other<top1.totalHits; other++) {\n          if (top1.scoreDocs[other].doc == id) {\n            found=true;\n            float otherScore = top1.scoreDocs[other].score;\n            // check if scores match\n            assertEquals(\"Doc \" + id + \" scores don't match\\n\"\n                + CheckHits.topdocsString(top1,0,0)\n                + CheckHits.topdocsString(top2,0,0)\n                + \"for query:\" + q.toString(),\n                score, otherScore, 0d);\n          }\n        }\n\n        // check if subset\n        if (!found) fail(\"Doc \" + id + \" not found\\n\"\n              + CheckHits.topdocsString(top1,0,0)\n              + CheckHits.topdocsString(top2,0,0)\n              + \"for query:\" + q.toString());\n      }\n    }\n\n","sourceOld":"    private void assertSubsetOfSameScores(Query q, TopDocs top1, TopDocs top2) {\n      // The constrained query\n      // should be a subset to the unconstrained query.\n      if (top2.totalHits > top1.totalHits) {\n        fail(\"Constrained results not a subset:\\n\"\n                      + CheckHits.topdocsString(top1,0,0)\n                      + CheckHits.topdocsString(top2,0,0)\n                      + \"for query:\" + q.toString());\n      }\n\n      for (int hit=0; hit<top2.totalHits; hit++) {\n        int id = top2.scoreDocs[hit].doc;\n        float score = top2.scoreDocs[hit].score;\n        boolean found=false;\n        // find this doc in other hits\n        for (int other=0; other<top1.totalHits; other++) {\n          if (top1.scoreDocs[other].doc == id) {\n            found=true;\n            float otherScore = top1.scoreDocs[other].score;\n            // check if scores match\n            assertEquals(\"Doc \" + id + \" scores don't match\\n\"\n                + CheckHits.topdocsString(top1,0,0)\n                + CheckHits.topdocsString(top2,0,0)\n                + \"for query:\" + q.toString(),\n                score, otherScore, CheckHits.explainToleranceDelta(score, otherScore));\n          }\n        }\n\n        // check if subset\n        if (!found) fail(\"Doc \" + id + \" not found\\n\"\n              + CheckHits.topdocsString(top1,0,0)\n              + CheckHits.topdocsString(top2,0,0)\n              + \"for query:\" + q.toString());\n      }\n    }\n\n","bugFix":null,"bugIntro":["6e97ad3b3c0d77cc9ec681ac22ddf2a024003bbc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch#assertSubsetOfSameScores(Query,TopDocs,TopDocs).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch#assertSubsetOfSameScores(Query,TopDocs,TopDocs).mjava","sourceNew":"    private void assertSubsetOfSameScores(Query q, TopDocs top1, TopDocs top2) {\n      // The constrained query\n      // should be a subset to the unconstrained query.\n      if (top2.totalHits > top1.totalHits) {\n        fail(\"Constrained results not a subset:\\n\"\n                      + CheckHits.topdocsString(top1,0,0)\n                      + CheckHits.topdocsString(top2,0,0)\n                      + \"for query:\" + q.toString());\n      }\n\n      for (int hit=0; hit<top2.totalHits; hit++) {\n        int id = top2.scoreDocs[hit].doc;\n        float score = top2.scoreDocs[hit].score;\n        boolean found=false;\n        // find this doc in other hits\n        for (int other=0; other<top1.totalHits; other++) {\n          if (top1.scoreDocs[other].doc == id) {\n            found=true;\n            float otherScore = top1.scoreDocs[other].score;\n            // check if scores match\n            assertEquals(\"Doc \" + id + \" scores don't match\\n\"\n                + CheckHits.topdocsString(top1,0,0)\n                + CheckHits.topdocsString(top2,0,0)\n                + \"for query:\" + q.toString(),\n                score, otherScore, 0d);\n          }\n        }\n\n        // check if subset\n        if (!found) fail(\"Doc \" + id + \" not found\\n\"\n              + CheckHits.topdocsString(top1,0,0)\n              + CheckHits.topdocsString(top2,0,0)\n              + \"for query:\" + q.toString());\n      }\n    }\n\n","sourceOld":"    private void assertSubsetOfSameScores(Query q, TopDocs top1, TopDocs top2) {\n      // The constrained query\n      // should be a subset to the unconstrained query.\n      if (top2.totalHits > top1.totalHits) {\n        fail(\"Constrained results not a subset:\\n\"\n                      + CheckHits.topdocsString(top1,0,0)\n                      + CheckHits.topdocsString(top2,0,0)\n                      + \"for query:\" + q.toString());\n      }\n\n      for (int hit=0; hit<top2.totalHits; hit++) {\n        int id = top2.scoreDocs[hit].doc;\n        float score = top2.scoreDocs[hit].score;\n        boolean found=false;\n        // find this doc in other hits\n        for (int other=0; other<top1.totalHits; other++) {\n          if (top1.scoreDocs[other].doc == id) {\n            found=true;\n            float otherScore = top1.scoreDocs[other].score;\n            // check if scores match\n            assertEquals(\"Doc \" + id + \" scores don't match\\n\"\n                + CheckHits.topdocsString(top1,0,0)\n                + CheckHits.topdocsString(top2,0,0)\n                + \"for query:\" + q.toString(),\n                score, otherScore, CheckHits.explainToleranceDelta(score, otherScore));\n          }\n        }\n\n        // check if subset\n        if (!found) fail(\"Doc \" + id + \" not found\\n\"\n              + CheckHits.topdocsString(top1,0,0)\n              + CheckHits.topdocsString(top2,0,0)\n              + \"for query:\" + q.toString());\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6e97ad3b3c0d77cc9ec681ac22ddf2a024003bbc","date":1512378875,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch#assertSubsetOfSameScores(Query,TopDocs,TopDocs).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch#assertSubsetOfSameScores(Query,TopDocs,TopDocs).mjava","sourceNew":"    private void assertSubsetOfSameScores(Query q, TopDocs top1, TopDocs top2) {\n      // The constrained query\n      // should be a subset to the unconstrained query.\n      if (top2.totalHits > top1.totalHits) {\n        fail(\"Constrained results not a subset:\\n\"\n                      + CheckHits.topdocsString(top1,0,0)\n                      + CheckHits.topdocsString(top2,0,0)\n                      + \"for query:\" + q.toString());\n      }\n\n      for (int hit=0; hit<top2.totalHits; hit++) {\n        int id = top2.scoreDocs[hit].doc;\n        float score = top2.scoreDocs[hit].score;\n        boolean found=false;\n        // find this doc in other hits\n        for (int other=0; other<top1.totalHits; other++) {\n          if (top1.scoreDocs[other].doc == id) {\n            found=true;\n            float otherScore = top1.scoreDocs[other].score;\n            // check if scores match\n            assertEquals(\"Doc \" + id + \" scores don't match\\n\"\n                + CheckHits.topdocsString(top1,0,0)\n                + CheckHits.topdocsString(top2,0,0)\n                + \"for query:\" + q.toString(),\n                score, otherScore,\n                // If there is at least one MUST/FILTER clause and if\n                // minShouldMatch is equal to the number of SHOULD clauses,\n                // then a query that was previously executed with\n                // ReqOptSumScorer is now executed with ConjunctionScorer.\n                // We need to introduce some leniency because ReqOptSumScorer\n                // casts intermediate values to floats before summing up again\n                // which hurts accuracy.\n                Math.ulp(score));\n          }\n        }\n\n        // check if subset\n        if (!found) fail(\"Doc \" + id + \" not found\\n\"\n              + CheckHits.topdocsString(top1,0,0)\n              + CheckHits.topdocsString(top2,0,0)\n              + \"for query:\" + q.toString());\n      }\n    }\n\n","sourceOld":"    private void assertSubsetOfSameScores(Query q, TopDocs top1, TopDocs top2) {\n      // The constrained query\n      // should be a subset to the unconstrained query.\n      if (top2.totalHits > top1.totalHits) {\n        fail(\"Constrained results not a subset:\\n\"\n                      + CheckHits.topdocsString(top1,0,0)\n                      + CheckHits.topdocsString(top2,0,0)\n                      + \"for query:\" + q.toString());\n      }\n\n      for (int hit=0; hit<top2.totalHits; hit++) {\n        int id = top2.scoreDocs[hit].doc;\n        float score = top2.scoreDocs[hit].score;\n        boolean found=false;\n        // find this doc in other hits\n        for (int other=0; other<top1.totalHits; other++) {\n          if (top1.scoreDocs[other].doc == id) {\n            found=true;\n            float otherScore = top1.scoreDocs[other].score;\n            // check if scores match\n            assertEquals(\"Doc \" + id + \" scores don't match\\n\"\n                + CheckHits.topdocsString(top1,0,0)\n                + CheckHits.topdocsString(top2,0,0)\n                + \"for query:\" + q.toString(),\n                score, otherScore, 0d);\n          }\n        }\n\n        // check if subset\n        if (!found) fail(\"Doc \" + id + \" not found\\n\"\n              + CheckHits.topdocsString(top1,0,0)\n              + CheckHits.topdocsString(top2,0,0)\n              + \"for query:\" + q.toString());\n      }\n    }\n\n","bugFix":["c7732a106554be0db3e03ac5211e46f6e0c285b8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch#assertSubsetOfSameScores(Query,TopDocs,TopDocs).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch#assertSubsetOfSameScores(Query,TopDocs,TopDocs).mjava","sourceNew":"    private void assertSubsetOfSameScores(Query q, TopDocs top1, TopDocs top2) {\n      // The constrained query\n      // should be a subset to the unconstrained query.\n      if (top2.totalHits.value > top1.totalHits.value) {\n        fail(\"Constrained results not a subset:\\n\"\n                      + CheckHits.topdocsString(top1,0,0)\n                      + CheckHits.topdocsString(top2,0,0)\n                      + \"for query:\" + q.toString());\n      }\n\n      for (int hit=0; hit<top2.totalHits.value; hit++) {\n        int id = top2.scoreDocs[hit].doc;\n        float score = top2.scoreDocs[hit].score;\n        boolean found=false;\n        // find this doc in other hits\n        for (int other=0; other<top1.totalHits.value; other++) {\n          if (top1.scoreDocs[other].doc == id) {\n            found=true;\n            float otherScore = top1.scoreDocs[other].score;\n            // check if scores match\n            assertEquals(\"Doc \" + id + \" scores don't match\\n\"\n                + CheckHits.topdocsString(top1,0,0)\n                + CheckHits.topdocsString(top2,0,0)\n                + \"for query:\" + q.toString(),\n                score, otherScore,\n                // If there is at least one MUST/FILTER clause and if\n                // minShouldMatch is equal to the number of SHOULD clauses,\n                // then a query that was previously executed with\n                // ReqOptSumScorer is now executed with ConjunctionScorer.\n                // We need to introduce some leniency because ReqOptSumScorer\n                // casts intermediate values to floats before summing up again\n                // which hurts accuracy.\n                Math.ulp(score));\n          }\n        }\n\n        // check if subset\n        if (!found) fail(\"Doc \" + id + \" not found\\n\"\n              + CheckHits.topdocsString(top1,0,0)\n              + CheckHits.topdocsString(top2,0,0)\n              + \"for query:\" + q.toString());\n      }\n    }\n\n","sourceOld":"    private void assertSubsetOfSameScores(Query q, TopDocs top1, TopDocs top2) {\n      // The constrained query\n      // should be a subset to the unconstrained query.\n      if (top2.totalHits > top1.totalHits) {\n        fail(\"Constrained results not a subset:\\n\"\n                      + CheckHits.topdocsString(top1,0,0)\n                      + CheckHits.topdocsString(top2,0,0)\n                      + \"for query:\" + q.toString());\n      }\n\n      for (int hit=0; hit<top2.totalHits; hit++) {\n        int id = top2.scoreDocs[hit].doc;\n        float score = top2.scoreDocs[hit].score;\n        boolean found=false;\n        // find this doc in other hits\n        for (int other=0; other<top1.totalHits; other++) {\n          if (top1.scoreDocs[other].doc == id) {\n            found=true;\n            float otherScore = top1.scoreDocs[other].score;\n            // check if scores match\n            assertEquals(\"Doc \" + id + \" scores don't match\\n\"\n                + CheckHits.topdocsString(top1,0,0)\n                + CheckHits.topdocsString(top2,0,0)\n                + \"for query:\" + q.toString(),\n                score, otherScore,\n                // If there is at least one MUST/FILTER clause and if\n                // minShouldMatch is equal to the number of SHOULD clauses,\n                // then a query that was previously executed with\n                // ReqOptSumScorer is now executed with ConjunctionScorer.\n                // We need to introduce some leniency because ReqOptSumScorer\n                // casts intermediate values to floats before summing up again\n                // which hurts accuracy.\n                Math.ulp(score));\n          }\n        }\n\n        // check if subset\n        if (!found) fail(\"Doc \" + id + \" not found\\n\"\n              + CheckHits.topdocsString(top1,0,0)\n              + CheckHits.topdocsString(top2,0,0)\n              + \"for query:\" + q.toString());\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7732a106554be0db3e03ac5211e46f6e0c285b8":["af549b45614d869371e17e0b5b4ca47535d552c0"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["af549b45614d869371e17e0b5b4ca47535d552c0","c7732a106554be0db3e03ac5211e46f6e0c285b8"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","af549b45614d869371e17e0b5b4ca47535d552c0"],"6e97ad3b3c0d77cc9ec681ac22ddf2a024003bbc":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"83788ad129a5154d5c6562c4e8ce3db48793aada":["6e97ad3b3c0d77cc9ec681ac22ddf2a024003bbc"],"af549b45614d869371e17e0b5b4ca47535d552c0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","af549b45614d869371e17e0b5b4ca47535d552c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["83788ad129a5154d5c6562c4e8ce3db48793aada"]},"commit2Childs":{"c7732a106554be0db3e03ac5211e46f6e0c285b8":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["6e97ad3b3c0d77cc9ec681ac22ddf2a024003bbc"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"6e97ad3b3c0d77cc9ec681ac22ddf2a024003bbc":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c7869f64c874ebf7f317d22c00baf2b6857797a6","af549b45614d869371e17e0b5b4ca47535d552c0","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"af549b45614d869371e17e0b5b4ca47535d552c0":["c7732a106554be0db3e03ac5211e46f6e0c285b8","1aad05eeff7818b0833c02ac6b743aa72054963b","c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}