{"path":"lucene/core/src/test/org/apache/lucene/util/TestSmallFloat#testFloatToByte().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestSmallFloat#testFloatToByte().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestSmallFloat#testFloatToByte().mjava","sourceNew":"  public void testFloatToByte() {\n    assertEquals(0, orig_floatToByte_v13(5.8123817E-10f));       // verify the old bug (see LUCENE-2937)\n    assertEquals(1, orig_floatToByte(5.8123817E-10f));           // verify it's fixed in this test code\n    assertEquals(1, SmallFloat.floatToByte315(5.8123817E-10f));  // verify it's fixed\n\n    // test some constants\n    assertEquals(0, SmallFloat.floatToByte315(0));\n    assertEquals(1, SmallFloat.floatToByte315(Float.MIN_VALUE));             // underflow rounds up to smallest positive\n    assertEquals(255, SmallFloat.floatToByte315(Float.MAX_VALUE) & 0xff);    // overflow rounds down to largest positive\n    assertEquals(255, SmallFloat.floatToByte315(Float.POSITIVE_INFINITY) & 0xff);\n\n    // all negatives map to 0\n    assertEquals(0, SmallFloat.floatToByte315(-Float.MIN_VALUE));\n    assertEquals(0, SmallFloat.floatToByte315(-Float.MAX_VALUE));\n    assertEquals(0, SmallFloat.floatToByte315(Float.NEGATIVE_INFINITY));\n\n\n    // up iterations for more exhaustive test after changing something\n    int num = atLeast(100000);\n    for (int i = 0; i < num; i++) {\n      float f = Float.intBitsToFloat(random.nextInt());\n      if (Float.isNaN(f)) continue;    // skip NaN\n      byte b1 = orig_floatToByte(f);\n      byte b2 = SmallFloat.floatToByte(f,3,15);\n      byte b3 = SmallFloat.floatToByte315(f);\n      assertEquals(b1,b2);\n      assertEquals(b2,b3);\n\n      byte b4 = SmallFloat.floatToByte(f,5,2);\n      byte b5 = SmallFloat.floatToByte52(f);\n      assertEquals(b4,b5);\n    }\n  }\n\n","sourceOld":"  public void testFloatToByte() {\n    assertEquals(0, orig_floatToByte_v13(5.8123817E-10f));       // verify the old bug (see LUCENE-2937)\n    assertEquals(1, orig_floatToByte(5.8123817E-10f));           // verify it's fixed in this test code\n    assertEquals(1, SmallFloat.floatToByte315(5.8123817E-10f));  // verify it's fixed\n\n    // test some constants\n    assertEquals(0, SmallFloat.floatToByte315(0));\n    assertEquals(1, SmallFloat.floatToByte315(Float.MIN_VALUE));             // underflow rounds up to smallest positive\n    assertEquals(255, SmallFloat.floatToByte315(Float.MAX_VALUE) & 0xff);    // overflow rounds down to largest positive\n    assertEquals(255, SmallFloat.floatToByte315(Float.POSITIVE_INFINITY) & 0xff);\n\n    // all negatives map to 0\n    assertEquals(0, SmallFloat.floatToByte315(-Float.MIN_VALUE));\n    assertEquals(0, SmallFloat.floatToByte315(-Float.MAX_VALUE));\n    assertEquals(0, SmallFloat.floatToByte315(Float.NEGATIVE_INFINITY));\n\n\n    // up iterations for more exhaustive test after changing something\n    int num = atLeast(100000);\n    for (int i = 0; i < num; i++) {\n      float f = Float.intBitsToFloat(random.nextInt());\n      if (Float.isNaN(f)) continue;    // skip NaN\n      byte b1 = orig_floatToByte(f);\n      byte b2 = SmallFloat.floatToByte(f,3,15);\n      byte b3 = SmallFloat.floatToByte315(f);\n      assertEquals(b1,b2);\n      assertEquals(b2,b3);\n\n      byte b4 = SmallFloat.floatToByte(f,5,2);\n      byte b5 = SmallFloat.floatToByte52(f);\n      assertEquals(b4,b5);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestSmallFloat#testFloatToByte().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestSmallFloat#testFloatToByte().mjava","sourceNew":"  public void testFloatToByte() {\n    assertEquals(0, orig_floatToByte_v13(5.8123817E-10f));       // verify the old bug (see LUCENE-2937)\n    assertEquals(1, orig_floatToByte(5.8123817E-10f));           // verify it's fixed in this test code\n    assertEquals(1, SmallFloat.floatToByte315(5.8123817E-10f));  // verify it's fixed\n\n    // test some constants\n    assertEquals(0, SmallFloat.floatToByte315(0));\n    assertEquals(1, SmallFloat.floatToByte315(Float.MIN_VALUE));             // underflow rounds up to smallest positive\n    assertEquals(255, SmallFloat.floatToByte315(Float.MAX_VALUE) & 0xff);    // overflow rounds down to largest positive\n    assertEquals(255, SmallFloat.floatToByte315(Float.POSITIVE_INFINITY) & 0xff);\n\n    // all negatives map to 0\n    assertEquals(0, SmallFloat.floatToByte315(-Float.MIN_VALUE));\n    assertEquals(0, SmallFloat.floatToByte315(-Float.MAX_VALUE));\n    assertEquals(0, SmallFloat.floatToByte315(Float.NEGATIVE_INFINITY));\n\n\n    // up iterations for more exhaustive test after changing something\n    int num = atLeast(100000);\n    for (int i = 0; i < num; i++) {\n      float f = Float.intBitsToFloat(random().nextInt());\n      if (Float.isNaN(f)) continue;    // skip NaN\n      byte b1 = orig_floatToByte(f);\n      byte b2 = SmallFloat.floatToByte(f,3,15);\n      byte b3 = SmallFloat.floatToByte315(f);\n      assertEquals(b1,b2);\n      assertEquals(b2,b3);\n\n      byte b4 = SmallFloat.floatToByte(f,5,2);\n      byte b5 = SmallFloat.floatToByte52(f);\n      assertEquals(b4,b5);\n    }\n  }\n\n","sourceOld":"  public void testFloatToByte() {\n    assertEquals(0, orig_floatToByte_v13(5.8123817E-10f));       // verify the old bug (see LUCENE-2937)\n    assertEquals(1, orig_floatToByte(5.8123817E-10f));           // verify it's fixed in this test code\n    assertEquals(1, SmallFloat.floatToByte315(5.8123817E-10f));  // verify it's fixed\n\n    // test some constants\n    assertEquals(0, SmallFloat.floatToByte315(0));\n    assertEquals(1, SmallFloat.floatToByte315(Float.MIN_VALUE));             // underflow rounds up to smallest positive\n    assertEquals(255, SmallFloat.floatToByte315(Float.MAX_VALUE) & 0xff);    // overflow rounds down to largest positive\n    assertEquals(255, SmallFloat.floatToByte315(Float.POSITIVE_INFINITY) & 0xff);\n\n    // all negatives map to 0\n    assertEquals(0, SmallFloat.floatToByte315(-Float.MIN_VALUE));\n    assertEquals(0, SmallFloat.floatToByte315(-Float.MAX_VALUE));\n    assertEquals(0, SmallFloat.floatToByte315(Float.NEGATIVE_INFINITY));\n\n\n    // up iterations for more exhaustive test after changing something\n    int num = atLeast(100000);\n    for (int i = 0; i < num; i++) {\n      float f = Float.intBitsToFloat(random.nextInt());\n      if (Float.isNaN(f)) continue;    // skip NaN\n      byte b1 = orig_floatToByte(f);\n      byte b2 = SmallFloat.floatToByte(f,3,15);\n      byte b3 = SmallFloat.floatToByte315(f);\n      assertEquals(b1,b2);\n      assertEquals(b2,b3);\n\n      byte b4 = SmallFloat.floatToByte(f,5,2);\n      byte b5 = SmallFloat.floatToByte52(f);\n      assertEquals(b4,b5);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615370d2b876c3435773b5174df2e2242ad7981a","date":1495117651,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestSmallFloat#testFloatToByte().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestSmallFloat#testFloatToByte().mjava","sourceNew":"  public void testFloatToByte() {\n    assertEquals(0, orig_floatToByte_v13(5.8123817E-10f));       // verify the old bug (see LUCENE-2937)\n    assertEquals(1, orig_floatToByte(5.8123817E-10f));           // verify it's fixed in this test code\n    assertEquals(1, SmallFloat.floatToByte315(5.8123817E-10f));  // verify it's fixed\n\n    // test some constants\n    assertEquals(0, SmallFloat.floatToByte315(0));\n    assertEquals(1, SmallFloat.floatToByte315(Float.MIN_VALUE));             // underflow rounds up to smallest positive\n    assertEquals(255, SmallFloat.floatToByte315(Float.MAX_VALUE) & 0xff);    // overflow rounds down to largest positive\n    assertEquals(255, SmallFloat.floatToByte315(Float.POSITIVE_INFINITY) & 0xff);\n\n    // all negatives map to 0\n    assertEquals(0, SmallFloat.floatToByte315(-Float.MIN_VALUE));\n    assertEquals(0, SmallFloat.floatToByte315(-Float.MAX_VALUE));\n    assertEquals(0, SmallFloat.floatToByte315(Float.NEGATIVE_INFINITY));\n\n\n    // up iterations for more exhaustive test after changing something\n    int num = atLeast(100000);\n    for (int i = 0; i < num; i++) {\n      float f = Float.intBitsToFloat(random().nextInt());\n      if (Float.isNaN(f)) continue;    // skip NaN\n      byte b1 = orig_floatToByte(f);\n      byte b2 = SmallFloat.floatToByte(f,3,15);\n      byte b3 = SmallFloat.floatToByte315(f);\n      assertEquals(b1,b2);\n      assertEquals(b2,b3);\n    }\n  }\n\n","sourceOld":"  public void testFloatToByte() {\n    assertEquals(0, orig_floatToByte_v13(5.8123817E-10f));       // verify the old bug (see LUCENE-2937)\n    assertEquals(1, orig_floatToByte(5.8123817E-10f));           // verify it's fixed in this test code\n    assertEquals(1, SmallFloat.floatToByte315(5.8123817E-10f));  // verify it's fixed\n\n    // test some constants\n    assertEquals(0, SmallFloat.floatToByte315(0));\n    assertEquals(1, SmallFloat.floatToByte315(Float.MIN_VALUE));             // underflow rounds up to smallest positive\n    assertEquals(255, SmallFloat.floatToByte315(Float.MAX_VALUE) & 0xff);    // overflow rounds down to largest positive\n    assertEquals(255, SmallFloat.floatToByte315(Float.POSITIVE_INFINITY) & 0xff);\n\n    // all negatives map to 0\n    assertEquals(0, SmallFloat.floatToByte315(-Float.MIN_VALUE));\n    assertEquals(0, SmallFloat.floatToByte315(-Float.MAX_VALUE));\n    assertEquals(0, SmallFloat.floatToByte315(Float.NEGATIVE_INFINITY));\n\n\n    // up iterations for more exhaustive test after changing something\n    int num = atLeast(100000);\n    for (int i = 0; i < num; i++) {\n      float f = Float.intBitsToFloat(random().nextInt());\n      if (Float.isNaN(f)) continue;    // skip NaN\n      byte b1 = orig_floatToByte(f);\n      byte b2 = SmallFloat.floatToByte(f,3,15);\n      byte b3 = SmallFloat.floatToByte315(f);\n      assertEquals(b1,b2);\n      assertEquals(b2,b3);\n\n      byte b4 = SmallFloat.floatToByte(f,5,2);\n      byte b5 = SmallFloat.floatToByte52(f);\n      assertEquals(b4,b5);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestSmallFloat#testFloatToByte().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestSmallFloat#testFloatToByte().mjava","sourceNew":"  public void testFloatToByte() {\n    assertEquals(0, orig_floatToByte_v13(5.8123817E-10f));       // verify the old bug (see LUCENE-2937)\n    assertEquals(1, orig_floatToByte(5.8123817E-10f));           // verify it's fixed in this test code\n    assertEquals(1, SmallFloat.floatToByte315(5.8123817E-10f));  // verify it's fixed\n\n    // test some constants\n    assertEquals(0, SmallFloat.floatToByte315(0));\n    assertEquals(1, SmallFloat.floatToByte315(Float.MIN_VALUE));             // underflow rounds up to smallest positive\n    assertEquals(255, SmallFloat.floatToByte315(Float.MAX_VALUE) & 0xff);    // overflow rounds down to largest positive\n    assertEquals(255, SmallFloat.floatToByte315(Float.POSITIVE_INFINITY) & 0xff);\n\n    // all negatives map to 0\n    assertEquals(0, SmallFloat.floatToByte315(-Float.MIN_VALUE));\n    assertEquals(0, SmallFloat.floatToByte315(-Float.MAX_VALUE));\n    assertEquals(0, SmallFloat.floatToByte315(Float.NEGATIVE_INFINITY));\n\n\n    // up iterations for more exhaustive test after changing something\n    int num = atLeast(100000);\n    for (int i = 0; i < num; i++) {\n      float f = Float.intBitsToFloat(random().nextInt());\n      if (Float.isNaN(f)) continue;    // skip NaN\n      byte b1 = orig_floatToByte(f);\n      byte b2 = SmallFloat.floatToByte(f,3,15);\n      byte b3 = SmallFloat.floatToByte315(f);\n      assertEquals(b1,b2);\n      assertEquals(b2,b3);\n    }\n  }\n\n","sourceOld":"  public void testFloatToByte() {\n    assertEquals(0, orig_floatToByte_v13(5.8123817E-10f));       // verify the old bug (see LUCENE-2937)\n    assertEquals(1, orig_floatToByte(5.8123817E-10f));           // verify it's fixed in this test code\n    assertEquals(1, SmallFloat.floatToByte315(5.8123817E-10f));  // verify it's fixed\n\n    // test some constants\n    assertEquals(0, SmallFloat.floatToByte315(0));\n    assertEquals(1, SmallFloat.floatToByte315(Float.MIN_VALUE));             // underflow rounds up to smallest positive\n    assertEquals(255, SmallFloat.floatToByte315(Float.MAX_VALUE) & 0xff);    // overflow rounds down to largest positive\n    assertEquals(255, SmallFloat.floatToByte315(Float.POSITIVE_INFINITY) & 0xff);\n\n    // all negatives map to 0\n    assertEquals(0, SmallFloat.floatToByte315(-Float.MIN_VALUE));\n    assertEquals(0, SmallFloat.floatToByte315(-Float.MAX_VALUE));\n    assertEquals(0, SmallFloat.floatToByte315(Float.NEGATIVE_INFINITY));\n\n\n    // up iterations for more exhaustive test after changing something\n    int num = atLeast(100000);\n    for (int i = 0; i < num; i++) {\n      float f = Float.intBitsToFloat(random().nextInt());\n      if (Float.isNaN(f)) continue;    // skip NaN\n      byte b1 = orig_floatToByte(f);\n      byte b2 = SmallFloat.floatToByte(f,3,15);\n      byte b3 = SmallFloat.floatToByte315(f);\n      assertEquals(b1,b2);\n      assertEquals(b2,b3);\n\n      byte b4 = SmallFloat.floatToByte(f,5,2);\n      byte b5 = SmallFloat.floatToByte52(f);\n      assertEquals(b4,b5);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","615370d2b876c3435773b5174df2e2242ad7981a"],"615370d2b876c3435773b5174df2e2242ad7981a":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["615370d2b876c3435773b5174df2e2242ad7981a"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"615370d2b876c3435773b5174df2e2242ad7981a":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["e9017cf144952056066919f1ebc7897ff9bd71b1","615370d2b876c3435773b5174df2e2242ad7981a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}