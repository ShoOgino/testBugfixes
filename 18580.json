{"path":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","commits":[{"id":"91109046a59c58ee0ee5d0d2767b08d1f30d6702","date":1000830588,"type":0,"author":"Jason van Zyl","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"/dev/null","sourceNew":"  /** Flushes all changes to an index, closes all associated files, and closes\n    the directory that the index is stored in. */\n  public final synchronized void close() throws IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    directory.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["328c1568e471f0c6eaa49ec00334ca59e573710f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a10198efba39d45c46f8714efe9a15616f9c79d","date":1001608022,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /** Flushes all changes to an index, closes all associated files, and closes\n    the directory that the index is stored in. */\n  public final synchronized void close() throws IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    directory.makeLock(\"write.lock\").release();  // release write lock\n    directory.close();\n  }\n\n","sourceOld":"  /** Flushes all changes to an index, closes all associated files, and closes\n    the directory that the index is stored in. */\n  public final synchronized void close() throws IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3fb2e14da294a8c919c6356cbbc8049158c368a7","date":1013197182,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /** Flushes all changes to an index, closes all associated files, and closes\n    the directory that the index is stored in. */\n  public final synchronized void close() throws IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    writeLock.release();                          // release write lock\n    writeLock = null;\n    directory.close();\n  }\n\n","sourceOld":"  /** Flushes all changes to an index, closes all associated files, and closes\n    the directory that the index is stored in. */\n  public final synchronized void close() throws IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    directory.makeLock(\"write.lock\").release();  // release write lock\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9c7454619ea6a0710272c1dd947345cee64489f6","date":1026927484,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /** Flushes all changes to an index, closes all associated files, and closes\n    the directory that the index is stored in. */\n  public synchronized void close() throws IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    writeLock.release();                          // release write lock\n    writeLock = null;\n    directory.close();\n  }\n\n","sourceOld":"  /** Flushes all changes to an index, closes all associated files, and closes\n    the directory that the index is stored in. */\n  public final synchronized void close() throws IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    writeLock.release();                          // release write lock\n    writeLock = null;\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":["1b54a9bc667895a2095a886184bf69a3179e63df"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"42a7d0b384f0022c5a29e562b809ebf73991d7e6","date":1082489615,"type":3,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /** Flushes all changes to an index and closes all associated files. */\n  public synchronized void close() throws IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    writeLock.release();                          // release write lock\n    writeLock = null;\n    if(closeDir)\n      directory.close();\n  }\n\n","sourceOld":"  /** Flushes all changes to an index, closes all associated files, and closes\n    the directory that the index is stored in. */\n  public synchronized void close() throws IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    writeLock.release();                          // release write lock\n    writeLock = null;\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":["328c1568e471f0c6eaa49ec00334ca59e573710f","5a664b1395d4341b88e32d36297d7670f1a665ac"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb1981e606f66dba202e9c48f6bd4f108f022586","date":1101760861,"type":3,"author":"Bernhard Messer","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /** Flushes all changes to an index and closes all associated files. */\n  public synchronized void close() throws IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    if (writeLock != null) {\n      writeLock.release();                          // release write lock\n      writeLock = null;\n    }\n    if(closeDir)\n      directory.close();\n  }\n\n","sourceOld":"  /** Flushes all changes to an index and closes all associated files. */\n  public synchronized void close() throws IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    writeLock.release();                          // release write lock\n    writeLock = null;\n    if(closeDir)\n      directory.close();\n  }\n\n","bugFix":null,"bugIntro":["328c1568e471f0c6eaa49ec00334ca59e573710f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1507a324c1f939ed71e01297733a49b9c36e5688","date":1155783141,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /** Flushes all changes to an index and closes all associated files. */\n  public synchronized void close() throws IOException {\n    flushRamSegments();\n    // testInvariants();\n    ramDirectory.close();\n    if (writeLock != null) {\n      writeLock.release();                          // release write lock\n      writeLock = null;\n    }\n    if(closeDir)\n      directory.close();\n  }\n\n","sourceOld":"  /** Flushes all changes to an index and closes all associated files. */\n  public synchronized void close() throws IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    if (writeLock != null) {\n      writeLock.release();                          // release write lock\n      writeLock = null;\n    }\n    if(closeDir)\n      directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d7052f725a053aa55424f966831826f61b798bf1","date":1158258681,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /** Flushes all changes to an index and closes all associated files. */\n  public synchronized void close() throws IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    if (writeLock != null) {\n      writeLock.release();                          // release write lock\n      writeLock = null;\n    }\n    if(closeDir)\n      directory.close();\n  }\n\n","sourceOld":"  /** Flushes all changes to an index and closes all associated files. */\n  public synchronized void close() throws IOException {\n    flushRamSegments();\n    // testInvariants();\n    ramDirectory.close();\n    if (writeLock != null) {\n      writeLock.release();                          // release write lock\n      writeLock = null;\n    }\n    if(closeDir)\n      directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5a664b1395d4341b88e32d36297d7670f1a665ac","date":1166527887,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /**\n   * Flushes all changes to an index and closes all\n   * associated files.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexReader.isLocked(directory)) {\n   *     IndexReader.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   */\n  public synchronized void close() throws IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    if (writeLock != null) {\n      writeLock.release();                          // release write lock\n      writeLock = null;\n    }\n    if(closeDir)\n      directory.close();\n  }\n\n","sourceOld":"  /** Flushes all changes to an index and closes all associated files. */\n  public synchronized void close() throws IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    if (writeLock != null) {\n      writeLock.release();                          // release write lock\n      writeLock = null;\n    }\n    if(closeDir)\n      directory.close();\n  }\n\n","bugFix":["42a7d0b384f0022c5a29e562b809ebf73991d7e6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b54a9bc667895a2095a886184bf69a3179e63df","date":1172088096,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /**\n   * Flushes all changes to an index and closes all\n   * associated files.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexReader.isLocked(directory)) {\n   *     IndexReader.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public synchronized void close() throws CorruptIndexException, IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    if (writeLock != null) {\n      writeLock.release();                          // release write lock\n      writeLock = null;\n    }\n    if(closeDir)\n      directory.close();\n  }\n\n","sourceOld":"  /**\n   * Flushes all changes to an index and closes all\n   * associated files.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexReader.isLocked(directory)) {\n   *     IndexReader.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   */\n  public synchronized void close() throws IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    if (writeLock != null) {\n      writeLock.release();                          // release write lock\n      writeLock = null;\n    }\n    if(closeDir)\n      directory.close();\n  }\n\n","bugFix":["9c7454619ea6a0710272c1dd947345cee64489f6"],"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8b6187898fc4413ccd18229711786550a280383c","date":1173776782,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /**\n   * Flushes all changes to an index and closes all\n   * associated files.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexReader.isLocked(directory)) {\n   *     IndexReader.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public synchronized void close() throws CorruptIndexException, IOException {\n    flushRamSegments();\n\n    if (commitPending) {\n      segmentInfos.write(directory);         // now commit changes\n      deleter.checkpoint(segmentInfos, true);\n      commitPending = false;\n      rollbackSegmentInfos = null;\n    }\n\n    ramDirectory.close();\n    if (writeLock != null) {\n      writeLock.release();                          // release write lock\n      writeLock = null;\n    }\n    if(closeDir)\n      directory.close();\n  }\n\n","sourceOld":"  /**\n   * Flushes all changes to an index and closes all\n   * associated files.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexReader.isLocked(directory)) {\n   *     IndexReader.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public synchronized void close() throws CorruptIndexException, IOException {\n    flushRamSegments();\n    ramDirectory.close();\n    if (writeLock != null) {\n      writeLock.release();                          // release write lock\n      writeLock = null;\n    }\n    if(closeDir)\n      directory.close();\n  }\n\n","bugFix":null,"bugIntro":["328c1568e471f0c6eaa49ec00334ca59e573710f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"328c1568e471f0c6eaa49ec00334ca59e573710f","date":1173897963,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /**\n   * Flushes all changes to an index and closes all\n   * associated files.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexReader.isLocked(directory)) {\n   *     IndexReader.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public synchronized void close() throws CorruptIndexException, IOException {\n    if (!closed) {\n      flushRamSegments();\n\n      if (commitPending) {\n        segmentInfos.write(directory);         // now commit changes\n        deleter.checkpoint(segmentInfos, true);\n        commitPending = false;\n        rollbackSegmentInfos = null;\n      }\n\n      ramDirectory.close();\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      closed = true;\n\n      if(closeDir)\n        directory.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Flushes all changes to an index and closes all\n   * associated files.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexReader.isLocked(directory)) {\n   *     IndexReader.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public synchronized void close() throws CorruptIndexException, IOException {\n    flushRamSegments();\n\n    if (commitPending) {\n      segmentInfos.write(directory);         // now commit changes\n      deleter.checkpoint(segmentInfos, true);\n      commitPending = false;\n      rollbackSegmentInfos = null;\n    }\n\n    ramDirectory.close();\n    if (writeLock != null) {\n      writeLock.release();                          // release write lock\n      writeLock = null;\n    }\n    if(closeDir)\n      directory.close();\n  }\n\n","bugFix":["91109046a59c58ee0ee5d0d2767b08d1f30d6702","8b6187898fc4413ccd18229711786550a280383c","fb1981e606f66dba202e9c48f6bd4f108f022586","42a7d0b384f0022c5a29e562b809ebf73991d7e6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4350b17bd363cd13a95171b8df1ca62ea4c3e71c","date":1183562198,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /**\n   * Flushes all changes to an index and closes all\n   * associated files.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexReader.isLocked(directory)) {\n   *     IndexReader.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public synchronized void close() throws CorruptIndexException, IOException {\n    if (!closed) {\n      flush(true, true);\n\n      if (commitPending) {\n        segmentInfos.write(directory);         // now commit changes\n        deleter.checkpoint(segmentInfos, true);\n        commitPending = false;\n        rollbackSegmentInfos = null;\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      closed = true;\n      docWriter = null;\n\n      if(closeDir)\n        directory.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Flushes all changes to an index and closes all\n   * associated files.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexReader.isLocked(directory)) {\n   *     IndexReader.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public synchronized void close() throws CorruptIndexException, IOException {\n    if (!closed) {\n      flushRamSegments();\n\n      if (commitPending) {\n        segmentInfos.write(directory);         // now commit changes\n        deleter.checkpoint(segmentInfos, true);\n        commitPending = false;\n        rollbackSegmentInfos = null;\n      }\n\n      ramDirectory.close();\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      closed = true;\n\n      if(closeDir)\n        directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc11e5e2e108e6cdd85ae2693383a15f41cbf35","date":1186166482,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /**\n   * Flushes all changes to an index and closes all\n   * associated files.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexReader.isLocked(directory)) {\n   *     IndexReader.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public synchronized void close() throws CorruptIndexException, IOException {\n    if (!closed) {\n      flush(true, true);\n\n      if (commitPending) {\n        segmentInfos.write(directory);         // now commit changes\n        if (infoStream != null)\n          infoStream.println(\"close: wrote segments file \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"\");\n        deleter.checkpoint(segmentInfos, true);\n        commitPending = false;\n        rollbackSegmentInfos = null;\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      closed = true;\n      docWriter = null;\n\n      if(closeDir)\n        directory.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Flushes all changes to an index and closes all\n   * associated files.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexReader.isLocked(directory)) {\n   *     IndexReader.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public synchronized void close() throws CorruptIndexException, IOException {\n    if (!closed) {\n      flush(true, true);\n\n      if (commitPending) {\n        segmentInfos.write(directory);         // now commit changes\n        deleter.checkpoint(segmentInfos, true);\n        commitPending = false;\n        rollbackSegmentInfos = null;\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      closed = true;\n      docWriter = null;\n\n      if(closeDir)\n        directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b1405362241b561f5590ff4a87d5d6e173bcd9cf","date":1190107634,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /**\n   * Flushes all changes to an index and closes all\n   * associated files.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexReader.isLocked(directory)) {\n   *     IndexReader.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public void close() throws CorruptIndexException, IOException {\n    close(true);\n  }\n\n","sourceOld":"  /**\n   * Flushes all changes to an index and closes all\n   * associated files.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexReader.isLocked(directory)) {\n   *     IndexReader.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public synchronized void close() throws CorruptIndexException, IOException {\n    if (!closed) {\n      flush(true, true);\n\n      if (commitPending) {\n        segmentInfos.write(directory);         // now commit changes\n        if (infoStream != null)\n          infoStream.println(\"close: wrote segments file \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"\");\n        deleter.checkpoint(segmentInfos, true);\n        commitPending = false;\n        rollbackSegmentInfos = null;\n      }\n\n      if (writeLock != null) {\n        writeLock.release();                          // release write lock\n        writeLock = null;\n      }\n      closed = true;\n      docWriter = null;\n\n      if(closeDir)\n        directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e82780afe6097066eb5befb86e9432f077667e3d","date":1202756169,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /**\n   * Commits all changes to an index and closes all\n   * associated files.  Note that this may be a costly\n   * operation, so, try to re-use a single writer instead of\n   * closing and opening a new one.  See {@link #commit} for\n   * caveats about write caching done by some IO devices.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexReader.isLocked(directory)) {\n   *     IndexReader.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public void close() throws CorruptIndexException, IOException {\n    close(true);\n  }\n\n","sourceOld":"  /**\n   * Flushes all changes to an index and closes all\n   * associated files.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexReader.isLocked(directory)) {\n   *     IndexReader.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public void close() throws CorruptIndexException, IOException {\n    close(true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"84acdfa12c18361ff932244db20470fce117e52d","date":1206384355,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /**\n   * Commits all changes to an index and closes all\n   * associated files.  Note that this may be a costly\n   * operation, so, try to re-use a single writer instead of\n   * closing and opening a new one.  See {@link #commit} for\n   * caveats about write caching done by some IO devices.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexWriter.isLocked(directory)) {\n   *     IndexWriter.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public void close() throws CorruptIndexException, IOException {\n    close(true);\n  }\n\n","sourceOld":"  /**\n   * Commits all changes to an index and closes all\n   * associated files.  Note that this may be a costly\n   * operation, so, try to re-use a single writer instead of\n   * closing and opening a new one.  See {@link #commit} for\n   * caveats about write caching done by some IO devices.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexReader.isLocked(directory)) {\n   *     IndexReader.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public void close() throws CorruptIndexException, IOException {\n    close(true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05ec4e7e3569b6c85ac07e8813a5d5ed5d1ef6dc","date":1221503613,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /**\n   * Commits all changes to an index and closes all\n   * associated files.  Note that this may be a costly\n   * operation, so, try to re-use a single writer instead of\n   * closing and opening a new one.  See {@link #commit()} for\n   * caveats about write caching done by some IO devices.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexWriter.isLocked(directory)) {\n   *     IndexWriter.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public void close() throws CorruptIndexException, IOException {\n    close(true);\n  }\n\n","sourceOld":"  /**\n   * Commits all changes to an index and closes all\n   * associated files.  Note that this may be a costly\n   * operation, so, try to re-use a single writer instead of\n   * closing and opening a new one.  See {@link #commit} for\n   * caveats about write caching done by some IO devices.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexWriter.isLocked(directory)) {\n   *     IndexWriter.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public void close() throws CorruptIndexException, IOException {\n    close(true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9665d17707cc21b1db995118ff36129723139ab","date":1225384420,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /**\n   * Commits all changes to an index and closes all\n   * associated files.  Note that this may be a costly\n   * operation, so, try to re-use a single writer instead of\n   * closing and opening a new one.  See {@link #commit()} for\n   * caveats about write caching done by some IO devices.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexWriter.isLocked(directory)) {\n   *     IndexWriter.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer, again.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public void close() throws CorruptIndexException, IOException {\n    close(true);\n  }\n\n","sourceOld":"  /**\n   * Commits all changes to an index and closes all\n   * associated files.  Note that this may be a costly\n   * operation, so, try to re-use a single writer instead of\n   * closing and opening a new one.  See {@link #commit()} for\n   * caveats about write caching done by some IO devices.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexWriter.isLocked(directory)) {\n   *     IndexWriter.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public void close() throws CorruptIndexException, IOException {\n    close(true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#close().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close().mjava","sourceNew":"  /**\n   * Commits all changes to an index and closes all\n   * associated files.  Note that this may be a costly\n   * operation, so, try to re-use a single writer instead of\n   * closing and opening a new one.  See {@link #commit()} for\n   * caveats about write caching done by some IO devices.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexWriter.isLocked(directory)) {\n   *     IndexWriter.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer, again.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public void close() throws CorruptIndexException, IOException {\n    close(true);\n  }\n\n","sourceOld":"  /**\n   * Commits all changes to an index and closes all\n   * associated files.  Note that this may be a costly\n   * operation, so, try to re-use a single writer instead of\n   * closing and opening a new one.  See {@link #commit()} for\n   * caveats about write caching done by some IO devices.\n   *\n   * <p> If an Exception is hit during close, eg due to disk\n   * full or some other reason, then both the on-disk index\n   * and the internal state of the IndexWriter instance will\n   * be consistent.  However, the close will not be complete\n   * even though part of it (flushing buffered documents)\n   * may have succeeded, so the write lock will still be\n   * held.</p>\n   * \n   * <p> If you can correct the underlying cause (eg free up\n   * some disk space) then you can call close() again.\n   * Failing that, if you want to force the write lock to be\n   * released (dangerous, because you may then lose buffered\n   * docs in the IndexWriter instance) then you can do\n   * something like this:</p>\n   *\n   * <pre>\n   * try {\n   *   writer.close();\n   * } finally {\n   *   if (IndexWriter.isLocked(directory)) {\n   *     IndexWriter.unlock(directory);\n   *   }\n   * }\n   * </pre>\n   *\n   * after which, you must be certain not to use the writer\n   * instance anymore.</p>\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer, again.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public void close() throws CorruptIndexException, IOException {\n    close(true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"d7052f725a053aa55424f966831826f61b798bf1":["1507a324c1f939ed71e01297733a49b9c36e5688"],"3a10198efba39d45c46f8714efe9a15616f9c79d":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["7dc11e5e2e108e6cdd85ae2693383a15f41cbf35"],"328c1568e471f0c6eaa49ec00334ca59e573710f":["8b6187898fc4413ccd18229711786550a280383c"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7dc11e5e2e108e6cdd85ae2693383a15f41cbf35":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"1b54a9bc667895a2095a886184bf69a3179e63df":["5a664b1395d4341b88e32d36297d7670f1a665ac"],"42a7d0b384f0022c5a29e562b809ebf73991d7e6":["9c7454619ea6a0710272c1dd947345cee64489f6"],"5a664b1395d4341b88e32d36297d7670f1a665ac":["d7052f725a053aa55424f966831826f61b798bf1"],"84acdfa12c18361ff932244db20470fce117e52d":["e82780afe6097066eb5befb86e9432f077667e3d"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["328c1568e471f0c6eaa49ec00334ca59e573710f"],"e9665d17707cc21b1db995118ff36129723139ab":["05ec4e7e3569b6c85ac07e8813a5d5ed5d1ef6dc"],"3fb2e14da294a8c919c6356cbbc8049158c368a7":["3a10198efba39d45c46f8714efe9a15616f9c79d"],"1507a324c1f939ed71e01297733a49b9c36e5688":["fb1981e606f66dba202e9c48f6bd4f108f022586"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9c7454619ea6a0710272c1dd947345cee64489f6":["3fb2e14da294a8c919c6356cbbc8049158c368a7"],"e82780afe6097066eb5befb86e9432f077667e3d":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"8b6187898fc4413ccd18229711786550a280383c":["1b54a9bc667895a2095a886184bf69a3179e63df"],"fb1981e606f66dba202e9c48f6bd4f108f022586":["42a7d0b384f0022c5a29e562b809ebf73991d7e6"],"05ec4e7e3569b6c85ac07e8813a5d5ed5d1ef6dc":["84acdfa12c18361ff932244db20470fce117e52d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["e9665d17707cc21b1db995118ff36129723139ab"]},"commit2Childs":{"d7052f725a053aa55424f966831826f61b798bf1":["5a664b1395d4341b88e32d36297d7670f1a665ac"],"3a10198efba39d45c46f8714efe9a15616f9c79d":["3fb2e14da294a8c919c6356cbbc8049158c368a7"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["3a10198efba39d45c46f8714efe9a15616f9c79d"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["e82780afe6097066eb5befb86e9432f077667e3d"],"328c1568e471f0c6eaa49ec00334ca59e573710f":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"7dc11e5e2e108e6cdd85ae2693383a15f41cbf35":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"1b54a9bc667895a2095a886184bf69a3179e63df":["8b6187898fc4413ccd18229711786550a280383c"],"42a7d0b384f0022c5a29e562b809ebf73991d7e6":["fb1981e606f66dba202e9c48f6bd4f108f022586"],"5a664b1395d4341b88e32d36297d7670f1a665ac":["1b54a9bc667895a2095a886184bf69a3179e63df"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["7dc11e5e2e108e6cdd85ae2693383a15f41cbf35"],"84acdfa12c18361ff932244db20470fce117e52d":["05ec4e7e3569b6c85ac07e8813a5d5ed5d1ef6dc"],"e9665d17707cc21b1db995118ff36129723139ab":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"3fb2e14da294a8c919c6356cbbc8049158c368a7":["9c7454619ea6a0710272c1dd947345cee64489f6"],"1507a324c1f939ed71e01297733a49b9c36e5688":["d7052f725a053aa55424f966831826f61b798bf1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"9c7454619ea6a0710272c1dd947345cee64489f6":["42a7d0b384f0022c5a29e562b809ebf73991d7e6"],"8b6187898fc4413ccd18229711786550a280383c":["328c1568e471f0c6eaa49ec00334ca59e573710f"],"e82780afe6097066eb5befb86e9432f077667e3d":["84acdfa12c18361ff932244db20470fce117e52d"],"fb1981e606f66dba202e9c48f6bd4f108f022586":["1507a324c1f939ed71e01297733a49b9c36e5688"],"05ec4e7e3569b6c85ac07e8813a5d5ed5d1ef6dc":["e9665d17707cc21b1db995118ff36129723139ab"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}