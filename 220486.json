{"path":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphPhrase(TokenStream,String,int).mjava","commits":[{"id":"d79fd791e91f49ce8026885d7b8ac62bee4c8126","date":1487768721,"type":0,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphPhrase(TokenStream,String,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a span near (phrase) query from a graph token stream. The articulation points of the graph are visited in\n   * order and the queries created at each point are merged in the returned near query.\n   */\n  protected SpanQuery analyzeGraphPhrase(TokenStream source, String field, int phraseSlop)\n      throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    List<SpanQuery> clauses = new ArrayList<>();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final SpanQuery queryPos;\n      if (graph.hasSidePath(start)) {\n        List<SpanQuery> queries = new ArrayList<>();\n        Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        while (it.hasNext()) {\n          TokenStream ts = it.next();\n          SpanQuery q = createSpanQuery(ts, field);\n          if (q != null) {\n            queries.add(q);\n          }\n        }\n        if (queries.size() > 0) {\n          queryPos = new SpanOrQuery(queries.toArray(new SpanQuery[0]));\n        } else {\n          queryPos = null;\n        }\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = new SpanTermQuery(terms[0]);\n        } else {\n          SpanTermQuery[] orClauses = new SpanTermQuery[terms.length];\n          for (int idx = 0; idx < terms.length; idx++) {\n            orClauses[idx] = new SpanTermQuery(terms[idx]);\n          }\n\n          queryPos = new SpanOrQuery(orClauses);\n        }\n      }\n\n      if (queryPos != null) {\n        clauses.add(queryPos);\n      }\n    }\n\n    if (clauses.isEmpty()) {\n      return null;\n    } else if (clauses.size() == 1) {\n      return clauses.get(0);\n    } else {\n      return new SpanNearQuery(clauses.toArray(new SpanQuery[0]), phraseSlop, true);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["09e24e99071dbf35fb0600cecf5feb8f0b52ccf8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7267848f22239747d2a2bad85e4464e5823736cc","date":1538651093,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphPhrase(TokenStream,String,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphPhrase(TokenStream,String,int).mjava","sourceNew":"  /**\n   * Creates a span near (phrase) query from a graph token stream. The articulation points of the graph are visited in\n   * order and the queries created at each point are merged in the returned near query.\n   */\n  protected SpanQuery analyzeGraphPhrase(TokenStream source, String field, int phraseSlop)\n      throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    List<SpanQuery> clauses = new ArrayList<>();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final SpanQuery queryPos;\n      if (graph.hasSidePath(start)) {\n        List<SpanQuery> queries = new ArrayList<>();\n        Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        while (it.hasNext()) {\n          TokenStream ts = it.next();\n          SpanQuery q = createSpanQuery(ts, field);\n          if (q != null) {\n            if (queries.size() >= maxClauseCount) {\n              throw new BooleanQuery.TooManyClauses();\n            }\n            queries.add(q);\n          }\n        }\n        if (queries.size() > 0) {\n          queryPos = new SpanOrQuery(queries.toArray(new SpanQuery[0]));\n        } else {\n          queryPos = null;\n        }\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = new SpanTermQuery(terms[0]);\n        } else {\n          if (terms.length >= maxClauseCount) {\n            throw new BooleanQuery.TooManyClauses();\n          }\n          SpanTermQuery[] orClauses = new SpanTermQuery[terms.length];\n          for (int idx = 0; idx < terms.length; idx++) {\n            orClauses[idx] = new SpanTermQuery(terms[idx]);\n          }\n\n          queryPos = new SpanOrQuery(orClauses);\n        }\n      }\n\n      if (queryPos != null) {\n        if (clauses.size() >= maxClauseCount) {\n          throw new BooleanQuery.TooManyClauses();\n        }\n        clauses.add(queryPos);\n      }\n    }\n\n    if (clauses.isEmpty()) {\n      return null;\n    } else if (clauses.size() == 1) {\n      return clauses.get(0);\n    } else {\n      return new SpanNearQuery(clauses.toArray(new SpanQuery[0]), phraseSlop, true);\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a span near (phrase) query from a graph token stream. The articulation points of the graph are visited in\n   * order and the queries created at each point are merged in the returned near query.\n   */\n  protected SpanQuery analyzeGraphPhrase(TokenStream source, String field, int phraseSlop)\n      throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    List<SpanQuery> clauses = new ArrayList<>();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final SpanQuery queryPos;\n      if (graph.hasSidePath(start)) {\n        List<SpanQuery> queries = new ArrayList<>();\n        Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        while (it.hasNext()) {\n          TokenStream ts = it.next();\n          SpanQuery q = createSpanQuery(ts, field);\n          if (q != null) {\n            queries.add(q);\n          }\n        }\n        if (queries.size() > 0) {\n          queryPos = new SpanOrQuery(queries.toArray(new SpanQuery[0]));\n        } else {\n          queryPos = null;\n        }\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = new SpanTermQuery(terms[0]);\n        } else {\n          SpanTermQuery[] orClauses = new SpanTermQuery[terms.length];\n          for (int idx = 0; idx < terms.length; idx++) {\n            orClauses[idx] = new SpanTermQuery(terms[idx]);\n          }\n\n          queryPos = new SpanOrQuery(orClauses);\n        }\n      }\n\n      if (queryPos != null) {\n        clauses.add(queryPos);\n      }\n    }\n\n    if (clauses.isEmpty()) {\n      return null;\n    } else if (clauses.size() == 1) {\n      return clauses.get(0);\n    } else {\n      return new SpanNearQuery(clauses.toArray(new SpanQuery[0]), phraseSlop, true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09e24e99071dbf35fb0600cecf5feb8f0b52ccf8","date":1539974716,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphPhrase(TokenStream,String,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphPhrase(TokenStream,String,int).mjava","sourceNew":"  /**\n   * Creates graph phrase query from the tokenstream contents\n   */\n  protected Query analyzeGraphPhrase(TokenStream source, String field, int phraseSlop)\n      throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    if (phraseSlop > 0) {\n      /**\n       * Creates a boolean query from the graph token stream by extracting all the finite strings from the graph\n       * and using them to create phrase queries with the appropriate slop.\n       */\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      Iterator<TokenStream> it = graph.getFiniteStrings();\n      while (it.hasNext()) {\n        Query query = createFieldQuery(it.next(), BooleanClause.Occur.MUST, field, true, phraseSlop);\n        if (query != null) {\n          builder.add(query, BooleanClause.Occur.SHOULD);\n        }\n      }\n      return builder.build();\n    }\n\n    /**\n     * Creates a span near (phrase) query from a graph token stream.\n     * The articulation points of the graph are visited in order and the queries\n     * created at each point are merged in the returned near query.\n     */\n    List<SpanQuery> clauses = new ArrayList<>();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final SpanQuery queryPos;\n      if (graph.hasSidePath(start)) {\n        List<SpanQuery> queries = new ArrayList<>();\n        Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        while (it.hasNext()) {\n          TokenStream ts = it.next();\n          SpanQuery q = createSpanQuery(ts, field);\n          if (q != null) {\n            if (queries.size() >= maxClauseCount) {\n              throw new BooleanQuery.TooManyClauses();\n            }\n            queries.add(q);\n          }\n        }\n        if (queries.size() > 0) {\n          queryPos = new SpanOrQuery(queries.toArray(new SpanQuery[0]));\n        } else {\n          queryPos = null;\n        }\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = new SpanTermQuery(terms[0]);\n        } else {\n          if (terms.length >= maxClauseCount) {\n            throw new BooleanQuery.TooManyClauses();\n          }\n          SpanTermQuery[] orClauses = new SpanTermQuery[terms.length];\n          for (int idx = 0; idx < terms.length; idx++) {\n            orClauses[idx] = new SpanTermQuery(terms[idx]);\n          }\n\n          queryPos = new SpanOrQuery(orClauses);\n        }\n      }\n\n      if (queryPos != null) {\n        if (clauses.size() >= maxClauseCount) {\n          throw new BooleanQuery.TooManyClauses();\n        }\n        clauses.add(queryPos);\n      }\n    }\n\n    if (clauses.isEmpty()) {\n      return null;\n    } else if (clauses.size() == 1) {\n      return clauses.get(0);\n    } else {\n      return new SpanNearQuery(clauses.toArray(new SpanQuery[0]), 0, true);\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a span near (phrase) query from a graph token stream. The articulation points of the graph are visited in\n   * order and the queries created at each point are merged in the returned near query.\n   */\n  protected SpanQuery analyzeGraphPhrase(TokenStream source, String field, int phraseSlop)\n      throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    List<SpanQuery> clauses = new ArrayList<>();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final SpanQuery queryPos;\n      if (graph.hasSidePath(start)) {\n        List<SpanQuery> queries = new ArrayList<>();\n        Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        while (it.hasNext()) {\n          TokenStream ts = it.next();\n          SpanQuery q = createSpanQuery(ts, field);\n          if (q != null) {\n            if (queries.size() >= maxClauseCount) {\n              throw new BooleanQuery.TooManyClauses();\n            }\n            queries.add(q);\n          }\n        }\n        if (queries.size() > 0) {\n          queryPos = new SpanOrQuery(queries.toArray(new SpanQuery[0]));\n        } else {\n          queryPos = null;\n        }\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = new SpanTermQuery(terms[0]);\n        } else {\n          if (terms.length >= maxClauseCount) {\n            throw new BooleanQuery.TooManyClauses();\n          }\n          SpanTermQuery[] orClauses = new SpanTermQuery[terms.length];\n          for (int idx = 0; idx < terms.length; idx++) {\n            orClauses[idx] = new SpanTermQuery(terms[idx]);\n          }\n\n          queryPos = new SpanOrQuery(orClauses);\n        }\n      }\n\n      if (queryPos != null) {\n        if (clauses.size() >= maxClauseCount) {\n          throw new BooleanQuery.TooManyClauses();\n        }\n        clauses.add(queryPos);\n      }\n    }\n\n    if (clauses.isEmpty()) {\n      return null;\n    } else if (clauses.size() == 1) {\n      return clauses.get(0);\n    } else {\n      return new SpanNearQuery(clauses.toArray(new SpanQuery[0]), phraseSlop, true);\n    }\n  }\n\n","bugFix":["d79fd791e91f49ce8026885d7b8ac62bee4c8126"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36c70eb3b44de4355a7168b762cadc0f1cf194bc","date":1561542955,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphPhrase(TokenStream,String,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphPhrase(TokenStream,String,int).mjava","sourceNew":"  /**\n   * Creates graph phrase query from the tokenstream contents\n   */\n  protected Query analyzeGraphPhrase(TokenStream source, String field, int phraseSlop)\n      throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    if (phraseSlop > 0) {\n      /**\n       * Creates a boolean query from the graph token stream by extracting all the finite strings from the graph\n       * and using them to create phrase queries with the appropriate slop.\n       */\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      Iterator<TokenStream> it = graph.getFiniteStrings();\n      while (it.hasNext()) {\n        Query query = createFieldQuery(it.next(), BooleanClause.Occur.MUST, field, true, phraseSlop);\n        if (query != null) {\n          builder.add(query, BooleanClause.Occur.SHOULD);\n        }\n      }\n      return builder.build();\n    }\n\n    /**\n     * Creates a span near (phrase) query from a graph token stream.\n     * The articulation points of the graph are visited in order and the queries\n     * created at each point are merged in the returned near query.\n     */\n    List<SpanQuery> clauses = new ArrayList<>();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    int maxClauseCount = IndexSearcher.getMaxClauseCount();\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final SpanQuery queryPos;\n      if (graph.hasSidePath(start)) {\n        List<SpanQuery> queries = new ArrayList<>();\n        Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        while (it.hasNext()) {\n          TokenStream ts = it.next();\n          SpanQuery q = createSpanQuery(ts, field);\n          if (q != null) {\n            if (queries.size() >= maxClauseCount) {\n              throw new IndexSearcher.TooManyClauses();\n            }\n            queries.add(q);\n          }\n        }\n        if (queries.size() > 0) {\n          queryPos = new SpanOrQuery(queries.toArray(new SpanQuery[0]));\n        } else {\n          queryPos = null;\n        }\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = new SpanTermQuery(terms[0]);\n        } else {\n          if (terms.length >= maxClauseCount) {\n            throw new IndexSearcher.TooManyClauses();\n          }\n          SpanTermQuery[] orClauses = new SpanTermQuery[terms.length];\n          for (int idx = 0; idx < terms.length; idx++) {\n            orClauses[idx] = new SpanTermQuery(terms[idx]);\n          }\n\n          queryPos = new SpanOrQuery(orClauses);\n        }\n      }\n\n      if (queryPos != null) {\n        if (clauses.size() >= maxClauseCount) {\n          throw new IndexSearcher.TooManyClauses();\n        }\n        clauses.add(queryPos);\n      }\n    }\n\n    if (clauses.isEmpty()) {\n      return null;\n    } else if (clauses.size() == 1) {\n      return clauses.get(0);\n    } else {\n      return new SpanNearQuery(clauses.toArray(new SpanQuery[0]), 0, true);\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates graph phrase query from the tokenstream contents\n   */\n  protected Query analyzeGraphPhrase(TokenStream source, String field, int phraseSlop)\n      throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    if (phraseSlop > 0) {\n      /**\n       * Creates a boolean query from the graph token stream by extracting all the finite strings from the graph\n       * and using them to create phrase queries with the appropriate slop.\n       */\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      Iterator<TokenStream> it = graph.getFiniteStrings();\n      while (it.hasNext()) {\n        Query query = createFieldQuery(it.next(), BooleanClause.Occur.MUST, field, true, phraseSlop);\n        if (query != null) {\n          builder.add(query, BooleanClause.Occur.SHOULD);\n        }\n      }\n      return builder.build();\n    }\n\n    /**\n     * Creates a span near (phrase) query from a graph token stream.\n     * The articulation points of the graph are visited in order and the queries\n     * created at each point are merged in the returned near query.\n     */\n    List<SpanQuery> clauses = new ArrayList<>();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final SpanQuery queryPos;\n      if (graph.hasSidePath(start)) {\n        List<SpanQuery> queries = new ArrayList<>();\n        Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        while (it.hasNext()) {\n          TokenStream ts = it.next();\n          SpanQuery q = createSpanQuery(ts, field);\n          if (q != null) {\n            if (queries.size() >= maxClauseCount) {\n              throw new BooleanQuery.TooManyClauses();\n            }\n            queries.add(q);\n          }\n        }\n        if (queries.size() > 0) {\n          queryPos = new SpanOrQuery(queries.toArray(new SpanQuery[0]));\n        } else {\n          queryPos = null;\n        }\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = new SpanTermQuery(terms[0]);\n        } else {\n          if (terms.length >= maxClauseCount) {\n            throw new BooleanQuery.TooManyClauses();\n          }\n          SpanTermQuery[] orClauses = new SpanTermQuery[terms.length];\n          for (int idx = 0; idx < terms.length; idx++) {\n            orClauses[idx] = new SpanTermQuery(terms[idx]);\n          }\n\n          queryPos = new SpanOrQuery(orClauses);\n        }\n      }\n\n      if (queryPos != null) {\n        if (clauses.size() >= maxClauseCount) {\n          throw new BooleanQuery.TooManyClauses();\n        }\n        clauses.add(queryPos);\n      }\n    }\n\n    if (clauses.isEmpty()) {\n      return null;\n    } else if (clauses.size() == 1) {\n      return clauses.get(0);\n    } else {\n      return new SpanNearQuery(clauses.toArray(new SpanQuery[0]), 0, true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02bf300ae49caa47cd23550d69d6683a61ad89cb","date":1582727554,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphPhrase(TokenStream,String,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphPhrase(TokenStream,String,int).mjava","sourceNew":"  /**\n   * Creates graph phrase query from the tokenstream contents\n   */\n  protected Query analyzeGraphPhrase(TokenStream source, String field, int phraseSlop)\n      throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n\n    // Creates a boolean query from the graph token stream by extracting all the\n    // finite strings from the graph and using them to create phrase queries with\n    // the appropriate slop.\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    Iterator<TokenStream> it = graph.getFiniteStrings();\n    while (it.hasNext()) {\n      Query query = createFieldQuery(it.next(), BooleanClause.Occur.MUST, field, true, phraseSlop);\n      if (query != null) {\n        builder.add(query, BooleanClause.Occur.SHOULD);\n      }\n    }\n    return builder.build();\n\n  }\n\n","sourceOld":"  /**\n   * Creates graph phrase query from the tokenstream contents\n   */\n  protected Query analyzeGraphPhrase(TokenStream source, String field, int phraseSlop)\n      throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    if (phraseSlop > 0) {\n      /**\n       * Creates a boolean query from the graph token stream by extracting all the finite strings from the graph\n       * and using them to create phrase queries with the appropriate slop.\n       */\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      Iterator<TokenStream> it = graph.getFiniteStrings();\n      while (it.hasNext()) {\n        Query query = createFieldQuery(it.next(), BooleanClause.Occur.MUST, field, true, phraseSlop);\n        if (query != null) {\n          builder.add(query, BooleanClause.Occur.SHOULD);\n        }\n      }\n      return builder.build();\n    }\n\n    /**\n     * Creates a span near (phrase) query from a graph token stream.\n     * The articulation points of the graph are visited in order and the queries\n     * created at each point are merged in the returned near query.\n     */\n    List<SpanQuery> clauses = new ArrayList<>();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    int maxClauseCount = IndexSearcher.getMaxClauseCount();\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final SpanQuery queryPos;\n      if (graph.hasSidePath(start)) {\n        List<SpanQuery> queries = new ArrayList<>();\n        Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        while (it.hasNext()) {\n          TokenStream ts = it.next();\n          SpanQuery q = createSpanQuery(ts, field);\n          if (q != null) {\n            if (queries.size() >= maxClauseCount) {\n              throw new IndexSearcher.TooManyClauses();\n            }\n            queries.add(q);\n          }\n        }\n        if (queries.size() > 0) {\n          queryPos = new SpanOrQuery(queries.toArray(new SpanQuery[0]));\n        } else {\n          queryPos = null;\n        }\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = new SpanTermQuery(terms[0]);\n        } else {\n          if (terms.length >= maxClauseCount) {\n            throw new IndexSearcher.TooManyClauses();\n          }\n          SpanTermQuery[] orClauses = new SpanTermQuery[terms.length];\n          for (int idx = 0; idx < terms.length; idx++) {\n            orClauses[idx] = new SpanTermQuery(terms[idx]);\n          }\n\n          queryPos = new SpanOrQuery(orClauses);\n        }\n      }\n\n      if (queryPos != null) {\n        if (clauses.size() >= maxClauseCount) {\n          throw new IndexSearcher.TooManyClauses();\n        }\n        clauses.add(queryPos);\n      }\n    }\n\n    if (clauses.isEmpty()) {\n      return null;\n    } else if (clauses.size() == 1) {\n      return clauses.get(0);\n    } else {\n      return new SpanNearQuery(clauses.toArray(new SpanQuery[0]), 0, true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"09e24e99071dbf35fb0600cecf5feb8f0b52ccf8":["7267848f22239747d2a2bad85e4464e5823736cc"],"02bf300ae49caa47cd23550d69d6683a61ad89cb":["36c70eb3b44de4355a7168b762cadc0f1cf194bc"],"7267848f22239747d2a2bad85e4464e5823736cc":["d79fd791e91f49ce8026885d7b8ac62bee4c8126"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"36c70eb3b44de4355a7168b762cadc0f1cf194bc":["09e24e99071dbf35fb0600cecf5feb8f0b52ccf8"],"d79fd791e91f49ce8026885d7b8ac62bee4c8126":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["02bf300ae49caa47cd23550d69d6683a61ad89cb"]},"commit2Childs":{"09e24e99071dbf35fb0600cecf5feb8f0b52ccf8":["36c70eb3b44de4355a7168b762cadc0f1cf194bc"],"02bf300ae49caa47cd23550d69d6683a61ad89cb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7267848f22239747d2a2bad85e4464e5823736cc":["09e24e99071dbf35fb0600cecf5feb8f0b52ccf8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d79fd791e91f49ce8026885d7b8ac62bee4c8126"],"36c70eb3b44de4355a7168b762cadc0f1cf194bc":["02bf300ae49caa47cd23550d69d6683a61ad89cb"],"d79fd791e91f49ce8026885d7b8ac62bee4c8126":["7267848f22239747d2a2bad85e4464e5823736cc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}