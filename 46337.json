{"path":"lucene/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","commits":[{"id":"d4aa50b979cd392e00e5bc0f23f78cbd106cb968","date":1308150768,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns a new TopDocs, containing topN results across\n   *  the provided TopDocs, sorting by the specified {@link\n   *  Sort}.  Each of the TopDocs must have been sorted by\n   *  the same Sort, and sort field values must have been\n   *  filled (ie, <code>fillFields=true</code> must be\n   *  passed to {@link\n   *  TopFieldCollector#create}.\n   *\n   * <p>Pass sort=null to merge sort by score descending.\n   *\n   * @lucene.experimental */\n  public static TopDocsAndShards merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        totalHitCount += shard.totalHits;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, totalHitCount)];\n    final int[] shardIndex = new int[hits.length];\n\n    int hitUpto = 0;\n    while(hitUpto < hits.length) {\n      assert queue.size() > 0;\n      ShardRef ref = queue.pop();\n      hits[hitUpto] = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n      shardIndex[hitUpto] = ref.shardIndex;\n\n      //System.out.println(\"  hitUpto=\" + hitUpto);\n      //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n      hitUpto++;\n\n      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n        // Not done with this these TopDocs yet:\n        queue.add(ref);\n      }\n    }\n\n    return new TopDocsAndShards(totalHitCount, hits, maxScore, shardIndex);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5d731d304e051cf7ed37410c1431e942f41c09b","date":1308235976,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","sourceNew":"  /** Returns a new TopDocs, containing topN results across\n   *  the provided TopDocs, sorting by the specified {@link\n   *  Sort}.  Each of the TopDocs must have been sorted by\n   *  the same Sort, and sort field values must have been\n   *  filled (ie, <code>fillFields=true</code> must be\n   *  passed to {@link\n   *  TopFieldCollector#create}.\n   *\n   * <p>Pass sort=null to merge sort by score descending.\n   *\n   * @lucene.experimental */\n  public static TopDocs merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        totalHitCount += shard.totalHits;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, totalHitCount)];\n\n    int hitUpto = 0;\n    while(hitUpto < hits.length) {\n      assert queue.size() > 0;\n      ShardRef ref = queue.pop();\n      final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n      if (sort == null) {\n        hits[hitUpto] = new ScoreDoc(hit.doc, hit.score, ref.shardIndex);\n      } else {\n        hits[hitUpto] = new FieldDoc(hit.doc, hit.score, ((FieldDoc) hit).fields, ref.shardIndex);\n      }\n\n      //System.out.println(\"  hitUpto=\" + hitUpto);\n      //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n      hitUpto++;\n\n      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n        // Not done with this these TopDocs yet:\n        queue.add(ref);\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","sourceOld":"  /** Returns a new TopDocs, containing topN results across\n   *  the provided TopDocs, sorting by the specified {@link\n   *  Sort}.  Each of the TopDocs must have been sorted by\n   *  the same Sort, and sort field values must have been\n   *  filled (ie, <code>fillFields=true</code> must be\n   *  passed to {@link\n   *  TopFieldCollector#create}.\n   *\n   * <p>Pass sort=null to merge sort by score descending.\n   *\n   * @lucene.experimental */\n  public static TopDocsAndShards merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        totalHitCount += shard.totalHits;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, totalHitCount)];\n    final int[] shardIndex = new int[hits.length];\n\n    int hitUpto = 0;\n    while(hitUpto < hits.length) {\n      assert queue.size() > 0;\n      ShardRef ref = queue.pop();\n      hits[hitUpto] = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n      shardIndex[hitUpto] = ref.shardIndex;\n\n      //System.out.println(\"  hitUpto=\" + hitUpto);\n      //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n      hitUpto++;\n\n      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n        // Not done with this these TopDocs yet:\n        queue.add(ref);\n      }\n    }\n\n    return new TopDocsAndShards(totalHitCount, hits, maxScore, shardIndex);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","date":1308291005,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns a new TopDocs, containing topN results across\n   *  the provided TopDocs, sorting by the specified {@link\n   *  Sort}.  Each of the TopDocs must have been sorted by\n   *  the same Sort, and sort field values must have been\n   *  filled (ie, <code>fillFields=true</code> must be\n   *  passed to {@link\n   *  TopFieldCollector#create}.\n   *\n   * <p>Pass sort=null to merge sort by score descending.\n   *\n   * @lucene.experimental */\n  public static TopDocs merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        totalHitCount += shard.totalHits;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, totalHitCount)];\n\n    int hitUpto = 0;\n    while(hitUpto < hits.length) {\n      assert queue.size() > 0;\n      ShardRef ref = queue.pop();\n      final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n      if (sort == null) {\n        hits[hitUpto] = new ScoreDoc(hit.doc, hit.score, ref.shardIndex);\n      } else {\n        hits[hitUpto] = new FieldDoc(hit.doc, hit.score, ((FieldDoc) hit).fields, ref.shardIndex);\n      }\n\n      //System.out.println(\"  hitUpto=\" + hitUpto);\n      //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n      hitUpto++;\n\n      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n        // Not done with this these TopDocs yet:\n        queue.add(ref);\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa604af8d2ace89a31df3233bbe1ccd7e1967e74","date":1309292832,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","sourceNew":"  /** Returns a new TopDocs, containing topN results across\n   *  the provided TopDocs, sorting by the specified {@link\n   *  Sort}.  Each of the TopDocs must have been sorted by\n   *  the same Sort, and sort field values must have been\n   *  filled (ie, <code>fillFields=true</code> must be\n   *  passed to {@link\n   *  TopFieldCollector#create}.\n   *\n   * <p>Pass sort=null to merge sort by score descending.\n   *\n   * @lucene.experimental */\n  public static TopDocs merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        totalHitCount += shard.totalHits;\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, availHitCount)];\n\n    int hitUpto = 0;\n    while(hitUpto < hits.length) {\n      assert queue.size() > 0;\n      ShardRef ref = queue.pop();\n      final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n      if (sort == null) {\n        hits[hitUpto] = new ScoreDoc(hit.doc, hit.score, ref.shardIndex);\n      } else {\n        hits[hitUpto] = new FieldDoc(hit.doc, hit.score, ((FieldDoc) hit).fields, ref.shardIndex);\n      }\n\n      //System.out.println(\"  hitUpto=\" + hitUpto);\n      //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n      hitUpto++;\n\n      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n        // Not done with this these TopDocs yet:\n        queue.add(ref);\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","sourceOld":"  /** Returns a new TopDocs, containing topN results across\n   *  the provided TopDocs, sorting by the specified {@link\n   *  Sort}.  Each of the TopDocs must have been sorted by\n   *  the same Sort, and sort field values must have been\n   *  filled (ie, <code>fillFields=true</code> must be\n   *  passed to {@link\n   *  TopFieldCollector#create}.\n   *\n   * <p>Pass sort=null to merge sort by score descending.\n   *\n   * @lucene.experimental */\n  public static TopDocs merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        totalHitCount += shard.totalHits;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, totalHitCount)];\n\n    int hitUpto = 0;\n    while(hitUpto < hits.length) {\n      assert queue.size() > 0;\n      ShardRef ref = queue.pop();\n      final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n      if (sort == null) {\n        hits[hitUpto] = new ScoreDoc(hit.doc, hit.score, ref.shardIndex);\n      } else {\n        hits[hitUpto] = new FieldDoc(hit.doc, hit.score, ((FieldDoc) hit).fields, ref.shardIndex);\n      }\n\n      //System.out.println(\"  hitUpto=\" + hitUpto);\n      //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n      hitUpto++;\n\n      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n        // Not done with this these TopDocs yet:\n        queue.add(ref);\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","sourceNew":"  /** Returns a new TopDocs, containing topN results across\n   *  the provided TopDocs, sorting by the specified {@link\n   *  Sort}.  Each of the TopDocs must have been sorted by\n   *  the same Sort, and sort field values must have been\n   *  filled (ie, <code>fillFields=true</code> must be\n   *  passed to {@link\n   *  TopFieldCollector#create}.\n   *\n   * <p>Pass sort=null to merge sort by score descending.\n   *\n   * @lucene.experimental */\n  public static TopDocs merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        totalHitCount += shard.totalHits;\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, availHitCount)];\n\n    int hitUpto = 0;\n    while(hitUpto < hits.length) {\n      assert queue.size() > 0;\n      ShardRef ref = queue.pop();\n      final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n      if (sort == null) {\n        hits[hitUpto] = new ScoreDoc(hit.doc, hit.score, ref.shardIndex);\n      } else {\n        hits[hitUpto] = new FieldDoc(hit.doc, hit.score, ((FieldDoc) hit).fields, ref.shardIndex);\n      }\n\n      //System.out.println(\"  hitUpto=\" + hitUpto);\n      //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n      hitUpto++;\n\n      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n        // Not done with this these TopDocs yet:\n        queue.add(ref);\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","sourceOld":"  /** Returns a new TopDocs, containing topN results across\n   *  the provided TopDocs, sorting by the specified {@link\n   *  Sort}.  Each of the TopDocs must have been sorted by\n   *  the same Sort, and sort field values must have been\n   *  filled (ie, <code>fillFields=true</code> must be\n   *  passed to {@link\n   *  TopFieldCollector#create}.\n   *\n   * <p>Pass sort=null to merge sort by score descending.\n   *\n   * @lucene.experimental */\n  public static TopDocs merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        totalHitCount += shard.totalHits;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, totalHitCount)];\n\n    int hitUpto = 0;\n    while(hitUpto < hits.length) {\n      assert queue.size() > 0;\n      ShardRef ref = queue.pop();\n      final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n      if (sort == null) {\n        hits[hitUpto] = new ScoreDoc(hit.doc, hit.score, ref.shardIndex);\n      } else {\n        hits[hitUpto] = new FieldDoc(hit.doc, hit.score, ((FieldDoc) hit).fields, ref.shardIndex);\n      }\n\n      //System.out.println(\"  hitUpto=\" + hitUpto);\n      //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n      hitUpto++;\n\n      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n        // Not done with this these TopDocs yet:\n        queue.add(ref);\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","sourceNew":"  /** Returns a new TopDocs, containing topN results across\n   *  the provided TopDocs, sorting by the specified {@link\n   *  Sort}.  Each of the TopDocs must have been sorted by\n   *  the same Sort, and sort field values must have been\n   *  filled (ie, <code>fillFields=true</code> must be\n   *  passed to {@link\n   *  TopFieldCollector#create}.\n   *\n   * <p>Pass sort=null to merge sort by score descending.\n   *\n   * @lucene.experimental */\n  public static TopDocs merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        totalHitCount += shard.totalHits;\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, availHitCount)];\n\n    int hitUpto = 0;\n    while(hitUpto < hits.length) {\n      assert queue.size() > 0;\n      ShardRef ref = queue.pop();\n      final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n      if (sort == null) {\n        hits[hitUpto] = new ScoreDoc(hit.doc, hit.score, ref.shardIndex);\n      } else {\n        hits[hitUpto] = new FieldDoc(hit.doc, hit.score, ((FieldDoc) hit).fields, ref.shardIndex);\n      }\n\n      //System.out.println(\"  hitUpto=\" + hitUpto);\n      //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n      hitUpto++;\n\n      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n        // Not done with this these TopDocs yet:\n        queue.add(ref);\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","sourceOld":"  /** Returns a new TopDocs, containing topN results across\n   *  the provided TopDocs, sorting by the specified {@link\n   *  Sort}.  Each of the TopDocs must have been sorted by\n   *  the same Sort, and sort field values must have been\n   *  filled (ie, <code>fillFields=true</code> must be\n   *  passed to {@link\n   *  TopFieldCollector#create}.\n   *\n   * <p>Pass sort=null to merge sort by score descending.\n   *\n   * @lucene.experimental */\n  public static TopDocs merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        totalHitCount += shard.totalHits;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, totalHitCount)];\n\n    int hitUpto = 0;\n    while(hitUpto < hits.length) {\n      assert queue.size() > 0;\n      ShardRef ref = queue.pop();\n      final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n      if (sort == null) {\n        hits[hitUpto] = new ScoreDoc(hit.doc, hit.score, ref.shardIndex);\n      } else {\n        hits[hitUpto] = new FieldDoc(hit.doc, hit.score, ((FieldDoc) hit).fields, ref.shardIndex);\n      }\n\n      //System.out.println(\"  hitUpto=\" + hitUpto);\n      //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n      hitUpto++;\n\n      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n        // Not done with this these TopDocs yet:\n        queue.add(ref);\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ccc08aa684aee4964baee0644a6ba047bfd70829","date":1316263707,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","sourceNew":"  /** Returns a new TopDocs, containing topN results across\n   *  the provided TopDocs, sorting by the specified {@link\n   *  Sort}.  Each of the TopDocs must have been sorted by\n   *  the same Sort, and sort field values must have been\n   *  filled (ie, <code>fillFields=true</code> must be\n   *  passed to {@link\n   *  TopFieldCollector#create}.\n   *\n   * <p>Pass sort=null to merge sort by score descending.\n   *\n   * @lucene.experimental */\n  public static TopDocs merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        totalHitCount += shard.totalHits;\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, availHitCount)];\n\n    int hitUpto = 0;\n    while(hitUpto < hits.length) {\n      assert queue.size() > 0;\n      ShardRef ref = queue.pop();\n      final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n      hit.shardIndex = ref.shardIndex;\n      hits[hitUpto] = hit;\n\n      //System.out.println(\"  hitUpto=\" + hitUpto);\n      //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n      hitUpto++;\n\n      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n        // Not done with this these TopDocs yet:\n        queue.add(ref);\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","sourceOld":"  /** Returns a new TopDocs, containing topN results across\n   *  the provided TopDocs, sorting by the specified {@link\n   *  Sort}.  Each of the TopDocs must have been sorted by\n   *  the same Sort, and sort field values must have been\n   *  filled (ie, <code>fillFields=true</code> must be\n   *  passed to {@link\n   *  TopFieldCollector#create}.\n   *\n   * <p>Pass sort=null to merge sort by score descending.\n   *\n   * @lucene.experimental */\n  public static TopDocs merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        totalHitCount += shard.totalHits;\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, availHitCount)];\n\n    int hitUpto = 0;\n    while(hitUpto < hits.length) {\n      assert queue.size() > 0;\n      ShardRef ref = queue.pop();\n      final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n      if (sort == null) {\n        hits[hitUpto] = new ScoreDoc(hit.doc, hit.score, ref.shardIndex);\n      } else {\n        hits[hitUpto] = new FieldDoc(hit.doc, hit.score, ((FieldDoc) hit).fields, ref.shardIndex);\n      }\n\n      //System.out.println(\"  hitUpto=\" + hitUpto);\n      //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n      hitUpto++;\n\n      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n        // Not done with this these TopDocs yet:\n        queue.add(ref);\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"226aae72c0326f4299c16280195bade4530de537","date":1324221898,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","sourceNew":"  /** Returns a new TopDocs, containing topN results across\n   *  the provided TopDocs, sorting by the specified {@link\n   *  Sort}.  Each of the TopDocs must have been sorted by\n   *  the same Sort, and sort field values must have been\n   *  filled (ie, <code>fillFields=true</code> must be\n   *  passed to {@link\n   *  TopFieldCollector#create}.\n   *\n   * <p>Pass sort=null to merge sort by score descending.\n   *\n   * @lucene.experimental */\n  public static TopDocs merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, availHitCount)];\n\n    int hitUpto = 0;\n    while(hitUpto < hits.length) {\n      assert queue.size() > 0;\n      ShardRef ref = queue.pop();\n      final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n      hit.shardIndex = ref.shardIndex;\n      hits[hitUpto] = hit;\n\n      //System.out.println(\"  hitUpto=\" + hitUpto);\n      //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n      hitUpto++;\n\n      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n        // Not done with this these TopDocs yet:\n        queue.add(ref);\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","sourceOld":"  /** Returns a new TopDocs, containing topN results across\n   *  the provided TopDocs, sorting by the specified {@link\n   *  Sort}.  Each of the TopDocs must have been sorted by\n   *  the same Sort, and sort field values must have been\n   *  filled (ie, <code>fillFields=true</code> must be\n   *  passed to {@link\n   *  TopFieldCollector#create}.\n   *\n   * <p>Pass sort=null to merge sort by score descending.\n   *\n   * @lucene.experimental */\n  public static TopDocs merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        totalHitCount += shard.totalHits;\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, availHitCount)];\n\n    int hitUpto = 0;\n    while(hitUpto < hits.length) {\n      assert queue.size() > 0;\n      ShardRef ref = queue.pop();\n      final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n      hit.shardIndex = ref.shardIndex;\n      hits[hitUpto] = hit;\n\n      //System.out.println(\"  hitUpto=\" + hitUpto);\n      //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n      hitUpto++;\n\n      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n        // Not done with this these TopDocs yet:\n        queue.add(ref);\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/TopDocs#merge(Sort,int,TopDocs[]).mjava","sourceNew":"  /** Returns a new TopDocs, containing topN results across\n   *  the provided TopDocs, sorting by the specified {@link\n   *  Sort}.  Each of the TopDocs must have been sorted by\n   *  the same Sort, and sort field values must have been\n   *  filled (ie, <code>fillFields=true</code> must be\n   *  passed to {@link\n   *  TopFieldCollector#create}.\n   *\n   * <p>Pass sort=null to merge sort by score descending.\n   *\n   * @lucene.experimental */\n  public static TopDocs merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, availHitCount)];\n\n    int hitUpto = 0;\n    while(hitUpto < hits.length) {\n      assert queue.size() > 0;\n      ShardRef ref = queue.pop();\n      final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n      hit.shardIndex = ref.shardIndex;\n      hits[hitUpto] = hit;\n\n      //System.out.println(\"  hitUpto=\" + hitUpto);\n      //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n      hitUpto++;\n\n      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n        // Not done with this these TopDocs yet:\n        queue.add(ref);\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","sourceOld":"  /** Returns a new TopDocs, containing topN results across\n   *  the provided TopDocs, sorting by the specified {@link\n   *  Sort}.  Each of the TopDocs must have been sorted by\n   *  the same Sort, and sort field values must have been\n   *  filled (ie, <code>fillFields=true</code> must be\n   *  passed to {@link\n   *  TopFieldCollector#create}.\n   *\n   * <p>Pass sort=null to merge sort by score descending.\n   *\n   * @lucene.experimental */\n  public static TopDocs merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {\n\n    final PriorityQueue<ShardRef> queue;\n    if (sort == null) {\n      queue = new ScoreMergeSortQueue(shardHits);\n    } else {\n      queue = new MergeSortQueue(sort, shardHits);\n    }\n\n    int totalHitCount = 0;\n    int availHitCount = 0;\n    float maxScore = Float.MIN_VALUE;\n    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {\n      final TopDocs shard = shardHits[shardIDX];\n      // totalHits can be non-zero even if no hits were\n      // collected, when searchAfter was used:\n      totalHitCount += shard.totalHits;\n      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {\n        availHitCount += shard.scoreDocs.length;\n        queue.add(new ShardRef(shardIDX));\n        maxScore = Math.max(maxScore, shard.getMaxScore());\n        //System.out.println(\"  maxScore now \" + maxScore + \" vs \" + shard.getMaxScore());\n      }\n    }\n\n    if (availHitCount == 0) {\n      maxScore = Float.NaN;\n    }\n\n    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, availHitCount)];\n\n    int hitUpto = 0;\n    while(hitUpto < hits.length) {\n      assert queue.size() > 0;\n      ShardRef ref = queue.pop();\n      final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];\n      hit.shardIndex = ref.shardIndex;\n      hits[hitUpto] = hit;\n\n      //System.out.println(\"  hitUpto=\" + hitUpto);\n      //System.out.println(\"    doc=\" + hits[hitUpto].doc + \" score=\" + hits[hitUpto].score);\n\n      hitUpto++;\n\n      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {\n        // Not done with this these TopDocs yet:\n        queue.add(ref);\n      }\n    }\n\n    if (sort == null) {\n      return new TopDocs(totalHitCount, hits, maxScore);\n    } else {\n      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e5d731d304e051cf7ed37410c1431e942f41c09b"],"fa604af8d2ace89a31df3233bbe1ccd7e1967e74":["e5d731d304e051cf7ed37410c1431e942f41c09b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["226aae72c0326f4299c16280195bade4530de537"],"226aae72c0326f4299c16280195bade4530de537":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"ccc08aa684aee4964baee0644a6ba047bfd70829":["fa604af8d2ace89a31df3233bbe1ccd7e1967e74"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d4aa50b979cd392e00e5bc0f23f78cbd106cb968":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["e5d731d304e051cf7ed37410c1431e942f41c09b","fa604af8d2ace89a31df3233bbe1ccd7e1967e74"],"e5d731d304e051cf7ed37410c1431e942f41c09b":["d4aa50b979cd392e00e5bc0f23f78cbd106cb968"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","fa604af8d2ace89a31df3233bbe1ccd7e1967e74"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"fa604af8d2ace89a31df3233bbe1ccd7e1967e74":["ccc08aa684aee4964baee0644a6ba047bfd70829","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"226aae72c0326f4299c16280195bade4530de537":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"ccc08aa684aee4964baee0644a6ba047bfd70829":["226aae72c0326f4299c16280195bade4530de537"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","d4aa50b979cd392e00e5bc0f23f78cbd106cb968"],"d4aa50b979cd392e00e5bc0f23f78cbd106cb968":["e5d731d304e051cf7ed37410c1431e942f41c09b"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"e5d731d304e051cf7ed37410c1431e942f41c09b":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","fa604af8d2ace89a31df3233bbe1ccd7e1967e74","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"817d8435e9135b756f08ce6710ab0baac51bdf88":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}