{"path":"modules/analysis/kuromoji/src/tools/java/org/apache/lucene/analysis/ja/util/BinaryDictionaryWriter#put(String[]).mjava","commits":[{"id":"98d45c1ff2c99694b6de2201175f9b8b8b27b597","date":1332757908,"type":1,"author":"Christian Moen","isMerge":false,"pathNew":"modules/analysis/kuromoji/src/tools/java/org/apache/lucene/analysis/ja/util/BinaryDictionaryWriter#put(String[]).mjava","pathOld":"modules/analysis/kuromoji/src/tools/java/org/apache/lucene/analysis/kuromoji/util/BinaryDictionaryWriter#put(String[]).mjava","sourceNew":"  /**\n   * put the entry in map\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n    \n    StringBuilder sb = new StringBuilder();\n    \n    // build up the POS string\n    for (int i = 4; i < 8; i++) {\n      String part = entry[i];\n      assert part.length() > 0;\n      if (!\"*\".equals(part)) {\n        if (sb.length() > 0) {\n          sb.append('-');\n        }\n        sb.append(part);\n      }\n    }\n    \n    String posData = sb.toString();\n    \n    sb.setLength(0);\n    sb.append(CSVUtil.quoteEscape(posData));\n    sb.append(',');\n    if (!\"*\".equals(entry[8])) {\n      sb.append(CSVUtil.quoteEscape(entry[8]));\n    }\n    sb.append(',');\n    if (!\"*\".equals(entry[9])) {\n      sb.append(CSVUtil.quoteEscape(entry[9]));\n    }\n    String fullPOSData = sb.toString();\n    \n    String baseForm = entry[10];\n    String reading = entry[11];\n    String pronunciation = entry[12];\n    \n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case: two short, 3 bytes, and features (all as utf-16)\n    int worstCase = 4 + 3 + 2*(baseForm.length() + reading.length() + pronunciation.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    int flags = 0;\n    if (!(\"*\".equals(baseForm) || baseForm.equals(entry[0]))) {\n      flags |= BinaryDictionary.HAS_BASEFORM;\n    }\n    if (!reading.equals(toKatakana(entry[0]))) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n    if (!pronunciation.equals(reading)) {\n      flags |= BinaryDictionary.HAS_PRONUNCIATION;\n    }\n\n    assert leftId == rightId;\n    assert leftId < 4096; // there are still unused bits\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    \n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n    \n    buffer.putShort((short)(leftId << 3 | flags));\n    buffer.putShort(wordCost);\n\n    if ((flags & BinaryDictionary.HAS_BASEFORM) != 0) {\n      assert baseForm.length() < 16;\n      int shared = sharedPrefix(entry[0], baseForm);\n      int suffix = baseForm.length() - shared;\n      buffer.put((byte) (shared << 4 | suffix));\n      for (int i = shared; i < baseForm.length(); i++) {\n        buffer.putChar(baseForm.charAt(i));\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_READING) != 0) {\n      if (isKatakana(reading)) {\n        buffer.put((byte) (reading.length() << 1 | 1));\n        writeKatakana(reading);\n      } else {\n        buffer.put((byte) (reading.length() << 1));\n        for (int i = 0; i < reading.length(); i++) {\n          buffer.putChar(reading.charAt(i));\n        }\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_PRONUNCIATION) != 0) {\n      // we can save 150KB here, but it makes the reader a little complicated.\n      // int shared = sharedPrefix(reading, pronunciation);\n      // buffer.put((byte) shared);\n      // pronunciation = pronunciation.substring(shared);\n      if (isKatakana(pronunciation)) {\n        buffer.put((byte) (pronunciation.length() << 1 | 1));\n        writeKatakana(pronunciation);\n      } else {\n        buffer.put((byte) (pronunciation.length() << 1));\n        for (int i = 0; i < pronunciation.length(); i++) {\n          buffer.putChar(pronunciation.charAt(i));\n        }\n      }\n    }\n    \n    return buffer.position();\n  }\n\n","sourceOld":"  /**\n   * put the entry in map\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n    \n    StringBuilder sb = new StringBuilder();\n    \n    // build up the POS string\n    for (int i = 4; i < 8; i++) {\n      String part = entry[i];\n      assert part.length() > 0;\n      if (!\"*\".equals(part)) {\n        if (sb.length() > 0) {\n          sb.append('-');\n        }\n        sb.append(part);\n      }\n    }\n    \n    String posData = sb.toString();\n    \n    sb.setLength(0);\n    sb.append(CSVUtil.quoteEscape(posData));\n    sb.append(',');\n    if (!\"*\".equals(entry[8])) {\n      sb.append(CSVUtil.quoteEscape(entry[8]));\n    }\n    sb.append(',');\n    if (!\"*\".equals(entry[9])) {\n      sb.append(CSVUtil.quoteEscape(entry[9]));\n    }\n    String fullPOSData = sb.toString();\n    \n    String baseForm = entry[10];\n    String reading = entry[11];\n    String pronunciation = entry[12];\n    \n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case: two short, 3 bytes, and features (all as utf-16)\n    int worstCase = 4 + 3 + 2*(baseForm.length() + reading.length() + pronunciation.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    int flags = 0;\n    if (!(\"*\".equals(baseForm) || baseForm.equals(entry[0]))) {\n      flags |= BinaryDictionary.HAS_BASEFORM;\n    }\n    if (!reading.equals(toKatakana(entry[0]))) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n    if (!pronunciation.equals(reading)) {\n      flags |= BinaryDictionary.HAS_PRONUNCIATION;\n    }\n\n    assert leftId == rightId;\n    assert leftId < 4096; // there are still unused bits\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    \n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n    \n    buffer.putShort((short)(leftId << 3 | flags));\n    buffer.putShort(wordCost);\n\n    if ((flags & BinaryDictionary.HAS_BASEFORM) != 0) {\n      assert baseForm.length() < 16;\n      int shared = sharedPrefix(entry[0], baseForm);\n      int suffix = baseForm.length() - shared;\n      buffer.put((byte) (shared << 4 | suffix));\n      for (int i = shared; i < baseForm.length(); i++) {\n        buffer.putChar(baseForm.charAt(i));\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_READING) != 0) {\n      if (isKatakana(reading)) {\n        buffer.put((byte) (reading.length() << 1 | 1));\n        writeKatakana(reading);\n      } else {\n        buffer.put((byte) (reading.length() << 1));\n        for (int i = 0; i < reading.length(); i++) {\n          buffer.putChar(reading.charAt(i));\n        }\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_PRONUNCIATION) != 0) {\n      // we can save 150KB here, but it makes the reader a little complicated.\n      // int shared = sharedPrefix(reading, pronunciation);\n      // buffer.put((byte) shared);\n      // pronunciation = pronunciation.substring(shared);\n      if (isKatakana(pronunciation)) {\n        buffer.put((byte) (pronunciation.length() << 1 | 1));\n        writeKatakana(pronunciation);\n      } else {\n        buffer.put((byte) (pronunciation.length() << 1));\n        for (int i = 0; i < pronunciation.length(); i++) {\n          buffer.putChar(pronunciation.charAt(i));\n        }\n      }\n    }\n    \n    return buffer.position();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/kuromoji/src/tools/java/org/apache/lucene/analysis/ja/util/BinaryDictionaryWriter#put(String[]).mjava","pathOld":"modules/analysis/kuromoji/src/tools/java/org/apache/lucene/analysis/ja/util/BinaryDictionaryWriter#put(String[]).mjava","sourceNew":"  /**\n   * put the entry in map\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n    \n    StringBuilder sb = new StringBuilder();\n    \n    // build up the POS string\n    for (int i = 4; i < 8; i++) {\n      String part = entry[i];\n      assert part.length() > 0;\n      if (!\"*\".equals(part)) {\n        if (sb.length() > 0) {\n          sb.append('-');\n        }\n        sb.append(part);\n      }\n    }\n    \n    String posData = sb.toString();\n    \n    sb.setLength(0);\n    sb.append(CSVUtil.quoteEscape(posData));\n    sb.append(',');\n    if (!\"*\".equals(entry[8])) {\n      sb.append(CSVUtil.quoteEscape(entry[8]));\n    }\n    sb.append(',');\n    if (!\"*\".equals(entry[9])) {\n      sb.append(CSVUtil.quoteEscape(entry[9]));\n    }\n    String fullPOSData = sb.toString();\n    \n    String baseForm = entry[10];\n    String reading = entry[11];\n    String pronunciation = entry[12];\n    \n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case: two short, 3 bytes, and features (all as utf-16)\n    int worstCase = 4 + 3 + 2*(baseForm.length() + reading.length() + pronunciation.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    int flags = 0;\n    if (!(\"*\".equals(baseForm) || baseForm.equals(entry[0]))) {\n      flags |= BinaryDictionary.HAS_BASEFORM;\n    }\n    if (!reading.equals(toKatakana(entry[0]))) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n    if (!pronunciation.equals(reading)) {\n      flags |= BinaryDictionary.HAS_PRONUNCIATION;\n    }\n\n    assert leftId == rightId;\n    assert leftId < 4096; // there are still unused bits\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    \n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n    \n    buffer.putShort((short)(leftId << 3 | flags));\n    buffer.putShort(wordCost);\n\n    if ((flags & BinaryDictionary.HAS_BASEFORM) != 0) {\n      assert baseForm.length() < 16;\n      int shared = sharedPrefix(entry[0], baseForm);\n      int suffix = baseForm.length() - shared;\n      buffer.put((byte) (shared << 4 | suffix));\n      for (int i = shared; i < baseForm.length(); i++) {\n        buffer.putChar(baseForm.charAt(i));\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_READING) != 0) {\n      if (isKatakana(reading)) {\n        buffer.put((byte) (reading.length() << 1 | 1));\n        writeKatakana(reading);\n      } else {\n        buffer.put((byte) (reading.length() << 1));\n        for (int i = 0; i < reading.length(); i++) {\n          buffer.putChar(reading.charAt(i));\n        }\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_PRONUNCIATION) != 0) {\n      // we can save 150KB here, but it makes the reader a little complicated.\n      // int shared = sharedPrefix(reading, pronunciation);\n      // buffer.put((byte) shared);\n      // pronunciation = pronunciation.substring(shared);\n      if (isKatakana(pronunciation)) {\n        buffer.put((byte) (pronunciation.length() << 1 | 1));\n        writeKatakana(pronunciation);\n      } else {\n        buffer.put((byte) (pronunciation.length() << 1));\n        for (int i = 0; i < pronunciation.length(); i++) {\n          buffer.putChar(pronunciation.charAt(i));\n        }\n      }\n    }\n    \n    return buffer.position();\n  }\n\n","sourceOld":"  /**\n   * put the entry in map\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n    \n    StringBuilder sb = new StringBuilder();\n    \n    // build up the POS string\n    for (int i = 4; i < 8; i++) {\n      String part = entry[i];\n      assert part.length() > 0;\n      if (!\"*\".equals(part)) {\n        if (sb.length() > 0) {\n          sb.append('-');\n        }\n        sb.append(part);\n      }\n    }\n    \n    String posData = sb.toString();\n    \n    sb.setLength(0);\n    sb.append(CSVUtil.quoteEscape(posData));\n    sb.append(',');\n    if (!\"*\".equals(entry[8])) {\n      sb.append(CSVUtil.quoteEscape(entry[8]));\n    }\n    sb.append(',');\n    if (!\"*\".equals(entry[9])) {\n      sb.append(CSVUtil.quoteEscape(entry[9]));\n    }\n    String fullPOSData = sb.toString();\n    \n    String baseForm = entry[10];\n    String reading = entry[11];\n    String pronunciation = entry[12];\n    \n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case: two short, 3 bytes, and features (all as utf-16)\n    int worstCase = 4 + 3 + 2*(baseForm.length() + reading.length() + pronunciation.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    int flags = 0;\n    if (!(\"*\".equals(baseForm) || baseForm.equals(entry[0]))) {\n      flags |= BinaryDictionary.HAS_BASEFORM;\n    }\n    if (!reading.equals(toKatakana(entry[0]))) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n    if (!pronunciation.equals(reading)) {\n      flags |= BinaryDictionary.HAS_PRONUNCIATION;\n    }\n\n    assert leftId == rightId;\n    assert leftId < 4096; // there are still unused bits\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    \n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n    \n    buffer.putShort((short)(leftId << 3 | flags));\n    buffer.putShort(wordCost);\n\n    if ((flags & BinaryDictionary.HAS_BASEFORM) != 0) {\n      assert baseForm.length() < 16;\n      int shared = sharedPrefix(entry[0], baseForm);\n      int suffix = baseForm.length() - shared;\n      buffer.put((byte) (shared << 4 | suffix));\n      for (int i = shared; i < baseForm.length(); i++) {\n        buffer.putChar(baseForm.charAt(i));\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_READING) != 0) {\n      if (isKatakana(reading)) {\n        buffer.put((byte) (reading.length() << 1 | 1));\n        writeKatakana(reading);\n      } else {\n        buffer.put((byte) (reading.length() << 1));\n        for (int i = 0; i < reading.length(); i++) {\n          buffer.putChar(reading.charAt(i));\n        }\n      }\n    }\n    \n    if ((flags & BinaryDictionary.HAS_PRONUNCIATION) != 0) {\n      // we can save 150KB here, but it makes the reader a little complicated.\n      // int shared = sharedPrefix(reading, pronunciation);\n      // buffer.put((byte) shared);\n      // pronunciation = pronunciation.substring(shared);\n      if (isKatakana(pronunciation)) {\n        buffer.put((byte) (pronunciation.length() << 1 | 1));\n        writeKatakana(pronunciation);\n      } else {\n        buffer.put((byte) (pronunciation.length() << 1));\n        for (int i = 0; i < pronunciation.length(); i++) {\n          buffer.putChar(pronunciation.charAt(i));\n        }\n      }\n    }\n    \n    return buffer.position();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["98d45c1ff2c99694b6de2201175f9b8b8b27b597"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"98d45c1ff2c99694b6de2201175f9b8b8b27b597":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["98d45c1ff2c99694b6de2201175f9b8b8b27b597"],"98d45c1ff2c99694b6de2201175f9b8b8b27b597":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}