{"path":"solr/core/src/test/org/apache/solr/TestHighlightDedupGrouping#randomizedTest().mjava","commits":[{"id":"3717ad5d6103c6c5c87888e9d0e791b9124c98b6","date":1392066483,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestHighlightDedupGrouping#randomizedTest().mjava","pathOld":"/dev/null","sourceNew":"  private void randomizedTest() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    int numDocs = _TestUtil.nextInt(random(), 100, 1000);\n    int numGroups = _TestUtil.nextInt(random(), 1, numDocs / 50);\n    int[] docsInGroup = new int[numGroups + 1];\n    int percentDuplicates = _TestUtil.nextInt(random(), 1, 25);\n    for (int docid = 0 ; docid < numDocs ; ++docid) {\n      int group = _TestUtil.nextInt(random(), 1, numGroups);\n      ++docsInGroup[group];\n      boolean makeDuplicate = 0 == _TestUtil.nextInt(random(), 0, numDocs / percentDuplicates);\n      if (makeDuplicate) {\n        for (int shard = 0 ; shard < shardCount ; ++shard) {\n          addDoc(docid, group, shard);\n        }\n      } else {\n        int shard = _TestUtil.nextInt(random(), 0, shardCount - 1);\n        addDoc(docid, group, shard);\n      }\n    }\n    for (int shard = 0 ; shard < shardCount ; ++shard) {\n      clients.get(shard).commit();\n    }\n\n    for (int group = 1 ; group <= numGroups ; ++group) {\n      QueryResponse rsp = queryServer(params\n          (\"q\", group_ti1 + \":\" + group + \" AND \" + id_s1 + \":[* TO *]\", \"start\", \"0\", \"rows\", \"\" + numDocs,\n           \"fl\", id_s1 + \",\" + shard_i1, \"sort\", id_s1 + \" asc\", \"shards\", shards,\n           \"group\", \"true\", \"group.field\", id_s1\n          ,\"group.limit\", \"\" + numDocs\n          ,\"hl\", \"true\", \"hl.fl\", \"*\", \"hl.requireFieldMatch\", \"true\"\n          ));\n      // The number of highlit documents should be the same as the de-duplicated docs for this group\n      assertEquals(docsInGroup[group], rsp.getHighlighting().values().size());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestHighlightDedupGrouping#randomizedTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestHighlightDedupGrouping#randomizedTest().mjava","sourceNew":"  private void randomizedTest() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    int numDocs = TestUtil.nextInt(random(), 100, 1000);\n    int numGroups = TestUtil.nextInt(random(), 1, numDocs / 50);\n    int[] docsInGroup = new int[numGroups + 1];\n    int percentDuplicates = TestUtil.nextInt(random(), 1, 25);\n    for (int docid = 0 ; docid < numDocs ; ++docid) {\n      int group = TestUtil.nextInt(random(), 1, numGroups);\n      ++docsInGroup[group];\n      boolean makeDuplicate = 0 == TestUtil.nextInt(random(), 0, numDocs / percentDuplicates);\n      if (makeDuplicate) {\n        for (int shard = 0 ; shard < shardCount ; ++shard) {\n          addDoc(docid, group, shard);\n        }\n      } else {\n        int shard = TestUtil.nextInt(random(), 0, shardCount - 1);\n        addDoc(docid, group, shard);\n      }\n    }\n    for (int shard = 0 ; shard < shardCount ; ++shard) {\n      clients.get(shard).commit();\n    }\n\n    for (int group = 1 ; group <= numGroups ; ++group) {\n      QueryResponse rsp = queryServer(params\n          (\"q\", group_ti1 + \":\" + group + \" AND \" + id_s1 + \":[* TO *]\", \"start\", \"0\", \"rows\", \"\" + numDocs,\n           \"fl\", id_s1 + \",\" + shard_i1, \"sort\", id_s1 + \" asc\", \"shards\", shards,\n           \"group\", \"true\", \"group.field\", id_s1\n          ,\"group.limit\", \"\" + numDocs\n          ,\"hl\", \"true\", \"hl.fl\", \"*\", \"hl.requireFieldMatch\", \"true\"\n          ));\n      // The number of highlit documents should be the same as the de-duplicated docs for this group\n      assertEquals(docsInGroup[group], rsp.getHighlighting().values().size());\n    }\n  }\n\n","sourceOld":"  private void randomizedTest() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    int numDocs = _TestUtil.nextInt(random(), 100, 1000);\n    int numGroups = _TestUtil.nextInt(random(), 1, numDocs / 50);\n    int[] docsInGroup = new int[numGroups + 1];\n    int percentDuplicates = _TestUtil.nextInt(random(), 1, 25);\n    for (int docid = 0 ; docid < numDocs ; ++docid) {\n      int group = _TestUtil.nextInt(random(), 1, numGroups);\n      ++docsInGroup[group];\n      boolean makeDuplicate = 0 == _TestUtil.nextInt(random(), 0, numDocs / percentDuplicates);\n      if (makeDuplicate) {\n        for (int shard = 0 ; shard < shardCount ; ++shard) {\n          addDoc(docid, group, shard);\n        }\n      } else {\n        int shard = _TestUtil.nextInt(random(), 0, shardCount - 1);\n        addDoc(docid, group, shard);\n      }\n    }\n    for (int shard = 0 ; shard < shardCount ; ++shard) {\n      clients.get(shard).commit();\n    }\n\n    for (int group = 1 ; group <= numGroups ; ++group) {\n      QueryResponse rsp = queryServer(params\n          (\"q\", group_ti1 + \":\" + group + \" AND \" + id_s1 + \":[* TO *]\", \"start\", \"0\", \"rows\", \"\" + numDocs,\n           \"fl\", id_s1 + \",\" + shard_i1, \"sort\", id_s1 + \" asc\", \"shards\", shards,\n           \"group\", \"true\", \"group.field\", id_s1\n          ,\"group.limit\", \"\" + numDocs\n          ,\"hl\", \"true\", \"hl.fl\", \"*\", \"hl.requireFieldMatch\", \"true\"\n          ));\n      // The number of highlit documents should be the same as the de-duplicated docs for this group\n      assertEquals(docsInGroup[group], rsp.getHighlighting().values().size());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"072f211dfa8387028bb978d128c35bf9a450bbbf","date":1406041363,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestHighlightDedupGrouping#randomizedTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestHighlightDedupGrouping#randomizedTest().mjava","sourceNew":"  private void randomizedTest() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    int numDocs = TestUtil.nextInt(random(), 100, 1000);\n    int numGroups = TestUtil.nextInt(random(), 1, numDocs / 50);\n    int[] docsInGroup = new int[numGroups + 1];\n    int percentDuplicates = TestUtil.nextInt(random(), 1, 25);\n    for (int docid = 0 ; docid < numDocs ; ++docid) {\n      int group = TestUtil.nextInt(random(), 1, numGroups);\n      ++docsInGroup[group];\n      boolean makeDuplicate = 0 == TestUtil.nextInt(random(), 0, numDocs / percentDuplicates);\n      if (makeDuplicate) {\n        for (int shard = 0 ; shard < shardCount ; ++shard) {\n          addDoc(docid, group, shard);\n        }\n      } else {\n        int shard = TestUtil.nextInt(random(), 0, shardCount - 1);\n        addDoc(docid, group, shard);\n      }\n    }\n    for (int shard = 0 ; shard < shardCount ; ++shard) {\n      clients.get(shard).commit();\n    }\n\n    for (int group = 1 ; group <= numGroups ; ++group) {\n      QueryResponse rsp = queryServer(params\n          (\"q\", group_ti1 + \":\" + group + \" AND \" + id_s1 + \":[* TO *]\", \"start\", \"0\", \"rows\", \"\" + numDocs,\n           \"fl\", id_s1 + \",\" + shard_i1, \"sort\", id_s1 + \" asc\", \"shards\", shards,\n           \"group\", \"true\", \"group.field\", id_s1\n          ,\"group.limit\", \"\" + numDocs\n          ,\"hl\", \"true\", \"hl.fl\", \"*\", \"hl.requireFieldMatch\", \"true\"\n          ));\n      // The number of highlit documents should be the same as the de-duplicated docs for this group\n      assertEquals(docsInGroup[group], rsp.getHighlighting().values().size());\n    }\n  }\n\n","sourceOld":"  private void randomizedTest() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    int numDocs = TestUtil.nextInt(random(), 100, 1000);\n    int numGroups = TestUtil.nextInt(random(), 1, numDocs / 50);\n    int[] docsInGroup = new int[numGroups + 1];\n    int percentDuplicates = TestUtil.nextInt(random(), 1, 25);\n    for (int docid = 0 ; docid < numDocs ; ++docid) {\n      int group = TestUtil.nextInt(random(), 1, numGroups);\n      ++docsInGroup[group];\n      boolean makeDuplicate = 0 == TestUtil.nextInt(random(), 0, numDocs / percentDuplicates);\n      if (makeDuplicate) {\n        for (int shard = 0 ; shard < shardCount ; ++shard) {\n          addDoc(docid, group, shard);\n        }\n      } else {\n        int shard = TestUtil.nextInt(random(), 0, shardCount - 1);\n        addDoc(docid, group, shard);\n      }\n    }\n    for (int shard = 0 ; shard < shardCount ; ++shard) {\n      clients.get(shard).commit();\n    }\n\n    for (int group = 1 ; group <= numGroups ; ++group) {\n      QueryResponse rsp = queryServer(params\n          (\"q\", group_ti1 + \":\" + group + \" AND \" + id_s1 + \":[* TO *]\", \"start\", \"0\", \"rows\", \"\" + numDocs,\n           \"fl\", id_s1 + \",\" + shard_i1, \"sort\", id_s1 + \" asc\", \"shards\", shards,\n           \"group\", \"true\", \"group.field\", id_s1\n          ,\"group.limit\", \"\" + numDocs\n          ,\"hl\", \"true\", \"hl.fl\", \"*\", \"hl.requireFieldMatch\", \"true\"\n          ));\n      // The number of highlit documents should be the same as the de-duplicated docs for this group\n      assertEquals(docsInGroup[group], rsp.getHighlighting().values().size());\n    }\n  }\n\n","bugFix":["3717ad5d6103c6c5c87888e9d0e791b9124c98b6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"abb23fcc2461782ab204e61213240feb77d355aa","date":1422029612,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestHighlightDedupGrouping#randomizedTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestHighlightDedupGrouping#randomizedTest().mjava","sourceNew":"  private void randomizedTest() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    int numDocs = TestUtil.nextInt(random(), 100, 1000);\n    int numGroups = TestUtil.nextInt(random(), 1, numDocs / 50);\n    int[] docsInGroup = new int[numGroups + 1];\n    int percentDuplicates = TestUtil.nextInt(random(), 1, 25);\n    for (int docid = 0 ; docid < numDocs ; ++docid) {\n      int group = TestUtil.nextInt(random(), 1, numGroups);\n      ++docsInGroup[group];\n      boolean makeDuplicate = 0 == TestUtil.nextInt(random(), 0, numDocs / percentDuplicates);\n      if (makeDuplicate) {\n        for (int shard = 0 ; shard < getShardCount(); ++shard) {\n          addDoc(docid, group, shard);\n        }\n      } else {\n        int shard = TestUtil.nextInt(random(), 0, getShardCount() - 1);\n        addDoc(docid, group, shard);\n      }\n    }\n    for (int shard = 0 ; shard < getShardCount(); ++shard) {\n      clients.get(shard).commit();\n    }\n\n    for (int group = 1 ; group <= numGroups ; ++group) {\n      QueryResponse rsp = queryServer(params\n          (\"q\", group_ti1 + \":\" + group + \" AND \" + id_s1 + \":[* TO *]\", \"start\", \"0\", \"rows\", \"\" + numDocs,\n           \"fl\", id_s1 + \",\" + shard_i1, \"sort\", id_s1 + \" asc\", \"shards\", shards,\n           \"group\", \"true\", \"group.field\", id_s1\n          ,\"group.limit\", \"\" + numDocs\n          ,\"hl\", \"true\", \"hl.fl\", \"*\", \"hl.requireFieldMatch\", \"true\"\n          ));\n      // The number of highlit documents should be the same as the de-duplicated docs for this group\n      assertEquals(docsInGroup[group], rsp.getHighlighting().values().size());\n    }\n  }\n\n","sourceOld":"  private void randomizedTest() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"grouped\", UNORDERED);   // distrib grouping doesn't guarantee order of top level group commands\n\n    int numDocs = TestUtil.nextInt(random(), 100, 1000);\n    int numGroups = TestUtil.nextInt(random(), 1, numDocs / 50);\n    int[] docsInGroup = new int[numGroups + 1];\n    int percentDuplicates = TestUtil.nextInt(random(), 1, 25);\n    for (int docid = 0 ; docid < numDocs ; ++docid) {\n      int group = TestUtil.nextInt(random(), 1, numGroups);\n      ++docsInGroup[group];\n      boolean makeDuplicate = 0 == TestUtil.nextInt(random(), 0, numDocs / percentDuplicates);\n      if (makeDuplicate) {\n        for (int shard = 0 ; shard < shardCount ; ++shard) {\n          addDoc(docid, group, shard);\n        }\n      } else {\n        int shard = TestUtil.nextInt(random(), 0, shardCount - 1);\n        addDoc(docid, group, shard);\n      }\n    }\n    for (int shard = 0 ; shard < shardCount ; ++shard) {\n      clients.get(shard).commit();\n    }\n\n    for (int group = 1 ; group <= numGroups ; ++group) {\n      QueryResponse rsp = queryServer(params\n          (\"q\", group_ti1 + \":\" + group + \" AND \" + id_s1 + \":[* TO *]\", \"start\", \"0\", \"rows\", \"\" + numDocs,\n           \"fl\", id_s1 + \",\" + shard_i1, \"sort\", id_s1 + \" asc\", \"shards\", shards,\n           \"group\", \"true\", \"group.field\", id_s1\n          ,\"group.limit\", \"\" + numDocs\n          ,\"hl\", \"true\", \"hl.fl\", \"*\", \"hl.requireFieldMatch\", \"true\"\n          ));\n      // The number of highlit documents should be the same as the de-duplicated docs for this group\n      assertEquals(docsInGroup[group], rsp.getHighlighting().values().size());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"072f211dfa8387028bb978d128c35bf9a450bbbf":["6613659748fe4411a7dcf85266e55db1f95f7315"],"abb23fcc2461782ab204e61213240feb77d355aa":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"6613659748fe4411a7dcf85266e55db1f95f7315":["3717ad5d6103c6c5c87888e9d0e791b9124c98b6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3717ad5d6103c6c5c87888e9d0e791b9124c98b6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["abb23fcc2461782ab204e61213240feb77d355aa"]},"commit2Childs":{"072f211dfa8387028bb978d128c35bf9a450bbbf":["abb23fcc2461782ab204e61213240feb77d355aa"],"abb23fcc2461782ab204e61213240feb77d355aa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6613659748fe4411a7dcf85266e55db1f95f7315":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3717ad5d6103c6c5c87888e9d0e791b9124c98b6"],"3717ad5d6103c6c5c87888e9d0e791b9124c98b6":["6613659748fe4411a7dcf85266e55db1f95f7315"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}