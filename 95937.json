{"path":"lucene/core/src/test/org/apache/lucene/search/TestEarlyTerminatingSortingCollector#testEarlyTermination().mjava","commits":[{"id":"fb0345a2d45479f891041f8b3ce351bc975e64ac","date":1462708700,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestEarlyTerminatingSortingCollector#testEarlyTermination().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/search/TestEarlyTerminatingSortingCollector#testEarlyTermination().mjava","sourceNew":"  public void testEarlyTermination() throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        final Sort sort = new Sort(new SortField(\"ndv1\", SortField.Type.LONG, false));\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, new EarlyTerminatingSortingCollector(collector2, sort, numHits));\n        assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());\n        assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  public void testEarlyTermination() throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        final Sort sort = new Sort(new SortField(\"ndv1\", SortField.Type.LONG, false));\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, new EarlyTerminatingSortingCollector(collector2, sort, numHits));\n        assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());\n        assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":1,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestEarlyTerminatingSortingCollector#testEarlyTermination().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/search/TestEarlyTerminatingSortingCollector#testEarlyTermination().mjava","sourceNew":"  public void testEarlyTermination() throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        final Sort sort = new Sort(new SortField(\"ndv1\", SortField.Type.LONG, false));\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, new EarlyTerminatingSortingCollector(collector2, sort, numHits));\n        assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());\n        assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  public void testEarlyTermination() throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        final Sort sort = new Sort(new SortField(\"ndv1\", SortField.Type.LONG, false));\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, new EarlyTerminatingSortingCollector(collector2, sort, numHits, mergePolicy.getSort()));\n        assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());\n        assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestEarlyTerminatingSortingCollector#testEarlyTermination().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/search/TestEarlyTerminatingSortingCollector#testEarlyTermination().mjava","sourceNew":"  public void testEarlyTermination() throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        final Sort sort = new Sort(new SortField(\"ndv1\", SortField.Type.LONG, false));\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, new EarlyTerminatingSortingCollector(collector2, sort, numHits));\n        assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());\n        assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  public void testEarlyTermination() throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        final Sort sort = new Sort(new SortField(\"ndv1\", SortField.Type.LONG, false));\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, new EarlyTerminatingSortingCollector(collector2, sort, numHits, mergePolicy.getSort()));\n        assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());\n        assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestEarlyTerminatingSortingCollector#testEarlyTermination().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/search/TestEarlyTerminatingSortingCollector#testEarlyTermination().mjava","sourceNew":"  public void testEarlyTermination() throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        final Sort sort = new Sort(new SortField(\"ndv1\", SortField.Type.LONG, false));\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, new EarlyTerminatingSortingCollector(collector2, sort, numHits));\n        assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());\n        assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  public void testEarlyTermination() throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        final Sort sort = new Sort(new SortField(\"ndv1\", SortField.Type.LONG, false));\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, new EarlyTerminatingSortingCollector(collector2, sort, numHits, mergePolicy.getSort()));\n        assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());\n        assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestEarlyTerminatingSortingCollector#testEarlyTermination().mjava","pathOld":"/dev/null","sourceNew":"  public void testEarlyTermination() throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        final Sort sort = new Sort(new SortField(\"ndv1\", SortField.Type.LONG, false));\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, new EarlyTerminatingSortingCollector(collector2, sort, numHits));\n        assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());\n        assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"404d1ab7f6f396235047017c88d545fec15dafb7","date":1511975378,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestEarlyTerminatingSortingCollector#testEarlyTermination().mjava","sourceNew":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (trackMaxScore == false && paging == false && maxSegmentSize >= numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  public void testEarlyTermination() throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        final Sort sort = new Sort(new SortField(\"ndv1\", SortField.Type.LONG, false));\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, new EarlyTerminatingSortingCollector(collector2, sort, numHits));\n        assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());\n        assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":["90fd44f6cbe87f857a94381a51d1b32d629d090c","90fd44f6cbe87f857a94381a51d1b32d629d090c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestEarlyTerminatingSortingCollector#testEarlyTermination().mjava","sourceNew":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().maxDoc() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (trackMaxScore == false && paging == false && maxSegmentSize >= numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  public void testEarlyTermination() throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        final Sort sort = new Sort(new SortField(\"ndv1\", SortField.Type.LONG, false));\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, new EarlyTerminatingSortingCollector(collector2, sort, numHits));\n        assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());\n        assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"1aad05eeff7818b0833c02ac6b743aa72054963b":["d470c8182e92b264680e34081b75e70a9f2b3c89","404d1ab7f6f396235047017c88d545fec15dafb7"],"404d1ab7f6f396235047017c88d545fec15dafb7":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0ad30c6a479e764150a3316e57263319775f1df2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3d33e731a93d4b57e662ff094f64f94a745422d4"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","fb0345a2d45479f891041f8b3ce351bc975e64ac"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0ad30c6a479e764150a3316e57263319775f1df2"],"fb0345a2d45479f891041f8b3ce351bc975e64ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"1aad05eeff7818b0833c02ac6b743aa72054963b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"404d1ab7f6f396235047017c88d545fec15dafb7":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad30c6a479e764150a3316e57263319775f1df2","3d33e731a93d4b57e662ff094f64f94a745422d4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","fb0345a2d45479f891041f8b3ce351bc975e64ac"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["1aad05eeff7818b0833c02ac6b743aa72054963b","404d1ab7f6f396235047017c88d545fec15dafb7","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"fb0345a2d45479f891041f8b3ce351bc975e64ac":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}