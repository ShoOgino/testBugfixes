{"path":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","commits":[{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/StreamingSolrServers#getSolrServer(SolrCmdDistributor.Req).mjava","sourceNew":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      client = new ConcurrentUpdateSolrClient(url, httpClient, 100, 1, updateExecutor, true) {\n        @Override\n        public void handleError(Throwable ex) {\n          req.trackRequestResult(null, false);\n          log.error(\"error\", ex);\n          Error error = new Error();\n          error.e = (Exception) ex;\n          if (ex instanceof SolrException) {\n            error.statusCode = ((SolrException) ex).code();\n          }\n          error.req = req;\n          errors.add(error);\n        }\n        @Override\n        public void onSuccess(HttpResponse resp) {\n          req.trackRequestResult(resp, true);\n        }\n      };\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      client.setPollQueueTime(0);\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","sourceOld":"  public synchronized SolrServer getSolrServer(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrServer server = solrServers.get(url);\n    if (server == null) {\n      server = new ConcurrentUpdateSolrServer(url, httpClient, 100, 1, updateExecutor, true) {\n        @Override\n        public void handleError(Throwable ex) {\n          req.trackRequestResult(null, false);\n          log.error(\"error\", ex);\n          Error error = new Error();\n          error.e = (Exception) ex;\n          if (ex instanceof SolrException) {\n            error.statusCode = ((SolrException) ex).code();\n          }\n          error.req = req;\n          errors.add(error);\n        }\n        @Override\n        public void onSuccess(HttpResponse resp) {\n          req.trackRequestResult(resp, true);\n        }\n      };\n      server.setParser(new BinaryResponseParser());\n      server.setRequestWriter(new BinaryRequestWriter());\n      server.setPollQueueTime(0);\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      server.setQueryParams(queryParams);\n      solrServers.put(url, server);\n    }\n\n    return server;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7749d6fa52f4781f8f7488f2bd18b0fbb5959d0b","date":1432083803,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","sourceNew":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      client = new ConcurrentUpdateSolrClient(url, httpClient, 100, 1, updateExecutor, true) {\n        @Override\n        public void handleError(Throwable ex) {\n          req.trackRequestResult(null, false);\n          log.error(\"error\", ex);\n          Error error = new Error();\n          error.e = (Exception) ex;\n          if (ex instanceof SolrException) {\n            error.statusCode = ((SolrException) ex).code();\n          }\n          error.req = req;\n          errors.add(error);\n        }\n        @Override\n        public void onSuccess(HttpResponse resp) {\n          req.trackRequestResult(resp, true);\n        }\n      };\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      client.setPollQueueTime(req.pollQueueTime);\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","sourceOld":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      client = new ConcurrentUpdateSolrClient(url, httpClient, 100, 1, updateExecutor, true) {\n        @Override\n        public void handleError(Throwable ex) {\n          req.trackRequestResult(null, false);\n          log.error(\"error\", ex);\n          Error error = new Error();\n          error.e = (Exception) ex;\n          if (ex instanceof SolrException) {\n            error.statusCode = ((SolrException) ex).code();\n          }\n          error.req = req;\n          errors.add(error);\n        }\n        @Override\n        public void onSuccess(HttpResponse resp) {\n          req.trackRequestResult(resp, true);\n        }\n      };\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      client.setPollQueueTime(0);\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e447fd876c400c615e8c20e892c60eafc13b840","date":1445722283,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","sourceNew":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ConcurrentUpdateSolrClient(url, httpClient, 100, 1, updateExecutor, true) {\n        @Override\n        public void handleError(Throwable ex) {\n          req.trackRequestResult(null, false);\n          log.error(\"error\", ex);\n          Error error = new Error();\n          error.e = (Exception) ex;\n          if (ex instanceof SolrException) {\n            error.statusCode = ((SolrException) ex).code();\n          }\n          error.req = req;\n          errors.add(error);\n        }\n        @Override\n        public void onSuccess(HttpResponse resp) {\n          req.trackRequestResult(resp, true);\n        }\n      };\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      client.setPollQueueTime(req.pollQueueTime);\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","sourceOld":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      client = new ConcurrentUpdateSolrClient(url, httpClient, 100, 1, updateExecutor, true) {\n        @Override\n        public void handleError(Throwable ex) {\n          req.trackRequestResult(null, false);\n          log.error(\"error\", ex);\n          Error error = new Error();\n          error.e = (Exception) ex;\n          if (ex instanceof SolrException) {\n            error.statusCode = ((SolrException) ex).code();\n          }\n          error.req = req;\n          errors.add(error);\n        }\n        @Override\n        public void onSuccess(HttpResponse resp) {\n          req.trackRequestResult(resp, true);\n        }\n      };\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      client.setPollQueueTime(req.pollQueueTime);\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d5d13b25ebb64794230a241686b8ed3d4860be","date":1454776444,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","sourceNew":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ConcurrentUpdateSolrClient(url, httpClient, 100, runnerCount, updateExecutor, true) {\n        @Override\n        public void handleError(Throwable ex) {\n          req.trackRequestResult(null, false);\n          log.error(\"error\", ex);\n          Error error = new Error();\n          error.e = (Exception) ex;\n          if (ex instanceof SolrException) {\n            error.statusCode = ((SolrException) ex).code();\n          }\n          error.req = req;\n          errors.add(error);\n        }\n        @Override\n        public void onSuccess(HttpResponse resp) {\n          req.trackRequestResult(resp, true);\n        }\n      };\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      client.setPollQueueTime(req.pollQueueTime);\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","sourceOld":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ConcurrentUpdateSolrClient(url, httpClient, 100, 1, updateExecutor, true) {\n        @Override\n        public void handleError(Throwable ex) {\n          req.trackRequestResult(null, false);\n          log.error(\"error\", ex);\n          Error error = new Error();\n          error.e = (Exception) ex;\n          if (ex instanceof SolrException) {\n            error.statusCode = ((SolrException) ex).code();\n          }\n          error.req = req;\n          errors.add(error);\n        }\n        @Override\n        public void onSuccess(HttpResponse resp) {\n          req.trackRequestResult(resp, true);\n        }\n      };\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      client.setPollQueueTime(req.pollQueueTime);\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd75f58072bba84066e89d61bd7028de1bd5b632","date":1454871793,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","sourceNew":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ConcurrentUpdateSolrClient(url, httpClient, 100, runnerCount, updateExecutor, true) {\n        @Override\n        public void handleError(Throwable ex) {\n          req.trackRequestResult(null, false);\n          log.error(\"error\", ex);\n          Error error = new Error();\n          error.e = (Exception) ex;\n          if (ex instanceof SolrException) {\n            error.statusCode = ((SolrException) ex).code();\n          }\n          error.req = req;\n          errors.add(error);\n        }\n        @Override\n        public void onSuccess(HttpResponse resp) {\n          req.trackRequestResult(resp, true);\n        }\n      };\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      client.setPollQueueTime(req.pollQueueTime);\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","sourceOld":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ConcurrentUpdateSolrClient(url, httpClient, 100, 1, updateExecutor, true) {\n        @Override\n        public void handleError(Throwable ex) {\n          req.trackRequestResult(null, false);\n          log.error(\"error\", ex);\n          Error error = new Error();\n          error.e = (Exception) ex;\n          if (ex instanceof SolrException) {\n            error.statusCode = ((SolrException) ex).code();\n          }\n          error.req = req;\n          errors.add(error);\n        }\n        @Override\n        public void onSuccess(HttpResponse resp) {\n          req.trackRequestResult(resp, true);\n        }\n      };\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      client.setPollQueueTime(req.pollQueueTime);\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","sourceNew":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient(url, httpClient, 100, runnerCount, updateExecutor, true, req);\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      client.setPollQueueTime(req.pollQueueTime);\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","sourceOld":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ConcurrentUpdateSolrClient(url, httpClient, 100, runnerCount, updateExecutor, true) {\n        @Override\n        public void handleError(Throwable ex) {\n          req.trackRequestResult(null, false);\n          log.error(\"error\", ex);\n          Error error = new Error();\n          error.e = (Exception) ex;\n          if (ex instanceof SolrException) {\n            error.statusCode = ((SolrException) ex).code();\n          }\n          error.req = req;\n          errors.add(error);\n        }\n        @Override\n        public void onSuccess(HttpResponse resp) {\n          req.trackRequestResult(resp, true);\n        }\n      };\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      client.setPollQueueTime(req.pollQueueTime);\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","bugFix":null,"bugIntro":["c07dc645ff236a7d51da2a5ef49a948dfbf8610c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","sourceNew":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient(url, httpClient, 100, runnerCount, updateExecutor, true, req);\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      client.setPollQueueTime(req.pollQueueTime);\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","sourceOld":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ConcurrentUpdateSolrClient(url, httpClient, 100, runnerCount, updateExecutor, true) {\n        @Override\n        public void handleError(Throwable ex) {\n          req.trackRequestResult(null, false);\n          log.error(\"error\", ex);\n          Error error = new Error();\n          error.e = (Exception) ex;\n          if (ex instanceof SolrException) {\n            error.statusCode = ((SolrException) ex).code();\n          }\n          error.req = req;\n          errors.add(error);\n        }\n        @Override\n        public void onSuccess(HttpResponse resp) {\n          req.trackRequestResult(resp, true);\n        }\n      };\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      client.setPollQueueTime(req.pollQueueTime);\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7ca1cace44c816965501b934686a2354382f000","date":1487792658,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","sourceNew":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient(url, httpClient, 100, runnerCount, updateExecutor, true, req);\n      client.setPollQueueTime(Integer.MAX_VALUE); // minimize connections created\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","sourceOld":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient(url, httpClient, 100, runnerCount, updateExecutor, true, req);\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      client.setPollQueueTime(req.pollQueueTime);\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","bugFix":null,"bugIntro":["482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c07dc645ff236a7d51da2a5ef49a948dfbf8610c","date":1498242650,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","sourceNew":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient.Builder(url, req, errors)\n          .withHttpClient(httpClient)\n          .withQueueSize(100)\n          .withThreadCount(runnerCount)\n          .withExecutorService(updateExecutor)\n          .alwaysStreamDeletes()\n          .build();\n      client.setPollQueueTime(Integer.MAX_VALUE); // minimize connections created\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","sourceOld":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient(url, httpClient, 100, runnerCount, updateExecutor, true, req);\n      client.setPollQueueTime(Integer.MAX_VALUE); // minimize connections created\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","bugFix":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","sourceNew":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient.Builder(url, req, errors)\n          .withHttpClient(httpClient)\n          .withQueueSize(100)\n          .withThreadCount(runnerCount)\n          .withExecutorService(updateExecutor)\n          .alwaysStreamDeletes()\n          .build();\n      client.setPollQueueTime(Integer.MAX_VALUE); // minimize connections created\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","sourceOld":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient(url, httpClient, 100, runnerCount, updateExecutor, true, req);\n      client.setPollQueueTime(Integer.MAX_VALUE); // minimize connections created\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","sourceNew":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient.Builder(url, req, errors)\n          .withHttpClient(httpClient)\n          .withQueueSize(100)\n          .withThreadCount(runnerCount)\n          .withExecutorService(updateExecutor)\n          .alwaysStreamDeletes()\n          .build();\n      client.setPollQueueTime(Integer.MAX_VALUE); // minimize connections created\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","sourceOld":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient(url, httpClient, 100, runnerCount, updateExecutor, true, req);\n      client.setPollQueueTime(Integer.MAX_VALUE); // minimize connections created\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a2e58c9eb8714e96373ecfded6d0bfc84ad1d93d","date":1527531709,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","sourceNew":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient.Builder(url, req, errors)\n          .withHttpClient(httpClient)\n          .withQueueSize(100)\n          .withThreadCount(runnerCount)\n          .withExecutorService(updateExecutor)\n          .alwaysStreamDeletes()\n          .withSocketTimeout(socketTimeout)\n          .withConnectionTimeout(connectionTimeout)\n          .build();\n      client.setPollQueueTime(Integer.MAX_VALUE); // minimize connections created\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","sourceOld":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient.Builder(url, req, errors)\n          .withHttpClient(httpClient)\n          .withQueueSize(100)\n          .withThreadCount(runnerCount)\n          .withExecutorService(updateExecutor)\n          .alwaysStreamDeletes()\n          .build();\n      client.setPollQueueTime(Integer.MAX_VALUE); // minimize connections created\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","sourceNew":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateHttp2SolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient.Builder(url, httpClient, req, errors)\n          .withQueueSize(100)\n          .withThreadCount(runnerCount)\n          .withExecutorService(updateExecutor)\n          .alwaysStreamDeletes()\n          .build();\n      client.setPollQueueTime(Integer.MAX_VALUE); // minimize connections created\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","sourceOld":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateSolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient.Builder(url, req, errors)\n          .withHttpClient(httpClient)\n          .withQueueSize(100)\n          .withThreadCount(runnerCount)\n          .withExecutorService(updateExecutor)\n          .alwaysStreamDeletes()\n          .withSocketTimeout(socketTimeout)\n          .withConnectionTimeout(connectionTimeout)\n          .build();\n      client.setPollQueueTime(Integer.MAX_VALUE); // minimize connections created\n      client.setParser(new BinaryResponseParser());\n      client.setRequestWriter(new BinaryRequestWriter());\n      Set<String> queryParams = new HashSet<>(2);\n      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);\n      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);\n      client.setQueryParams(queryParams);\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"482ca6c86d7073e3c19096bdc74fe0e73da4554a","date":1576010743,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","sourceNew":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateHttp2SolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient.Builder(url, httpClient, req, errors)\n          .withQueueSize(100)\n          .withThreadCount(runnerCount)\n          .withExecutorService(updateExecutor)\n          .alwaysStreamDeletes()\n          .build();\n      client.setPollQueueTime(pollQueueTime); // minimize connections created\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","sourceOld":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateHttp2SolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient.Builder(url, httpClient, req, errors)\n          .withQueueSize(100)\n          .withThreadCount(runnerCount)\n          .withExecutorService(updateExecutor)\n          .alwaysStreamDeletes()\n          .build();\n      client.setPollQueueTime(Integer.MAX_VALUE); // minimize connections created\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","bugFix":["c7ca1cace44c816965501b934686a2354382f000"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a229cb50768e988c50a2106bdae3a92154f428bf","date":1576051038,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/StreamingSolrClients#getSolrClient(SolrCmdDistributor.Req).mjava","sourceNew":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateHttp2SolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient.Builder(url, httpClient, req, errors)\n          .withQueueSize(100)\n          .withThreadCount(runnerCount)\n          .withExecutorService(updateExecutor)\n          .alwaysStreamDeletes()\n          .build();\n      client.setPollQueueTime(pollQueueTime); // minimize connections created\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","sourceOld":"  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {\n    String url = getFullUrl(req.node.getUrl());\n    ConcurrentUpdateHttp2SolrClient client = solrClients.get(url);\n    if (client == null) {\n      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered\n      // on a greater scale since the current behavior is to only increase the number of connections/Runners when\n      // the queue is more than half full.\n      client = new ErrorReportingConcurrentUpdateSolrClient.Builder(url, httpClient, req, errors)\n          .withQueueSize(100)\n          .withThreadCount(runnerCount)\n          .withExecutorService(updateExecutor)\n          .alwaysStreamDeletes()\n          .build();\n      client.setPollQueueTime(Integer.MAX_VALUE); // minimize connections created\n      solrClients.put(url, client);\n    }\n\n    return client;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"482ca6c86d7073e3c19096bdc74fe0e73da4554a":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"a2e58c9eb8714e96373ecfded6d0bfc84ad1d93d":["28288370235ed02234a64753cdbf0c6ec096304a"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["d4d5d13b25ebb64794230a241686b8ed3d4860be"],"bafca15d8e408346a67f4282ad1143b88023893b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["c7ca1cace44c816965501b934686a2354382f000","c07dc645ff236a7d51da2a5ef49a948dfbf8610c"],"28288370235ed02234a64753cdbf0c6ec096304a":["c7ca1cace44c816965501b934686a2354382f000","c07dc645ff236a7d51da2a5ef49a948dfbf8610c"],"c07dc645ff236a7d51da2a5ef49a948dfbf8610c":["c7ca1cace44c816965501b934686a2354382f000"],"3e447fd876c400c615e8c20e892c60eafc13b840":["7749d6fa52f4781f8f7488f2bd18b0fbb5959d0b"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["a2e58c9eb8714e96373ecfded6d0bfc84ad1d93d"],"a229cb50768e988c50a2106bdae3a92154f428bf":["1a77e5e21cbd575a8240b0e3926164f15295f4e8","482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"dd75f58072bba84066e89d61bd7028de1bd5b632":["3e447fd876c400c615e8c20e892c60eafc13b840","d4d5d13b25ebb64794230a241686b8ed3d4860be"],"7749d6fa52f4781f8f7488f2bd18b0fbb5959d0b":["bafca15d8e408346a67f4282ad1143b88023893b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["d4d5d13b25ebb64794230a241686b8ed3d4860be","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"d4d5d13b25ebb64794230a241686b8ed3d4860be":["3e447fd876c400c615e8c20e892c60eafc13b840"],"c7ca1cace44c816965501b934686a2354382f000":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["482ca6c86d7073e3c19096bdc74fe0e73da4554a"]},"commit2Childs":{"482ca6c86d7073e3c19096bdc74fe0e73da4554a":["a229cb50768e988c50a2106bdae3a92154f428bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a2e58c9eb8714e96373ecfded6d0bfc84ad1d93d":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"bafca15d8e408346a67f4282ad1143b88023893b":["7749d6fa52f4781f8f7488f2bd18b0fbb5959d0b"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["a2e58c9eb8714e96373ecfded6d0bfc84ad1d93d"],"c07dc645ff236a7d51da2a5ef49a948dfbf8610c":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"3e447fd876c400c615e8c20e892c60eafc13b840":["dd75f58072bba84066e89d61bd7028de1bd5b632","d4d5d13b25ebb64794230a241686b8ed3d4860be"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["482ca6c86d7073e3c19096bdc74fe0e73da4554a","a229cb50768e988c50a2106bdae3a92154f428bf"],"a229cb50768e988c50a2106bdae3a92154f428bf":[],"dd75f58072bba84066e89d61bd7028de1bd5b632":[],"7749d6fa52f4781f8f7488f2bd18b0fbb5959d0b":["3e447fd876c400c615e8c20e892c60eafc13b840"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bafca15d8e408346a67f4282ad1143b88023893b"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["c7ca1cace44c816965501b934686a2354382f000"],"d4d5d13b25ebb64794230a241686b8ed3d4860be":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","dd75f58072bba84066e89d61bd7028de1bd5b632","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"c7ca1cace44c816965501b934686a2354382f000":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a","c07dc645ff236a7d51da2a5ef49a948dfbf8610c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","a229cb50768e988c50a2106bdae3a92154f428bf","dd75f58072bba84066e89d61bd7028de1bd5b632","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}