{"path":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","commits":[{"id":"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4","date":1452195469,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() throws Exception {\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    \n    SolrClient client;\n    HttpClient httpClient = HttpClientUtil.createClient(null);\n    int rndClient = 0;//random().nextInt(3);\n    if (rndClient == 0) {\n      client = new ConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1 thread\n    } else if (rndClient == 1)  {\n      client = new HttpSolrClient(url.toString(), httpClient);\n    } else if (rndClient == 2) {\n      client = new CloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n      ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n      ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n      ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n      ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n    } else {\n      throw new RuntimeException(\"impossible\");\n    }\n    \n    PoolingClientConnectionManager cm = (PoolingClientConnectionManager) httpClient.getConnectionManager();\n\n    HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n    HttpRoute route = new HttpRoute(target);\n    \n    ClientConnectionRequest mConn = getClientConnectionRequest(httpClient, route);\n   \n    ManagedClientConnection conn1 = getConn(mConn);\n    headerRequest(target, route, conn1);\n    conn1.releaseConnection();\n    cm.releaseConnection(conn1, -1, TimeUnit.MILLISECONDS);\n    \n    int queueBreaks = 0;\n    int cnt1 = atLeast(3);\n    int cnt2 = atLeast(30);\n    for (int j = 0; j < cnt1; j++) {\n      for (int i = 0; i < cnt2; i++) {\n        boolean done = false;\n        AddUpdateCommand c = new AddUpdateCommand(null);\n        c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n        try {\n          client.add(c.solrDoc);\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n        if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient && random().nextInt(10) > 8) {\n          queueBreaks++;\n          done = true;\n          Thread.sleep(350); // wait past streaming client poll time of 250ms\n        }\n      }\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n      }\n    }\n\n    route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n    mConn = cm.requestConnection(route, null);\n   \n    ManagedClientConnection conn2 = getConn(mConn);\n\n    HttpConnectionMetrics metrics = conn2.getMetrics();\n    headerRequest(target, route, conn2);\n    conn2.releaseConnection();\n    cm.releaseConnection(conn2, -1, TimeUnit.MILLISECONDS);\n\n    \n    assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \" + client.getClass().getSimpleName(), metrics);\n    \n    // we try and make sure the connection we get has handled all of the requests in this test\n    if (client instanceof ConcurrentUpdateSolrClient) {\n      // we can't fully control queue polling breaking up requests - allow a bit of leeway\n      int exp = cnt1 + queueBreaks + 2;\n      assertTrue(\n          \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n              + metrics.getRequestCount(),\n          Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n    } else {\n      assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName(),\n          cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n    }\n    \n    client.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["52d2091c9ce67709c348e85478face2beb6e82ee"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"52d2091c9ce67709c348e85478face2beb6e82ee","date":1454002453,"type":3,"author":"Mark Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    \n    SolrClient client;\n    HttpClient httpClient = HttpClientUtil.createClient(null);\n    int rndClient = random().nextInt(3);\n    if (rndClient == 0) {\n      client = new ConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1 thread\n    } else if (rndClient == 1)  {\n      client = new HttpSolrClient(url.toString(), httpClient);\n    } else if (rndClient == 2) {\n      client = new CloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n      ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n      ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n      ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n      ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n    } else {\n      throw new RuntimeException(\"impossible\");\n    }\n    \n    PoolingClientConnectionManager cm = (PoolingClientConnectionManager) httpClient.getConnectionManager();\n\n    HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n    HttpRoute route = new HttpRoute(target);\n    \n    ClientConnectionRequest mConn = getClientConnectionRequest(httpClient, route);\n   \n    ManagedClientConnection conn1 = getConn(mConn);\n    headerRequest(target, route, conn1);\n    conn1.releaseConnection();\n    cm.releaseConnection(conn1, -1, TimeUnit.MILLISECONDS);\n    \n    int queueBreaks = 0;\n    int cnt1 = atLeast(3);\n    int cnt2 = atLeast(30);\n    for (int j = 0; j < cnt1; j++) {\n      for (int i = 0; i < cnt2; i++) {\n        boolean done = false;\n        AddUpdateCommand c = new AddUpdateCommand(null);\n        c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n        try {\n          client.add(c.solrDoc);\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n        if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient && random().nextInt(10) > 8) {\n          queueBreaks++;\n          done = true;\n          Thread.sleep(350); // wait past streaming client poll time of 250ms\n        }\n      }\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n      }\n    }\n\n    route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n    mConn = cm.requestConnection(route, null);\n   \n    ManagedClientConnection conn2 = getConn(mConn);\n\n    HttpConnectionMetrics metrics = conn2.getMetrics();\n    headerRequest(target, route, conn2);\n    conn2.releaseConnection();\n    cm.releaseConnection(conn2, -1, TimeUnit.MILLISECONDS);\n\n    \n    assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \" + client.getClass().getSimpleName(), metrics);\n    \n    // we try and make sure the connection we get has handled all of the requests in this test\n    if (client instanceof ConcurrentUpdateSolrClient) {\n      // we can't fully control queue polling breaking up requests - allow a bit of leeway\n      int exp = cnt1 + queueBreaks + 2;\n      assertTrue(\n          \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n              + metrics.getRequestCount(),\n          Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n    } else {\n      assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName(),\n          cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n    }\n    \n    client.close();\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    \n    SolrClient client;\n    HttpClient httpClient = HttpClientUtil.createClient(null);\n    int rndClient = 0;//random().nextInt(3);\n    if (rndClient == 0) {\n      client = new ConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1 thread\n    } else if (rndClient == 1)  {\n      client = new HttpSolrClient(url.toString(), httpClient);\n    } else if (rndClient == 2) {\n      client = new CloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n      ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n      ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n      ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n      ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n    } else {\n      throw new RuntimeException(\"impossible\");\n    }\n    \n    PoolingClientConnectionManager cm = (PoolingClientConnectionManager) httpClient.getConnectionManager();\n\n    HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n    HttpRoute route = new HttpRoute(target);\n    \n    ClientConnectionRequest mConn = getClientConnectionRequest(httpClient, route);\n   \n    ManagedClientConnection conn1 = getConn(mConn);\n    headerRequest(target, route, conn1);\n    conn1.releaseConnection();\n    cm.releaseConnection(conn1, -1, TimeUnit.MILLISECONDS);\n    \n    int queueBreaks = 0;\n    int cnt1 = atLeast(3);\n    int cnt2 = atLeast(30);\n    for (int j = 0; j < cnt1; j++) {\n      for (int i = 0; i < cnt2; i++) {\n        boolean done = false;\n        AddUpdateCommand c = new AddUpdateCommand(null);\n        c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n        try {\n          client.add(c.solrDoc);\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n        if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient && random().nextInt(10) > 8) {\n          queueBreaks++;\n          done = true;\n          Thread.sleep(350); // wait past streaming client poll time of 250ms\n        }\n      }\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n      }\n    }\n\n    route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n    mConn = cm.requestConnection(route, null);\n   \n    ManagedClientConnection conn2 = getConn(mConn);\n\n    HttpConnectionMetrics metrics = conn2.getMetrics();\n    headerRequest(target, route, conn2);\n    conn2.releaseConnection();\n    cm.releaseConnection(conn2, -1, TimeUnit.MILLISECONDS);\n\n    \n    assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \" + client.getClass().getSimpleName(), metrics);\n    \n    // we try and make sure the connection we get has handled all of the requests in this test\n    if (client instanceof ConcurrentUpdateSolrClient) {\n      // we can't fully control queue polling breaking up requests - allow a bit of leeway\n      int exp = cnt1 + queueBreaks + 2;\n      assertTrue(\n          \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n              + metrics.getRequestCount(),\n          Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n    } else {\n      assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName(),\n          cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n    }\n    \n    client.close();\n  }\n\n","bugFix":["c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d15e34266d75e4e8b95da046cd0afc812367b38","date":1454246129,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    \n    SolrClient client;\n    HttpClient httpClient = HttpClientUtil.createClient(null);\n    int rndClient = random().nextInt(3);\n    if (rndClient == 0) {\n      client = new ConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1 thread\n    } else if (rndClient == 1)  {\n      client = new HttpSolrClient(url.toString(), httpClient);\n    } else if (rndClient == 2) {\n      client = new CloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n      ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n      ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n      ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n      ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n    } else {\n      throw new RuntimeException(\"impossible\");\n    }\n    \n    PoolingClientConnectionManager cm = (PoolingClientConnectionManager) httpClient.getConnectionManager();\n\n    HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n    HttpRoute route = new HttpRoute(target);\n    \n    ClientConnectionRequest mConn = getClientConnectionRequest(httpClient, route);\n   \n    ManagedClientConnection conn1 = getConn(mConn);\n    headerRequest(target, route, conn1);\n    conn1.releaseConnection();\n    cm.releaseConnection(conn1, -1, TimeUnit.MILLISECONDS);\n    \n    int queueBreaks = 0;\n    int cnt1 = atLeast(3);\n    int cnt2 = atLeast(30);\n    for (int j = 0; j < cnt1; j++) {\n      for (int i = 0; i < cnt2; i++) {\n        boolean done = false;\n        AddUpdateCommand c = new AddUpdateCommand(null);\n        c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n        try {\n          client.add(c.solrDoc);\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n        if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient && random().nextInt(10) > 8) {\n          queueBreaks++;\n          done = true;\n          Thread.sleep(350); // wait past streaming client poll time of 250ms\n        }\n      }\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n      }\n    }\n\n    route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n    mConn = cm.requestConnection(route, null);\n   \n    ManagedClientConnection conn2 = getConn(mConn);\n\n    HttpConnectionMetrics metrics = conn2.getMetrics();\n    headerRequest(target, route, conn2);\n    conn2.releaseConnection();\n    cm.releaseConnection(conn2, -1, TimeUnit.MILLISECONDS);\n\n    \n    assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \" + client.getClass().getSimpleName(), metrics);\n    \n    // we try and make sure the connection we get has handled all of the requests in this test\n    if (client instanceof ConcurrentUpdateSolrClient) {\n      // we can't fully control queue polling breaking up requests - allow a bit of leeway\n      int exp = cnt1 + queueBreaks + 2;\n      assertTrue(\n          \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n              + metrics.getRequestCount(),\n          Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n    } else {\n      assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName(),\n          cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n    }\n    \n    client.close();\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    \n    SolrClient client;\n    HttpClient httpClient = HttpClientUtil.createClient(null);\n    int rndClient = 0;//random().nextInt(3);\n    if (rndClient == 0) {\n      client = new ConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1 thread\n    } else if (rndClient == 1)  {\n      client = new HttpSolrClient(url.toString(), httpClient);\n    } else if (rndClient == 2) {\n      client = new CloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n      ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n      ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n      ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n      ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n    } else {\n      throw new RuntimeException(\"impossible\");\n    }\n    \n    PoolingClientConnectionManager cm = (PoolingClientConnectionManager) httpClient.getConnectionManager();\n\n    HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n    HttpRoute route = new HttpRoute(target);\n    \n    ClientConnectionRequest mConn = getClientConnectionRequest(httpClient, route);\n   \n    ManagedClientConnection conn1 = getConn(mConn);\n    headerRequest(target, route, conn1);\n    conn1.releaseConnection();\n    cm.releaseConnection(conn1, -1, TimeUnit.MILLISECONDS);\n    \n    int queueBreaks = 0;\n    int cnt1 = atLeast(3);\n    int cnt2 = atLeast(30);\n    for (int j = 0; j < cnt1; j++) {\n      for (int i = 0; i < cnt2; i++) {\n        boolean done = false;\n        AddUpdateCommand c = new AddUpdateCommand(null);\n        c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n        try {\n          client.add(c.solrDoc);\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n        if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient && random().nextInt(10) > 8) {\n          queueBreaks++;\n          done = true;\n          Thread.sleep(350); // wait past streaming client poll time of 250ms\n        }\n      }\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n      }\n    }\n\n    route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n    mConn = cm.requestConnection(route, null);\n   \n    ManagedClientConnection conn2 = getConn(mConn);\n\n    HttpConnectionMetrics metrics = conn2.getMetrics();\n    headerRequest(target, route, conn2);\n    conn2.releaseConnection();\n    cm.releaseConnection(conn2, -1, TimeUnit.MILLISECONDS);\n\n    \n    assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \" + client.getClass().getSimpleName(), metrics);\n    \n    // we try and make sure the connection we get has handled all of the requests in this test\n    if (client instanceof ConcurrentUpdateSolrClient) {\n      // we can't fully control queue polling breaking up requests - allow a bit of leeway\n      int exp = cnt1 + queueBreaks + 2;\n      assertTrue(\n          \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n              + metrics.getRequestCount(),\n          Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n    } else {\n      assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName(),\n          cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n    }\n    \n    client.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    \n    SolrClient client;\n    HttpClient httpClient = HttpClientUtil.createClient(null);\n    int rndClient = random().nextInt(3);\n    if (rndClient == 0) {\n      client = new ConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1 thread\n    } else if (rndClient == 1)  {\n      client = new HttpSolrClient(url.toString(), httpClient);\n    } else if (rndClient == 2) {\n      client = new CloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n      ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n      ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n      ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n      ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n    } else {\n      throw new RuntimeException(\"impossible\");\n    }\n    \n    PoolingClientConnectionManager cm = (PoolingClientConnectionManager) httpClient.getConnectionManager();\n\n    HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n    HttpRoute route = new HttpRoute(target);\n    \n    ClientConnectionRequest mConn = getClientConnectionRequest(httpClient, route);\n   \n    ManagedClientConnection conn1 = getConn(mConn);\n    headerRequest(target, route, conn1);\n    conn1.releaseConnection();\n    cm.releaseConnection(conn1, -1, TimeUnit.MILLISECONDS);\n    \n    int queueBreaks = 0;\n    int cnt1 = atLeast(3);\n    int cnt2 = atLeast(30);\n    for (int j = 0; j < cnt1; j++) {\n      for (int i = 0; i < cnt2; i++) {\n        boolean done = false;\n        AddUpdateCommand c = new AddUpdateCommand(null);\n        c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n        try {\n          client.add(c.solrDoc);\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n        if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient && random().nextInt(10) > 8) {\n          queueBreaks++;\n          done = true;\n          Thread.sleep(350); // wait past streaming client poll time of 250ms\n        }\n      }\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n      }\n    }\n\n    route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n    mConn = cm.requestConnection(route, null);\n   \n    ManagedClientConnection conn2 = getConn(mConn);\n\n    HttpConnectionMetrics metrics = conn2.getMetrics();\n    headerRequest(target, route, conn2);\n    conn2.releaseConnection();\n    cm.releaseConnection(conn2, -1, TimeUnit.MILLISECONDS);\n\n    \n    assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \" + client.getClass().getSimpleName(), metrics);\n    \n    // we try and make sure the connection we get has handled all of the requests in this test\n    if (client instanceof ConcurrentUpdateSolrClient) {\n      // we can't fully control queue polling breaking up requests - allow a bit of leeway\n      int exp = cnt1 + queueBreaks + 2;\n      assertTrue(\n          \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n              + metrics.getRequestCount(),\n          Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n    } else {\n      assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName(),\n          cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n    }\n    \n    client.close();\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    \n    SolrClient client;\n    HttpClient httpClient = HttpClientUtil.createClient(null);\n    int rndClient = 0;//random().nextInt(3);\n    if (rndClient == 0) {\n      client = new ConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1 thread\n    } else if (rndClient == 1)  {\n      client = new HttpSolrClient(url.toString(), httpClient);\n    } else if (rndClient == 2) {\n      client = new CloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n      ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n      ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n      ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n      ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n    } else {\n      throw new RuntimeException(\"impossible\");\n    }\n    \n    PoolingClientConnectionManager cm = (PoolingClientConnectionManager) httpClient.getConnectionManager();\n\n    HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n    HttpRoute route = new HttpRoute(target);\n    \n    ClientConnectionRequest mConn = getClientConnectionRequest(httpClient, route);\n   \n    ManagedClientConnection conn1 = getConn(mConn);\n    headerRequest(target, route, conn1);\n    conn1.releaseConnection();\n    cm.releaseConnection(conn1, -1, TimeUnit.MILLISECONDS);\n    \n    int queueBreaks = 0;\n    int cnt1 = atLeast(3);\n    int cnt2 = atLeast(30);\n    for (int j = 0; j < cnt1; j++) {\n      for (int i = 0; i < cnt2; i++) {\n        boolean done = false;\n        AddUpdateCommand c = new AddUpdateCommand(null);\n        c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n        try {\n          client.add(c.solrDoc);\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n        if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient && random().nextInt(10) > 8) {\n          queueBreaks++;\n          done = true;\n          Thread.sleep(350); // wait past streaming client poll time of 250ms\n        }\n      }\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n      }\n    }\n\n    route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n    mConn = cm.requestConnection(route, null);\n   \n    ManagedClientConnection conn2 = getConn(mConn);\n\n    HttpConnectionMetrics metrics = conn2.getMetrics();\n    headerRequest(target, route, conn2);\n    conn2.releaseConnection();\n    cm.releaseConnection(conn2, -1, TimeUnit.MILLISECONDS);\n\n    \n    assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \" + client.getClass().getSimpleName(), metrics);\n    \n    // we try and make sure the connection we get has handled all of the requests in this test\n    if (client instanceof ConcurrentUpdateSolrClient) {\n      // we can't fully control queue polling breaking up requests - allow a bit of leeway\n      int exp = cnt1 + queueBreaks + 2;\n      assertTrue(\n          \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n              + metrics.getRequestCount(),\n          Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n    } else {\n      assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName(),\n          cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n    }\n    \n    client.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"859081acf00749f5dd462772c571d611d4a4d2db","date":1459527719,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n    SolrClient client = null;\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try {\n      int rndClient = random().nextInt(3);\n      if (rndClient == 0) {\n        client = new ConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1\n                                                                                   // thread\n      } else if (rndClient == 1) {\n        client = new HttpSolrClient(url.toString(), httpClient);\n      } else if (rndClient == 2) {\n        client = new CloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n        ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n        ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n        ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n        ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n      } else {\n        throw new RuntimeException(\"impossible\");\n      }\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        for (int i = 0; i < cnt2; i++) {\n          boolean done = false;\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    } finally {\n      client.close();\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    \n    SolrClient client;\n    HttpClient httpClient = HttpClientUtil.createClient(null);\n    int rndClient = random().nextInt(3);\n    if (rndClient == 0) {\n      client = new ConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1 thread\n    } else if (rndClient == 1)  {\n      client = new HttpSolrClient(url.toString(), httpClient);\n    } else if (rndClient == 2) {\n      client = new CloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n      ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n      ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n      ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n      ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n    } else {\n      throw new RuntimeException(\"impossible\");\n    }\n    \n    PoolingClientConnectionManager cm = (PoolingClientConnectionManager) httpClient.getConnectionManager();\n\n    HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n    HttpRoute route = new HttpRoute(target);\n    \n    ClientConnectionRequest mConn = getClientConnectionRequest(httpClient, route);\n   \n    ManagedClientConnection conn1 = getConn(mConn);\n    headerRequest(target, route, conn1);\n    conn1.releaseConnection();\n    cm.releaseConnection(conn1, -1, TimeUnit.MILLISECONDS);\n    \n    int queueBreaks = 0;\n    int cnt1 = atLeast(3);\n    int cnt2 = atLeast(30);\n    for (int j = 0; j < cnt1; j++) {\n      for (int i = 0; i < cnt2; i++) {\n        boolean done = false;\n        AddUpdateCommand c = new AddUpdateCommand(null);\n        c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n        try {\n          client.add(c.solrDoc);\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n        if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient && random().nextInt(10) > 8) {\n          queueBreaks++;\n          done = true;\n          Thread.sleep(350); // wait past streaming client poll time of 250ms\n        }\n      }\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n      }\n    }\n\n    route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n    mConn = cm.requestConnection(route, null);\n   \n    ManagedClientConnection conn2 = getConn(mConn);\n\n    HttpConnectionMetrics metrics = conn2.getMetrics();\n    headerRequest(target, route, conn2);\n    conn2.releaseConnection();\n    cm.releaseConnection(conn2, -1, TimeUnit.MILLISECONDS);\n\n    \n    assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \" + client.getClass().getSimpleName(), metrics);\n    \n    // we try and make sure the connection we get has handled all of the requests in this test\n    if (client instanceof ConcurrentUpdateSolrClient) {\n      // we can't fully control queue polling breaking up requests - allow a bit of leeway\n      int exp = cnt1 + queueBreaks + 2;\n      assertTrue(\n          \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n              + metrics.getRequestCount(),\n          Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n    } else {\n      assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName(),\n          cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n    }\n    \n    client.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n    SolrClient client = null;\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try {\n      int rndClient = random().nextInt(3);\n      if (rndClient == 0) {\n        client = getConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1\n                                                                                   // thread\n      } else if (rndClient == 1) {\n        client = getHttpSolrClient(url.toString(), httpClient);\n      } else if (rndClient == 2) {\n        client = getCloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n        ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n        ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n        ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n        ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n      } else {\n        throw new RuntimeException(\"impossible\");\n      }\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        for (int i = 0; i < cnt2; i++) {\n          boolean done = false;\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    } finally {\n      client.close();\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n    SolrClient client = null;\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try {\n      int rndClient = random().nextInt(3);\n      if (rndClient == 0) {\n        client = new ConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1\n                                                                                   // thread\n      } else if (rndClient == 1) {\n        client = new HttpSolrClient(url.toString(), httpClient);\n      } else if (rndClient == 2) {\n        client = new CloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n        ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n        ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n        ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n        ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n      } else {\n        throw new RuntimeException(\"impossible\");\n      }\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        for (int i = 0; i < cnt2; i++) {\n          boolean done = false;\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    } finally {\n      client.close();\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n    SolrClient client = null;\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try {\n      int rndClient = random().nextInt(3);\n      if (rndClient == 0) {\n        client = getConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1\n                                                                                   // thread\n      } else if (rndClient == 1) {\n        client = getHttpSolrClient(url.toString(), httpClient);\n      } else if (rndClient == 2) {\n        client = getCloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n        ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n        ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n        ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n        ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n      } else {\n        throw new RuntimeException(\"impossible\");\n      }\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        for (int i = 0; i < cnt2; i++) {\n          boolean done = false;\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    } finally {\n      client.close();\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n    SolrClient client = null;\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try {\n      int rndClient = random().nextInt(3);\n      if (rndClient == 0) {\n        client = new ConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1\n                                                                                   // thread\n      } else if (rndClient == 1) {\n        client = new HttpSolrClient(url.toString(), httpClient);\n      } else if (rndClient == 2) {\n        client = new CloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n        ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n        ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n        ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n        ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n      } else {\n        throw new RuntimeException(\"impossible\");\n      }\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        for (int i = 0; i < cnt2; i++) {\n          boolean done = false;\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    } finally {\n      client.close();\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ebf70dabe6279454c5ff460bdea3f0dc2814a86","date":1463672611,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#testConnectionReuse().mjava","pathOld":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","sourceNew":"  @Test\n  public void testConnectionReuse() throws Exception {\n\n    URL url = cluster.getJettySolrRunners().get(0).getBaseUrl();\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try (SolrClient client = buildClient(httpClient, url)) {\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        boolean done = false;\n        for (int i = 0; i < cnt2; i++) {\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    }\n    finally {\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n    SolrClient client = null;\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try {\n      int rndClient = random().nextInt(3);\n      if (rndClient == 0) {\n        client = getConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1\n                                                                                   // thread\n      } else if (rndClient == 1) {\n        client = getHttpSolrClient(url.toString(), httpClient);\n      } else if (rndClient == 2) {\n        client = getCloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n        ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n        ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n        ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n        ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n      } else {\n        throw new RuntimeException(\"impossible\");\n      }\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        for (int i = 0; i < cnt2; i++) {\n          boolean done = false;\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    } finally {\n      client.close();\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#testConnectionReuse().mjava","pathOld":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","sourceNew":"  @Test\n  public void testConnectionReuse() throws Exception {\n\n    URL url = cluster.getJettySolrRunners().get(0).getBaseUrl();\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try (SolrClient client = buildClient(httpClient, url)) {\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        boolean done = false;\n        for (int i = 0; i < cnt2; i++) {\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    }\n    finally {\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n    SolrClient client = null;\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try {\n      int rndClient = random().nextInt(3);\n      if (rndClient == 0) {\n        client = getConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1\n                                                                                   // thread\n      } else if (rndClient == 1) {\n        client = getHttpSolrClient(url.toString(), httpClient);\n      } else if (rndClient == 2) {\n        client = getCloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n        ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n        ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n        ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n        ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n      } else {\n        throw new RuntimeException(\"impossible\");\n      }\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        for (int i = 0; i < cnt2; i++) {\n          boolean done = false;\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    } finally {\n      client.close();\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#test().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void test() throws Exception {\n\n    URL url = new URL(((HttpSolrClient) clients.get(0)).getBaseURL());\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n    SolrClient client = null;\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try {\n      int rndClient = random().nextInt(3);\n      if (rndClient == 0) {\n        client = getConcurrentUpdateSolrClient(url.toString(), httpClient, 6, 1); // currently only testing with 1\n                                                                                   // thread\n      } else if (rndClient == 1) {\n        client = getHttpSolrClient(url.toString(), httpClient);\n      } else if (rndClient == 2) {\n        client = getCloudSolrClient(zkServer.getZkAddress(), random().nextBoolean(), httpClient);\n        ((CloudSolrClient) client).setParallelUpdates(random().nextBoolean());\n        ((CloudSolrClient) client).setDefaultCollection(DEFAULT_COLLECTION);\n        ((CloudSolrClient) client).getLbClient().setConnectionTimeout(30000);\n        ((CloudSolrClient) client).getLbClient().setSoTimeout(60000);\n      } else {\n        throw new RuntimeException(\"impossible\");\n      }\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        for (int i = 0; i < cnt2; i++) {\n          boolean done = false;\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    } finally {\n      client.close();\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"859081acf00749f5dd462772c571d611d4a4d2db":["8d15e34266d75e4e8b95da046cd0afc812367b38"],"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["859081acf00749f5dd462772c571d611d4a4d2db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4","8d15e34266d75e4e8b95da046cd0afc812367b38"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["859081acf00749f5dd462772c571d611d4a4d2db","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"5ebf70dabe6279454c5ff460bdea3f0dc2814a86":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"8d15e34266d75e4e8b95da046cd0afc812367b38":["c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4","52d2091c9ce67709c348e85478face2beb6e82ee"],"52d2091c9ce67709c348e85478face2beb6e82ee":["c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","5ebf70dabe6279454c5ff460bdea3f0dc2814a86"]},"commit2Childs":{"859081acf00749f5dd462772c571d611d4a4d2db":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","8d15e34266d75e4e8b95da046cd0afc812367b38","52d2091c9ce67709c348e85478face2beb6e82ee"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["5ebf70dabe6279454c5ff460bdea3f0dc2814a86","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89"],"5ebf70dabe6279454c5ff460bdea3f0dc2814a86":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"8d15e34266d75e4e8b95da046cd0afc812367b38":["859081acf00749f5dd462772c571d611d4a4d2db","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"52d2091c9ce67709c348e85478face2beb6e82ee":["8d15e34266d75e4e8b95da046cd0afc812367b38"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}