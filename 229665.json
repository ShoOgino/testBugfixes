{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int,int,int,int,int,boolean,boolean,boolean,boolean,boolean).mjava","commits":[{"id":"422da43e6414338103dfc37b7c8c68dcbe309d87","date":1405540909,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int,int,int,int,int,boolean,boolean,boolean,boolean,boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int,int,int,int,int,boolean,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Generates a list of stems for the provided word\n   *\n   * @param word Word to generate the stems for\n   * @param previous previous affix that was removed (so we dont remove same one twice)\n   * @param prevFlag Flag from a previous stemming step that need to be cross-checked with any affixes in this recursive step\n   * @param prefixFlag flag of the most inner removed prefix, so that when removing a suffix, its also checked against the word\n   * @param recursionDepth current recursiondepth\n   * @param doPrefix true if we should remove prefixes\n   * @param doSuffix true if we should remove suffixes\n   * @param previousWasPrefix true if the previous removal was a prefix:\n   *        if we are removing a suffix, and it has no continuation requirements, its ok.\n   *        but two prefixes (COMPLEXPREFIXES) or two suffixes must have continuation requirements to recurse. \n   * @param circumfix true if the previous prefix removal was signed as a circumfix\n   *        this means inner most suffix must also contain circumfix flag.\n   * @param caseVariant true if we are searching for a case variant. if the word has KEEPCASE flag it cannot succeed.\n   * @return List of stems, or empty list if no stems are found\n   */\n  private List<CharsRef> stem(char word[], int length, int previous, int prevFlag, int prefixFlag, int recursionDepth, boolean doPrefix, boolean doSuffix, boolean previousWasPrefix, boolean circumfix, boolean caseVariant) throws IOException {\n    \n    // TODO: allow this stuff to be reused by tokenfilter\n    List<CharsRef> stems = new ArrayList<>();\n    \n    if (doPrefix && dictionary.prefixes != null) {\n      FST<IntsRef> fst = dictionary.prefixes;\n      Outputs<IntsRef> outputs = fst.outputs;\n      FST.BytesReader bytesReader = prefixReaders[recursionDepth];\n      FST.Arc<IntsRef> arc = prefixArcs[recursionDepth];\n      fst.getFirstArc(arc);\n      IntsRef NO_OUTPUT = outputs.getNoOutput();\n      IntsRef output = NO_OUTPUT;\n      int limit = dictionary.fullStrip ? length : length-1;\n      for (int i = 0; i < limit; i++) {\n        if (i > 0) {\n          int ch = word[i-1];\n          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {\n            break;\n          } else if (arc.output != NO_OUTPUT) {\n            output = fst.outputs.add(output, arc.output);\n          }\n        }\n        IntsRef prefixes = null;\n        if (!arc.isFinal()) {\n          continue;\n        } else {\n          prefixes = fst.outputs.add(output, arc.nextFinalOutput);\n        }\n        \n        for (int j = 0; j < prefixes.length; j++) {\n          int prefix = prefixes.ints[prefixes.offset + j];\n          if (prefix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * prefix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            if (dictionary.onlyincompound == -1) {\n              compatible = true;\n            } else {\n              // check if affix is allowed in a non-compound word\n              dictionary.flagLookup.get(append, scratch);\n              char appendFlags[] = Dictionary.decodeFlags(scratch);\n              compatible = !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            }\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            boolean allowed = dictionary.onlyincompound == -1 || \n                              !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            compatible = allowed && hasCrossCheckedFlag((char)prevFlag, appendFlags, false);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int deAffixedStart = i;\n            int deAffixedLength = length - deAffixedStart;\n            \n            int stripStart = dictionary.stripOffsets[stripOrd];\n            int stripEnd = dictionary.stripOffsets[stripOrd+1];\n            int stripLength = stripEnd - stripStart;\n            \n            if (!checkCondition(condition, dictionary.stripData, stripStart, stripLength, word, deAffixedStart, deAffixedLength)) {\n              continue;\n            }\n            \n            char strippedWord[] = new char[stripLength + deAffixedLength];\n            System.arraycopy(dictionary.stripData, stripStart, strippedWord, 0, stripLength);\n            System.arraycopy(word, deAffixedStart, strippedWord, stripLength, deAffixedLength);\n\n            List<CharsRef> stemList = applyAffix(strippedWord, strippedWord.length, prefix, -1, recursionDepth, true, circumfix, caseVariant);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    } \n    \n    if (doSuffix && dictionary.suffixes != null) {\n      FST<IntsRef> fst = dictionary.suffixes;\n      Outputs<IntsRef> outputs = fst.outputs;\n      FST.BytesReader bytesReader = suffixReaders[recursionDepth];\n      FST.Arc<IntsRef> arc = suffixArcs[recursionDepth];\n      fst.getFirstArc(arc);\n      IntsRef NO_OUTPUT = outputs.getNoOutput();\n      IntsRef output = NO_OUTPUT;\n      int limit = dictionary.fullStrip ? 0 : 1;\n      for (int i = length; i >= limit; i--) {\n        if (i < length) {\n          int ch = word[i];\n          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {\n            break;\n          } else if (arc.output != NO_OUTPUT) {\n            output = fst.outputs.add(output, arc.output);\n          }\n        }\n        IntsRef suffixes = null;\n        if (!arc.isFinal()) {\n          continue;\n        } else {\n          suffixes = fst.outputs.add(output, arc.nextFinalOutput);\n        }\n        \n        for (int j = 0; j < suffixes.length; j++) {\n          int suffix = suffixes.ints[suffixes.offset + j];\n          if (suffix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * suffix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            if (dictionary.onlyincompound == -1) {\n              compatible = true;\n            } else {\n              // check if affix is allowed in a non-compound word\n              dictionary.flagLookup.get(append, scratch);\n              char appendFlags[] = Dictionary.decodeFlags(scratch);\n              compatible = !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            }\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            boolean allowed = dictionary.onlyincompound == -1 || \n                              !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            compatible = allowed && hasCrossCheckedFlag((char)prevFlag, appendFlags, previousWasPrefix);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int appendLength = length - i;\n            int deAffixedLength = length - appendLength;\n            \n            int stripStart = dictionary.stripOffsets[stripOrd];\n            int stripEnd = dictionary.stripOffsets[stripOrd+1];\n            int stripLength = stripEnd - stripStart;\n            \n            if (!checkCondition(condition, word, 0, deAffixedLength, dictionary.stripData, stripStart, stripLength)) {\n              continue;\n            }\n\n            char strippedWord[] = new char[stripLength + deAffixedLength];\n            System.arraycopy(word, 0, strippedWord, 0, deAffixedLength);\n            System.arraycopy(dictionary.stripData, stripStart, strippedWord, deAffixedLength, stripLength);\n            \n            List<CharsRef> stemList = applyAffix(strippedWord, strippedWord.length, suffix, prefixFlag, recursionDepth, false, circumfix, caseVariant);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Generates a list of stems for the provided word\n   *\n   * @param word Word to generate the stems for\n   * @param previous previous affix that was removed (so we dont remove same one twice)\n   * @param prevFlag Flag from a previous stemming step that need to be cross-checked with any affixes in this recursive step\n   * @param prefixFlag flag of the most inner removed prefix, so that when removing a suffix, its also checked against the word\n   * @param recursionDepth current recursiondepth\n   * @param doPrefix true if we should remove prefixes\n   * @param doSuffix true if we should remove suffixes\n   * @param previousWasPrefix true if the previous removal was a prefix:\n   *        if we are removing a suffix, and it has no continuation requirements, its ok.\n   *        but two prefixes (COMPLEXPREFIXES) or two suffixes must have continuation requirements to recurse. \n   * @param circumfix true if the previous prefix removal was signed as a circumfix\n   *        this means inner most suffix must also contain circumfix flag.\n   * @return List of stems, or empty list if no stems are found\n   */\n  private List<CharsRef> stem(char word[], int length, int previous, int prevFlag, int prefixFlag, int recursionDepth, boolean doPrefix, boolean doSuffix, boolean previousWasPrefix, boolean circumfix) throws IOException {\n    \n    // TODO: allow this stuff to be reused by tokenfilter\n    List<CharsRef> stems = new ArrayList<>();\n    \n    if (doPrefix && dictionary.prefixes != null) {\n      FST<IntsRef> fst = dictionary.prefixes;\n      Outputs<IntsRef> outputs = fst.outputs;\n      FST.BytesReader bytesReader = prefixReaders[recursionDepth];\n      FST.Arc<IntsRef> arc = prefixArcs[recursionDepth];\n      fst.getFirstArc(arc);\n      IntsRef NO_OUTPUT = outputs.getNoOutput();\n      IntsRef output = NO_OUTPUT;\n      int limit = dictionary.fullStrip ? length : length-1;\n      for (int i = 0; i < limit; i++) {\n        if (i > 0) {\n          int ch = word[i-1];\n          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {\n            break;\n          } else if (arc.output != NO_OUTPUT) {\n            output = fst.outputs.add(output, arc.output);\n          }\n        }\n        IntsRef prefixes = null;\n        if (!arc.isFinal()) {\n          continue;\n        } else {\n          prefixes = fst.outputs.add(output, arc.nextFinalOutput);\n        }\n        \n        for (int j = 0; j < prefixes.length; j++) {\n          int prefix = prefixes.ints[prefixes.offset + j];\n          if (prefix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * prefix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            compatible = true;\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            compatible = hasCrossCheckedFlag((char)prevFlag, appendFlags, false);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int deAffixedStart = i;\n            int deAffixedLength = length - deAffixedStart;\n            \n            int stripStart = dictionary.stripOffsets[stripOrd];\n            int stripEnd = dictionary.stripOffsets[stripOrd+1];\n            int stripLength = stripEnd - stripStart;\n            \n            if (!checkCondition(condition, dictionary.stripData, stripStart, stripLength, word, deAffixedStart, deAffixedLength)) {\n              continue;\n            }\n            \n            char strippedWord[] = new char[stripLength + deAffixedLength];\n            System.arraycopy(dictionary.stripData, stripStart, strippedWord, 0, stripLength);\n            System.arraycopy(word, deAffixedStart, strippedWord, stripLength, deAffixedLength);\n\n            List<CharsRef> stemList = applyAffix(strippedWord, strippedWord.length, prefix, -1, recursionDepth, true, circumfix);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    } \n    \n    if (doSuffix && dictionary.suffixes != null) {\n      FST<IntsRef> fst = dictionary.suffixes;\n      Outputs<IntsRef> outputs = fst.outputs;\n      FST.BytesReader bytesReader = suffixReaders[recursionDepth];\n      FST.Arc<IntsRef> arc = suffixArcs[recursionDepth];\n      fst.getFirstArc(arc);\n      IntsRef NO_OUTPUT = outputs.getNoOutput();\n      IntsRef output = NO_OUTPUT;\n      int limit = dictionary.fullStrip ? 0 : 1;\n      for (int i = length; i >= limit; i--) {\n        if (i < length) {\n          int ch = word[i];\n          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {\n            break;\n          } else if (arc.output != NO_OUTPUT) {\n            output = fst.outputs.add(output, arc.output);\n          }\n        }\n        IntsRef suffixes = null;\n        if (!arc.isFinal()) {\n          continue;\n        } else {\n          suffixes = fst.outputs.add(output, arc.nextFinalOutput);\n        }\n        \n        for (int j = 0; j < suffixes.length; j++) {\n          int suffix = suffixes.ints[suffixes.offset + j];\n          if (suffix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * suffix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            compatible = true;\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            compatible = hasCrossCheckedFlag((char)prevFlag, appendFlags, previousWasPrefix);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int appendLength = length - i;\n            int deAffixedLength = length - appendLength;\n            \n            int stripStart = dictionary.stripOffsets[stripOrd];\n            int stripEnd = dictionary.stripOffsets[stripOrd+1];\n            int stripLength = stripEnd - stripStart;\n            \n            if (!checkCondition(condition, word, 0, deAffixedLength, dictionary.stripData, stripStart, stripLength)) {\n              continue;\n            }\n\n            char strippedWord[] = new char[stripLength + deAffixedLength];\n            System.arraycopy(word, 0, strippedWord, 0, deAffixedLength);\n            System.arraycopy(dictionary.stripData, stripStart, strippedWord, deAffixedLength, stripLength);\n            \n            List<CharsRef> stemList = applyAffix(strippedWord, strippedWord.length, suffix, prefixFlag, recursionDepth, false, circumfix);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int,int,int,int,int,boolean,boolean,boolean,boolean,boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int,int,int,int,int,boolean,boolean,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Generates a list of stems for the provided word\n   *\n   * @param word Word to generate the stems for\n   * @param previous previous affix that was removed (so we dont remove same one twice)\n   * @param prevFlag Flag from a previous stemming step that need to be cross-checked with any affixes in this recursive step\n   * @param prefixFlag flag of the most inner removed prefix, so that when removing a suffix, it's also checked against the word\n   * @param recursionDepth current recursiondepth\n   * @param doPrefix true if we should remove prefixes\n   * @param doSuffix true if we should remove suffixes\n   * @param previousWasPrefix true if the previous removal was a prefix:\n   *        if we are removing a suffix, and it has no continuation requirements, it's ok.\n   *        but two prefixes (COMPLEXPREFIXES) or two suffixes must have continuation requirements to recurse. \n   * @param circumfix true if the previous prefix removal was signed as a circumfix\n   *        this means inner most suffix must also contain circumfix flag.\n   * @param caseVariant true if we are searching for a case variant. if the word has KEEPCASE flag it cannot succeed.\n   * @return List of stems, or empty list if no stems are found\n   */\n  private List<CharsRef> stem(char word[], int length, int previous, int prevFlag, int prefixFlag, int recursionDepth, boolean doPrefix, boolean doSuffix, boolean previousWasPrefix, boolean circumfix, boolean caseVariant) throws IOException {\n    \n    // TODO: allow this stuff to be reused by tokenfilter\n    List<CharsRef> stems = new ArrayList<>();\n    \n    if (doPrefix && dictionary.prefixes != null) {\n      FST<IntsRef> fst = dictionary.prefixes;\n      Outputs<IntsRef> outputs = fst.outputs;\n      FST.BytesReader bytesReader = prefixReaders[recursionDepth];\n      FST.Arc<IntsRef> arc = prefixArcs[recursionDepth];\n      fst.getFirstArc(arc);\n      IntsRef NO_OUTPUT = outputs.getNoOutput();\n      IntsRef output = NO_OUTPUT;\n      int limit = dictionary.fullStrip ? length : length-1;\n      for (int i = 0; i < limit; i++) {\n        if (i > 0) {\n          int ch = word[i-1];\n          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {\n            break;\n          } else if (arc.output != NO_OUTPUT) {\n            output = fst.outputs.add(output, arc.output);\n          }\n        }\n        IntsRef prefixes = null;\n        if (!arc.isFinal()) {\n          continue;\n        } else {\n          prefixes = fst.outputs.add(output, arc.nextFinalOutput);\n        }\n        \n        for (int j = 0; j < prefixes.length; j++) {\n          int prefix = prefixes.ints[prefixes.offset + j];\n          if (prefix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * prefix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            if (dictionary.onlyincompound == -1) {\n              compatible = true;\n            } else {\n              // check if affix is allowed in a non-compound word\n              dictionary.flagLookup.get(append, scratch);\n              char appendFlags[] = Dictionary.decodeFlags(scratch);\n              compatible = !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            }\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            boolean allowed = dictionary.onlyincompound == -1 || \n                              !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            compatible = allowed && hasCrossCheckedFlag((char)prevFlag, appendFlags, false);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int deAffixedStart = i;\n            int deAffixedLength = length - deAffixedStart;\n            \n            int stripStart = dictionary.stripOffsets[stripOrd];\n            int stripEnd = dictionary.stripOffsets[stripOrd+1];\n            int stripLength = stripEnd - stripStart;\n            \n            if (!checkCondition(condition, dictionary.stripData, stripStart, stripLength, word, deAffixedStart, deAffixedLength)) {\n              continue;\n            }\n            \n            char strippedWord[] = new char[stripLength + deAffixedLength];\n            System.arraycopy(dictionary.stripData, stripStart, strippedWord, 0, stripLength);\n            System.arraycopy(word, deAffixedStart, strippedWord, stripLength, deAffixedLength);\n\n            List<CharsRef> stemList = applyAffix(strippedWord, strippedWord.length, prefix, -1, recursionDepth, true, circumfix, caseVariant);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    } \n    \n    if (doSuffix && dictionary.suffixes != null) {\n      FST<IntsRef> fst = dictionary.suffixes;\n      Outputs<IntsRef> outputs = fst.outputs;\n      FST.BytesReader bytesReader = suffixReaders[recursionDepth];\n      FST.Arc<IntsRef> arc = suffixArcs[recursionDepth];\n      fst.getFirstArc(arc);\n      IntsRef NO_OUTPUT = outputs.getNoOutput();\n      IntsRef output = NO_OUTPUT;\n      int limit = dictionary.fullStrip ? 0 : 1;\n      for (int i = length; i >= limit; i--) {\n        if (i < length) {\n          int ch = word[i];\n          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {\n            break;\n          } else if (arc.output != NO_OUTPUT) {\n            output = fst.outputs.add(output, arc.output);\n          }\n        }\n        IntsRef suffixes = null;\n        if (!arc.isFinal()) {\n          continue;\n        } else {\n          suffixes = fst.outputs.add(output, arc.nextFinalOutput);\n        }\n        \n        for (int j = 0; j < suffixes.length; j++) {\n          int suffix = suffixes.ints[suffixes.offset + j];\n          if (suffix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * suffix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            if (dictionary.onlyincompound == -1) {\n              compatible = true;\n            } else {\n              // check if affix is allowed in a non-compound word\n              dictionary.flagLookup.get(append, scratch);\n              char appendFlags[] = Dictionary.decodeFlags(scratch);\n              compatible = !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            }\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            boolean allowed = dictionary.onlyincompound == -1 || \n                              !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            compatible = allowed && hasCrossCheckedFlag((char)prevFlag, appendFlags, previousWasPrefix);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int appendLength = length - i;\n            int deAffixedLength = length - appendLength;\n            \n            int stripStart = dictionary.stripOffsets[stripOrd];\n            int stripEnd = dictionary.stripOffsets[stripOrd+1];\n            int stripLength = stripEnd - stripStart;\n            \n            if (!checkCondition(condition, word, 0, deAffixedLength, dictionary.stripData, stripStart, stripLength)) {\n              continue;\n            }\n\n            char strippedWord[] = new char[stripLength + deAffixedLength];\n            System.arraycopy(word, 0, strippedWord, 0, deAffixedLength);\n            System.arraycopy(dictionary.stripData, stripStart, strippedWord, deAffixedLength, stripLength);\n            \n            List<CharsRef> stemList = applyAffix(strippedWord, strippedWord.length, suffix, prefixFlag, recursionDepth, false, circumfix, caseVariant);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Generates a list of stems for the provided word\n   *\n   * @param word Word to generate the stems for\n   * @param previous previous affix that was removed (so we dont remove same one twice)\n   * @param prevFlag Flag from a previous stemming step that need to be cross-checked with any affixes in this recursive step\n   * @param prefixFlag flag of the most inner removed prefix, so that when removing a suffix, its also checked against the word\n   * @param recursionDepth current recursiondepth\n   * @param doPrefix true if we should remove prefixes\n   * @param doSuffix true if we should remove suffixes\n   * @param previousWasPrefix true if the previous removal was a prefix:\n   *        if we are removing a suffix, and it has no continuation requirements, its ok.\n   *        but two prefixes (COMPLEXPREFIXES) or two suffixes must have continuation requirements to recurse. \n   * @param circumfix true if the previous prefix removal was signed as a circumfix\n   *        this means inner most suffix must also contain circumfix flag.\n   * @param caseVariant true if we are searching for a case variant. if the word has KEEPCASE flag it cannot succeed.\n   * @return List of stems, or empty list if no stems are found\n   */\n  private List<CharsRef> stem(char word[], int length, int previous, int prevFlag, int prefixFlag, int recursionDepth, boolean doPrefix, boolean doSuffix, boolean previousWasPrefix, boolean circumfix, boolean caseVariant) throws IOException {\n    \n    // TODO: allow this stuff to be reused by tokenfilter\n    List<CharsRef> stems = new ArrayList<>();\n    \n    if (doPrefix && dictionary.prefixes != null) {\n      FST<IntsRef> fst = dictionary.prefixes;\n      Outputs<IntsRef> outputs = fst.outputs;\n      FST.BytesReader bytesReader = prefixReaders[recursionDepth];\n      FST.Arc<IntsRef> arc = prefixArcs[recursionDepth];\n      fst.getFirstArc(arc);\n      IntsRef NO_OUTPUT = outputs.getNoOutput();\n      IntsRef output = NO_OUTPUT;\n      int limit = dictionary.fullStrip ? length : length-1;\n      for (int i = 0; i < limit; i++) {\n        if (i > 0) {\n          int ch = word[i-1];\n          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {\n            break;\n          } else if (arc.output != NO_OUTPUT) {\n            output = fst.outputs.add(output, arc.output);\n          }\n        }\n        IntsRef prefixes = null;\n        if (!arc.isFinal()) {\n          continue;\n        } else {\n          prefixes = fst.outputs.add(output, arc.nextFinalOutput);\n        }\n        \n        for (int j = 0; j < prefixes.length; j++) {\n          int prefix = prefixes.ints[prefixes.offset + j];\n          if (prefix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * prefix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            if (dictionary.onlyincompound == -1) {\n              compatible = true;\n            } else {\n              // check if affix is allowed in a non-compound word\n              dictionary.flagLookup.get(append, scratch);\n              char appendFlags[] = Dictionary.decodeFlags(scratch);\n              compatible = !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            }\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            boolean allowed = dictionary.onlyincompound == -1 || \n                              !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            compatible = allowed && hasCrossCheckedFlag((char)prevFlag, appendFlags, false);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int deAffixedStart = i;\n            int deAffixedLength = length - deAffixedStart;\n            \n            int stripStart = dictionary.stripOffsets[stripOrd];\n            int stripEnd = dictionary.stripOffsets[stripOrd+1];\n            int stripLength = stripEnd - stripStart;\n            \n            if (!checkCondition(condition, dictionary.stripData, stripStart, stripLength, word, deAffixedStart, deAffixedLength)) {\n              continue;\n            }\n            \n            char strippedWord[] = new char[stripLength + deAffixedLength];\n            System.arraycopy(dictionary.stripData, stripStart, strippedWord, 0, stripLength);\n            System.arraycopy(word, deAffixedStart, strippedWord, stripLength, deAffixedLength);\n\n            List<CharsRef> stemList = applyAffix(strippedWord, strippedWord.length, prefix, -1, recursionDepth, true, circumfix, caseVariant);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    } \n    \n    if (doSuffix && dictionary.suffixes != null) {\n      FST<IntsRef> fst = dictionary.suffixes;\n      Outputs<IntsRef> outputs = fst.outputs;\n      FST.BytesReader bytesReader = suffixReaders[recursionDepth];\n      FST.Arc<IntsRef> arc = suffixArcs[recursionDepth];\n      fst.getFirstArc(arc);\n      IntsRef NO_OUTPUT = outputs.getNoOutput();\n      IntsRef output = NO_OUTPUT;\n      int limit = dictionary.fullStrip ? 0 : 1;\n      for (int i = length; i >= limit; i--) {\n        if (i < length) {\n          int ch = word[i];\n          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {\n            break;\n          } else if (arc.output != NO_OUTPUT) {\n            output = fst.outputs.add(output, arc.output);\n          }\n        }\n        IntsRef suffixes = null;\n        if (!arc.isFinal()) {\n          continue;\n        } else {\n          suffixes = fst.outputs.add(output, arc.nextFinalOutput);\n        }\n        \n        for (int j = 0; j < suffixes.length; j++) {\n          int suffix = suffixes.ints[suffixes.offset + j];\n          if (suffix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * suffix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            if (dictionary.onlyincompound == -1) {\n              compatible = true;\n            } else {\n              // check if affix is allowed in a non-compound word\n              dictionary.flagLookup.get(append, scratch);\n              char appendFlags[] = Dictionary.decodeFlags(scratch);\n              compatible = !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            }\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            boolean allowed = dictionary.onlyincompound == -1 || \n                              !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            compatible = allowed && hasCrossCheckedFlag((char)prevFlag, appendFlags, previousWasPrefix);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int appendLength = length - i;\n            int deAffixedLength = length - appendLength;\n            \n            int stripStart = dictionary.stripOffsets[stripOrd];\n            int stripEnd = dictionary.stripOffsets[stripOrd+1];\n            int stripLength = stripEnd - stripStart;\n            \n            if (!checkCondition(condition, word, 0, deAffixedLength, dictionary.stripData, stripStart, stripLength)) {\n              continue;\n            }\n\n            char strippedWord[] = new char[stripLength + deAffixedLength];\n            System.arraycopy(word, 0, strippedWord, 0, deAffixedLength);\n            System.arraycopy(dictionary.stripData, stripStart, strippedWord, deAffixedLength, stripLength);\n            \n            List<CharsRef> stemList = applyAffix(strippedWord, strippedWord.length, suffix, prefixFlag, recursionDepth, false, circumfix, caseVariant);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int,int,int,int,int,boolean,boolean,boolean,boolean,boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int,int,int,int,int,boolean,boolean,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Generates a list of stems for the provided word\n   *\n   * @param word Word to generate the stems for\n   * @param previous previous affix that was removed (so we dont remove same one twice)\n   * @param prevFlag Flag from a previous stemming step that need to be cross-checked with any affixes in this recursive step\n   * @param prefixFlag flag of the most inner removed prefix, so that when removing a suffix, it's also checked against the word\n   * @param recursionDepth current recursiondepth\n   * @param doPrefix true if we should remove prefixes\n   * @param doSuffix true if we should remove suffixes\n   * @param previousWasPrefix true if the previous removal was a prefix:\n   *        if we are removing a suffix, and it has no continuation requirements, it's ok.\n   *        but two prefixes (COMPLEXPREFIXES) or two suffixes must have continuation requirements to recurse. \n   * @param circumfix true if the previous prefix removal was signed as a circumfix\n   *        this means inner most suffix must also contain circumfix flag.\n   * @param caseVariant true if we are searching for a case variant. if the word has KEEPCASE flag it cannot succeed.\n   * @return List of stems, or empty list if no stems are found\n   */\n  private List<CharsRef> stem(char word[], int length, int previous, int prevFlag, int prefixFlag, int recursionDepth, boolean doPrefix, boolean doSuffix, boolean previousWasPrefix, boolean circumfix, boolean caseVariant) throws IOException {\n    \n    // TODO: allow this stuff to be reused by tokenfilter\n    List<CharsRef> stems = new ArrayList<>();\n    \n    if (doPrefix && dictionary.prefixes != null) {\n      FST<IntsRef> fst = dictionary.prefixes;\n      Outputs<IntsRef> outputs = fst.outputs;\n      FST.BytesReader bytesReader = prefixReaders[recursionDepth];\n      FST.Arc<IntsRef> arc = prefixArcs[recursionDepth];\n      fst.getFirstArc(arc);\n      IntsRef NO_OUTPUT = outputs.getNoOutput();\n      IntsRef output = NO_OUTPUT;\n      int limit = dictionary.fullStrip ? length : length-1;\n      for (int i = 0; i < limit; i++) {\n        if (i > 0) {\n          int ch = word[i-1];\n          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {\n            break;\n          } else if (arc.output() != NO_OUTPUT) {\n            output = fst.outputs.add(output, arc.output());\n          }\n        }\n        IntsRef prefixes = null;\n        if (!arc.isFinal()) {\n          continue;\n        } else {\n          prefixes = fst.outputs.add(output, arc.nextFinalOutput());\n        }\n        \n        for (int j = 0; j < prefixes.length; j++) {\n          int prefix = prefixes.ints[prefixes.offset + j];\n          if (prefix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * prefix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            if (dictionary.onlyincompound == -1) {\n              compatible = true;\n            } else {\n              // check if affix is allowed in a non-compound word\n              dictionary.flagLookup.get(append, scratch);\n              char appendFlags[] = Dictionary.decodeFlags(scratch);\n              compatible = !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            }\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            boolean allowed = dictionary.onlyincompound == -1 || \n                              !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            compatible = allowed && hasCrossCheckedFlag((char)prevFlag, appendFlags, false);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int deAffixedStart = i;\n            int deAffixedLength = length - deAffixedStart;\n            \n            int stripStart = dictionary.stripOffsets[stripOrd];\n            int stripEnd = dictionary.stripOffsets[stripOrd+1];\n            int stripLength = stripEnd - stripStart;\n            \n            if (!checkCondition(condition, dictionary.stripData, stripStart, stripLength, word, deAffixedStart, deAffixedLength)) {\n              continue;\n            }\n            \n            char strippedWord[] = new char[stripLength + deAffixedLength];\n            System.arraycopy(dictionary.stripData, stripStart, strippedWord, 0, stripLength);\n            System.arraycopy(word, deAffixedStart, strippedWord, stripLength, deAffixedLength);\n\n            List<CharsRef> stemList = applyAffix(strippedWord, strippedWord.length, prefix, -1, recursionDepth, true, circumfix, caseVariant);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    } \n    \n    if (doSuffix && dictionary.suffixes != null) {\n      FST<IntsRef> fst = dictionary.suffixes;\n      Outputs<IntsRef> outputs = fst.outputs;\n      FST.BytesReader bytesReader = suffixReaders[recursionDepth];\n      FST.Arc<IntsRef> arc = suffixArcs[recursionDepth];\n      fst.getFirstArc(arc);\n      IntsRef NO_OUTPUT = outputs.getNoOutput();\n      IntsRef output = NO_OUTPUT;\n      int limit = dictionary.fullStrip ? 0 : 1;\n      for (int i = length; i >= limit; i--) {\n        if (i < length) {\n          int ch = word[i];\n          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {\n            break;\n          } else if (arc.output() != NO_OUTPUT) {\n            output = fst.outputs.add(output, arc.output());\n          }\n        }\n        IntsRef suffixes = null;\n        if (!arc.isFinal()) {\n          continue;\n        } else {\n          suffixes = fst.outputs.add(output, arc.nextFinalOutput());\n        }\n        \n        for (int j = 0; j < suffixes.length; j++) {\n          int suffix = suffixes.ints[suffixes.offset + j];\n          if (suffix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * suffix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            if (dictionary.onlyincompound == -1) {\n              compatible = true;\n            } else {\n              // check if affix is allowed in a non-compound word\n              dictionary.flagLookup.get(append, scratch);\n              char appendFlags[] = Dictionary.decodeFlags(scratch);\n              compatible = !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            }\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            boolean allowed = dictionary.onlyincompound == -1 || \n                              !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            compatible = allowed && hasCrossCheckedFlag((char)prevFlag, appendFlags, previousWasPrefix);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int appendLength = length - i;\n            int deAffixedLength = length - appendLength;\n            \n            int stripStart = dictionary.stripOffsets[stripOrd];\n            int stripEnd = dictionary.stripOffsets[stripOrd+1];\n            int stripLength = stripEnd - stripStart;\n            \n            if (!checkCondition(condition, word, 0, deAffixedLength, dictionary.stripData, stripStart, stripLength)) {\n              continue;\n            }\n\n            char strippedWord[] = new char[stripLength + deAffixedLength];\n            System.arraycopy(word, 0, strippedWord, 0, deAffixedLength);\n            System.arraycopy(dictionary.stripData, stripStart, strippedWord, deAffixedLength, stripLength);\n            \n            List<CharsRef> stemList = applyAffix(strippedWord, strippedWord.length, suffix, prefixFlag, recursionDepth, false, circumfix, caseVariant);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Generates a list of stems for the provided word\n   *\n   * @param word Word to generate the stems for\n   * @param previous previous affix that was removed (so we dont remove same one twice)\n   * @param prevFlag Flag from a previous stemming step that need to be cross-checked with any affixes in this recursive step\n   * @param prefixFlag flag of the most inner removed prefix, so that when removing a suffix, it's also checked against the word\n   * @param recursionDepth current recursiondepth\n   * @param doPrefix true if we should remove prefixes\n   * @param doSuffix true if we should remove suffixes\n   * @param previousWasPrefix true if the previous removal was a prefix:\n   *        if we are removing a suffix, and it has no continuation requirements, it's ok.\n   *        but two prefixes (COMPLEXPREFIXES) or two suffixes must have continuation requirements to recurse. \n   * @param circumfix true if the previous prefix removal was signed as a circumfix\n   *        this means inner most suffix must also contain circumfix flag.\n   * @param caseVariant true if we are searching for a case variant. if the word has KEEPCASE flag it cannot succeed.\n   * @return List of stems, or empty list if no stems are found\n   */\n  private List<CharsRef> stem(char word[], int length, int previous, int prevFlag, int prefixFlag, int recursionDepth, boolean doPrefix, boolean doSuffix, boolean previousWasPrefix, boolean circumfix, boolean caseVariant) throws IOException {\n    \n    // TODO: allow this stuff to be reused by tokenfilter\n    List<CharsRef> stems = new ArrayList<>();\n    \n    if (doPrefix && dictionary.prefixes != null) {\n      FST<IntsRef> fst = dictionary.prefixes;\n      Outputs<IntsRef> outputs = fst.outputs;\n      FST.BytesReader bytesReader = prefixReaders[recursionDepth];\n      FST.Arc<IntsRef> arc = prefixArcs[recursionDepth];\n      fst.getFirstArc(arc);\n      IntsRef NO_OUTPUT = outputs.getNoOutput();\n      IntsRef output = NO_OUTPUT;\n      int limit = dictionary.fullStrip ? length : length-1;\n      for (int i = 0; i < limit; i++) {\n        if (i > 0) {\n          int ch = word[i-1];\n          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {\n            break;\n          } else if (arc.output != NO_OUTPUT) {\n            output = fst.outputs.add(output, arc.output);\n          }\n        }\n        IntsRef prefixes = null;\n        if (!arc.isFinal()) {\n          continue;\n        } else {\n          prefixes = fst.outputs.add(output, arc.nextFinalOutput);\n        }\n        \n        for (int j = 0; j < prefixes.length; j++) {\n          int prefix = prefixes.ints[prefixes.offset + j];\n          if (prefix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * prefix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            if (dictionary.onlyincompound == -1) {\n              compatible = true;\n            } else {\n              // check if affix is allowed in a non-compound word\n              dictionary.flagLookup.get(append, scratch);\n              char appendFlags[] = Dictionary.decodeFlags(scratch);\n              compatible = !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            }\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            boolean allowed = dictionary.onlyincompound == -1 || \n                              !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            compatible = allowed && hasCrossCheckedFlag((char)prevFlag, appendFlags, false);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int deAffixedStart = i;\n            int deAffixedLength = length - deAffixedStart;\n            \n            int stripStart = dictionary.stripOffsets[stripOrd];\n            int stripEnd = dictionary.stripOffsets[stripOrd+1];\n            int stripLength = stripEnd - stripStart;\n            \n            if (!checkCondition(condition, dictionary.stripData, stripStart, stripLength, word, deAffixedStart, deAffixedLength)) {\n              continue;\n            }\n            \n            char strippedWord[] = new char[stripLength + deAffixedLength];\n            System.arraycopy(dictionary.stripData, stripStart, strippedWord, 0, stripLength);\n            System.arraycopy(word, deAffixedStart, strippedWord, stripLength, deAffixedLength);\n\n            List<CharsRef> stemList = applyAffix(strippedWord, strippedWord.length, prefix, -1, recursionDepth, true, circumfix, caseVariant);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    } \n    \n    if (doSuffix && dictionary.suffixes != null) {\n      FST<IntsRef> fst = dictionary.suffixes;\n      Outputs<IntsRef> outputs = fst.outputs;\n      FST.BytesReader bytesReader = suffixReaders[recursionDepth];\n      FST.Arc<IntsRef> arc = suffixArcs[recursionDepth];\n      fst.getFirstArc(arc);\n      IntsRef NO_OUTPUT = outputs.getNoOutput();\n      IntsRef output = NO_OUTPUT;\n      int limit = dictionary.fullStrip ? 0 : 1;\n      for (int i = length; i >= limit; i--) {\n        if (i < length) {\n          int ch = word[i];\n          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {\n            break;\n          } else if (arc.output != NO_OUTPUT) {\n            output = fst.outputs.add(output, arc.output);\n          }\n        }\n        IntsRef suffixes = null;\n        if (!arc.isFinal()) {\n          continue;\n        } else {\n          suffixes = fst.outputs.add(output, arc.nextFinalOutput);\n        }\n        \n        for (int j = 0; j < suffixes.length; j++) {\n          int suffix = suffixes.ints[suffixes.offset + j];\n          if (suffix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * suffix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            if (dictionary.onlyincompound == -1) {\n              compatible = true;\n            } else {\n              // check if affix is allowed in a non-compound word\n              dictionary.flagLookup.get(append, scratch);\n              char appendFlags[] = Dictionary.decodeFlags(scratch);\n              compatible = !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            }\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            boolean allowed = dictionary.onlyincompound == -1 || \n                              !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            compatible = allowed && hasCrossCheckedFlag((char)prevFlag, appendFlags, previousWasPrefix);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int appendLength = length - i;\n            int deAffixedLength = length - appendLength;\n            \n            int stripStart = dictionary.stripOffsets[stripOrd];\n            int stripEnd = dictionary.stripOffsets[stripOrd+1];\n            int stripLength = stripEnd - stripStart;\n            \n            if (!checkCondition(condition, word, 0, deAffixedLength, dictionary.stripData, stripStart, stripLength)) {\n              continue;\n            }\n\n            char strippedWord[] = new char[stripLength + deAffixedLength];\n            System.arraycopy(word, 0, strippedWord, 0, deAffixedLength);\n            System.arraycopy(dictionary.stripData, stripStart, strippedWord, deAffixedLength, stripLength);\n            \n            List<CharsRef> stemList = applyAffix(strippedWord, strippedWord.length, suffix, prefixFlag, recursionDepth, false, circumfix, caseVariant);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int,int,int,int,int,boolean,boolean,boolean,boolean,boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int,int,int,int,int,boolean,boolean,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Generates a list of stems for the provided word\n   *\n   * @param word Word to generate the stems for\n   * @param previous previous affix that was removed (so we dont remove same one twice)\n   * @param prevFlag Flag from a previous stemming step that need to be cross-checked with any affixes in this recursive step\n   * @param prefixFlag flag of the most inner removed prefix, so that when removing a suffix, it's also checked against the word\n   * @param recursionDepth current recursiondepth\n   * @param doPrefix true if we should remove prefixes\n   * @param doSuffix true if we should remove suffixes\n   * @param previousWasPrefix true if the previous removal was a prefix:\n   *        if we are removing a suffix, and it has no continuation requirements, it's ok.\n   *        but two prefixes (COMPLEXPREFIXES) or two suffixes must have continuation requirements to recurse. \n   * @param circumfix true if the previous prefix removal was signed as a circumfix\n   *        this means inner most suffix must also contain circumfix flag.\n   * @param caseVariant true if we are searching for a case variant. if the word has KEEPCASE flag it cannot succeed.\n   * @return List of stems, or empty list if no stems are found\n   */\n  private List<CharsRef> stem(char word[], int length, int previous, int prevFlag, int prefixFlag, int recursionDepth, boolean doPrefix, boolean doSuffix, boolean previousWasPrefix, boolean circumfix, boolean caseVariant) throws IOException {\n    \n    // TODO: allow this stuff to be reused by tokenfilter\n    List<CharsRef> stems = new ArrayList<>();\n    \n    if (doPrefix && dictionary.prefixes != null) {\n      FST<IntsRef> fst = dictionary.prefixes;\n      Outputs<IntsRef> outputs = fst.outputs;\n      FST.BytesReader bytesReader = prefixReaders[recursionDepth];\n      FST.Arc<IntsRef> arc = prefixArcs[recursionDepth];\n      fst.getFirstArc(arc);\n      IntsRef NO_OUTPUT = outputs.getNoOutput();\n      IntsRef output = NO_OUTPUT;\n      int limit = dictionary.fullStrip ? length : length-1;\n      for (int i = 0; i < limit; i++) {\n        if (i > 0) {\n          int ch = word[i-1];\n          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {\n            break;\n          } else if (arc.output() != NO_OUTPUT) {\n            output = fst.outputs.add(output, arc.output());\n          }\n        }\n        IntsRef prefixes = null;\n        if (!arc.isFinal()) {\n          continue;\n        } else {\n          prefixes = fst.outputs.add(output, arc.nextFinalOutput());\n        }\n        \n        for (int j = 0; j < prefixes.length; j++) {\n          int prefix = prefixes.ints[prefixes.offset + j];\n          if (prefix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * prefix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            if (dictionary.onlyincompound == -1) {\n              compatible = true;\n            } else {\n              // check if affix is allowed in a non-compound word\n              dictionary.flagLookup.get(append, scratch);\n              char appendFlags[] = Dictionary.decodeFlags(scratch);\n              compatible = !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            }\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            boolean allowed = dictionary.onlyincompound == -1 || \n                              !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            compatible = allowed && hasCrossCheckedFlag((char)prevFlag, appendFlags, false);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int deAffixedStart = i;\n            int deAffixedLength = length - deAffixedStart;\n            \n            int stripStart = dictionary.stripOffsets[stripOrd];\n            int stripEnd = dictionary.stripOffsets[stripOrd+1];\n            int stripLength = stripEnd - stripStart;\n            \n            if (!checkCondition(condition, dictionary.stripData, stripStart, stripLength, word, deAffixedStart, deAffixedLength)) {\n              continue;\n            }\n            \n            char strippedWord[] = new char[stripLength + deAffixedLength];\n            System.arraycopy(dictionary.stripData, stripStart, strippedWord, 0, stripLength);\n            System.arraycopy(word, deAffixedStart, strippedWord, stripLength, deAffixedLength);\n\n            List<CharsRef> stemList = applyAffix(strippedWord, strippedWord.length, prefix, -1, recursionDepth, true, circumfix, caseVariant);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    } \n    \n    if (doSuffix && dictionary.suffixes != null) {\n      FST<IntsRef> fst = dictionary.suffixes;\n      Outputs<IntsRef> outputs = fst.outputs;\n      FST.BytesReader bytesReader = suffixReaders[recursionDepth];\n      FST.Arc<IntsRef> arc = suffixArcs[recursionDepth];\n      fst.getFirstArc(arc);\n      IntsRef NO_OUTPUT = outputs.getNoOutput();\n      IntsRef output = NO_OUTPUT;\n      int limit = dictionary.fullStrip ? 0 : 1;\n      for (int i = length; i >= limit; i--) {\n        if (i < length) {\n          int ch = word[i];\n          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {\n            break;\n          } else if (arc.output() != NO_OUTPUT) {\n            output = fst.outputs.add(output, arc.output());\n          }\n        }\n        IntsRef suffixes = null;\n        if (!arc.isFinal()) {\n          continue;\n        } else {\n          suffixes = fst.outputs.add(output, arc.nextFinalOutput());\n        }\n        \n        for (int j = 0; j < suffixes.length; j++) {\n          int suffix = suffixes.ints[suffixes.offset + j];\n          if (suffix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * suffix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            if (dictionary.onlyincompound == -1) {\n              compatible = true;\n            } else {\n              // check if affix is allowed in a non-compound word\n              dictionary.flagLookup.get(append, scratch);\n              char appendFlags[] = Dictionary.decodeFlags(scratch);\n              compatible = !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            }\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            boolean allowed = dictionary.onlyincompound == -1 || \n                              !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            compatible = allowed && hasCrossCheckedFlag((char)prevFlag, appendFlags, previousWasPrefix);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int appendLength = length - i;\n            int deAffixedLength = length - appendLength;\n            \n            int stripStart = dictionary.stripOffsets[stripOrd];\n            int stripEnd = dictionary.stripOffsets[stripOrd+1];\n            int stripLength = stripEnd - stripStart;\n            \n            if (!checkCondition(condition, word, 0, deAffixedLength, dictionary.stripData, stripStart, stripLength)) {\n              continue;\n            }\n\n            char strippedWord[] = new char[stripLength + deAffixedLength];\n            System.arraycopy(word, 0, strippedWord, 0, deAffixedLength);\n            System.arraycopy(dictionary.stripData, stripStart, strippedWord, deAffixedLength, stripLength);\n            \n            List<CharsRef> stemList = applyAffix(strippedWord, strippedWord.length, suffix, prefixFlag, recursionDepth, false, circumfix, caseVariant);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Generates a list of stems for the provided word\n   *\n   * @param word Word to generate the stems for\n   * @param previous previous affix that was removed (so we dont remove same one twice)\n   * @param prevFlag Flag from a previous stemming step that need to be cross-checked with any affixes in this recursive step\n   * @param prefixFlag flag of the most inner removed prefix, so that when removing a suffix, it's also checked against the word\n   * @param recursionDepth current recursiondepth\n   * @param doPrefix true if we should remove prefixes\n   * @param doSuffix true if we should remove suffixes\n   * @param previousWasPrefix true if the previous removal was a prefix:\n   *        if we are removing a suffix, and it has no continuation requirements, it's ok.\n   *        but two prefixes (COMPLEXPREFIXES) or two suffixes must have continuation requirements to recurse. \n   * @param circumfix true if the previous prefix removal was signed as a circumfix\n   *        this means inner most suffix must also contain circumfix flag.\n   * @param caseVariant true if we are searching for a case variant. if the word has KEEPCASE flag it cannot succeed.\n   * @return List of stems, or empty list if no stems are found\n   */\n  private List<CharsRef> stem(char word[], int length, int previous, int prevFlag, int prefixFlag, int recursionDepth, boolean doPrefix, boolean doSuffix, boolean previousWasPrefix, boolean circumfix, boolean caseVariant) throws IOException {\n    \n    // TODO: allow this stuff to be reused by tokenfilter\n    List<CharsRef> stems = new ArrayList<>();\n    \n    if (doPrefix && dictionary.prefixes != null) {\n      FST<IntsRef> fst = dictionary.prefixes;\n      Outputs<IntsRef> outputs = fst.outputs;\n      FST.BytesReader bytesReader = prefixReaders[recursionDepth];\n      FST.Arc<IntsRef> arc = prefixArcs[recursionDepth];\n      fst.getFirstArc(arc);\n      IntsRef NO_OUTPUT = outputs.getNoOutput();\n      IntsRef output = NO_OUTPUT;\n      int limit = dictionary.fullStrip ? length : length-1;\n      for (int i = 0; i < limit; i++) {\n        if (i > 0) {\n          int ch = word[i-1];\n          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {\n            break;\n          } else if (arc.output != NO_OUTPUT) {\n            output = fst.outputs.add(output, arc.output);\n          }\n        }\n        IntsRef prefixes = null;\n        if (!arc.isFinal()) {\n          continue;\n        } else {\n          prefixes = fst.outputs.add(output, arc.nextFinalOutput);\n        }\n        \n        for (int j = 0; j < prefixes.length; j++) {\n          int prefix = prefixes.ints[prefixes.offset + j];\n          if (prefix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * prefix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            if (dictionary.onlyincompound == -1) {\n              compatible = true;\n            } else {\n              // check if affix is allowed in a non-compound word\n              dictionary.flagLookup.get(append, scratch);\n              char appendFlags[] = Dictionary.decodeFlags(scratch);\n              compatible = !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            }\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            boolean allowed = dictionary.onlyincompound == -1 || \n                              !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            compatible = allowed && hasCrossCheckedFlag((char)prevFlag, appendFlags, false);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int deAffixedStart = i;\n            int deAffixedLength = length - deAffixedStart;\n            \n            int stripStart = dictionary.stripOffsets[stripOrd];\n            int stripEnd = dictionary.stripOffsets[stripOrd+1];\n            int stripLength = stripEnd - stripStart;\n            \n            if (!checkCondition(condition, dictionary.stripData, stripStart, stripLength, word, deAffixedStart, deAffixedLength)) {\n              continue;\n            }\n            \n            char strippedWord[] = new char[stripLength + deAffixedLength];\n            System.arraycopy(dictionary.stripData, stripStart, strippedWord, 0, stripLength);\n            System.arraycopy(word, deAffixedStart, strippedWord, stripLength, deAffixedLength);\n\n            List<CharsRef> stemList = applyAffix(strippedWord, strippedWord.length, prefix, -1, recursionDepth, true, circumfix, caseVariant);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    } \n    \n    if (doSuffix && dictionary.suffixes != null) {\n      FST<IntsRef> fst = dictionary.suffixes;\n      Outputs<IntsRef> outputs = fst.outputs;\n      FST.BytesReader bytesReader = suffixReaders[recursionDepth];\n      FST.Arc<IntsRef> arc = suffixArcs[recursionDepth];\n      fst.getFirstArc(arc);\n      IntsRef NO_OUTPUT = outputs.getNoOutput();\n      IntsRef output = NO_OUTPUT;\n      int limit = dictionary.fullStrip ? 0 : 1;\n      for (int i = length; i >= limit; i--) {\n        if (i < length) {\n          int ch = word[i];\n          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {\n            break;\n          } else if (arc.output != NO_OUTPUT) {\n            output = fst.outputs.add(output, arc.output);\n          }\n        }\n        IntsRef suffixes = null;\n        if (!arc.isFinal()) {\n          continue;\n        } else {\n          suffixes = fst.outputs.add(output, arc.nextFinalOutput);\n        }\n        \n        for (int j = 0; j < suffixes.length; j++) {\n          int suffix = suffixes.ints[suffixes.offset + j];\n          if (suffix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * suffix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            if (dictionary.onlyincompound == -1) {\n              compatible = true;\n            } else {\n              // check if affix is allowed in a non-compound word\n              dictionary.flagLookup.get(append, scratch);\n              char appendFlags[] = Dictionary.decodeFlags(scratch);\n              compatible = !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            }\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            boolean allowed = dictionary.onlyincompound == -1 || \n                              !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);\n            compatible = allowed && hasCrossCheckedFlag((char)prevFlag, appendFlags, previousWasPrefix);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int appendLength = length - i;\n            int deAffixedLength = length - appendLength;\n            \n            int stripStart = dictionary.stripOffsets[stripOrd];\n            int stripEnd = dictionary.stripOffsets[stripOrd+1];\n            int stripLength = stripEnd - stripStart;\n            \n            if (!checkCondition(condition, word, 0, deAffixedLength, dictionary.stripData, stripStart, stripLength)) {\n              continue;\n            }\n\n            char strippedWord[] = new char[stripLength + deAffixedLength];\n            System.arraycopy(word, 0, strippedWord, 0, deAffixedLength);\n            System.arraycopy(dictionary.stripData, stripStart, strippedWord, deAffixedLength, stripLength);\n            \n            List<CharsRef> stemList = applyAffix(strippedWord, strippedWord.length, suffix, prefixFlag, recursionDepth, false, circumfix, caseVariant);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54204c8a3ca26aeafd273139fc29baf70d0f6786":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["422da43e6414338103dfc37b7c8c68dcbe309d87"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"422da43e6414338103dfc37b7c8c68dcbe309d87":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f8061ddd97f3352007d927dae445884a6f3d857b":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["54204c8a3ca26aeafd273139fc29baf70d0f6786"]},"commit2Childs":{"54204c8a3ca26aeafd273139fc29baf70d0f6786":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["54204c8a3ca26aeafd273139fc29baf70d0f6786","f8061ddd97f3352007d927dae445884a6f3d857b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["422da43e6414338103dfc37b7c8c68dcbe309d87"],"422da43e6414338103dfc37b7c8c68dcbe309d87":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}