{"path":"src/java/org/apache/lucene/search/ConjunctionScorer#init(int).mjava","commits":[{"id":"a251547210ad8523f10c15c461496a2ad4bb3df4","date":1195837134,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/ConjunctionScorer#init(int).mjava","pathOld":"/dev/null","sourceNew":"  // Note... most of this could be done in the constructor\n  // thus skipping a check for firstTime per call to next() and skipTo()\n  private boolean init(int target) throws IOException {\n    firstTime=false;\n    more = scorers.length>1;\n    for (int i=0; i<scorers.length; i++) {\n      more = target==0 ? scorers[i].next() : scorers[i].skipTo(target);\n      if (!more)\n        return false;\n    }\n\n    // Sort the array the first time...\n    // We don't need to sort the array in any future calls because we know\n    // it will already start off sorted (all scorers on same doc).\n\n    // note that this comparator is not consistent with equals!\n    Arrays.sort(scorers, new Comparator() {         // sort the array\n        public int compare(Object o1, Object o2) {\n          return ((Scorer)o1).doc() - ((Scorer)o2).doc();\n        }\n      });\n\n    doNext();\n\n    // If first-time skip distance is any predictor of\n    // scorer sparseness, then we should always try to skip first on\n    // those scorers.\n    // Keep last scorer in it's last place (it will be the first\n    // to be skipped on), but reverse all of the others so that\n    // they will be skipped on in order of original high skip.\n    int end=(scorers.length-1)-1;\n    for (int i=0; i<(end>>1); i++) {\n      Scorer tmp = scorers[i];\n      scorers[i] = scorers[end-i];\n      scorers[end-i] = tmp;\n    }\n\n    return more;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55f4e6c6fc884fd70724190215f7bb5485fa5b55","date":1203893004,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/ConjunctionScorer#init(int).mjava","pathOld":"src/java/org/apache/lucene/search/ConjunctionScorer#init(int).mjava","sourceNew":"  // Note... most of this could be done in the constructor\n  // thus skipping a check for firstTime per call to next() and skipTo()\n  private boolean init(int target) throws IOException {\n    firstTime=false;\n    more = scorers.length>1;\n    for (int i=0; i<scorers.length; i++) {\n      more = target==0 ? scorers[i].next() : scorers[i].skipTo(target);\n      if (!more)\n        return false;\n    }\n\n    // Sort the array the first time...\n    // We don't need to sort the array in any future calls because we know\n    // it will already start off sorted (all scorers on same doc).\n\n    // note that this comparator is not consistent with equals!\n    Arrays.sort(scorers, new Comparator() {         // sort the array\n        public int compare(Object o1, Object o2) {\n          return ((Scorer)o1).doc() - ((Scorer)o2).doc();\n        }\n      });\n\n    doNext();\n\n    // If first-time skip distance is any predictor of\n    // scorer sparseness, then we should always try to skip first on\n    // those scorers.\n    // Keep last scorer in it's last place (it will be the first\n    // to be skipped on), but reverse all of the others so that\n    // they will be skipped on in order of original high skip.\n    int end=(scorers.length-1);\n    for (int i=0; i<(end>>1); i++) {\n      Scorer tmp = scorers[i];\n      scorers[i] = scorers[end-i-1];\n      scorers[end-i-1] = tmp;\n    }\n\n    return more;\n  }\n\n","sourceOld":"  // Note... most of this could be done in the constructor\n  // thus skipping a check for firstTime per call to next() and skipTo()\n  private boolean init(int target) throws IOException {\n    firstTime=false;\n    more = scorers.length>1;\n    for (int i=0; i<scorers.length; i++) {\n      more = target==0 ? scorers[i].next() : scorers[i].skipTo(target);\n      if (!more)\n        return false;\n    }\n\n    // Sort the array the first time...\n    // We don't need to sort the array in any future calls because we know\n    // it will already start off sorted (all scorers on same doc).\n\n    // note that this comparator is not consistent with equals!\n    Arrays.sort(scorers, new Comparator() {         // sort the array\n        public int compare(Object o1, Object o2) {\n          return ((Scorer)o1).doc() - ((Scorer)o2).doc();\n        }\n      });\n\n    doNext();\n\n    // If first-time skip distance is any predictor of\n    // scorer sparseness, then we should always try to skip first on\n    // those scorers.\n    // Keep last scorer in it's last place (it will be the first\n    // to be skipped on), but reverse all of the others so that\n    // they will be skipped on in order of original high skip.\n    int end=(scorers.length-1)-1;\n    for (int i=0; i<(end>>1); i++) {\n      Scorer tmp = scorers[i];\n      scorers[i] = scorers[end-i];\n      scorers[end-i] = tmp;\n    }\n\n    return more;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30a558487f2298c2c19ceca9103c1b6865d64708","date":1244393921,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/search/ConjunctionScorer#init(int).mjava","sourceNew":null,"sourceOld":"  // Note... most of this could be done in the constructor\n  // thus skipping a check for firstTime per call to next() and skipTo()\n  private boolean init(int target) throws IOException {\n    firstTime=false;\n    more = scorers.length>1;\n    for (int i=0; i<scorers.length; i++) {\n      more = target==0 ? scorers[i].next() : scorers[i].skipTo(target);\n      if (!more)\n        return false;\n    }\n\n    // Sort the array the first time...\n    // We don't need to sort the array in any future calls because we know\n    // it will already start off sorted (all scorers on same doc).\n\n    // note that this comparator is not consistent with equals!\n    Arrays.sort(scorers, new Comparator() {         // sort the array\n        public int compare(Object o1, Object o2) {\n          return ((Scorer)o1).doc() - ((Scorer)o2).doc();\n        }\n      });\n\n    doNext();\n\n    // If first-time skip distance is any predictor of\n    // scorer sparseness, then we should always try to skip first on\n    // those scorers.\n    // Keep last scorer in it's last place (it will be the first\n    // to be skipped on), but reverse all of the others so that\n    // they will be skipped on in order of original high skip.\n    int end=(scorers.length-1);\n    for (int i=0; i<(end>>1); i++) {\n      Scorer tmp = scorers[i];\n      scorers[i] = scorers[end-i-1];\n      scorers[end-i-1] = tmp;\n    }\n\n    return more;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"30a558487f2298c2c19ceca9103c1b6865d64708":["55f4e6c6fc884fd70724190215f7bb5485fa5b55"],"a251547210ad8523f10c15c461496a2ad4bb3df4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"55f4e6c6fc884fd70724190215f7bb5485fa5b55":["a251547210ad8523f10c15c461496a2ad4bb3df4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["30a558487f2298c2c19ceca9103c1b6865d64708"]},"commit2Childs":{"30a558487f2298c2c19ceca9103c1b6865d64708":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a251547210ad8523f10c15c461496a2ad4bb3df4":["55f4e6c6fc884fd70724190215f7bb5485fa5b55"],"55f4e6c6fc884fd70724190215f7bb5485fa5b55":["30a558487f2298c2c19ceca9103c1b6865d64708"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a251547210ad8523f10c15c461496a2ad4bb3df4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}