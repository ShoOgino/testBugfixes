{"path":"lucene/core/src/java/org/apache/lucene/index/MergeRateLimiter#maybePause(long,long).mjava","commits":[{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MergeRateLimiter#maybePause(long,long).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns NO if no pause happened, STOPPED if pause because rate was 0.0 (merge is stopped), PAUSED if paused with a normal rate limit. */\n  private synchronized PauseResult maybePause(long bytes, long curNS) throws MergePolicy.MergeAbortedException {\n    double secondsToPause = (bytes/1024./1024.) / mbPerSec;\n\n    // Time we should sleep until; this is purely instantaneous\n    // rate (just adds seconds onto the last time we had paused to);\n    // maybe we should also offer decayed recent history one?\n    long targetNS = lastNS + (long) (1000000000 * secondsToPause);\n\n    long curPauseNS = targetNS - curNS;\n\n    // NOTE: except maybe on real-time JVMs, minimum realistic\n    // wait/sleep time is 1 msec; if you pass just 1 nsec the impl\n    // rounds up to 1 msec, so we don't bother unless it's > 2 msec:\n\n    if (curPauseNS <= 2000000) {\n      return PauseResult.NO;\n    }\n\n    // Defensive: sleep for at most 250 msec; the loop above will call us again if we should keep sleeping:\n    if (curPauseNS > 250L*1000000) {\n      curPauseNS = 250L*1000000;\n    }\n\n    int sleepMS = (int) (curPauseNS / 1000000);\n    int sleepNS = (int) (curPauseNS % 1000000);\n\n    // Now is a good time to abort the merge:\n    checkAbort();\n\n    double rate = mbPerSec;\n\n    try {\n      // CMS can wake us up here if it changes our target rate:\n      wait(sleepMS, sleepNS);\n    } catch (InterruptedException ie) {\n      throw new ThreadInterruptedException(ie);\n    }\n\n    if (rate == 0.0) {\n      return PauseResult.STOPPED;\n    } else {\n      return PauseResult.PAUSED;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7bf95be1fe06a3535aa13b9fc2ce7ebac0eae6db","date":1420822089,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MergeRateLimiter#maybePause(long,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MergeRateLimiter#maybePause(long,long).mjava","sourceNew":"  /** Returns NO if no pause happened, STOPPED if pause because rate was 0.0 (merge is stopped), PAUSED if paused with a normal rate limit. */\n  private synchronized PauseResult maybePause(long bytes, long curNS) throws MergePolicy.MergeAbortedException {\n\n    // Now is a good time to abort the merge:\n    checkAbort();\n\n    double secondsToPause = (bytes/1024./1024.) / mbPerSec;\n\n    // Time we should sleep until; this is purely instantaneous\n    // rate (just adds seconds onto the last time we had paused to);\n    // maybe we should also offer decayed recent history one?\n    long targetNS = lastNS + (long) (1000000000 * secondsToPause);\n\n    long curPauseNS = targetNS - curNS;\n\n    // NOTE: except maybe on real-time JVMs, minimum realistic\n    // wait/sleep time is 1 msec; if you pass just 1 nsec the impl\n    // rounds up to 1 msec, so we don't bother unless it's > 2 msec:\n\n    if (curPauseNS <= 2000000) {\n      return PauseResult.NO;\n    }\n\n    // Defensive: sleep for at most 250 msec; the loop above will call us again if we should keep sleeping:\n    if (curPauseNS > 250L*1000000) {\n      curPauseNS = 250L*1000000;\n    }\n\n    int sleepMS = (int) (curPauseNS / 1000000);\n    int sleepNS = (int) (curPauseNS % 1000000);\n\n    double rate = mbPerSec;\n\n    try {\n      // CMS can wake us up here if it changes our target rate:\n      wait(sleepMS, sleepNS);\n    } catch (InterruptedException ie) {\n      throw new ThreadInterruptedException(ie);\n    }\n\n    if (rate == 0.0) {\n      return PauseResult.STOPPED;\n    } else {\n      return PauseResult.PAUSED;\n    }\n  }\n\n","sourceOld":"  /** Returns NO if no pause happened, STOPPED if pause because rate was 0.0 (merge is stopped), PAUSED if paused with a normal rate limit. */\n  private synchronized PauseResult maybePause(long bytes, long curNS) throws MergePolicy.MergeAbortedException {\n    double secondsToPause = (bytes/1024./1024.) / mbPerSec;\n\n    // Time we should sleep until; this is purely instantaneous\n    // rate (just adds seconds onto the last time we had paused to);\n    // maybe we should also offer decayed recent history one?\n    long targetNS = lastNS + (long) (1000000000 * secondsToPause);\n\n    long curPauseNS = targetNS - curNS;\n\n    // NOTE: except maybe on real-time JVMs, minimum realistic\n    // wait/sleep time is 1 msec; if you pass just 1 nsec the impl\n    // rounds up to 1 msec, so we don't bother unless it's > 2 msec:\n\n    if (curPauseNS <= 2000000) {\n      return PauseResult.NO;\n    }\n\n    // Defensive: sleep for at most 250 msec; the loop above will call us again if we should keep sleeping:\n    if (curPauseNS > 250L*1000000) {\n      curPauseNS = 250L*1000000;\n    }\n\n    int sleepMS = (int) (curPauseNS / 1000000);\n    int sleepNS = (int) (curPauseNS % 1000000);\n\n    // Now is a good time to abort the merge:\n    checkAbort();\n\n    double rate = mbPerSec;\n\n    try {\n      // CMS can wake us up here if it changes our target rate:\n      wait(sleepMS, sleepNS);\n    } catch (InterruptedException ie) {\n      throw new ThreadInterruptedException(ie);\n    }\n\n    if (rate == 0.0) {\n      return PauseResult.STOPPED;\n    } else {\n      return PauseResult.PAUSED;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1ee9437ba5a8297220428d48a6bb823d1fcd57b","date":1489137809,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MergeRateLimiter#maybePause(long,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MergeRateLimiter#maybePause(long,long).mjava","sourceNew":"  /** \n   * Returns the number of nanoseconds spent in a paused state or <code>-1</code>\n   * if no pause was applied. If the thread needs pausing, this method delegates \n   * to the linked {@link OneMergeProgress}. \n   */\n  private long maybePause(long bytes, long curNS) throws MergePolicy.MergeAbortedException {\n    // Now is a good time to abort the merge:\n    if (mergeProgress.isAborted()) {\n      throw new MergePolicy.MergeAbortedException(\"Merge aborted.\");\n    }\n\n    double rate = mbPerSec; // read from volatile rate once.\n    double secondsToPause = (bytes/1024./1024.) / rate;\n\n    // Time we should sleep until; this is purely instantaneous\n    // rate (just adds seconds onto the last time we had paused to);\n    // maybe we should also offer decayed recent history one?\n    long targetNS = lastNS + (long) (1000000000 * secondsToPause);\n\n    long curPauseNS = targetNS - curNS;\n\n    // We don't bother with thread pausing if the pause is smaller than 2 msec.\n    if (curPauseNS <= MIN_PAUSE_NS) {\n      // Set to curNS, not targetNS, to enforce the instant rate, not\n      // the \"averaged over all history\" rate:\n      lastNS = curNS;\n      return -1;\n    }\n\n    // Defensive: don't sleep for too long; the loop above will call us again if\n    // we should keep sleeping and the rate may be adjusted in between.\n    if (curPauseNS > MAX_PAUSE_NS) {\n      curPauseNS = MAX_PAUSE_NS;\n    }\n\n    long start = System.nanoTime();\n    try {\n      mergeProgress.pauseNanos(\n          curPauseNS, \n          rate == 0.0 ? PauseReason.STOPPED : PauseReason.PAUSED,\n          () -> rate == mbPerSec);\n    } catch (InterruptedException ie) {\n      throw new ThreadInterruptedException(ie);\n    }\n    return System.nanoTime() - start;\n  }\n\n","sourceOld":"  /** Returns NO if no pause happened, STOPPED if pause because rate was 0.0 (merge is stopped), PAUSED if paused with a normal rate limit. */\n  private synchronized PauseResult maybePause(long bytes, long curNS) throws MergePolicy.MergeAbortedException {\n\n    // Now is a good time to abort the merge:\n    checkAbort();\n\n    double secondsToPause = (bytes/1024./1024.) / mbPerSec;\n\n    // Time we should sleep until; this is purely instantaneous\n    // rate (just adds seconds onto the last time we had paused to);\n    // maybe we should also offer decayed recent history one?\n    long targetNS = lastNS + (long) (1000000000 * secondsToPause);\n\n    long curPauseNS = targetNS - curNS;\n\n    // NOTE: except maybe on real-time JVMs, minimum realistic\n    // wait/sleep time is 1 msec; if you pass just 1 nsec the impl\n    // rounds up to 1 msec, so we don't bother unless it's > 2 msec:\n\n    if (curPauseNS <= 2000000) {\n      return PauseResult.NO;\n    }\n\n    // Defensive: sleep for at most 250 msec; the loop above will call us again if we should keep sleeping:\n    if (curPauseNS > 250L*1000000) {\n      curPauseNS = 250L*1000000;\n    }\n\n    int sleepMS = (int) (curPauseNS / 1000000);\n    int sleepNS = (int) (curPauseNS % 1000000);\n\n    double rate = mbPerSec;\n\n    try {\n      // CMS can wake us up here if it changes our target rate:\n      wait(sleepMS, sleepNS);\n    } catch (InterruptedException ie) {\n      throw new ThreadInterruptedException(ie);\n    }\n\n    if (rate == 0.0) {\n      return PauseResult.STOPPED;\n    } else {\n      return PauseResult.PAUSED;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["7bf95be1fe06a3535aa13b9fc2ce7ebac0eae6db"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7bf95be1fe06a3535aa13b9fc2ce7ebac0eae6db":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["7bf95be1fe06a3535aa13b9fc2ce7ebac0eae6db"],"7bf95be1fe06a3535aa13b9fc2ce7ebac0eae6db":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}