{"path":"lucene/backwards/src/java/org/apache/lucene/index/DocumentsWriter#balanceRAM().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backwards/src/java/org/apache/lucene/index/DocumentsWriter#balanceRAM().mjava","pathOld":"backwards/src/java/org/apache/lucene/index/DocumentsWriter#balanceRAM().mjava","sourceNew":"  /* We have three pools of RAM: Postings, byte blocks\n   * (holds freq/prox posting data) and char blocks (holds\n   * characters in the term).  Different docs require\n   * varying amount of storage from these three classes.\n   * For example, docs with many unique single-occurrence\n   * short terms will use up the Postings RAM and hardly any\n   * of the other two.  Whereas docs with very large terms\n   * will use alot of char blocks RAM and relatively less of\n   * the other two.  This method just frees allocations from\n   * the pools once we are over-budget, which balances the\n   * pools to match the current docs. */\n  void balanceRAM() {\n\n    // We flush when we've used our target usage\n    final long flushTrigger = ramBufferSize;\n\n    final long deletesRAMUsed = deletesInRAM.bytesUsed+deletesFlushed.bytesUsed;\n\n    if (numBytesAlloc+deletesRAMUsed > freeTrigger) {\n\n      if (infoStream != null)\n        message(\"  RAM: now balance allocations: usedMB=\" + toMB(numBytesUsed) +\n                \" vs trigger=\" + toMB(flushTrigger) +\n                \" allocMB=\" + toMB(numBytesAlloc) +\n                \" deletesMB=\" + toMB(deletesRAMUsed) +\n                \" vs trigger=\" + toMB(freeTrigger) +\n                \" byteBlockFree=\" + toMB(byteBlockAllocator.freeByteBlocks.size()*BYTE_BLOCK_SIZE) +\n                \" charBlockFree=\" + toMB(freeCharBlocks.size()*CHAR_BLOCK_SIZE*CHAR_NUM_BYTE));\n\n      final long startBytesAlloc = numBytesAlloc + deletesRAMUsed;\n\n      int iter = 0;\n\n      // We free equally from each pool in 32 KB\n      // chunks until we are below our threshold\n      // (freeLevel)\n\n      boolean any = true;\n\n      while(numBytesAlloc+deletesRAMUsed > freeLevel) {\n      \n        synchronized(this) {\n          if (0 == byteBlockAllocator.freeByteBlocks.size() && 0 == freeCharBlocks.size() && 0 == freeIntBlocks.size() && !any) {\n            // Nothing else to free -- must flush now.\n            bufferIsFull = numBytesUsed+deletesRAMUsed > flushTrigger;\n            if (infoStream != null) {\n              if (numBytesUsed > flushTrigger)\n                message(\"    nothing to free; now set bufferIsFull\");\n              else\n                message(\"    nothing to free\");\n            }\n            assert numBytesUsed <= numBytesAlloc;\n            break;\n          }\n\n          if ((0 == iter % 4) && byteBlockAllocator.freeByteBlocks.size() > 0) {\n            byteBlockAllocator.freeByteBlocks.remove(byteBlockAllocator.freeByteBlocks.size()-1);\n            numBytesAlloc -= BYTE_BLOCK_SIZE;\n          }\n\n          if ((1 == iter % 4) && freeCharBlocks.size() > 0) {\n            freeCharBlocks.remove(freeCharBlocks.size()-1);\n            numBytesAlloc -= CHAR_BLOCK_SIZE * CHAR_NUM_BYTE;\n          }\n\n          if ((2 == iter % 4) && freeIntBlocks.size() > 0) {\n            freeIntBlocks.remove(freeIntBlocks.size()-1);\n            numBytesAlloc -= INT_BLOCK_SIZE * INT_NUM_BYTE;\n          }\n        }\n\n        if ((3 == iter % 4) && any)\n          // Ask consumer to free any recycled state\n          any = consumer.freeRAM();\n\n        iter++;\n      }\n\n      if (infoStream != null)\n        message(\"    after free: freedMB=\" + nf.format((startBytesAlloc-numBytesAlloc-deletesRAMUsed)/1024./1024.) + \" usedMB=\" + nf.format((numBytesUsed+deletesRAMUsed)/1024./1024.) + \" allocMB=\" + nf.format(numBytesAlloc/1024./1024.));\n      \n    } else {\n      // If we have not crossed the 100% mark, but have\n      // crossed the 95% mark of RAM we are actually\n      // using, go ahead and flush.  This prevents\n      // over-allocating and then freeing, with every\n      // flush.\n      synchronized(this) {\n\n        if (numBytesUsed+deletesRAMUsed > flushTrigger) {\n          if (infoStream != null)\n            message(\"  RAM: now flush @ usedMB=\" + nf.format(numBytesUsed/1024./1024.) +\n                    \" allocMB=\" + nf.format(numBytesAlloc/1024./1024.) +\n                    \" deletesMB=\" + nf.format(deletesRAMUsed/1024./1024.) +\n                    \" triggerMB=\" + nf.format(flushTrigger/1024./1024.));\n\n          bufferIsFull = true;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /* We have three pools of RAM: Postings, byte blocks\n   * (holds freq/prox posting data) and char blocks (holds\n   * characters in the term).  Different docs require\n   * varying amount of storage from these three classes.\n   * For example, docs with many unique single-occurrence\n   * short terms will use up the Postings RAM and hardly any\n   * of the other two.  Whereas docs with very large terms\n   * will use alot of char blocks RAM and relatively less of\n   * the other two.  This method just frees allocations from\n   * the pools once we are over-budget, which balances the\n   * pools to match the current docs. */\n  void balanceRAM() {\n\n    // We flush when we've used our target usage\n    final long flushTrigger = ramBufferSize;\n\n    final long deletesRAMUsed = deletesInRAM.bytesUsed+deletesFlushed.bytesUsed;\n\n    if (numBytesAlloc+deletesRAMUsed > freeTrigger) {\n\n      if (infoStream != null)\n        message(\"  RAM: now balance allocations: usedMB=\" + toMB(numBytesUsed) +\n                \" vs trigger=\" + toMB(flushTrigger) +\n                \" allocMB=\" + toMB(numBytesAlloc) +\n                \" deletesMB=\" + toMB(deletesRAMUsed) +\n                \" vs trigger=\" + toMB(freeTrigger) +\n                \" byteBlockFree=\" + toMB(byteBlockAllocator.freeByteBlocks.size()*BYTE_BLOCK_SIZE) +\n                \" charBlockFree=\" + toMB(freeCharBlocks.size()*CHAR_BLOCK_SIZE*CHAR_NUM_BYTE));\n\n      final long startBytesAlloc = numBytesAlloc + deletesRAMUsed;\n\n      int iter = 0;\n\n      // We free equally from each pool in 32 KB\n      // chunks until we are below our threshold\n      // (freeLevel)\n\n      boolean any = true;\n\n      while(numBytesAlloc+deletesRAMUsed > freeLevel) {\n      \n        synchronized(this) {\n          if (0 == byteBlockAllocator.freeByteBlocks.size() && 0 == freeCharBlocks.size() && 0 == freeIntBlocks.size() && !any) {\n            // Nothing else to free -- must flush now.\n            bufferIsFull = numBytesUsed+deletesRAMUsed > flushTrigger;\n            if (infoStream != null) {\n              if (numBytesUsed > flushTrigger)\n                message(\"    nothing to free; now set bufferIsFull\");\n              else\n                message(\"    nothing to free\");\n            }\n            assert numBytesUsed <= numBytesAlloc;\n            break;\n          }\n\n          if ((0 == iter % 4) && byteBlockAllocator.freeByteBlocks.size() > 0) {\n            byteBlockAllocator.freeByteBlocks.remove(byteBlockAllocator.freeByteBlocks.size()-1);\n            numBytesAlloc -= BYTE_BLOCK_SIZE;\n          }\n\n          if ((1 == iter % 4) && freeCharBlocks.size() > 0) {\n            freeCharBlocks.remove(freeCharBlocks.size()-1);\n            numBytesAlloc -= CHAR_BLOCK_SIZE * CHAR_NUM_BYTE;\n          }\n\n          if ((2 == iter % 4) && freeIntBlocks.size() > 0) {\n            freeIntBlocks.remove(freeIntBlocks.size()-1);\n            numBytesAlloc -= INT_BLOCK_SIZE * INT_NUM_BYTE;\n          }\n        }\n\n        if ((3 == iter % 4) && any)\n          // Ask consumer to free any recycled state\n          any = consumer.freeRAM();\n\n        iter++;\n      }\n\n      if (infoStream != null)\n        message(\"    after free: freedMB=\" + nf.format((startBytesAlloc-numBytesAlloc-deletesRAMUsed)/1024./1024.) + \" usedMB=\" + nf.format((numBytesUsed+deletesRAMUsed)/1024./1024.) + \" allocMB=\" + nf.format(numBytesAlloc/1024./1024.));\n      \n    } else {\n      // If we have not crossed the 100% mark, but have\n      // crossed the 95% mark of RAM we are actually\n      // using, go ahead and flush.  This prevents\n      // over-allocating and then freeing, with every\n      // flush.\n      synchronized(this) {\n\n        if (numBytesUsed+deletesRAMUsed > flushTrigger) {\n          if (infoStream != null)\n            message(\"  RAM: now flush @ usedMB=\" + nf.format(numBytesUsed/1024./1024.) +\n                    \" allocMB=\" + nf.format(numBytesAlloc/1024./1024.) +\n                    \" deletesMB=\" + nf.format(deletesRAMUsed/1024./1024.) +\n                    \" triggerMB=\" + nf.format(flushTrigger/1024./1024.));\n\n          bufferIsFull = true;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90eca6fcb6635ca73ea4fdbe2f57d2033b66d3b6","date":1272983566,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/backwards/src/java/org/apache/lucene/index/DocumentsWriter#balanceRAM().mjava","sourceNew":null,"sourceOld":"  /* We have three pools of RAM: Postings, byte blocks\n   * (holds freq/prox posting data) and char blocks (holds\n   * characters in the term).  Different docs require\n   * varying amount of storage from these three classes.\n   * For example, docs with many unique single-occurrence\n   * short terms will use up the Postings RAM and hardly any\n   * of the other two.  Whereas docs with very large terms\n   * will use alot of char blocks RAM and relatively less of\n   * the other two.  This method just frees allocations from\n   * the pools once we are over-budget, which balances the\n   * pools to match the current docs. */\n  void balanceRAM() {\n\n    // We flush when we've used our target usage\n    final long flushTrigger = ramBufferSize;\n\n    final long deletesRAMUsed = deletesInRAM.bytesUsed+deletesFlushed.bytesUsed;\n\n    if (numBytesAlloc+deletesRAMUsed > freeTrigger) {\n\n      if (infoStream != null)\n        message(\"  RAM: now balance allocations: usedMB=\" + toMB(numBytesUsed) +\n                \" vs trigger=\" + toMB(flushTrigger) +\n                \" allocMB=\" + toMB(numBytesAlloc) +\n                \" deletesMB=\" + toMB(deletesRAMUsed) +\n                \" vs trigger=\" + toMB(freeTrigger) +\n                \" byteBlockFree=\" + toMB(byteBlockAllocator.freeByteBlocks.size()*BYTE_BLOCK_SIZE) +\n                \" charBlockFree=\" + toMB(freeCharBlocks.size()*CHAR_BLOCK_SIZE*CHAR_NUM_BYTE));\n\n      final long startBytesAlloc = numBytesAlloc + deletesRAMUsed;\n\n      int iter = 0;\n\n      // We free equally from each pool in 32 KB\n      // chunks until we are below our threshold\n      // (freeLevel)\n\n      boolean any = true;\n\n      while(numBytesAlloc+deletesRAMUsed > freeLevel) {\n      \n        synchronized(this) {\n          if (0 == byteBlockAllocator.freeByteBlocks.size() && 0 == freeCharBlocks.size() && 0 == freeIntBlocks.size() && !any) {\n            // Nothing else to free -- must flush now.\n            bufferIsFull = numBytesUsed+deletesRAMUsed > flushTrigger;\n            if (infoStream != null) {\n              if (numBytesUsed > flushTrigger)\n                message(\"    nothing to free; now set bufferIsFull\");\n              else\n                message(\"    nothing to free\");\n            }\n            assert numBytesUsed <= numBytesAlloc;\n            break;\n          }\n\n          if ((0 == iter % 4) && byteBlockAllocator.freeByteBlocks.size() > 0) {\n            byteBlockAllocator.freeByteBlocks.remove(byteBlockAllocator.freeByteBlocks.size()-1);\n            numBytesAlloc -= BYTE_BLOCK_SIZE;\n          }\n\n          if ((1 == iter % 4) && freeCharBlocks.size() > 0) {\n            freeCharBlocks.remove(freeCharBlocks.size()-1);\n            numBytesAlloc -= CHAR_BLOCK_SIZE * CHAR_NUM_BYTE;\n          }\n\n          if ((2 == iter % 4) && freeIntBlocks.size() > 0) {\n            freeIntBlocks.remove(freeIntBlocks.size()-1);\n            numBytesAlloc -= INT_BLOCK_SIZE * INT_NUM_BYTE;\n          }\n        }\n\n        if ((3 == iter % 4) && any)\n          // Ask consumer to free any recycled state\n          any = consumer.freeRAM();\n\n        iter++;\n      }\n\n      if (infoStream != null)\n        message(\"    after free: freedMB=\" + nf.format((startBytesAlloc-numBytesAlloc-deletesRAMUsed)/1024./1024.) + \" usedMB=\" + nf.format((numBytesUsed+deletesRAMUsed)/1024./1024.) + \" allocMB=\" + nf.format(numBytesAlloc/1024./1024.));\n      \n    } else {\n      // If we have not crossed the 100% mark, but have\n      // crossed the 95% mark of RAM we are actually\n      // using, go ahead and flush.  This prevents\n      // over-allocating and then freeing, with every\n      // flush.\n      synchronized(this) {\n\n        if (numBytesUsed+deletesRAMUsed > flushTrigger) {\n          if (infoStream != null)\n            message(\"  RAM: now flush @ usedMB=\" + nf.format(numBytesUsed/1024./1024.) +\n                    \" allocMB=\" + nf.format(numBytesAlloc/1024./1024.) +\n                    \" deletesMB=\" + nf.format(deletesRAMUsed/1024./1024.) +\n                    \" triggerMB=\" + nf.format(flushTrigger/1024./1024.));\n\n          bufferIsFull = true;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"90eca6fcb6635ca73ea4fdbe2f57d2033b66d3b6":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["90eca6fcb6635ca73ea4fdbe2f57d2033b66d3b6"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"90eca6fcb6635ca73ea4fdbe2f57d2033b66d3b6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["90eca6fcb6635ca73ea4fdbe2f57d2033b66d3b6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}