{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDeleteById(DeleteUpdateCommand).mjava","commits":[{"id":"615bf5b56d95ed8c9bf06a402db6c817d6bff21a","date":1509492118,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDeleteById(DeleteUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  // Implementing min_rf here was a bit tricky. When a request comes in for a delete by id to a replica that does _not_\n  // have any documents specified by those IDs, the request is not forwarded to any other replicas on that shard. Thus\n  // we have to spoof the replicationTracker and set the achieved rf to the number of active replicas.\n  //\n  private void doDeleteById(DeleteUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null, cmd.getRoute());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    // check if client has requested minimum replication factor information. will set replicationTracker to null if\n    // we aren't the leader or subShardLeader\n    checkReplicationTracker(cmd);\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true, null, null);\n      }\n\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, cloudDesc.getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, nodesByRoutingRules, params, true, null, null);\n      }\n    }\n\n    if (nodes != null) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      if (req.getParams().get(UpdateRequest.MIN_REPFACT) != null) {\n        params.add(UpdateRequest.MIN_REPFACT, req.getParams().get(UpdateRequest.MIN_REPFACT));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params, false, rollupReplicationTracker, leaderReplicationTracker);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<>(1);\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad55ff45b3a5483090d87a63019d0e6a8d4b5a65","date":1509551229,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDeleteById(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDeleteById(DeleteUpdateCommand).mjava","sourceNew":"  // Implementing min_rf here was a bit tricky. When a request comes in for a delete by id to a replica that does _not_\n  // have any documents specified by those IDs, the request is not forwarded to any other replicas on that shard. Thus\n  // we have to spoof the replicationTracker and set the achieved rf to the number of active replicas.\n  //\n  private void doDeleteById(DeleteUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null, cmd.getRoute());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    // check if client has requested minimum replication factor information. will set replicationTracker to null if\n    // we aren't the leader or subShardLeader\n    checkReplicationTracker(cmd);\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true, null, null);\n      }\n\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, collection);\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, nodesByRoutingRules, params, true, null, null);\n      }\n    }\n\n    if (nodes != null) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      if (req.getParams().get(UpdateRequest.MIN_REPFACT) != null) {\n        params.add(UpdateRequest.MIN_REPFACT, req.getParams().get(UpdateRequest.MIN_REPFACT));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params, false, rollupReplicationTracker, leaderReplicationTracker);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<>(1);\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  // Implementing min_rf here was a bit tricky. When a request comes in for a delete by id to a replica that does _not_\n  // have any documents specified by those IDs, the request is not forwarded to any other replicas on that shard. Thus\n  // we have to spoof the replicationTracker and set the achieved rf to the number of active replicas.\n  //\n  private void doDeleteById(DeleteUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null, cmd.getRoute());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    // check if client has requested minimum replication factor information. will set replicationTracker to null if\n    // we aren't the leader or subShardLeader\n    checkReplicationTracker(cmd);\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true, null, null);\n      }\n\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, cloudDesc.getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, nodesByRoutingRules, params, true, null, null);\n      }\n    }\n\n    if (nodes != null) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      if (req.getParams().get(UpdateRequest.MIN_REPFACT) != null) {\n        params.add(UpdateRequest.MIN_REPFACT, req.getParams().get(UpdateRequest.MIN_REPFACT));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params, false, rollupReplicationTracker, leaderReplicationTracker);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<>(1);\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43f5f8344e80b4bfb2069917069430266753d2f0","date":1538584815,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDeleteById(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDeleteById(DeleteUpdateCommand).mjava","sourceNew":"  // Implementing min_rf here was a bit tricky. When a request comes in for a delete by id to a replica that does _not_\n  // have any documents specified by those IDs, the request is not forwarded to any other replicas on that shard. Thus\n  // we have to spoof the replicationTracker and set the achieved rf to the number of active replicas.\n  //\n  private void doDeleteById(DeleteUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null, cmd.getRoute());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    // check if client has requested minimum replication factor information. will set replicationTracker to null if\n    // we aren't the leader or subShardLeader\n    checkReplicationTracker(cmd);\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true, null, null);\n      }\n\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, collection);\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, nodesByRoutingRules, params, true, null, null);\n      }\n    }\n\n    if (nodes != null) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      if (req.getParams().get(UpdateRequest.MIN_REPFACT) != null) {\n        // TODO: Kept for rolling upgrades only. Remove in Solr 9\n        params.add(UpdateRequest.MIN_REPFACT, req.getParams().get(UpdateRequest.MIN_REPFACT));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params, false, rollupReplicationTracker, leaderReplicationTracker);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<>(1);\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  // Implementing min_rf here was a bit tricky. When a request comes in for a delete by id to a replica that does _not_\n  // have any documents specified by those IDs, the request is not forwarded to any other replicas on that shard. Thus\n  // we have to spoof the replicationTracker and set the achieved rf to the number of active replicas.\n  //\n  private void doDeleteById(DeleteUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null, cmd.getRoute());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    // check if client has requested minimum replication factor information. will set replicationTracker to null if\n    // we aren't the leader or subShardLeader\n    checkReplicationTracker(cmd);\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true, null, null);\n      }\n\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, collection);\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, nodesByRoutingRules, params, true, null, null);\n      }\n    }\n\n    if (nodes != null) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      if (req.getParams().get(UpdateRequest.MIN_REPFACT) != null) {\n        params.add(UpdateRequest.MIN_REPFACT, req.getParams().get(UpdateRequest.MIN_REPFACT));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params, false, rollupReplicationTracker, leaderReplicationTracker);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<>(1);\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d70e774cb25c8a8d2c3e5e84200f235f9168d87","date":1553016391,"type":3,"author":"Bar Rotstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDeleteById(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDeleteById(DeleteUpdateCommand).mjava","sourceNew":"  // Implementing min_rf here was a bit tricky. When a request comes in for a delete by id to a replica that does _not_\n  // have any documents specified by those IDs, the request is not forwarded to any other replicas on that shard. Thus\n  // we have to spoof the replicationTracker and set the achieved rf to the number of active replicas.\n  //\n  protected void doDeleteById(DeleteUpdateCommand cmd) throws IOException {\n\n    setupRequest(cmd);\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    doDistribDeleteById(cmd);\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<>(1);\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","sourceOld":"  // Implementing min_rf here was a bit tricky. When a request comes in for a delete by id to a replica that does _not_\n  // have any documents specified by those IDs, the request is not forwarded to any other replicas on that shard. Thus\n  // we have to spoof the replicationTracker and set the achieved rf to the number of active replicas.\n  //\n  private void doDeleteById(DeleteUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getId(), null, cmd.getRoute());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    // check if client has requested minimum replication factor information. will set replicationTracker to null if\n    // we aren't the leader or subShardLeader\n    checkReplicationTracker(cmd);\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getId(), null);\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, subShardLeaders, params, true, null, null);\n      }\n\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getId(), null);\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, collection);\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribDelete(cmd, nodesByRoutingRules, params, true, null, null);\n      }\n    }\n\n    if (nodes != null) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ? DistribPhase.FROMLEADER.toString()\n              : DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      if (req.getParams().get(UpdateRequest.MIN_REPFACT) != null) {\n        // TODO: Kept for rolling upgrades only. Remove in Solr 9\n        params.add(UpdateRequest.MIN_REPFACT, req.getParams().get(UpdateRequest.MIN_REPFACT));\n      }\n      cmdDistrib.distribDelete(cmd, nodes, params, false, rollupReplicationTracker, leaderReplicationTracker);\n    }\n\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<>(1);\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"43f5f8344e80b4bfb2069917069430266753d2f0":["ad55ff45b3a5483090d87a63019d0e6a8d4b5a65"],"ad55ff45b3a5483090d87a63019d0e6a8d4b5a65":["615bf5b56d95ed8c9bf06a402db6c817d6bff21a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"615bf5b56d95ed8c9bf06a402db6c817d6bff21a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["43f5f8344e80b4bfb2069917069430266753d2f0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"]},"commit2Childs":{"43f5f8344e80b4bfb2069917069430266753d2f0":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"ad55ff45b3a5483090d87a63019d0e6a8d4b5a65":["43f5f8344e80b4bfb2069917069430266753d2f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["615bf5b56d95ed8c9bf06a402db6c817d6bff21a"],"615bf5b56d95ed8c9bf06a402db6c817d6bff21a":["ad55ff45b3a5483090d87a63019d0e6a8d4b5a65"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}