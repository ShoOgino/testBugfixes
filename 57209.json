{"path":"solr/core/src/java/org/apache/solr/pkg/PackageAPI.Edit#add(PayloadObj[Package.AddVersion]).mjava","commits":[{"id":"9fbcc7055e8c549bce2c868275542860dba71a0e","date":1593065764,"type":1,"author":"noble","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/pkg/PackageAPI.Edit#add(PayloadObj[Package.AddVersion]).mjava","pathOld":"solr/core/src/java/org/apache/solr/pkg/PackageAPI.Edit#add(SolrQueryRequest,SolrQueryResponse,PayloadObj[Package.AddVersion]).mjava","sourceNew":"    @Command(name = \"add\")\n    @SuppressWarnings({\"unchecked\"})\n    public void add(PayloadObj<Package.AddVersion> payload) {\n      if (!checkEnabled(payload)) return;\n      Package.AddVersion add = payload.get();\n      if (add.files.isEmpty()) {\n        payload.addError(\"No files specified\");\n        return;\n      }\n      PackageStoreAPI packageStoreAPI = coreContainer.getPackageStoreAPI();\n      packageStoreAPI.validateFiles(add.files, true, s -> payload.addError(s));\n      if (payload.hasError()) return;\n      Packages[] finalState = new Packages[1];\n      try {\n        coreContainer.getZkController().getZkClient().atomicUpdate(SOLR_PKGS_PATH, (stat, bytes) -> {\n          Packages packages = null;\n          try {\n            packages = bytes == null ? new Packages() : mapper.readValue(bytes, Packages.class);\n            packages = packages.copy();\n          } catch (IOException e) {\n            log.error(\"Error deserializing packages.json\", e);\n            packages = new Packages();\n          }\n          @SuppressWarnings({\"rawtypes\"})\n          List list = packages.packages.computeIfAbsent(add.pkg, Utils.NEW_ARRAYLIST_FUN);\n          for (Object o : list) {\n            if (o instanceof PkgVersion) {\n              PkgVersion version = (PkgVersion) o;\n              if (Objects.equals(version.version, add.version)) {\n                payload.addError(\"Version '\" + add.version + \"' exists already\");\n                return null;\n              }\n            }\n          }\n          list.add(new PkgVersion(add));\n          packages.znodeVersion = stat.getVersion() + 1;\n          finalState[0] = packages;\n          return Utils.toJSON(packages);\n        });\n      } catch (KeeperException | InterruptedException e) {\n        finalState[0] = null;\n        handleZkErr(e);\n      }\n      if (finalState[0] != null) {\n//        succeeded in updating\n        pkgs = finalState[0];\n        notifyAllNodesToSync(pkgs.znodeVersion);\n        packageLoader.refreshPackageConf();\n      }\n\n    }\n\n","sourceOld":"    @Command(name = \"add\")\n    @SuppressWarnings({\"unchecked\"})\n    public void add(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<Package.AddVersion> payload) {\n      if (!checkEnabled(payload)) return;\n      Package.AddVersion add = payload.get();\n      if (add.files.isEmpty()) {\n        payload.addError(\"No files specified\");\n        return;\n      }\n      PackageStoreAPI packageStoreAPI = coreContainer.getPackageStoreAPI();\n      packageStoreAPI.validateFiles(add.files, true, s -> payload.addError(s));\n      if (payload.hasError()) return;\n      Packages[] finalState = new Packages[1];\n      try {\n        coreContainer.getZkController().getZkClient().atomicUpdate(SOLR_PKGS_PATH, (stat, bytes) -> {\n          Packages packages = null;\n          try {\n            packages = bytes == null ? new Packages() : mapper.readValue(bytes, Packages.class);\n            packages = packages.copy();\n          } catch (IOException e) {\n            log.error(\"Error deserializing packages.json\", e);\n            packages = new Packages();\n          }\n          @SuppressWarnings({\"rawtypes\"})\n          List list = packages.packages.computeIfAbsent(add.pkg, Utils.NEW_ARRAYLIST_FUN);\n          for (Object o : list) {\n            if (o instanceof PkgVersion) {\n              PkgVersion version = (PkgVersion) o;\n              if (Objects.equals(version.version, add.version)) {\n                payload.addError(\"Version '\" + add.version + \"' exists already\");\n                return null;\n              }\n            }\n          }\n          list.add(new PkgVersion(add));\n          packages.znodeVersion = stat.getVersion() + 1;\n          finalState[0] = packages;\n          return Utils.toJSON(packages);\n        });\n      } catch (KeeperException | InterruptedException e) {\n        finalState[0] = null;\n        handleZkErr(e);\n      }\n      if (finalState[0] != null) {\n//        succeeded in updating\n        pkgs = finalState[0];\n        notifyAllNodesToSync(pkgs.znodeVersion);\n        packageLoader.refreshPackageConf();\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5143a137c6366836cdc47feaad23a1f86ba50c3b","date":1599311985,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/pkg/PackageAPI.Edit#add(PayloadObj[Package.AddVersion]).mjava","pathOld":"solr/core/src/java/org/apache/solr/pkg/PackageAPI.Edit#add(PayloadObj[Package.AddVersion]).mjava","sourceNew":"    @Command(name = \"add\")\n    @SuppressWarnings({\"unchecked\"})\n    public void add(PayloadObj<Package.AddVersion> payload) {\n      if (!checkEnabled(payload)) return;\n      Package.AddVersion add = payload.get();\n      if (add.files.isEmpty()) {\n        payload.addError(\"No files specified\");\n        return;\n      }\n      PackageStoreAPI packageStoreAPI = coreContainer.getPackageStoreAPI();\n      packageStoreAPI.validateFiles(add.files, true, s -> payload.addError(s));\n      if (payload.hasError()) return;\n      Packages[] finalState = new Packages[1];\n      try {\n        coreContainer.getZkController().getZkClient().atomicUpdate(SOLR_PKGS_PATH, (stat, bytes) -> {\n          Packages packages = null;\n          try {\n            packages = bytes == null ? new Packages() : mapper.readValue(bytes, Packages.class);\n            packages = packages.copy();\n          } catch (IOException e) {\n            log.error(\"Error deserializing packages.json\", e);\n            packages = new Packages();\n          }\n          List<PkgVersion> list = packages.packages.computeIfAbsent(add.pkg, o -> new ArrayList<>());\n          for (PkgVersion version : list) {\n            if (Objects.equals(version.version, add.version)) {\n              payload.addError(\"Version '\" + add.version + \"' exists already\");\n              return null;\n            }\n          }\n          list.add(new PkgVersion(add));\n          packages.znodeVersion = stat.getVersion() + 1;\n          finalState[0] = packages;\n          return Utils.toJSON(packages);\n        });\n      } catch (KeeperException | InterruptedException e) {\n        finalState[0] = null;\n        handleZkErr(e);\n      }\n      if (finalState[0] != null) {\n//        succeeded in updating\n        pkgs = finalState[0];\n        notifyAllNodesToSync(pkgs.znodeVersion);\n        packageLoader.refreshPackageConf();\n      }\n\n    }\n\n","sourceOld":"    @Command(name = \"add\")\n    @SuppressWarnings({\"unchecked\"})\n    public void add(PayloadObj<Package.AddVersion> payload) {\n      if (!checkEnabled(payload)) return;\n      Package.AddVersion add = payload.get();\n      if (add.files.isEmpty()) {\n        payload.addError(\"No files specified\");\n        return;\n      }\n      PackageStoreAPI packageStoreAPI = coreContainer.getPackageStoreAPI();\n      packageStoreAPI.validateFiles(add.files, true, s -> payload.addError(s));\n      if (payload.hasError()) return;\n      Packages[] finalState = new Packages[1];\n      try {\n        coreContainer.getZkController().getZkClient().atomicUpdate(SOLR_PKGS_PATH, (stat, bytes) -> {\n          Packages packages = null;\n          try {\n            packages = bytes == null ? new Packages() : mapper.readValue(bytes, Packages.class);\n            packages = packages.copy();\n          } catch (IOException e) {\n            log.error(\"Error deserializing packages.json\", e);\n            packages = new Packages();\n          }\n          @SuppressWarnings({\"rawtypes\"})\n          List list = packages.packages.computeIfAbsent(add.pkg, Utils.NEW_ARRAYLIST_FUN);\n          for (Object o : list) {\n            if (o instanceof PkgVersion) {\n              PkgVersion version = (PkgVersion) o;\n              if (Objects.equals(version.version, add.version)) {\n                payload.addError(\"Version '\" + add.version + \"' exists already\");\n                return null;\n              }\n            }\n          }\n          list.add(new PkgVersion(add));\n          packages.znodeVersion = stat.getVersion() + 1;\n          finalState[0] = packages;\n          return Utils.toJSON(packages);\n        });\n      } catch (KeeperException | InterruptedException e) {\n        finalState[0] = null;\n        handleZkErr(e);\n      }\n      if (finalState[0] != null) {\n//        succeeded in updating\n        pkgs = finalState[0];\n        notifyAllNodesToSync(pkgs.znodeVersion);\n        packageLoader.refreshPackageConf();\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9fbcc7055e8c549bce2c868275542860dba71a0e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5143a137c6366836cdc47feaad23a1f86ba50c3b":["9fbcc7055e8c549bce2c868275542860dba71a0e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5143a137c6366836cdc47feaad23a1f86ba50c3b"]},"commit2Childs":{"9fbcc7055e8c549bce2c868275542860dba71a0e":["5143a137c6366836cdc47feaad23a1f86ba50c3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9fbcc7055e8c549bce2c868275542860dba71a0e"],"5143a137c6366836cdc47feaad23a1f86ba50c3b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}