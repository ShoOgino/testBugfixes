{"path":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader();\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader();\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader();\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader();\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe31ae3a69266f8acd2d1c341b4f285ee7f5c574","date":1350477646,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader();\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader();\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"db4fdbf3d262768eabc027cd8321edca0cd11fa8","date":1350574784,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader();\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader();\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"081b68cb9e8f4b5405b40bfb223fd7c587171aa1","date":1360072766,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader();\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":["eb9ee9de2835c3956662372b9e2407fe0e0fb731","203cbba17e28e65424501a76bf0ff5471c8eef06"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e4d4ec39bf5396230748ca859ff05ab024b6fc5","date":1360112310,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader();\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f077558a20149ff0f23405cbae03daeb5aa5a29d","date":1415893048,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aeebe27bce18b879b80f68494c52cda1021b5705","date":1417792137,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2713584a660051cd646423be682771e3bbd99985","date":1425046322,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4388b311bcdd7863e5e3c63404688e60d8e14fe","date":1434124772,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), terms);\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), terms);\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), terms);\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1db68e96dd908fcd79ef809095822736aa601d08","date":1434630596,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), terms);\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), terms);\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4db7976c38cb8d2fbd54bae4fa5ec4b0f0d5c789","date":1439672757,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), terms);\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), terms);\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2dfdf766e55e943d942055d7de53c7ad6bc45283","date":1441632886,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,float,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, float boost, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BoostQuery) {\n      BoostQuery boostQuery = (BoostQuery) query;\n      extract(boostQuery.getQuery(), boost * boostQuery.getBoost(), terms);\n    } else if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), boost, terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      extractWeightedSpanTerms(terms, sp, boost);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query, boost);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, boost, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query, boost);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), boost, terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), boost, terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), boost, terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        extractWeightedSpanTerms(terms, sp, boost);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), boost, terms);\n    } else {\n      Query origQuery = query;\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        rewritten = MultiTermQuery.SCORING_BOOLEAN_REWRITE.rewrite(reader, (MultiTermQuery) query);\n      } else {\n        rewritten = origQuery.rewrite(reader);\n      }\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, boost, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with {@link WeightedSpanTerm}s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException If there is a low-level I/O error\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          extract(clause.getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof ConstantScoreQuery) {\n      final Query q = ((ConstantScoreQuery) query).getQuery();\n      if (q != null) {\n        extract(q, terms);\n      }\n    } else if (query instanceof CommonTermsQuery) {\n      // specialized since rewriting would change the result query \n      // this query is TermContext sensitive.\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof ToParentBlockJoinQuery) {\n      extract(((ToParentBlockJoinQuery) query).getChildQuery(), terms);\n    } else if (query instanceof ToChildBlockJoinQuery) {\n      extract(((ToChildBlockJoinQuery) query).getParentQuery(), terms);\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    } else if (query instanceof MatchAllDocsQuery) {\n      //nothing\n    } else if (query instanceof CustomScoreQuery){\n      extract(((CustomScoreQuery) query).getSubQuery(), terms);\n    } else {\n      Query origQuery = query;\n      if (query instanceof MultiTermQuery) {\n        if (!expandMultiTermQuery) {\n          return;\n        }\n        MultiTermQuery copy = (MultiTermQuery) query.clone();\n        copy.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        origQuery = copy;\n      }\n      final IndexReader reader = getLeafContext().reader();\n      Query rewritten = origQuery.rewrite(reader);\n      if (rewritten != origQuery) {\n        // only rewrite once and then flatten again - the rewritten query could have a speacial treatment\n        // if this method is overwritten in a subclass or above in the next recursion\n        extract(rewritten, terms);\n      } \n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":["7b0d0cdee6b728fdf8a8cf5bec3320bb7f67fa16","cb2eac46a4023564c3d2b41ec4bc90eb48e61154"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"b1eb427f2c6beed80d1724555fc1db003ccf3030":["f077558a20149ff0f23405cbae03daeb5aa5a29d"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["081b68cb9e8f4b5405b40bfb223fd7c587171aa1"],"2713584a660051cd646423be682771e3bbd99985":["aeebe27bce18b879b80f68494c52cda1021b5705"],"3e4d4ec39bf5396230748ca859ff05ab024b6fc5":["fe31ae3a69266f8acd2d1c341b4f285ee7f5c574","081b68cb9e8f4b5405b40bfb223fd7c587171aa1"],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["4db7976c38cb8d2fbd54bae4fa5ec4b0f0d5c789"],"db4fdbf3d262768eabc027cd8321edca0cd11fa8":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","fe31ae3a69266f8acd2d1c341b4f285ee7f5c574"],"f077558a20149ff0f23405cbae03daeb5aa5a29d":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"fe31ae3a69266f8acd2d1c341b4f285ee7f5c574":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"a4388b311bcdd7863e5e3c63404688e60d8e14fe":["2713584a660051cd646423be682771e3bbd99985"],"aeebe27bce18b879b80f68494c52cda1021b5705":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["a4388b311bcdd7863e5e3c63404688e60d8e14fe"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["aeebe27bce18b879b80f68494c52cda1021b5705","2713584a660051cd646423be682771e3bbd99985"],"1db68e96dd908fcd79ef809095822736aa601d08":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"081b68cb9e8f4b5405b40bfb223fd7c587171aa1":["fe31ae3a69266f8acd2d1c341b4f285ee7f5c574"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4db7976c38cb8d2fbd54bae4fa5ec4b0f0d5c789":["1db68e96dd908fcd79ef809095822736aa601d08"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2dfdf766e55e943d942055d7de53c7ad6bc45283"]},"commit2Childs":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["db4fdbf3d262768eabc027cd8321edca0cd11fa8","fe31ae3a69266f8acd2d1c341b4f285ee7f5c574"],"b1eb427f2c6beed80d1724555fc1db003ccf3030":["aeebe27bce18b879b80f68494c52cda1021b5705"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["f077558a20149ff0f23405cbae03daeb5aa5a29d"],"2713584a660051cd646423be682771e3bbd99985":["a4388b311bcdd7863e5e3c63404688e60d8e14fe","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"3e4d4ec39bf5396230748ca859ff05ab024b6fc5":[],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"db4fdbf3d262768eabc027cd8321edca0cd11fa8":[],"f077558a20149ff0f23405cbae03daeb5aa5a29d":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"fe31ae3a69266f8acd2d1c341b4f285ee7f5c574":["3e4d4ec39bf5396230748ca859ff05ab024b6fc5","db4fdbf3d262768eabc027cd8321edca0cd11fa8","081b68cb9e8f4b5405b40bfb223fd7c587171aa1"],"a4388b311bcdd7863e5e3c63404688e60d8e14fe":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"aeebe27bce18b879b80f68494c52cda1021b5705":["2713584a660051cd646423be682771e3bbd99985","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["1db68e96dd908fcd79ef809095822736aa601d08"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"081b68cb9e8f4b5405b40bfb223fd7c587171aa1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","3e4d4ec39bf5396230748ca859ff05ab024b6fc5"],"1db68e96dd908fcd79ef809095822736aa601d08":["4db7976c38cb8d2fbd54bae4fa5ec4b0f0d5c789"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"4db7976c38cb8d2fbd54bae4fa5ec4b0f0d5c789":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3e4d4ec39bf5396230748ca859ff05ab024b6fc5","db4fdbf3d262768eabc027cd8321edca0cd11fa8","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}