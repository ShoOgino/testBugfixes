{"path":"lucene/facet/src/java/org/apache/lucene/facet/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(IndexReader,String).mjava","commits":[{"id":"21d36d0db865f7b84026b447bec653469a6e66df","date":1385495602,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(IndexReader,String).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/simple/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(IndexReader,String).mjava","sourceNew":"  /** Create an instance, scanning the {@link\n   *  SortedSetDocValues} from the provided reader, with\n   *  default {@link FacetIndexingParams}. */\n  public SortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = FacetsConfig.stringToPath(spare.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":"  /** Create an instance, scanning the {@link\n   *  SortedSetDocValues} from the provided reader, with\n   *  default {@link FacetIndexingParams}. */\n  public SortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = FacetsConfig.stringToPath(spare.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6e499df4729e7162d5b39a70b0142e3186a029f","date":1385554050,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(IndexReader,String).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(IndexReader,String).mjava","sourceNew":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public SortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = FacetsConfig.stringToPath(spare.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":"  /** Create an instance, scanning the {@link\n   *  SortedSetDocValues} from the provided reader, with\n   *  default {@link FacetIndexingParams}. */\n  public SortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = FacetsConfig.stringToPath(spare.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4edc984f0f4ac77c37e48ace2932f780f888453c","date":1388475218,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(IndexReader,String).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(IndexReader,String).mjava","sourceNew":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public SortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = FacetsConfig.stringToPath(spare.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public SortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = FacetsConfig.stringToPath(spare.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b6e499df4729e7162d5b39a70b0142e3186a029f":["21d36d0db865f7b84026b447bec653469a6e66df"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4edc984f0f4ac77c37e48ace2932f780f888453c":["b6e499df4729e7162d5b39a70b0142e3186a029f"],"21d36d0db865f7b84026b447bec653469a6e66df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"b6e499df4729e7162d5b39a70b0142e3186a029f":["4edc984f0f4ac77c37e48ace2932f780f888453c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["21d36d0db865f7b84026b447bec653469a6e66df","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"21d36d0db865f7b84026b447bec653469a6e66df":["b6e499df4729e7162d5b39a70b0142e3186a029f"],"4edc984f0f4ac77c37e48ace2932f780f888453c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4edc984f0f4ac77c37e48ace2932f780f888453c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}