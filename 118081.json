{"path":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","commits":[{"id":"658a1d7b74c99b3d845fb1f852331a1c4623368e","date":1396631281,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c0e11c85a63a4eb8a3f072df2a1d380b7e48c14","date":1396642661,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c15a75016387504d70a40cba6e9314b8885307f0","date":1397542349,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n         System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof LeafReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n         System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n         System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60596f28be69b10c37a56a303c2dbea07b2ca4ba","date":1425060541,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof LeafReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      ret.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n         System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      ret.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof LeafReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n         System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51a6c45b517e7699dc1e378c609477edb3bc7e7d","date":1425218350,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof LeafReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n         System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      ret.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof LeafReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      ret.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n         System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      ret.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof LeafReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n         System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      ret.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof LeafReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n         System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d211216c83f01894810543d1c107160a9ae3650b","date":1488289605,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof LeafReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (r.getReaderCacheHelper() == null || random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n         System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.getReaderCacheHelper().addClosedListener(cacheKey -> TestUtil.shutdownExecutorService(ex));\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      ret.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof LeafReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n         System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      ret.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb1ea7c2a1a6c0b29808a5562d417545dd5529e4","date":1558462722,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof LeafReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (r.getReaderCacheHelper() == null || random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n         System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.getReaderCacheHelper().addClosedListener(cacheKey -> TestUtil.shutdownExecutorService(ex));\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else if (random.nextBoolean()) {\n        int maxDocPerSlice = 1 + random.nextInt(100000);\n        int maxSegmentsPerSlice = 1 + random.nextInt(20);\n        ret = new IndexSearcher(r, ex) {\n          @Override\n          protected LeafSlice[] slices(List<LeafReaderContext> leaves) {\n            return slices(leaves, maxDocPerSlice, maxSegmentsPerSlice);\n          }\n        };\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      ret.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders. If\n   * <code>wrapWithAssertions</code> is true, this searcher might be an\n   * {@link AssertingIndexSearcher} instance.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap, boolean wrapWithAssertions) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof LeafReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          Rethrow.rethrow(e);\n        }\n      }\n      final IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      } else {\n        ret = random.nextBoolean() ? new IndexSearcher(r) : new IndexSearcher(r.getContext());\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (r.getReaderCacheHelper() == null || random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n         System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.getReaderCacheHelper().addClosedListener(cacheKey -> TestUtil.shutdownExecutorService(ex));\n      }\n      IndexSearcher ret;\n      if (wrapWithAssertions) {\n        ret = random.nextBoolean()\n            ? new AssertingIndexSearcher(random, r, ex)\n            : new AssertingIndexSearcher(random, r.getContext(), ex);\n      } else {\n        ret = random.nextBoolean()\n            ? new IndexSearcher(r, ex)\n            : new IndexSearcher(r.getContext(), ex);\n      }\n      ret.setSimilarity(classEnvRule.similarity);\n      ret.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"51a6c45b517e7699dc1e378c609477edb3bc7e7d":["60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["c9fb5f46e264daf5ba3860defe623a89d202dd87","51a6c45b517e7699dc1e378c609477edb3bc7e7d"],"60596f28be69b10c37a56a303c2dbea07b2ca4ba":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4c0e11c85a63a4eb8a3f072df2a1d380b7e48c14"],"d211216c83f01894810543d1c107160a9ae3650b":["51a6c45b517e7699dc1e378c609477edb3bc7e7d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cb1ea7c2a1a6c0b29808a5562d417545dd5529e4":["d211216c83f01894810543d1c107160a9ae3650b"],"c15a75016387504d70a40cba6e9314b8885307f0":["4c0e11c85a63a4eb8a3f072df2a1d380b7e48c14"],"4c0e11c85a63a4eb8a3f072df2a1d380b7e48c14":["658a1d7b74c99b3d845fb1f852331a1c4623368e"],"658a1d7b74c99b3d845fb1f852331a1c4623368e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["c15a75016387504d70a40cba6e9314b8885307f0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cb1ea7c2a1a6c0b29808a5562d417545dd5529e4"]},"commit2Childs":{"51a6c45b517e7699dc1e378c609477edb3bc7e7d":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","d211216c83f01894810543d1c107160a9ae3650b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"60596f28be69b10c37a56a303c2dbea07b2ca4ba":["51a6c45b517e7699dc1e378c609477edb3bc7e7d"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","658a1d7b74c99b3d845fb1f852331a1c4623368e"],"d211216c83f01894810543d1c107160a9ae3650b":["cb1ea7c2a1a6c0b29808a5562d417545dd5529e4"],"cb1ea7c2a1a6c0b29808a5562d417545dd5529e4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c15a75016387504d70a40cba6e9314b8885307f0":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"4c0e11c85a63a4eb8a3f072df2a1d380b7e48c14":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","c15a75016387504d70a40cba6e9314b8885307f0"],"658a1d7b74c99b3d845fb1f852331a1c4623368e":["4c0e11c85a63a4eb8a3f072df2a1d380b7e48c14"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","15e323346eac5e4685c0a9f2df85eb96b4239bbb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}