{"path":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b3a4ab7d2fe963a5a758d16f8bed1b0ce3b9027","date":1328885564,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (cores.isZooKeeperAware() && corename.length() == 0) {\n              core = cores.getCore(\"\");\n            } else if (!cores.isZooKeeperAware()) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, core, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"42adc3dd939782319f2cdf85dc21bdc497297d22","date":1328892177,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, core, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (cores.isZooKeeperAware() && corename.length() == 0) {\n              core = cores.getCore(\"\");\n            } else if (!cores.isZooKeeperAware()) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, core, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30bbdb9dd708c5f7b113e3c7c1ebc06c7453b4e3","date":1329434163,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, core, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d8d46584d4a299aaed53fdd79f1cd77f222aee1e","date":1331071171,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3941895748f08018a2a9b5ac13e5fcadc7e89e0","date":1332737017,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && !(handler instanceof SearchHandler)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's now only supported for SearchHandlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac6a079080790283c4003d11dac815d031a7b23d","date":1333203551,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && !(handler instanceof SearchHandler)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's now only supported for SearchHandlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a8954ce7749d4df8d7288d333126e079af73f12","date":1340166187,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"33d0ed80b7b47e34ad3ff033a77544563aba3085","date":1341244632,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1","date":1346817835,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 403, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7d0565444d6381434fbff66cecf07da249f2bb4","date":1357484111,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0713b289be914e52cc2ec942aeb7306f0593a787","date":1361852996,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          } else {\n            // try the default core\n            core = cores.getCore(\"\");\n          }\n          // TODO: if we couldn't find it locally, look on other nodes\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37","date":1362545433,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1cfa38e36fa296bb93d77df7d5556257dffa4535","date":1362635543,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    doFilter(request, response, chain, false);\n  }\n\n","sourceOld":"  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if (this.cores == null) {\n      ((HttpServletResponse)response).sendError( 503, \"Server is shutting down\" );\n      return;\n    }\n    CoreContainer cores = this.cores;\n    SolrCore core = null;\n    SolrQueryRequest solrReq = null;\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        // Check for the core admin collections url\n        if( path.equals( \"/admin/collections\" ) ) {\n          handler = cores.getCollectionsHandler();\n          solrReq =  SolrRequestParsers.DEFAULT.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            if (!cores.isZooKeeperAware() ) {\n              core = cores.getCore(\"\");\n            }\n          }\n        }\n        \n        if (core == null && cores.isZooKeeperAware()) {\n          // we couldn't find the core - lets make sure a collection was not specified instead\n          core = getCoreByCollection(cores, corename, path);\n          \n          if (core != null) {\n            // we found a core, update the path\n            path = path.substring( idx );\n          }\n          \n          // if we couldn't find it locally, look on other nodes\n          if (core == null && idx > 0) {\n            String coreUrl = getRemotCoreUrl(cores, corename);\n            if (coreUrl != null) {\n              path = path.substring( idx );\n              remoteQuery(coreUrl + path, req, solrReq, resp);\n              return;\n            }\n          }\n          \n          // try the default core\n          if (core == null) {\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Handle /schema/* paths via Restlet\n          if( path.startsWith(\"/schema\") ) {\n            solrReq = parser.parse(core, path, req);\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, new SolrQueryResponse()));\n            if( path.equals(req.getServletPath()) ) {\n              // avoid endless loop - pass through to Restlet via webapp\n              chain.doFilter(request, response);\n            } else {\n              // forward rewritten URI (without path prefix and core/collection name) to Restlet\n              req.getRequestDispatcher(path).forward(request, response);\n            }\n            return;\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n                if( qt != null && qt.startsWith(\"/\") && (handler instanceof ContentStreamHandlerBase)) {\n                  //For security reasons it's a bad idea to allow a leading '/', ex: /select?qt=/update see SOLR-3161\n                  //There was no restriction from Solr 1.4 thru 3.5 and it's not supported for update handlers.\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid Request Handler ('qt').  Do not use /select to access: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( core, solrReq, request, (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1","c7d0565444d6381434fbff66cecf07da249f2bb4"],"c7d0565444d6381434fbff66cecf07da249f2bb4":["7530de27b87b961b51f01bd1299b7004d46e8823"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["30bbdb9dd708c5f7b113e3c7c1ebc06c7453b4e3","d8d46584d4a299aaed53fdd79f1cd77f222aee1e"],"1cfa38e36fa296bb93d77df7d5556257dffa4535":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37"],"7a8954ce7749d4df8d7288d333126e079af73f12":["ac6a079080790283c4003d11dac815d031a7b23d"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1":["33d0ed80b7b47e34ad3ff033a77544563aba3085"],"ac6a079080790283c4003d11dac815d031a7b23d":["e3941895748f08018a2a9b5ac13e5fcadc7e89e0"],"e3941895748f08018a2a9b5ac13e5fcadc7e89e0":["d8d46584d4a299aaed53fdd79f1cd77f222aee1e"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"42adc3dd939782319f2cdf85dc21bdc497297d22":["7b3a4ab7d2fe963a5a758d16f8bed1b0ce3b9027"],"d8d46584d4a299aaed53fdd79f1cd77f222aee1e":["30bbdb9dd708c5f7b113e3c7c1ebc06c7453b4e3"],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["7a8954ce7749d4df8d7288d333126e079af73f12"],"0713b289be914e52cc2ec942aeb7306f0593a787":["c7d0565444d6381434fbff66cecf07da249f2bb4"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"30bbdb9dd708c5f7b113e3c7c1ebc06c7453b4e3":["42adc3dd939782319f2cdf85dc21bdc497297d22"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["7a8954ce7749d4df8d7288d333126e079af73f12","33d0ed80b7b47e34ad3ff033a77544563aba3085"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["c26f00b574427b55127e869b935845554afde1fa"],"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37":["0713b289be914e52cc2ec942aeb7306f0593a787"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7b3a4ab7d2fe963a5a758d16f8bed1b0ce3b9027":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1cfa38e36fa296bb93d77df7d5556257dffa4535"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"c7d0565444d6381434fbff66cecf07da249f2bb4":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","0713b289be914e52cc2ec942aeb7306f0593a787"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"1cfa38e36fa296bb93d77df7d5556257dffa4535":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7a8954ce7749d4df8d7288d333126e079af73f12":["33d0ed80b7b47e34ad3ff033a77544563aba3085","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"c26f00b574427b55127e869b935845554afde1fa":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"ac6a079080790283c4003d11dac815d031a7b23d":["7a8954ce7749d4df8d7288d333126e079af73f12"],"e3941895748f08018a2a9b5ac13e5fcadc7e89e0":["ac6a079080790283c4003d11dac815d031a7b23d"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"42adc3dd939782319f2cdf85dc21bdc497297d22":["30bbdb9dd708c5f7b113e3c7c1ebc06c7453b4e3"],"d8d46584d4a299aaed53fdd79f1cd77f222aee1e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","e3941895748f08018a2a9b5ac13e5fcadc7e89e0"],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"0713b289be914e52cc2ec942aeb7306f0593a787":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"30bbdb9dd708c5f7b113e3c7c1ebc06c7453b4e3":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d8d46584d4a299aaed53fdd79f1cd77f222aee1e"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","7b3a4ab7d2fe963a5a758d16f8bed1b0ce3b9027"],"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37":["1cfa38e36fa296bb93d77df7d5556257dffa4535"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"7b3a4ab7d2fe963a5a758d16f8bed1b0ce3b9027":["42adc3dd939782319f2cdf85dc21bdc497297d22"],"7530de27b87b961b51f01bd1299b7004d46e8823":["c7d0565444d6381434fbff66cecf07da249f2bb4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","fe33227f6805edab2036cbb80645cc4e2d1fa424","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}