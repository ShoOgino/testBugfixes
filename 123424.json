{"path":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n    \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n    \tTerm term = new Term(field, token.toString());\n      SuggestWord[] suggestions = checker.suggestSimilar(term, \n          options.count, options.reader, options.onlyMorePopular, accuracy);\n      result.addFrequency(token, options.reader.docFreq(term));\n      for (SuggestWord suggestion : suggestions) {\n        result.add(token, suggestion.string, suggestion.freq);      \t\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n    \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n    \tTerm term = new Term(field, token.toString());\n      SuggestWord[] suggestions = checker.suggestSimilar(term, \n          options.count, options.reader, options.onlyMorePopular, accuracy);\n      result.addFrequency(token, options.reader.docFreq(term));\n      for (SuggestWord suggestion : suggestions) {\n        result.add(token, suggestion.string, suggestion.freq);      \t\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n    \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n    \tTerm term = new Term(field, token.toString());\n      SuggestWord[] suggestions = checker.suggestSimilar(term, \n          options.count, options.reader, options.onlyMorePopular, accuracy);\n      result.addFrequency(token, options.reader.docFreq(term));\n      for (SuggestWord suggestion : suggestions) {\n        result.add(token, suggestion.string, suggestion.freq);      \t\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n    \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n    \tTerm term = new Term(field, token.toString());\n      SuggestWord[] suggestions = checker.suggestSimilar(term, \n          options.count, options.reader, options.onlyMorePopular, accuracy);\n      result.addFrequency(token, options.reader.docFreq(term));\n      for (SuggestWord suggestion : suggestions) {\n        result.add(token, suggestion.string, suggestion.freq);      \t\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n    \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n    \tTerm term = new Term(field, token.toString());\n      SuggestWord[] suggestions = checker.suggestSimilar(term, \n          options.count, options.reader, options.onlyMorePopular, accuracy);\n      result.addFrequency(token, options.reader.docFreq(term));\n      for (SuggestWord suggestion : suggestions) {\n        result.add(token, suggestion.string, suggestion.freq);      \t\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n    \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n    \tTerm term = new Term(field, token.toString());\n      SuggestWord[] suggestions = checker.suggestSimilar(term, \n          options.count, options.reader, options.onlyMorePopular, accuracy);\n      result.addFrequency(token, options.reader.docFreq(term));\n      for (SuggestWord suggestion : suggestions) {\n        result.add(token, suggestion.string, suggestion.freq);      \t\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0f2476332da483dc2ea1fdd80b5968380653166","date":1316180489,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n    \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    SuggestMode mode = options.onlyMorePopular ? SuggestMode.SUGGEST_MORE_POPULAR : SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX;\n    for (Token token : options.tokens) {\n    \tTerm term = new Term(field, token.toString());\n      SuggestWord[] suggestions = checker.suggestSimilar(term, \n          options.count, options.reader, mode, accuracy);\n      result.addFrequency(token, options.reader.docFreq(term));\n      for (SuggestWord suggestion : suggestions) {\n        result.add(token, suggestion.string, suggestion.freq);      \t\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n    \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n    \tTerm term = new Term(field, token.toString());\n      SuggestWord[] suggestions = checker.suggestSimilar(term, \n          options.count, options.reader, options.onlyMorePopular, accuracy);\n      result.addFrequency(token, options.reader.docFreq(term));\n      for (SuggestWord suggestion : suggestions) {\n        result.add(token, suggestion.string, suggestion.freq);      \t\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5","date":1320922486,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n        \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    SuggestMode mode = options.onlyMorePopular ? SuggestMode.SUGGEST_MORE_POPULAR : SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX;\n    for (Token token : options.tokens) {\n    \tTerm term = new Term(field, token.toString());\n      SuggestWord[] suggestions = checker.suggestSimilar(term, \n          options.count, options.reader, mode, accuracy); \n      \n      int docFreq = 0;\n      if(options.extendedResults || suggestions.length==0) {\n        docFreq = options.reader.docFreq(term);\n      }\n      \n      if(options.extendedResults) {        \n        result.addFrequency(token, docFreq);\n      }\n      if(suggestions.length==0 && docFreq==0) {\n        List<String> empty = Collections.emptyList();\n        result.add(token, empty);\n      } else {        \n        for (SuggestWord suggestion : suggestions) {\n          result.add(token, suggestion.string, suggestion.freq);      \t\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n    \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    SuggestMode mode = options.onlyMorePopular ? SuggestMode.SUGGEST_MORE_POPULAR : SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX;\n    for (Token token : options.tokens) {\n    \tTerm term = new Term(field, token.toString());\n      SuggestWord[] suggestions = checker.suggestSimilar(term, \n          options.count, options.reader, mode, accuracy);\n      result.addFrequency(token, options.reader.docFreq(term));\n      for (SuggestWord suggestion : suggestions) {\n        result.add(token, suggestion.string, suggestion.freq);      \t\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"541f6605a29362fa8a42f33b69069e7da5178034","date":1337786849,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n        \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n      String tokenText = token.toString();\n      Term term = new Term(field, tokenText);\n      int freq = options.reader.docFreq(term);\n      int count = (options.alternativeTermCount != null && freq > 0) ? options.alternativeTermCount: options.count;\n      SuggestWord[] suggestions = checker.suggestSimilar(term, count,options.reader, options.suggestMode, accuracy);\n      result.addFrequency(token, freq);\n            \n      // If considering alternatives to \"correctly-spelled\" terms, then add the\n      // original as a viable suggestion.\n      if (options.alternativeTermCount != null && freq > 0) {\n        boolean foundOriginal = false;\n        SuggestWord[] suggestionsWithOrig = new SuggestWord[suggestions.length + 1];\n        for (int i = 0; i < suggestions.length; i++) {\n          if (suggestions[i].string.equals(tokenText)) {\n            foundOriginal = true;\n            break;\n          }\n          suggestionsWithOrig[i + 1] = suggestions[i];\n        }\n        if (!foundOriginal) {\n          SuggestWord orig = new SuggestWord();\n          orig.freq = freq;\n          orig.string = tokenText;\n          suggestionsWithOrig[0] = orig;\n          suggestions = suggestionsWithOrig;\n        }\n      }      \n      if(suggestions.length==0 && freq==0) {\n        List<String> empty = Collections.emptyList();\n        result.add(token, empty);\n      } else {        \n        for (SuggestWord suggestion : suggestions) {\n          result.add(token, suggestion.string, suggestion.freq);      \t\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n        \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    SuggestMode mode = options.onlyMorePopular ? SuggestMode.SUGGEST_MORE_POPULAR : SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX;\n    for (Token token : options.tokens) {\n    \tTerm term = new Term(field, token.toString());\n      SuggestWord[] suggestions = checker.suggestSimilar(term, \n          options.count, options.reader, mode, accuracy); \n      \n      int docFreq = 0;\n      if(options.extendedResults || suggestions.length==0) {\n        docFreq = options.reader.docFreq(term);\n      }\n      \n      if(options.extendedResults) {        \n        result.addFrequency(token, docFreq);\n      }\n      if(suggestions.length==0 && docFreq==0) {\n        List<String> empty = Collections.emptyList();\n        result.add(token, empty);\n      } else {        \n        for (SuggestWord suggestion : suggestions) {\n          result.add(token, suggestion.string, suggestion.freq);      \t\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["55b8276f00bacdbaefed6689ef19a4d3a309bf10"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3599646b4d4c346cf74d334813488b8b337b5bf5","date":1337790261,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n        \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n      String tokenText = token.toString();\n      Term term = new Term(field, tokenText);\n      int freq = options.reader.docFreq(term);\n      int count = (options.alternativeTermCount != null && freq > 0) ? options.alternativeTermCount: options.count;\n      SuggestWord[] suggestions = checker.suggestSimilar(term, count,options.reader, options.suggestMode, accuracy);\n      result.addFrequency(token, freq);\n            \n      // If considering alternatives to \"correctly-spelled\" terms, then add the\n      // original as a viable suggestion.\n      if (options.alternativeTermCount != null && freq > 0) {\n        boolean foundOriginal = false;\n        SuggestWord[] suggestionsWithOrig = new SuggestWord[suggestions.length + 1];\n        for (int i = 0; i < suggestions.length; i++) {\n          if (suggestions[i].string.equals(tokenText)) {\n            foundOriginal = true;\n            break;\n          }\n          suggestionsWithOrig[i + 1] = suggestions[i];\n        }\n        if (!foundOriginal) {\n          SuggestWord orig = new SuggestWord();\n          orig.freq = freq;\n          orig.string = tokenText;\n          suggestionsWithOrig[0] = orig;\n          suggestions = suggestionsWithOrig;\n        }\n      }      \n      if(suggestions.length==0 && freq==0) {\n        List<String> empty = Collections.emptyList();\n        result.add(token, empty);\n      } else {        \n        for (SuggestWord suggestion : suggestions) {\n          result.add(token, suggestion.string, suggestion.freq);      \t\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n        \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    SuggestMode mode = options.onlyMorePopular ? SuggestMode.SUGGEST_MORE_POPULAR : SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX;\n    for (Token token : options.tokens) {\n    \tTerm term = new Term(field, token.toString());\n      SuggestWord[] suggestions = checker.suggestSimilar(term, \n          options.count, options.reader, mode, accuracy); \n      \n      int docFreq = 0;\n      if(options.extendedResults || suggestions.length==0) {\n        docFreq = options.reader.docFreq(term);\n      }\n      \n      if(options.extendedResults) {        \n        result.addFrequency(token, docFreq);\n      }\n      if(suggestions.length==0 && docFreq==0) {\n        List<String> empty = Collections.emptyList();\n        result.add(token, empty);\n      } else {        \n        for (SuggestWord suggestion : suggestions) {\n          result.add(token, suggestion.string, suggestion.freq);      \t\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n        \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n      String tokenText = token.toString();\n      Term term = new Term(field, tokenText);\n      int freq = options.reader.docFreq(term);\n      int count = (options.alternativeTermCount != null && freq > 0) ? options.alternativeTermCount: options.count;\n      SuggestWord[] suggestions = checker.suggestSimilar(term, count,options.reader, options.suggestMode, accuracy);\n      result.addFrequency(token, freq);\n            \n      // If considering alternatives to \"correctly-spelled\" terms, then add the\n      // original as a viable suggestion.\n      if (options.alternativeTermCount != null && freq > 0) {\n        boolean foundOriginal = false;\n        SuggestWord[] suggestionsWithOrig = new SuggestWord[suggestions.length + 1];\n        for (int i = 0; i < suggestions.length; i++) {\n          if (suggestions[i].string.equals(tokenText)) {\n            foundOriginal = true;\n            break;\n          }\n          suggestionsWithOrig[i + 1] = suggestions[i];\n        }\n        if (!foundOriginal) {\n          SuggestWord orig = new SuggestWord();\n          orig.freq = freq;\n          orig.string = tokenText;\n          suggestionsWithOrig[0] = orig;\n          suggestions = suggestionsWithOrig;\n        }\n      }      \n      if(suggestions.length==0 && freq==0) {\n        List<String> empty = Collections.emptyList();\n        result.add(token, empty);\n      } else {        \n        for (SuggestWord suggestion : suggestions) {\n          result.add(token, suggestion.string, suggestion.freq);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n        \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n      String tokenText = token.toString();\n      Term term = new Term(field, tokenText);\n      int freq = options.reader.docFreq(term);\n      int count = (options.alternativeTermCount != null && freq > 0) ? options.alternativeTermCount: options.count;\n      SuggestWord[] suggestions = checker.suggestSimilar(term, count,options.reader, options.suggestMode, accuracy);\n      result.addFrequency(token, freq);\n            \n      // If considering alternatives to \"correctly-spelled\" terms, then add the\n      // original as a viable suggestion.\n      if (options.alternativeTermCount != null && freq > 0) {\n        boolean foundOriginal = false;\n        SuggestWord[] suggestionsWithOrig = new SuggestWord[suggestions.length + 1];\n        for (int i = 0; i < suggestions.length; i++) {\n          if (suggestions[i].string.equals(tokenText)) {\n            foundOriginal = true;\n            break;\n          }\n          suggestionsWithOrig[i + 1] = suggestions[i];\n        }\n        if (!foundOriginal) {\n          SuggestWord orig = new SuggestWord();\n          orig.freq = freq;\n          orig.string = tokenText;\n          suggestionsWithOrig[0] = orig;\n          suggestions = suggestionsWithOrig;\n        }\n      }      \n      if(suggestions.length==0 && freq==0) {\n        List<String> empty = Collections.emptyList();\n        result.add(token, empty);\n      } else {        \n        for (SuggestWord suggestion : suggestions) {\n          result.add(token, suggestion.string, suggestion.freq);      \t\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55b8276f00bacdbaefed6689ef19a4d3a309bf10","date":1399312570,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n        \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n      String tokenText = token.toString();\n      Term term = new Term(field, tokenText);\n      int freq = options.reader.docFreq(term);\n      int count = (options.alternativeTermCount > 0 && freq > 0) ? options.alternativeTermCount: options.count;\n      SuggestWord[] suggestions = checker.suggestSimilar(term, count,options.reader, options.suggestMode, accuracy);\n      result.addFrequency(token, freq);\n            \n      // If considering alternatives to \"correctly-spelled\" terms, then add the\n      // original as a viable suggestion.\n      if (options.alternativeTermCount > 0 && freq > 0) {\n        boolean foundOriginal = false;\n        SuggestWord[] suggestionsWithOrig = new SuggestWord[suggestions.length + 1];\n        for (int i = 0; i < suggestions.length; i++) {\n          if (suggestions[i].string.equals(tokenText)) {\n            foundOriginal = true;\n            break;\n          }\n          suggestionsWithOrig[i + 1] = suggestions[i];\n        }\n        if (!foundOriginal) {\n          SuggestWord orig = new SuggestWord();\n          orig.freq = freq;\n          orig.string = tokenText;\n          suggestionsWithOrig[0] = orig;\n          suggestions = suggestionsWithOrig;\n        }\n      }      \n      if(suggestions.length==0 && freq==0) {\n        List<String> empty = Collections.emptyList();\n        result.add(token, empty);\n      } else {        \n        for (SuggestWord suggestion : suggestions) {\n          result.add(token, suggestion.string, suggestion.freq);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n        \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n      String tokenText = token.toString();\n      Term term = new Term(field, tokenText);\n      int freq = options.reader.docFreq(term);\n      int count = (options.alternativeTermCount != null && freq > 0) ? options.alternativeTermCount: options.count;\n      SuggestWord[] suggestions = checker.suggestSimilar(term, count,options.reader, options.suggestMode, accuracy);\n      result.addFrequency(token, freq);\n            \n      // If considering alternatives to \"correctly-spelled\" terms, then add the\n      // original as a viable suggestion.\n      if (options.alternativeTermCount != null && freq > 0) {\n        boolean foundOriginal = false;\n        SuggestWord[] suggestionsWithOrig = new SuggestWord[suggestions.length + 1];\n        for (int i = 0; i < suggestions.length; i++) {\n          if (suggestions[i].string.equals(tokenText)) {\n            foundOriginal = true;\n            break;\n          }\n          suggestionsWithOrig[i + 1] = suggestions[i];\n        }\n        if (!foundOriginal) {\n          SuggestWord orig = new SuggestWord();\n          orig.freq = freq;\n          orig.string = tokenText;\n          suggestionsWithOrig[0] = orig;\n          suggestions = suggestionsWithOrig;\n        }\n      }      \n      if(suggestions.length==0 && freq==0) {\n        List<String> empty = Collections.emptyList();\n        result.add(token, empty);\n      } else {        \n        for (SuggestWord suggestion : suggestions) {\n          result.add(token, suggestion.string, suggestion.freq);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":["541f6605a29362fa8a42f33b69069e7da5178034"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    log.debug(\"getSuggestions: \" + options.tokens);\n        \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n      String tokenText = token.toString();\n      Term term = new Term(field, tokenText);\n      int freq = options.reader.docFreq(term);\n      int count = (options.alternativeTermCount > 0 && freq > 0) ? options.alternativeTermCount: options.count;\n      SuggestWord[] suggestions = checker.suggestSimilar(term, count,options.reader, options.suggestMode, accuracy);\n      result.addFrequency(token, freq);\n            \n      // If considering alternatives to \"correctly-spelled\" terms, then add the\n      // original as a viable suggestion.\n      if (options.alternativeTermCount > 0 && freq > 0) {\n        boolean foundOriginal = false;\n        SuggestWord[] suggestionsWithOrig = new SuggestWord[suggestions.length + 1];\n        for (int i = 0; i < suggestions.length; i++) {\n          if (suggestions[i].string.equals(tokenText)) {\n            foundOriginal = true;\n            break;\n          }\n          suggestionsWithOrig[i + 1] = suggestions[i];\n        }\n        if (!foundOriginal) {\n          SuggestWord orig = new SuggestWord();\n          orig.freq = freq;\n          orig.string = tokenText;\n          suggestionsWithOrig[0] = orig;\n          suggestions = suggestionsWithOrig;\n        }\n      }      \n      if(suggestions.length==0 && freq==0) {\n        List<String> empty = Collections.emptyList();\n        result.add(token, empty);\n      } else {        \n        for (SuggestWord suggestion : suggestions) {\n          result.add(token, suggestion.string, suggestion.freq);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    LOG.debug(\"getSuggestions: \" + options.tokens);\n        \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n      String tokenText = token.toString();\n      Term term = new Term(field, tokenText);\n      int freq = options.reader.docFreq(term);\n      int count = (options.alternativeTermCount > 0 && freq > 0) ? options.alternativeTermCount: options.count;\n      SuggestWord[] suggestions = checker.suggestSimilar(term, count,options.reader, options.suggestMode, accuracy);\n      result.addFrequency(token, freq);\n            \n      // If considering alternatives to \"correctly-spelled\" terms, then add the\n      // original as a viable suggestion.\n      if (options.alternativeTermCount > 0 && freq > 0) {\n        boolean foundOriginal = false;\n        SuggestWord[] suggestionsWithOrig = new SuggestWord[suggestions.length + 1];\n        for (int i = 0; i < suggestions.length; i++) {\n          if (suggestions[i].string.equals(tokenText)) {\n            foundOriginal = true;\n            break;\n          }\n          suggestionsWithOrig[i + 1] = suggestions[i];\n        }\n        if (!foundOriginal) {\n          SuggestWord orig = new SuggestWord();\n          orig.freq = freq;\n          orig.string = tokenText;\n          suggestionsWithOrig[0] = orig;\n          suggestions = suggestionsWithOrig;\n        }\n      }      \n      if(suggestions.length==0 && freq==0) {\n        List<String> empty = Collections.emptyList();\n        result.add(token, empty);\n      } else {        \n        for (SuggestWord suggestion : suggestions) {\n          result.add(token, suggestion.string, suggestion.freq);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54faedfb0e03479a38f5ee82f2dfaeea536e9404","date":1587251295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/DirectSolrSpellChecker#getSuggestions(SpellingOptions).mjava","sourceNew":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    log.debug(\"getSuggestions: {}\", options.tokens);\n        \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n      String tokenText = token.toString();\n      Term term = new Term(field, tokenText);\n      int freq = options.reader.docFreq(term);\n      int count = (options.alternativeTermCount > 0 && freq > 0) ? options.alternativeTermCount: options.count;\n      SuggestWord[] suggestions = checker.suggestSimilar(term, count,options.reader, options.suggestMode, accuracy);\n      result.addFrequency(token, freq);\n            \n      // If considering alternatives to \"correctly-spelled\" terms, then add the\n      // original as a viable suggestion.\n      if (options.alternativeTermCount > 0 && freq > 0) {\n        boolean foundOriginal = false;\n        SuggestWord[] suggestionsWithOrig = new SuggestWord[suggestions.length + 1];\n        for (int i = 0; i < suggestions.length; i++) {\n          if (suggestions[i].string.equals(tokenText)) {\n            foundOriginal = true;\n            break;\n          }\n          suggestionsWithOrig[i + 1] = suggestions[i];\n        }\n        if (!foundOriginal) {\n          SuggestWord orig = new SuggestWord();\n          orig.freq = freq;\n          orig.string = tokenText;\n          suggestionsWithOrig[0] = orig;\n          suggestions = suggestionsWithOrig;\n        }\n      }      \n      if(suggestions.length==0 && freq==0) {\n        List<String> empty = Collections.emptyList();\n        result.add(token, empty);\n      } else {        \n        for (SuggestWord suggestion : suggestions) {\n          result.add(token, suggestion.string, suggestion.freq);\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  @Override\n  public SpellingResult getSuggestions(SpellingOptions options)\n      throws IOException {\n    log.debug(\"getSuggestions: \" + options.tokens);\n        \n    SpellingResult result = new SpellingResult();\n    float accuracy = (options.accuracy == Float.MIN_VALUE) ? checker.getAccuracy() : options.accuracy;\n    \n    for (Token token : options.tokens) {\n      String tokenText = token.toString();\n      Term term = new Term(field, tokenText);\n      int freq = options.reader.docFreq(term);\n      int count = (options.alternativeTermCount > 0 && freq > 0) ? options.alternativeTermCount: options.count;\n      SuggestWord[] suggestions = checker.suggestSimilar(term, count,options.reader, options.suggestMode, accuracy);\n      result.addFrequency(token, freq);\n            \n      // If considering alternatives to \"correctly-spelled\" terms, then add the\n      // original as a viable suggestion.\n      if (options.alternativeTermCount > 0 && freq > 0) {\n        boolean foundOriginal = false;\n        SuggestWord[] suggestionsWithOrig = new SuggestWord[suggestions.length + 1];\n        for (int i = 0; i < suggestions.length; i++) {\n          if (suggestions[i].string.equals(tokenText)) {\n            foundOriginal = true;\n            break;\n          }\n          suggestionsWithOrig[i + 1] = suggestions[i];\n        }\n        if (!foundOriginal) {\n          SuggestWord orig = new SuggestWord();\n          orig.freq = freq;\n          orig.string = tokenText;\n          suggestionsWithOrig[0] = orig;\n          suggestions = suggestionsWithOrig;\n        }\n      }      \n      if(suggestions.length==0 && freq==0) {\n        List<String> empty = Collections.emptyList();\n        result.add(token, empty);\n      } else {        \n        for (SuggestWord suggestion : suggestions) {\n          result.add(token, suggestion.string, suggestion.freq);\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"541f6605a29362fa8a42f33b69069e7da5178034":["51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5"],"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"b0f2476332da483dc2ea1fdd80b5968380653166":["c26f00b574427b55127e869b935845554afde1fa"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3599646b4d4c346cf74d334813488b8b337b5bf5":["51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5","541f6605a29362fa8a42f33b69069e7da5178034"],"51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5":["b0f2476332da483dc2ea1fdd80b5968380653166"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"55b8276f00bacdbaefed6689ef19a4d3a309bf10":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["55b8276f00bacdbaefed6689ef19a4d3a309bf10"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["541f6605a29362fa8a42f33b69069e7da5178034"]},"commit2Childs":{"c26f00b574427b55127e869b935845554afde1fa":["b0f2476332da483dc2ea1fdd80b5968380653166"],"541f6605a29362fa8a42f33b69069e7da5178034":["3599646b4d4c346cf74d334813488b8b337b5bf5","4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b0f2476332da483dc2ea1fdd80b5968380653166":["51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"3599646b4d4c346cf74d334813488b8b337b5bf5":[],"51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5":["541f6605a29362fa8a42f33b69069e7da5178034","3599646b4d4c346cf74d334813488b8b337b5bf5"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"55b8276f00bacdbaefed6689ef19a4d3a309bf10":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["55b8276f00bacdbaefed6689ef19a4d3a309bf10"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3599646b4d4c346cf74d334813488b8b337b5bf5","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}