{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","commits":[{"id":"2ee5c613bc76903f5e2dee48b9d63c3a9ed3aeb0","date":1337448276,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private void copySegmentAsIs(SegmentInfo info, String segName,\n                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    if (info.getDocStoreOffset() != -1) {\n      // only violate the codec this way if its preflex\n      info.getCodec().storedFieldsFormat().files(info, codecDocStoreFiles);\n      info.getCodec().termVectorsFormat().files(info, codecDocStoreFiles);\n    }\n\n    // Copy the segment files\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      \n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    info.setDocStore(info.getDocStoreOffset(), newDsName, info.getDocStoreIsCompoundFile());\n    info.dir = directory;\n    info.name = segName;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private void copySegmentAsIs(SegmentInfo info, String segName,\n      Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    if (info.getDocStoreOffset() != -1) {\n      // only violate the codec this way if its preflex\n      codec.storedFieldsFormat().files(info, codecDocStoreFiles);\n      codec.termVectorsFormat().files(info, codecDocStoreFiles);\n    }\n    \n    // Copy the segment files\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      \n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    info.setDocStore(info.getDocStoreOffset(), newDsName, info.getDocStoreIsCompoundFile());\n    info.dir = directory;\n    info.name = segName;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4356000e349e38c9fb48034695b7c309abd54557","date":1337460341,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfo copySegmentAsIs(SegmentInfo info, String segName,\n                                      Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                      Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    if (info.getDocStoreOffset() != -1) {\n      // only violate the codec this way if its preflex\n      info.getCodec().storedFieldsFormat().files(info, codecDocStoreFiles);\n      info.getCodec().termVectorsFormat().files(info, codecDocStoreFiles);\n    }\n\n    //System.out.println(\"copy seg=\" + info.name + \" version=\" + info.getVersion());\n    \n    // Copy the segment files\n    for (String file: info.files()) {\n\n      // nocommit messy: insteda we should pull .files()\n      // from the codec's SIFormat and check if it's in\n      // there...\n      if (file.endsWith(\".si\")) {\n        continue;\n      }\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      //System.out.println(\"COPY \" + file + \" -> \" + newFileName);\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    // Same SI as before but we change directory and name:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.getVersion(), segName, info.docCount, info.getDocStoreOffset(),\n                                          newDsName, info.getDocStoreIsCompoundFile(), info.getNormGen(), info.getUseCompoundFile(),\n                                          info.getDelCount(), info.getCodec(), info.getDiagnostics());\n    newInfo.setDelGen(info.getDelGen());\n\n    // nocommit need to pass real FIS...\n    // nocommit maybe we don't pass FIS......?\n    // nocommit messy....\n    //if (!newInfo.getCodec().getName().equals(\"Lucene3x\")) {\n    if (!newInfo.getVersion().startsWith(\"3.\")) {\n      //System.out.println(\"  now write si for seg=\" + newInfo.name + \" codec=\" + newInfo.getCodec());\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(newInfo, null);\n    }\n    \n    return newInfo;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private void copySegmentAsIs(SegmentInfo info, String segName,\n      Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    if (info.getDocStoreOffset() != -1) {\n      // only violate the codec this way if its preflex\n      codec.storedFieldsFormat().files(info, codecDocStoreFiles);\n      codec.termVectorsFormat().files(info, codecDocStoreFiles);\n    }\n    \n    // Copy the segment files\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      \n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    info.setDocStore(info.getDocStoreOffset(), newDsName, info.getDocStoreIsCompoundFile());\n    info.dir = directory;\n    info.name = segName;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"352763be0465236f8e2ac188aa1b761cb3e1c9ee","date":1337516554,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfo copySegmentAsIs(SegmentInfo info, String segName,\n                                      Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                      Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfosFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if its preflex &\n      // shares doc stores\n      info.getCodec().storedFieldsFormat().files(info, codecDocStoreFiles);\n      info.getCodec().termVectorsFormat().files(info, codecDocStoreFiles);\n    }\n\n    //System.out.println(\"copy seg=\" + info.name + \" version=\" + info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.getVersion(), segName, info.docCount, info.getDocStoreOffset(),\n                                          newDsName, info.getDocStoreIsCompoundFile(), info.getNormGen(), info.getUseCompoundFile(),\n                                          info.getDelCount(), info.getCodec(), info.getDiagnostics());\n    newInfo.setDelGen(info.getDelGen());\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper dirWrapper = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(dirWrapper, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n    final Set<String> siFileNames = dirWrapper.getCreatedFiles();\n    \n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFileNames != null && siFileNames.contains(newFileName)) {\n        // We already rewwrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfo;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfo copySegmentAsIs(SegmentInfo info, String segName,\n                                      Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                      Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    if (info.getDocStoreOffset() != -1) {\n      // only violate the codec this way if its preflex\n      info.getCodec().storedFieldsFormat().files(info, codecDocStoreFiles);\n      info.getCodec().termVectorsFormat().files(info, codecDocStoreFiles);\n    }\n\n    //System.out.println(\"copy seg=\" + info.name + \" version=\" + info.getVersion());\n    \n    // Copy the segment files\n    for (String file: info.files()) {\n\n      // nocommit messy: insteda we should pull .files()\n      // from the codec's SIFormat and check if it's in\n      // there...\n      if (file.endsWith(\".si\")) {\n        continue;\n      }\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      //System.out.println(\"COPY \" + file + \" -> \" + newFileName);\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    // Same SI as before but we change directory and name:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.getVersion(), segName, info.docCount, info.getDocStoreOffset(),\n                                          newDsName, info.getDocStoreIsCompoundFile(), info.getNormGen(), info.getUseCompoundFile(),\n                                          info.getDelCount(), info.getCodec(), info.getDiagnostics());\n    newInfo.setDelGen(info.getDelGen());\n\n    // nocommit need to pass real FIS...\n    // nocommit maybe we don't pass FIS......?\n    // nocommit messy....\n    //if (!newInfo.getCodec().getName().equals(\"Lucene3x\")) {\n    if (!newInfo.getVersion().startsWith(\"3.\")) {\n      //System.out.println(\"  now write si for seg=\" + newInfo.name + \" codec=\" + newInfo.getCodec());\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(newInfo, null);\n    }\n    \n    return newInfo;\n  }\n\n","bugFix":null,"bugIntro":["5f6bd27530a2846413fe2d00030493c0e2d3a072","5f6bd27530a2846413fe2d00030493c0e2d3a072"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1494abe5dc85557ec2e2772f87660d48f831c3a5","date":1337614370,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfo copySegmentAsIs(SegmentInfo info, String segName,\n                                      Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                      Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfosFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.name + \" version=\" + info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.getVersion(), segName, info.docCount, info.getDocStoreOffset(),\n                                          newDsName, info.getDocStoreIsCompoundFile(), info.getNormGen(), info.getUseCompoundFile(),\n                                          info.getDelCount(), info.getCodec(), info.getDiagnostics());\n    newInfo.setDelGen(info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n    \n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    try {\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(directory, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      // nocommit hack\n      //if (siFileNames != null && siFileNames.contains(newFileName)) {\n      if (newFileName.endsWith(\".si\")) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfo;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfo copySegmentAsIs(SegmentInfo info, String segName,\n                                      Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                      Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfosFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if its preflex &\n      // shares doc stores\n      info.getCodec().storedFieldsFormat().files(info, codecDocStoreFiles);\n      info.getCodec().termVectorsFormat().files(info, codecDocStoreFiles);\n    }\n\n    //System.out.println(\"copy seg=\" + info.name + \" version=\" + info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.getVersion(), segName, info.docCount, info.getDocStoreOffset(),\n                                          newDsName, info.getDocStoreIsCompoundFile(), info.getNormGen(), info.getUseCompoundFile(),\n                                          info.getDelCount(), info.getCodec(), info.getDiagnostics());\n    newInfo.setDelGen(info.getDelGen());\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper dirWrapper = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(dirWrapper, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n    final Set<String> siFileNames = dirWrapper.getCreatedFiles();\n    \n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      if (siFileNames != null && siFileNames.contains(newFileName)) {\n        // We already rewwrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfo;\n  }\n\n","bugFix":null,"bugIntro":["5f6bd27530a2846413fe2d00030493c0e2d3a072","5f6bd27530a2846413fe2d00030493c0e2d3a072"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ace9b78896617dcee984890f3300d45c539c1b15","date":1337655022,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfo copySegmentAsIs(SegmentInfo info, String segName,\n                                      Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                      Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.name + \" version=\" + info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.getVersion(), segName, info.docCount, info.getDocStoreOffset(),\n                                          newDsName, info.getDocStoreIsCompoundFile(), info.getNormGen(), info.getUseCompoundFile(),\n                                          info.getDelCount(), info.getCodec(), info.getDiagnostics());\n    newInfo.setDelGen(info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n    \n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    try {\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(directory, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      // nocommit hack\n      //if (siFileNames != null && siFileNames.contains(newFileName)) {\n      if (newFileName.endsWith(\".si\")) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfo;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfo copySegmentAsIs(SegmentInfo info, String segName,\n                                      Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                      Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfosFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.name + \" version=\" + info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.getVersion(), segName, info.docCount, info.getDocStoreOffset(),\n                                          newDsName, info.getDocStoreIsCompoundFile(), info.getNormGen(), info.getUseCompoundFile(),\n                                          info.getDelCount(), info.getCodec(), info.getDiagnostics());\n    newInfo.setDelGen(info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n    \n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    try {\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(directory, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      // nocommit hack\n      //if (siFileNames != null && siFileNames.contains(newFileName)) {\n      if (newFileName.endsWith(\".si\")) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.info.getDocStoreSegment(), \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.docCount, info.info.getDocStoreOffset(),\n                                          newDsName, info.info.getDocStoreIsCompoundFile(), info.info.getNormGen(), info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n    \n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    try {\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(directory, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      // nocommit hack\n      //if (siFileNames != null && siFileNames.contains(newFileName)) {\n      if (newFileName.endsWith(\".si\")) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfo copySegmentAsIs(SegmentInfo info, String segName,\n                                      Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                      Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    final boolean hasSharedDocStore = info.getDocStoreOffset() != -1;\n    final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.name,\n                                                                        \"\",\n                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);\n\n    if (hasSharedDocStore) {\n      // only violate the codec this way if it's preflex &\n      // shares doc stores\n      assert info.getDocStoreSegment() != null;\n      // nocommit what to do....\n      if (info.getDocStoreIsCompoundFile()) {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"cfx\"));\n      } else {\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"fdt\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"fdx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"tvx\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"tvf\"));\n        codecDocStoreFiles.add(IndexFileNames.segmentFileName(info.getDocStoreSegment(), \"\", \"tvd\"));\n      }\n    }\n\n    //System.out.println(\"copy seg=\" + info.name + \" version=\" + info.getVersion());\n\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.getVersion(), segName, info.docCount, info.getDocStoreOffset(),\n                                          newDsName, info.getDocStoreIsCompoundFile(), info.getNormGen(), info.getUseCompoundFile(),\n                                          info.getDelCount(), info.getCodec(), info.getDiagnostics());\n    newInfo.setDelGen(info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names:\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n    \n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    try {\n      newInfo.getCodec().segmentInfosFormat().getSegmentInfosWriter().write(directory, newInfo, null, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n\n      // nocommit hack\n      //if (siFileNames != null && siFileNames.contains(newFileName)) {\n      if (newFileName.endsWith(\".si\")) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfo,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":null,"sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private void copySegmentAsIs(SegmentInfo info, String segName,\n                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    String dsName = info.getDocStoreSegment();\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n    \n    Set<String> codecDocStoreFiles = new HashSet<String>();\n    if (info.getDocStoreOffset() != -1) {\n      // only violate the codec this way if its preflex\n      info.getCodec().storedFieldsFormat().files(info, codecDocStoreFiles);\n      info.getCodec().termVectorsFormat().files(info, codecDocStoreFiles);\n    }\n\n    // Copy the segment files\n    for (String file: info.files()) {\n      final String newFileName;\n      if (codecDocStoreFiles.contains(file)) {\n        newFileName = newDsName + IndexFileNames.stripSegmentName(file);\n        if (dsFilesCopied.contains(newFileName)) {\n          continue;\n        }\n        dsFilesCopied.add(newFileName);\n      } else {\n        newFileName = segName + IndexFileNames.stripSegmentName(file);\n      }\n      \n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists\";\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    info.setDocStore(info.getDocStoreOffset(), newDsName, info.getDocStoreIsCompoundFile());\n    info.dir = directory;\n    info.name = segName;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["2ee5c613bc76903f5e2dee48b9d63c3a9ed3aeb0","9d153abcf92dc5329d98571a8c3035df9bd80648"],"4356000e349e38c9fb48034695b7c309abd54557":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"352763be0465236f8e2ac188aa1b761cb3e1c9ee":["4356000e349e38c9fb48034695b7c309abd54557"],"2ee5c613bc76903f5e2dee48b9d63c3a9ed3aeb0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9d153abcf92dc5329d98571a8c3035df9bd80648":["ace9b78896617dcee984890f3300d45c539c1b15"],"ace9b78896617dcee984890f3300d45c539c1b15":["1494abe5dc85557ec2e2772f87660d48f831c3a5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"1494abe5dc85557ec2e2772f87660d48f831c3a5":["352763be0465236f8e2ac188aa1b761cb3e1c9ee"]},"commit2Childs":{"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4356000e349e38c9fb48034695b7c309abd54557":["352763be0465236f8e2ac188aa1b761cb3e1c9ee"],"352763be0465236f8e2ac188aa1b761cb3e1c9ee":["1494abe5dc85557ec2e2772f87660d48f831c3a5"],"2ee5c613bc76903f5e2dee48b9d63c3a9ed3aeb0":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4356000e349e38c9fb48034695b7c309abd54557","2ee5c613bc76903f5e2dee48b9d63c3a9ed3aeb0"],"ace9b78896617dcee984890f3300d45c539c1b15":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"1494abe5dc85557ec2e2772f87660d48f831c3a5":["ace9b78896617dcee984890f3300d45c539c1b15"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}