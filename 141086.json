{"path":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/BasicDocMaker#createDocument(DocData,int,int).mjava","commits":[{"id":"e89c3770b3944888d0ff89f39fe010644f0d1854","date":1171287140,"type":0,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/BasicDocMaker#createDocument(DocData,int,int).mjava","pathOld":"/dev/null","sourceNew":"  // create a doc\r\n  // use only part of the body, modify it to keep the rest (or use all if size==0).\r\n  // reset the docdata properties so they are not added more than once.\r\n  private Document createDocument(DocData docData, int size, int cnt) {\r\n    int docid = incrNumDocsCreated();\r\n    Document doc = new Document();\r\n    doc.add(new Field(\"docid\", \"doc\"+docid, storeVal, indexVal, termVecVal));\r\n    if (docData.name!=null) {\r\n      String name = (cnt<0 ? docData.name : docData.name+\"_\"+cnt);\r\n      doc.add(new Field(\"docname\", name, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.date!=null) {\r\n      String dateStr = DateTools.dateToString(docData.date, DateTools.Resolution.SECOND);\r\n      doc.add(new Field(\"docdate\", dateStr, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.title!=null) {\r\n      doc.add(new Field(\"doctitle\", docData.title, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.body!=null && docData.body.length()>0) {\r\n      String bdy;\r\n      if (size<=0 || size>=docData.body.length()) {\r\n        bdy = docData.body; // use all\r\n        docData.body = \"\";  // nothing left\r\n      } else {\r\n        // attempt not to break words - if whitespace found within next 20 chars...\r\n        for (int n=size-1; n<size+20 && n<docData.body.length(); n++) {\r\n          if (Character.isWhitespace(docData.body.charAt(n))) {\r\n            size = n;\r\n            break;\r\n          }\r\n        }\r\n        bdy = docData.body.substring(0,size); // use part\r\n        docData.body = docData.body.substring(size); // some left\r\n      }\r\n      doc.add(new Field(BODY_FIELD, bdy, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.props!=null) {\r\n      for (Iterator it = docData.props.keySet().iterator(); it.hasNext(); ) {\r\n        String key = (String) it.next();\r\n        String val = (String) docData.props.get(key);\r\n        doc.add(new Field(key, val, storeVal, indexVal, termVecVal));\r\n      }\r\n      docData.props = null;\r\n    }\r\n    //System.out.println(\"============== Created doc \"+numDocsCreated+\" :\\n\"+doc+\"\\n==========\");\r\n    return doc;\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd4e80edfd616a2da1bb91fd01d54d8d0b9e10b1","date":1174621692,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/BasicDocMaker#createDocument(DocData,int,int).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/BasicDocMaker#createDocument(DocData,int,int).mjava","sourceNew":"  // create a doc\r\n  // use only part of the body, modify it to keep the rest (or use all if size==0).\r\n  // reset the docdata properties so they are not added more than once.\r\n  private Document createDocument(DocData docData, int size, int cnt) {\r\n    int docid = incrNumDocsCreated();\r\n    Document doc = new Document();\r\n    doc.add(new Field(\"docid\", \"doc\"+docid, storeVal, indexVal, termVecVal));\r\n    if (docData.name!=null) {\r\n      String name = (cnt<0 ? docData.name : docData.name+\"_\"+cnt);\r\n      doc.add(new Field(\"docname\", name, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.date!=null) {\r\n      String dateStr = DateTools.dateToString(docData.date, DateTools.Resolution.SECOND);\r\n      doc.add(new Field(\"docdate\", dateStr, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.title!=null) {\r\n      doc.add(new Field(\"doctitle\", docData.title, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.body!=null && docData.body.length()>0) {\r\n      String bdy;\r\n      if (size<=0 || size>=docData.body.length()) {\r\n        bdy = docData.body; // use all\r\n        docData.body = \"\";  // nothing left\r\n      } else {\r\n        // attempt not to break words - if whitespace found within next 20 chars...\r\n        for (int n=size-1; n<size+20 && n<docData.body.length(); n++) {\r\n          if (Character.isWhitespace(docData.body.charAt(n))) {\r\n            size = n;\r\n            break;\r\n          }\r\n        }\r\n        bdy = docData.body.substring(0,size); // use part\r\n        docData.body = docData.body.substring(size); // some left\r\n      }\r\n      doc.add(new Field(BODY_FIELD, bdy, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.bytes != null && docData.bytes.length != 0)\r\n    {\r\n      doc.add(new Field(\"bytes\", docData.bytes, Field.Store.YES));\r\n    }\r\n    if (docData.props!=null) {\r\n      for (Iterator it = docData.props.keySet().iterator(); it.hasNext(); ) {\r\n        String key = (String) it.next();\r\n        String val = (String) docData.props.get(key);\r\n        doc.add(new Field(key, val, storeVal, indexVal, termVecVal));\r\n      }\r\n      docData.props = null;\r\n    }\r\n    //System.out.println(\"============== Created doc \"+numDocsCreated+\" :\\n\"+doc+\"\\n==========\");\r\n    return doc;\r\n  }\r\n\n","sourceOld":"  // create a doc\r\n  // use only part of the body, modify it to keep the rest (or use all if size==0).\r\n  // reset the docdata properties so they are not added more than once.\r\n  private Document createDocument(DocData docData, int size, int cnt) {\r\n    int docid = incrNumDocsCreated();\r\n    Document doc = new Document();\r\n    doc.add(new Field(\"docid\", \"doc\"+docid, storeVal, indexVal, termVecVal));\r\n    if (docData.name!=null) {\r\n      String name = (cnt<0 ? docData.name : docData.name+\"_\"+cnt);\r\n      doc.add(new Field(\"docname\", name, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.date!=null) {\r\n      String dateStr = DateTools.dateToString(docData.date, DateTools.Resolution.SECOND);\r\n      doc.add(new Field(\"docdate\", dateStr, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.title!=null) {\r\n      doc.add(new Field(\"doctitle\", docData.title, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.body!=null && docData.body.length()>0) {\r\n      String bdy;\r\n      if (size<=0 || size>=docData.body.length()) {\r\n        bdy = docData.body; // use all\r\n        docData.body = \"\";  // nothing left\r\n      } else {\r\n        // attempt not to break words - if whitespace found within next 20 chars...\r\n        for (int n=size-1; n<size+20 && n<docData.body.length(); n++) {\r\n          if (Character.isWhitespace(docData.body.charAt(n))) {\r\n            size = n;\r\n            break;\r\n          }\r\n        }\r\n        bdy = docData.body.substring(0,size); // use part\r\n        docData.body = docData.body.substring(size); // some left\r\n      }\r\n      doc.add(new Field(BODY_FIELD, bdy, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.props!=null) {\r\n      for (Iterator it = docData.props.keySet().iterator(); it.hasNext(); ) {\r\n        String key = (String) it.next();\r\n        String val = (String) docData.props.get(key);\r\n        doc.add(new Field(key, val, storeVal, indexVal, termVecVal));\r\n      }\r\n      docData.props = null;\r\n    }\r\n    //System.out.println(\"============== Created doc \"+numDocsCreated+\" :\\n\"+doc+\"\\n==========\");\r\n    return doc;\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0f4b47efbf80cb689c6a58715ad0b93b088658e","date":1174655626,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/BasicDocMaker#createDocument(DocData,int,int).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/BasicDocMaker#createDocument(DocData,int,int).mjava","sourceNew":"  // create a doc\r\n  // use only part of the body, modify it to keep the rest (or use all if size==0).\r\n  // reset the docdata properties so they are not added more than once.\r\n  private Document createDocument(DocData docData, int size, int cnt) throws UnsupportedEncodingException {\r\n    int docid = incrNumDocsCreated();\r\n    Document doc = new Document();\r\n    doc.add(new Field(\"docid\", \"doc\"+docid, storeVal, indexVal, termVecVal));\r\n    if (docData.name!=null) {\r\n      String name = (cnt<0 ? docData.name : docData.name+\"_\"+cnt);\r\n      doc.add(new Field(\"docname\", name, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.date!=null) {\r\n      String dateStr = DateTools.dateToString(docData.date, DateTools.Resolution.SECOND);\r\n      doc.add(new Field(\"docdate\", dateStr, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.title!=null) {\r\n      doc.add(new Field(\"doctitle\", docData.title, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.body!=null && docData.body.length()>0) {\r\n      String bdy;\r\n      if (size<=0 || size>=docData.body.length()) {\r\n        bdy = docData.body; // use all\r\n        docData.body = \"\";  // nothing left\r\n      } else {\r\n        // attempt not to break words - if whitespace found within next 20 chars...\r\n        for (int n=size-1; n<size+20 && n<docData.body.length(); n++) {\r\n          if (Character.isWhitespace(docData.body.charAt(n))) {\r\n            size = n;\r\n            break;\r\n          }\r\n        }\r\n        bdy = docData.body.substring(0,size); // use part\r\n        docData.body = docData.body.substring(size); // some left\r\n      }\r\n      doc.add(new Field(BODY_FIELD, bdy, storeVal, indexVal, termVecVal));\r\n      if (storeBytes == true) {\r\n        doc.add(new Field(\"bytes\", bdy.getBytes(\"UTF-8\"), Field.Store.YES));\r\n      }\r\n    }\r\n\r\n    if (docData.props!=null) {\r\n      for (Iterator it = docData.props.keySet().iterator(); it.hasNext(); ) {\r\n        String key = (String) it.next();\r\n        String val = (String) docData.props.get(key);\r\n        doc.add(new Field(key, val, storeVal, indexVal, termVecVal));\r\n      }\r\n      docData.props = null;\r\n    }\r\n    //System.out.println(\"============== Created doc \"+numDocsCreated+\" :\\n\"+doc+\"\\n==========\");\r\n    return doc;\r\n  }\r\n\n","sourceOld":"  // create a doc\r\n  // use only part of the body, modify it to keep the rest (or use all if size==0).\r\n  // reset the docdata properties so they are not added more than once.\r\n  private Document createDocument(DocData docData, int size, int cnt) {\r\n    int docid = incrNumDocsCreated();\r\n    Document doc = new Document();\r\n    doc.add(new Field(\"docid\", \"doc\"+docid, storeVal, indexVal, termVecVal));\r\n    if (docData.name!=null) {\r\n      String name = (cnt<0 ? docData.name : docData.name+\"_\"+cnt);\r\n      doc.add(new Field(\"docname\", name, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.date!=null) {\r\n      String dateStr = DateTools.dateToString(docData.date, DateTools.Resolution.SECOND);\r\n      doc.add(new Field(\"docdate\", dateStr, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.title!=null) {\r\n      doc.add(new Field(\"doctitle\", docData.title, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.body!=null && docData.body.length()>0) {\r\n      String bdy;\r\n      if (size<=0 || size>=docData.body.length()) {\r\n        bdy = docData.body; // use all\r\n        docData.body = \"\";  // nothing left\r\n      } else {\r\n        // attempt not to break words - if whitespace found within next 20 chars...\r\n        for (int n=size-1; n<size+20 && n<docData.body.length(); n++) {\r\n          if (Character.isWhitespace(docData.body.charAt(n))) {\r\n            size = n;\r\n            break;\r\n          }\r\n        }\r\n        bdy = docData.body.substring(0,size); // use part\r\n        docData.body = docData.body.substring(size); // some left\r\n      }\r\n      doc.add(new Field(BODY_FIELD, bdy, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.bytes != null && docData.bytes.length != 0)\r\n    {\r\n      doc.add(new Field(\"bytes\", docData.bytes, Field.Store.YES));\r\n    }\r\n    if (docData.props!=null) {\r\n      for (Iterator it = docData.props.keySet().iterator(); it.hasNext(); ) {\r\n        String key = (String) it.next();\r\n        String val = (String) docData.props.get(key);\r\n        doc.add(new Field(key, val, storeVal, indexVal, termVecVal));\r\n      }\r\n      docData.props = null;\r\n    }\r\n    //System.out.println(\"============== Created doc \"+numDocsCreated+\" :\\n\"+doc+\"\\n==========\");\r\n    return doc;\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81573e29e6e5db648330b225c60d44b1c3eb388e","date":1174927593,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/BasicDocMaker#createDocument(DocData,int,int).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/BasicDocMaker#createDocument(DocData,int,int).mjava","sourceNew":"  // create a doc\r\n  // use only part of the body, modify it to keep the rest (or use all if size==0).\r\n  // reset the docdata properties so they are not added more than once.\r\n  private Document createDocument(DocData docData, int size, int cnt) throws UnsupportedEncodingException {\r\n    int docid = incrNumDocsCreated();\r\n    Document doc = new Document();\r\n    doc.add(new Field(\"docid\", \"doc\"+docid, storeVal, indexVal, termVecVal));\r\n    if (docData.getName()!=null) {\r\n      String name = (cnt<0 ? docData.getName() : docData.getName()+\"_\"+cnt);\r\n      doc.add(new Field(\"docname\", name, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.getDate()!=null) {\r\n      String dateStr = DateTools.dateToString(docData.getDate(), DateTools.Resolution.SECOND);\r\n      doc.add(new Field(\"docdate\", dateStr, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.getTitle()!=null) {\r\n      doc.add(new Field(\"doctitle\", docData.getTitle(), storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.getBody()!=null && docData.getBody().length()>0) {\r\n      String bdy;\r\n      if (size<=0 || size>=docData.getBody().length()) {\r\n        bdy = docData.getBody(); // use all\r\n        docData.setBody(\"\");  // nothing left\r\n      } else {\r\n        // attempt not to break words - if whitespace found within next 20 chars...\r\n        for (int n=size-1; n<size+20 && n<docData.getBody().length(); n++) {\r\n          if (Character.isWhitespace(docData.getBody().charAt(n))) {\r\n            size = n;\r\n            break;\r\n          }\r\n        }\r\n        bdy = docData.getBody().substring(0,size); // use part\r\n        docData.setBody(docData.getBody().substring(size)); // some left\r\n      }\r\n      doc.add(new Field(BODY_FIELD, bdy, storeVal, indexVal, termVecVal));\r\n      if (storeBytes == true) {\r\n        doc.add(new Field(\"bytes\", bdy.getBytes(\"UTF-8\"), Field.Store.YES));\r\n      }\r\n    }\r\n\r\n    if (docData.getProps()!=null) {\r\n      for (Iterator it = docData.getProps().keySet().iterator(); it.hasNext(); ) {\r\n        String key = (String) it.next();\r\n        String val = (String) docData.getProps().get(key);\r\n        doc.add(new Field(key, val, storeVal, indexVal, termVecVal));\r\n      }\r\n      docData.setProps(null);\r\n    }\r\n    //System.out.println(\"============== Created doc \"+numDocsCreated+\" :\\n\"+doc+\"\\n==========\");\r\n    return doc;\r\n  }\r\n\n","sourceOld":"  // create a doc\r\n  // use only part of the body, modify it to keep the rest (or use all if size==0).\r\n  // reset the docdata properties so they are not added more than once.\r\n  private Document createDocument(DocData docData, int size, int cnt) throws UnsupportedEncodingException {\r\n    int docid = incrNumDocsCreated();\r\n    Document doc = new Document();\r\n    doc.add(new Field(\"docid\", \"doc\"+docid, storeVal, indexVal, termVecVal));\r\n    if (docData.name!=null) {\r\n      String name = (cnt<0 ? docData.name : docData.name+\"_\"+cnt);\r\n      doc.add(new Field(\"docname\", name, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.date!=null) {\r\n      String dateStr = DateTools.dateToString(docData.date, DateTools.Resolution.SECOND);\r\n      doc.add(new Field(\"docdate\", dateStr, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.title!=null) {\r\n      doc.add(new Field(\"doctitle\", docData.title, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.body!=null && docData.body.length()>0) {\r\n      String bdy;\r\n      if (size<=0 || size>=docData.body.length()) {\r\n        bdy = docData.body; // use all\r\n        docData.body = \"\";  // nothing left\r\n      } else {\r\n        // attempt not to break words - if whitespace found within next 20 chars...\r\n        for (int n=size-1; n<size+20 && n<docData.body.length(); n++) {\r\n          if (Character.isWhitespace(docData.body.charAt(n))) {\r\n            size = n;\r\n            break;\r\n          }\r\n        }\r\n        bdy = docData.body.substring(0,size); // use part\r\n        docData.body = docData.body.substring(size); // some left\r\n      }\r\n      doc.add(new Field(BODY_FIELD, bdy, storeVal, indexVal, termVecVal));\r\n      if (storeBytes == true) {\r\n        doc.add(new Field(\"bytes\", bdy.getBytes(\"UTF-8\"), Field.Store.YES));\r\n      }\r\n    }\r\n\r\n    if (docData.props!=null) {\r\n      for (Iterator it = docData.props.keySet().iterator(); it.hasNext(); ) {\r\n        String key = (String) it.next();\r\n        String val = (String) docData.props.get(key);\r\n        doc.add(new Field(key, val, storeVal, indexVal, termVecVal));\r\n      }\r\n      docData.props = null;\r\n    }\r\n    //System.out.println(\"============== Created doc \"+numDocsCreated+\" :\\n\"+doc+\"\\n==========\");\r\n    return doc;\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3738fa43eaa87dc7b393fe98b04cde1019e20bac","date":1175557034,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/BasicDocMaker#createDocument(DocData,int,int).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/BasicDocMaker#createDocument(DocData,int,int).mjava","sourceNew":"  // create a doc\n  // use only part of the body, modify it to keep the rest (or use all if size==0).\n  // reset the docdata properties so they are not added more than once.\n  private Document createDocument(DocData docData, int size, int cnt) throws UnsupportedEncodingException {\n    int docid = incrNumDocsCreated();\n    Document doc = new Document();\n    doc.add(new Field(\"docid\", \"doc\"+docid, storeVal, indexVal, termVecVal));\n    if (docData.getName()!=null) {\n      String name = (cnt<0 ? docData.getName() : docData.getName()+\"_\"+cnt);\n      doc.add(new Field(\"docname\", name, storeVal, indexVal, termVecVal));\n    }\n    if (docData.getDate()!=null) {\n      String dateStr = DateTools.dateToString(docData.getDate(), DateTools.Resolution.SECOND);\n      doc.add(new Field(\"docdate\", dateStr, storeVal, indexVal, termVecVal));\n    }\n    if (docData.getTitle()!=null) {\n      doc.add(new Field(\"doctitle\", docData.getTitle(), storeVal, indexVal, termVecVal));\n    }\n    if (docData.getBody()!=null && docData.getBody().length()>0) {\n      String bdy;\n      if (size<=0 || size>=docData.getBody().length()) {\n        bdy = docData.getBody(); // use all\n        docData.setBody(\"\");  // nothing left\n      } else {\n        // attempt not to break words - if whitespace found within next 20 chars...\n        for (int n=size-1; n<size+20 && n<docData.getBody().length(); n++) {\n          if (Character.isWhitespace(docData.getBody().charAt(n))) {\n            size = n;\n            break;\n          }\n        }\n        bdy = docData.getBody().substring(0,size); // use part\n        docData.setBody(docData.getBody().substring(size)); // some left\n      }\n      doc.add(new Field(BODY_FIELD, bdy, storeVal, indexVal, termVecVal));\n      if (storeBytes == true) {\n        doc.add(new Field(\"bytes\", bdy.getBytes(\"UTF-8\"), Field.Store.YES));\n      }\n    }\n\n    if (docData.getProps()!=null) {\n      for (Iterator it = docData.getProps().keySet().iterator(); it.hasNext(); ) {\n        String key = (String) it.next();\n        String val = (String) docData.getProps().get(key);\n        doc.add(new Field(key, val, storeVal, indexVal, termVecVal));\n      }\n      docData.setProps(null);\n    }\n    //System.out.println(\"============== Created doc \"+numDocsCreated+\" :\\n\"+doc+\"\\n==========\");\n    return doc;\n  }\n\n","sourceOld":"  // create a doc\r\n  // use only part of the body, modify it to keep the rest (or use all if size==0).\r\n  // reset the docdata properties so they are not added more than once.\r\n  private Document createDocument(DocData docData, int size, int cnt) throws UnsupportedEncodingException {\r\n    int docid = incrNumDocsCreated();\r\n    Document doc = new Document();\r\n    doc.add(new Field(\"docid\", \"doc\"+docid, storeVal, indexVal, termVecVal));\r\n    if (docData.getName()!=null) {\r\n      String name = (cnt<0 ? docData.getName() : docData.getName()+\"_\"+cnt);\r\n      doc.add(new Field(\"docname\", name, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.getDate()!=null) {\r\n      String dateStr = DateTools.dateToString(docData.getDate(), DateTools.Resolution.SECOND);\r\n      doc.add(new Field(\"docdate\", dateStr, storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.getTitle()!=null) {\r\n      doc.add(new Field(\"doctitle\", docData.getTitle(), storeVal, indexVal, termVecVal));\r\n    }\r\n    if (docData.getBody()!=null && docData.getBody().length()>0) {\r\n      String bdy;\r\n      if (size<=0 || size>=docData.getBody().length()) {\r\n        bdy = docData.getBody(); // use all\r\n        docData.setBody(\"\");  // nothing left\r\n      } else {\r\n        // attempt not to break words - if whitespace found within next 20 chars...\r\n        for (int n=size-1; n<size+20 && n<docData.getBody().length(); n++) {\r\n          if (Character.isWhitespace(docData.getBody().charAt(n))) {\r\n            size = n;\r\n            break;\r\n          }\r\n        }\r\n        bdy = docData.getBody().substring(0,size); // use part\r\n        docData.setBody(docData.getBody().substring(size)); // some left\r\n      }\r\n      doc.add(new Field(BODY_FIELD, bdy, storeVal, indexVal, termVecVal));\r\n      if (storeBytes == true) {\r\n        doc.add(new Field(\"bytes\", bdy.getBytes(\"UTF-8\"), Field.Store.YES));\r\n      }\r\n    }\r\n\r\n    if (docData.getProps()!=null) {\r\n      for (Iterator it = docData.getProps().keySet().iterator(); it.hasNext(); ) {\r\n        String key = (String) it.next();\r\n        String val = (String) docData.getProps().get(key);\r\n        doc.add(new Field(key, val, storeVal, indexVal, termVecVal));\r\n      }\r\n      docData.setProps(null);\r\n    }\r\n    //System.out.println(\"============== Created doc \"+numDocsCreated+\" :\\n\"+doc+\"\\n==========\");\r\n    return doc;\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c528d38c8d9b2452e932321931b11e7c19a96d5","date":1185353698,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/BasicDocMaker#createDocument(DocData,int,int).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/BasicDocMaker#createDocument(DocData,int,int).mjava","sourceNew":"  // create a doc\n  // use only part of the body, modify it to keep the rest (or use all if size==0).\n  // reset the docdata properties so they are not added more than once.\n  private Document createDocument(DocData docData, int size, int cnt) throws UnsupportedEncodingException {\n    int docid = incrNumDocsCreated();\n    Document doc = new Document();\n    doc.add(new Field(ID_FIELD, \"doc\"+docid, storeVal, indexVal, termVecVal));\n    if (docData.getName()!=null) {\n      String name = (cnt<0 ? docData.getName() : docData.getName()+\"_\"+cnt);\n      doc.add(new Field(NAME_FIELD, name, storeVal, indexVal, termVecVal));\n    }\n    if (docData.getDate()!=null) {\n      String dateStr = DateTools.dateToString(docData.getDate(), DateTools.Resolution.SECOND);\n      doc.add(new Field(DATE_FIELD, dateStr, storeVal, indexVal, termVecVal));\n    }\n    if (docData.getTitle()!=null) {\n      doc.add(new Field(TITLE_FIELD, docData.getTitle(), storeVal, indexVal, termVecVal));\n    }\n    if (docData.getBody()!=null && docData.getBody().length()>0) {\n      String bdy;\n      if (size<=0 || size>=docData.getBody().length()) {\n        bdy = docData.getBody(); // use all\n        docData.setBody(\"\");  // nothing left\n      } else {\n        // attempt not to break words - if whitespace found within next 20 chars...\n        for (int n=size-1; n<size+20 && n<docData.getBody().length(); n++) {\n          if (Character.isWhitespace(docData.getBody().charAt(n))) {\n            size = n;\n            break;\n          }\n        }\n        bdy = docData.getBody().substring(0,size); // use part\n        docData.setBody(docData.getBody().substring(size)); // some left\n      }\n      doc.add(new Field(BODY_FIELD, bdy, storeVal, indexVal, termVecVal));\n      if (storeBytes == true) {\n        doc.add(new Field(BYTES_FIELD, bdy.getBytes(\"UTF-8\"), Field.Store.YES));\n      }\n    }\n\n    if (docData.getProps()!=null) {\n      for (Iterator it = docData.getProps().keySet().iterator(); it.hasNext(); ) {\n        String key = (String) it.next();\n        String val = (String) docData.getProps().get(key);\n        doc.add(new Field(key, val, storeVal, indexVal, termVecVal));\n      }\n      docData.setProps(null);\n    }\n    //System.out.println(\"============== Created doc \"+numDocsCreated+\" :\\n\"+doc+\"\\n==========\");\n    return doc;\n  }\n\n","sourceOld":"  // create a doc\n  // use only part of the body, modify it to keep the rest (or use all if size==0).\n  // reset the docdata properties so they are not added more than once.\n  private Document createDocument(DocData docData, int size, int cnt) throws UnsupportedEncodingException {\n    int docid = incrNumDocsCreated();\n    Document doc = new Document();\n    doc.add(new Field(\"docid\", \"doc\"+docid, storeVal, indexVal, termVecVal));\n    if (docData.getName()!=null) {\n      String name = (cnt<0 ? docData.getName() : docData.getName()+\"_\"+cnt);\n      doc.add(new Field(\"docname\", name, storeVal, indexVal, termVecVal));\n    }\n    if (docData.getDate()!=null) {\n      String dateStr = DateTools.dateToString(docData.getDate(), DateTools.Resolution.SECOND);\n      doc.add(new Field(\"docdate\", dateStr, storeVal, indexVal, termVecVal));\n    }\n    if (docData.getTitle()!=null) {\n      doc.add(new Field(\"doctitle\", docData.getTitle(), storeVal, indexVal, termVecVal));\n    }\n    if (docData.getBody()!=null && docData.getBody().length()>0) {\n      String bdy;\n      if (size<=0 || size>=docData.getBody().length()) {\n        bdy = docData.getBody(); // use all\n        docData.setBody(\"\");  // nothing left\n      } else {\n        // attempt not to break words - if whitespace found within next 20 chars...\n        for (int n=size-1; n<size+20 && n<docData.getBody().length(); n++) {\n          if (Character.isWhitespace(docData.getBody().charAt(n))) {\n            size = n;\n            break;\n          }\n        }\n        bdy = docData.getBody().substring(0,size); // use part\n        docData.setBody(docData.getBody().substring(size)); // some left\n      }\n      doc.add(new Field(BODY_FIELD, bdy, storeVal, indexVal, termVecVal));\n      if (storeBytes == true) {\n        doc.add(new Field(\"bytes\", bdy.getBytes(\"UTF-8\"), Field.Store.YES));\n      }\n    }\n\n    if (docData.getProps()!=null) {\n      for (Iterator it = docData.getProps().keySet().iterator(); it.hasNext(); ) {\n        String key = (String) it.next();\n        String val = (String) docData.getProps().get(key);\n        doc.add(new Field(key, val, storeVal, indexVal, termVecVal));\n      }\n      docData.setProps(null);\n    }\n    //System.out.println(\"============== Created doc \"+numDocsCreated+\" :\\n\"+doc+\"\\n==========\");\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6944b9fa6d8ef96b83ae2d3a4332d03b3857355b","date":1245355139,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/BasicDocMaker#createDocument(DocData,int,int).mjava","sourceNew":null,"sourceOld":"  // create a doc\n  // use only part of the body, modify it to keep the rest (or use all if size==0).\n  // reset the docdata properties so they are not added more than once.\n  private Document createDocument(DocData docData, int size, int cnt) throws UnsupportedEncodingException {\n    int docid = incrNumDocsCreated();\n    Document doc = new Document();\n    doc.add(new Field(ID_FIELD, \"doc\"+docid, storeVal, indexVal, termVecVal));\n    if (docData.getName()!=null) {\n      String name = (cnt<0 ? docData.getName() : docData.getName()+\"_\"+cnt);\n      doc.add(new Field(NAME_FIELD, name, storeVal, indexVal, termVecVal));\n    }\n    if (docData.getDate()!=null) {\n      String dateStr = DateTools.dateToString(docData.getDate(), DateTools.Resolution.SECOND);\n      doc.add(new Field(DATE_FIELD, dateStr, storeVal, indexVal, termVecVal));\n    }\n    if (docData.getTitle()!=null) {\n      doc.add(new Field(TITLE_FIELD, docData.getTitle(), storeVal, indexVal, termVecVal));\n    }\n    if (docData.getBody()!=null && docData.getBody().length()>0) {\n      String bdy;\n      if (size<=0 || size>=docData.getBody().length()) {\n        bdy = docData.getBody(); // use all\n        docData.setBody(\"\");  // nothing left\n      } else {\n        // attempt not to break words - if whitespace found within next 20 chars...\n        for (int n=size-1; n<size+20 && n<docData.getBody().length(); n++) {\n          if (Character.isWhitespace(docData.getBody().charAt(n))) {\n            size = n;\n            break;\n          }\n        }\n        bdy = docData.getBody().substring(0,size); // use part\n        docData.setBody(docData.getBody().substring(size)); // some left\n      }\n      doc.add(new Field(BODY_FIELD, bdy, storeVal, indexVal, termVecVal));\n      if (storeBytes == true) {\n        doc.add(new Field(BYTES_FIELD, bdy.getBytes(\"UTF-8\"), Field.Store.YES));\n      }\n    }\n\n    if (docData.getProps()!=null) {\n      for (Iterator it = docData.getProps().keySet().iterator(); it.hasNext(); ) {\n        String key = (String) it.next();\n        String val = (String) docData.getProps().get(key);\n        doc.add(new Field(key, val, storeVal, indexVal, termVecVal));\n      }\n      docData.setProps(null);\n    }\n    //System.out.println(\"============== Created doc \"+numDocsCreated+\" :\\n\"+doc+\"\\n==========\");\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3c528d38c8d9b2452e932321931b11e7c19a96d5":["3738fa43eaa87dc7b393fe98b04cde1019e20bac"],"6944b9fa6d8ef96b83ae2d3a4332d03b3857355b":["3c528d38c8d9b2452e932321931b11e7c19a96d5"],"bd4e80edfd616a2da1bb91fd01d54d8d0b9e10b1":["e89c3770b3944888d0ff89f39fe010644f0d1854"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a0f4b47efbf80cb689c6a58715ad0b93b088658e":["bd4e80edfd616a2da1bb91fd01d54d8d0b9e10b1"],"3738fa43eaa87dc7b393fe98b04cde1019e20bac":["81573e29e6e5db648330b225c60d44b1c3eb388e"],"e89c3770b3944888d0ff89f39fe010644f0d1854":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"81573e29e6e5db648330b225c60d44b1c3eb388e":["a0f4b47efbf80cb689c6a58715ad0b93b088658e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6944b9fa6d8ef96b83ae2d3a4332d03b3857355b"]},"commit2Childs":{"3c528d38c8d9b2452e932321931b11e7c19a96d5":["6944b9fa6d8ef96b83ae2d3a4332d03b3857355b"],"6944b9fa6d8ef96b83ae2d3a4332d03b3857355b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bd4e80edfd616a2da1bb91fd01d54d8d0b9e10b1":["a0f4b47efbf80cb689c6a58715ad0b93b088658e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e89c3770b3944888d0ff89f39fe010644f0d1854"],"a0f4b47efbf80cb689c6a58715ad0b93b088658e":["81573e29e6e5db648330b225c60d44b1c3eb388e"],"3738fa43eaa87dc7b393fe98b04cde1019e20bac":["3c528d38c8d9b2452e932321931b11e7c19a96d5"],"e89c3770b3944888d0ff89f39fe010644f0d1854":["bd4e80edfd616a2da1bb91fd01d54d8d0b9e10b1"],"81573e29e6e5db648330b225c60d44b1c3eb388e":["3738fa43eaa87dc7b393fe98b04cde1019e20bac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}