{"path":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(AtomicReaderContext context) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(AtomicReaderContext context) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(AtomicReaderContext context) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(AtomicReaderContext context) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":["61cbcf396559d597a914594d7e2830c142ecfd91"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(AtomicReaderContext context) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(AtomicReaderContext context) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae73da626f97850c922c42736f808d0378e165f0","date":1396625460,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(AtomicReaderContext context) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(AtomicReaderContext context) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f657d9837900f4519ca1cbd5e98d86d4bba4dab","date":1417790596,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"781239fc84d36be12b84e4d3e2618f5f07a182e3","date":1423139668,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":["61cbcf396559d597a914594d7e2830c142ecfd91"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"95e93d67f29b6bee6e39efb3fb6f1237b5b9850b","date":1487325043,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n        \n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n        \n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285244982ce6aa163d1e60a707f0e6e121736ce5","date":1536055304,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorable scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorable scorer) {\n          this.scorer = scorer;\n        }\n        \n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n          this.scorer = scorer;\n        }\n        \n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d77dafd89756a5161d244985903e3487ca109182","date":1548679743,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorable scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorable scorer) {\n          this.scorer = scorer;\n        }\n        \n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new SimpleCollector() {\n        private Scorable scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorable scorer) {\n          this.scorer = scorer;\n        }\n        \n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"781239fc84d36be12b84e4d3e2618f5f07a182e3":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"d77dafd89756a5161d244985903e3487ca109182":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"95e93d67f29b6bee6e39efb3fb6f1237b5b9850b":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"0f657d9837900f4519ca1cbd5e98d86d4bba4dab":["ae73da626f97850c922c42736f808d0378e165f0"],"417142ff08fda9cf0b72d5133e63097a166c6458":["95e93d67f29b6bee6e39efb3fb6f1237b5b9850b","9fc47cb7b4346802411bb432f501ed0673d7119e"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["417142ff08fda9cf0b72d5133e63097a166c6458"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["0f657d9837900f4519ca1cbd5e98d86d4bba4dab"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","ae73da626f97850c922c42736f808d0378e165f0"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b89678825b68eccaf09e6ab71675fc0b0af1e099","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ae73da626f97850c922c42736f808d0378e165f0":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["95e93d67f29b6bee6e39efb3fb6f1237b5b9850b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d77dafd89756a5161d244985903e3487ca109182"]},"commit2Childs":{"781239fc84d36be12b84e4d3e2618f5f07a182e3":["95e93d67f29b6bee6e39efb3fb6f1237b5b9850b"],"d77dafd89756a5161d244985903e3487ca109182":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"95e93d67f29b6bee6e39efb3fb6f1237b5b9850b":["417142ff08fda9cf0b72d5133e63097a166c6458","9fc47cb7b4346802411bb432f501ed0673d7119e"],"0f657d9837900f4519ca1cbd5e98d86d4bba4dab":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"417142ff08fda9cf0b72d5133e63097a166c6458":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["d77dafd89756a5161d244985903e3487ca109182"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"ae73da626f97850c922c42736f808d0378e165f0":["0f657d9837900f4519ca1cbd5e98d86d4bba4dab","15e323346eac5e4685c0a9f2df85eb96b4239bbb"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","fe33227f6805edab2036cbb80645cc4e2d1fa424","ae73da626f97850c922c42736f808d0378e165f0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}