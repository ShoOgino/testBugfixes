{"path":"lucene/sandbox/src/java/org/apache/lucene/search/TermAutomatonQuery#rewrite(IndexReader).mjava","commits":[{"id":"6f39ae26126a88ee050e14ab738bb6c6d0dad877","date":1478516006,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/TermAutomatonQuery#rewrite(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  public Query rewrite(IndexReader reader) throws IOException {\n    if (Operations.isEmpty(det)) {\n      return new MatchNoDocsQuery();\n    }\n\n    IntsRef single = Operations.getSingleton(det);\n    if (single != null && single.length == 1) {\n      return new TermQuery(new Term(field, idToTerm.get(single.ints[single.offset])));\n    }\n\n    // TODO: can PhraseQuery really handle multiple terms at the same position?  If so, why do we even have MultiPhraseQuery?\n    \n    // Try for either PhraseQuery or MultiPhraseQuery, which only works when the automaton is a sausage:\n    MultiPhraseQuery.Builder mpq = new MultiPhraseQuery.Builder();\n    PhraseQuery.Builder pq = new PhraseQuery.Builder();\n\n    Transition t = new Transition();\n    int state = 0;\n    int pos = 0;\n    query:\n    while (true) {\n      int count = det.initTransition(state, t);\n      if (count == 0) {\n        if (det.isAccept(state) == false) {\n          mpq = null;\n          pq = null;\n        }\n        break;\n      } else if (det.isAccept(state)) {\n        mpq = null;\n        pq = null;\n        break;\n      }\n      int dest = -1;\n      List<Term> terms = new ArrayList<>();\n      boolean matchesAny = false;\n      for(int i=0;i<count;i++) {\n        det.getNextTransition(t);\n        if (i == 0) {\n          dest = t.dest;\n        } else if (dest != t.dest) {\n          mpq = null;\n          pq = null;\n          break query;\n        }\n\n        matchesAny |= anyTermID >= t.min && anyTermID <= t.max;\n\n        if (matchesAny == false) {\n          for(int termID=t.min;termID<=t.max;termID++) {\n            terms.add(new Term(field, idToTerm.get(termID)));\n          }\n        }\n      }\n      if (matchesAny == false) {\n        mpq.add(terms.toArray(new Term[terms.size()]), pos);\n        if (pq != null) {\n          if (terms.size() == 1) {\n            pq.add(terms.get(0), pos);\n          } else {\n            pq = null;\n          }\n        }\n      }\n      state = dest;\n      pos++;\n    }\n\n    if (pq != null) {\n      return pq.build();\n    } else if (mpq != null) {\n      return mpq.build();\n    }\n    \n    // TODO: we could maybe also rewrite to union of PhraseQuery (pull all finite strings) if it's \"worth it\"?\n    return this;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/TermAutomatonQuery#rewrite(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  public Query rewrite(IndexReader reader) throws IOException {\n    if (Operations.isEmpty(det)) {\n      return new MatchNoDocsQuery();\n    }\n\n    IntsRef single = Operations.getSingleton(det);\n    if (single != null && single.length == 1) {\n      return new TermQuery(new Term(field, idToTerm.get(single.ints[single.offset])));\n    }\n\n    // TODO: can PhraseQuery really handle multiple terms at the same position?  If so, why do we even have MultiPhraseQuery?\n    \n    // Try for either PhraseQuery or MultiPhraseQuery, which only works when the automaton is a sausage:\n    MultiPhraseQuery.Builder mpq = new MultiPhraseQuery.Builder();\n    PhraseQuery.Builder pq = new PhraseQuery.Builder();\n\n    Transition t = new Transition();\n    int state = 0;\n    int pos = 0;\n    query:\n    while (true) {\n      int count = det.initTransition(state, t);\n      if (count == 0) {\n        if (det.isAccept(state) == false) {\n          mpq = null;\n          pq = null;\n        }\n        break;\n      } else if (det.isAccept(state)) {\n        mpq = null;\n        pq = null;\n        break;\n      }\n      int dest = -1;\n      List<Term> terms = new ArrayList<>();\n      boolean matchesAny = false;\n      for(int i=0;i<count;i++) {\n        det.getNextTransition(t);\n        if (i == 0) {\n          dest = t.dest;\n        } else if (dest != t.dest) {\n          mpq = null;\n          pq = null;\n          break query;\n        }\n\n        matchesAny |= anyTermID >= t.min && anyTermID <= t.max;\n\n        if (matchesAny == false) {\n          for(int termID=t.min;termID<=t.max;termID++) {\n            terms.add(new Term(field, idToTerm.get(termID)));\n          }\n        }\n      }\n      if (matchesAny == false) {\n        mpq.add(terms.toArray(new Term[terms.size()]), pos);\n        if (pq != null) {\n          if (terms.size() == 1) {\n            pq.add(terms.get(0), pos);\n          } else {\n            pq = null;\n          }\n        }\n      }\n      state = dest;\n      pos++;\n    }\n\n    if (pq != null) {\n      return pq.build();\n    } else if (mpq != null) {\n      return mpq.build();\n    }\n    \n    // TODO: we could maybe also rewrite to union of PhraseQuery (pull all finite strings) if it's \"worth it\"?\n    return this;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6f39ae26126a88ee050e14ab738bb6c6d0dad877":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6f39ae26126a88ee050e14ab738bb6c6d0dad877"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6f39ae26126a88ee050e14ab738bb6c6d0dad877"]},"commit2Childs":{"6f39ae26126a88ee050e14ab738bb6c6d0dad877":["199dfa410f1fdbfd3294106b04096cce5ed34b21","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6f39ae26126a88ee050e14ab738bb6c6d0dad877","199dfa410f1fdbfd3294106b04096cce5ed34b21"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["199dfa410f1fdbfd3294106b04096cce5ed34b21","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}