{"path":"solr/solrj/src/java/org/apache/solr/common/util/NamedList#findRecursive(String...).mjava","commits":[{"id":"62126a2398119ce2a86e01db19c6d1c84e2b9d03","date":1368893778,"type":0,"author":"Shawn Heisey","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/NamedList#findRecursive(String...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Recursively parses the NamedList structure to arrive at a\n   * specific element.  As you descend the NamedList tree, the\n   * last element can be any type, including NamedList, but\n   * the previous elements MUST be NamedList ojects themselves.\n   * This method is particularly useful for parsing the response\n   * from Solr's /admin/mbeans handler. \n   * \n   * Explicit casts are recommended.\n   * Usage examples:\n   *\n   * String coreName = (String) response.findRecursive(\n   * \"solr-mbeans\", \"CORE\", \"core\", \"stats\", \"coreName\");\n   * long numDoc = (long) response.findRecursive(\n   * \"solr-mbeans\", \"CORE\", \"searcher\", \"stats\", \"numDocs\");\n   *\n   * @param args One or more strings specifying the tree to navigate.\n   * @return the last entry in the tree, null if not found.\n   */\n  public T findRecursive(String... args) {\n    NamedList<T> list = null;\n    T value = null;\n    for (String key : args) {\n      /* First pass: this list.  Later passes: previous value. */\n      if (list == null) {\n        list = this;\n      }\n      else\n      {\n        if (NamedList.class.isInstance(value)) {\n          list = (NamedList<T>) value;\n        } else {\n          value = null;\n          break;\n        }\n      }\n      value = list.get(key);\n    }\n    return value;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09cb84e8f7cc3f05b42efa917e6377e8909c74b5","date":1369035595,"type":3,"author":"Shawn Heisey","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/NamedList#findRecursive(String...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/NamedList#findRecursive(String...).mjava","sourceNew":"  /**\n   * Recursively parses the NamedList structure to arrive at a specific element.\n   * As you descend the NamedList tree, the last element can be any type,\n   * including NamedList, but the previous elements MUST be NamedList objects\n   * themselves. A null value is returned if the indicated hierarchy doesn't\n   * exist, but NamedList allows null values so that could be the actual value\n   * at the end of the path.\n   * \n   * This method is particularly useful for parsing the response from Solr's\n   * /admin/mbeans handler, but it also works for any complex structure.\n   * \n   * Explicitly casting the return value is recommended. An even safer option is\n   * to accept the return value as an object and then check its type.\n   * \n   * Usage examples:\n   * \n   * String coreName = (String) response.findRecursive\n   * (\"solr-mbeans\", \"CORE\", \"core\", \"stats\", \"coreName\");\n   * long numDoc = (long) response.findRecursive\n   * (\"solr-mbeans\", \"CORE\", \"searcher\", \"stats\", \"numDocs\");\n   * \n   * @param args\n   *          One or more strings specifying the tree to navigate.\n   * @return the last entry in the given path hierarchy, null if not found.\n   */\n  public Object findRecursive(String... args) {\n    NamedList<?> currentList = null;\n    Object value = null;\n    for (int i = 0; i < args.length; i++) {\n      String key = args[i];\n      /*\n       * The first time through the loop, the current list is null, so we assign\n       * it to this list. Then we retrieve the first key from this list and\n       * assign it to value.\n       * \n       * On the next loop, we check whether the retrieved value is a NamedList.\n       * If it is, then we drop down to that NamedList, grab the value of the\n       * next key, and start the loop over. If it is not a NamedList, then we\n       * assign the value to null and break out of the loop.\n       * \n       * Assigning the value to null and then breaking out of the loop seems\n       * like the wrong thing to do, but there's a very simple reason that it\n       * works: If we have reached the last key, then the loop ends naturally\n       * after we retrieve the value, and that code is never executed.\n       */\n      if (currentList == null) {\n        currentList = this;\n      } else {\n        if (value instanceof NamedList) {\n          currentList = (NamedList<?>) value;\n        } else {\n          value = null;\n          break;\n        }\n      }\n      /*\n       * We do not need to do a null check on currentList for the following\n       * assignment. The instanceof check above will fail if the current list is\n       * null, and if that happens, the loop will end before this point.\n       */\n      value = currentList.get(key, 0);\n    }\n    return value;\n  }\n\n","sourceOld":"  /**\n   * Recursively parses the NamedList structure to arrive at a\n   * specific element.  As you descend the NamedList tree, the\n   * last element can be any type, including NamedList, but\n   * the previous elements MUST be NamedList ojects themselves.\n   * This method is particularly useful for parsing the response\n   * from Solr's /admin/mbeans handler. \n   * \n   * Explicit casts are recommended.\n   * Usage examples:\n   *\n   * String coreName = (String) response.findRecursive(\n   * \"solr-mbeans\", \"CORE\", \"core\", \"stats\", \"coreName\");\n   * long numDoc = (long) response.findRecursive(\n   * \"solr-mbeans\", \"CORE\", \"searcher\", \"stats\", \"numDocs\");\n   *\n   * @param args One or more strings specifying the tree to navigate.\n   * @return the last entry in the tree, null if not found.\n   */\n  public T findRecursive(String... args) {\n    NamedList<T> list = null;\n    T value = null;\n    for (String key : args) {\n      /* First pass: this list.  Later passes: previous value. */\n      if (list == null) {\n        list = this;\n      }\n      else\n      {\n        if (NamedList.class.isInstance(value)) {\n          list = (NamedList<T>) value;\n        } else {\n          value = null;\n          break;\n        }\n      }\n      value = list.get(key);\n    }\n    return value;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"62126a2398119ce2a86e01db19c6d1c84e2b9d03":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["09cb84e8f7cc3f05b42efa917e6377e8909c74b5"],"09cb84e8f7cc3f05b42efa917e6377e8909c74b5":["62126a2398119ce2a86e01db19c6d1c84e2b9d03"]},"commit2Childs":{"62126a2398119ce2a86e01db19c6d1c84e2b9d03":["09cb84e8f7cc3f05b42efa917e6377e8909c74b5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["62126a2398119ce2a86e01db19c6d1c84e2b9d03"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"09cb84e8f7cc3f05b42efa917e6377e8909c74b5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}