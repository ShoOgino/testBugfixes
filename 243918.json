{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperationsLight#minimizeHopcroft(LightAutomaton).mjava","commits":[{"id":"ac34f0c5bb9274821fb0cb18075234e02002e9bf","date":1402508126,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperationsLight#minimizeHopcroft(LightAutomaton).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static LightAutomaton minimizeHopcroft(LightAutomaton a) {\n    if (a.isEmpty()) {\n      return new LightAutomaton();\n    }\n    a = BasicOperations.determinize(a);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      LightAutomaton.Transition t = new LightAutomaton.Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = a.totalize();\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    LightAutomaton result = new LightAutomaton();\n\n    LightAutomaton.Transition t = new LightAutomaton.Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    // nocommit maybe LA should be born already with the initial state?\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finish();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return BasicOperations.removeDeadTransitions(result);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c8cfaac638acc80d26d08288440ede37e6539e9","date":1402678000,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperationsLight#minimizeHopcroft(LightAutomaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperationsLight#minimizeHopcroft(LightAutomaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static LightAutomaton minimizeHopcroft(LightAutomaton a) {\n    if (a.isEmpty()) {\n      return new LightAutomaton();\n    }\n    a = BasicOperations.determinize(a);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = a.totalize();\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    LightAutomaton result = new LightAutomaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    // nocommit maybe LA should be born already with the initial state?\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finish();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return BasicOperations.removeDeadTransitions(result);\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static LightAutomaton minimizeHopcroft(LightAutomaton a) {\n    if (a.isEmpty()) {\n      return new LightAutomaton();\n    }\n    a = BasicOperations.determinize(a);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      LightAutomaton.Transition t = new LightAutomaton.Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = a.totalize();\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    LightAutomaton result = new LightAutomaton();\n\n    LightAutomaton.Transition t = new LightAutomaton.Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    // nocommit maybe LA should be born already with the initial state?\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finish();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return BasicOperations.removeDeadTransitions(result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a67285d1a68175d877eb9fd1624fccad3db028ff","date":1402779028,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperationsLight#minimizeHopcroft(LightAutomaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperationsLight#minimizeHopcroft(LightAutomaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static LightAutomaton minimizeHopcroft(LightAutomaton a) {\n    if (a.isEmpty()) {\n      return new LightAutomaton();\n    }\n    a = BasicOperations.determinize(a);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = a.totalize();\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    LightAutomaton result = new LightAutomaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    // nocommit maybe LA should be born already with the initial state?\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finish();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return BasicOperations.removeDeadStates(result);\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static LightAutomaton minimizeHopcroft(LightAutomaton a) {\n    if (a.isEmpty()) {\n      return new LightAutomaton();\n    }\n    a = BasicOperations.determinize(a);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = a.totalize();\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    LightAutomaton result = new LightAutomaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    // nocommit maybe LA should be born already with the initial state?\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finish();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return BasicOperations.removeDeadTransitions(result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9","date":1402946522,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperationsLight#minimizeHopcroft(LightAutomaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperationsLight#minimizeHopcroft(LightAutomaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static LightAutomaton minimizeHopcroft(LightAutomaton a) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new LightAutomaton();\n    }\n    a = BasicOperations.determinize(a);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = a.totalize();\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    LightAutomaton result = new LightAutomaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return BasicOperations.removeDeadStates(result);\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static LightAutomaton minimizeHopcroft(LightAutomaton a) {\n    if (a.isEmpty()) {\n      return new LightAutomaton();\n    }\n    a = BasicOperations.determinize(a);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = a.totalize();\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    LightAutomaton result = new LightAutomaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    // nocommit maybe LA should be born already with the initial state?\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finish();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return BasicOperations.removeDeadStates(result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperationsLight#minimizeHopcroft(LightAutomaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static Automaton minimizeHopcroft(Automaton a) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new Automaton();\n    }\n    a = Operations.determinize(a);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = a.totalize();\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    Automaton result = new Automaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return Operations.removeDeadStates(result);\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static LightAutomaton minimizeHopcroft(LightAutomaton a) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new LightAutomaton();\n    }\n    a = BasicOperations.determinize(a);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = a.totalize();\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    LightAutomaton result = new LightAutomaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return BasicOperations.removeDeadStates(result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["a67285d1a68175d877eb9fd1624fccad3db028ff"],"a67285d1a68175d877eb9fd1624fccad3db028ff":["0c8cfaac638acc80d26d08288440ede37e6539e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"0c8cfaac638acc80d26d08288440ede37e6539e9":["ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"a67285d1a68175d877eb9fd1624fccad3db028ff":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ac34f0c5bb9274821fb0cb18075234e02002e9bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":[],"0c8cfaac638acc80d26d08288440ede37e6539e9":["a67285d1a68175d877eb9fd1624fccad3db028ff"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["0c8cfaac638acc80d26d08288440ede37e6539e9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}