{"path":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    // in this first phase, request only the unique key field\n    // and any fields needed for merging.\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    if ( (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES)!=0 || rb.getSortSpec().includesScore()) {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName() + \",score\");\n    } else {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());      \n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    // in this first phase, request only the unique key field\n    // and any fields needed for merging.\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    if ( (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES)!=0 || rb.getSortSpec().includesScore()) {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName() + \",score\");\n    } else {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());      \n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    // in this first phase, request only the unique key field\n    // and any fields needed for merging.\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    if ( (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES)!=0 || rb.getSortSpec().includesScore()) {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName() + \",score\");\n    } else {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());      \n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    // in this first phase, request only the unique key field\n    // and any fields needed for merging.\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    if ( (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES)!=0 || rb.getSortSpec().includesScore()) {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName() + \",score\");\n    } else {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());      \n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    // in this first phase, request only the unique key field\n    // and any fields needed for merging.\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    if ( (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES)!=0 || rb.getSortSpec().includesScore()) {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName() + \",score\");\n    } else {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());      \n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    // in this first phase, request only the unique key field\n    // and any fields needed for merging.\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    if ( (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES)!=0 || rb.getSortSpec().includesScore()) {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName() + \",score\");\n    } else {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());      \n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6446ce810056afd1a06b7a7239ec3cb3b65e31e","date":1393220603,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    if(fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    // in this first phase, request only the unique key field\n    // and any fields needed for merging.\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    if ( (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES)!=0 || rb.getSortSpec().includesScore()) {\n      sreq.params.set(CommonParams.FL, keyFieldName + \",score\");\n    } else {\n      sreq.params.set(CommonParams.FL, keyFieldName);\n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    // in this first phase, request only the unique key field\n    // and any fields needed for merging.\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    if ( (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES)!=0 || rb.getSortSpec().includesScore()) {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName() + \",score\");\n    } else {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());      \n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","date":1393532551,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    if(fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    // in this first phase, request only the unique key field\n    // and any fields needed for merging.\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    if ( (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES)!=0 || rb.getSortSpec().includesScore()) {\n      sreq.params.set(CommonParams.FL, keyFieldName + \",score\");\n    } else {\n      sreq.params.set(CommonParams.FL, keyFieldName);\n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    // in this first phase, request only the unique key field\n    // and any fields needed for merging.\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    if ( (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES)!=0 || rb.getSortSpec().includesScore()) {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName() + \",score\");\n    } else {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());      \n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ba39ba201a572fd944ed71d888de0cd4f2957af","date":1404307334,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames()))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    if (distribSinglePass) {\n      String fl = rb.req.getParams().get(CommonParams.FL);\n      if (fl == null) {\n        if (fields.getRequestedFieldNames() == null && fields.wantsAllFields()) {\n          fl = \"*\";\n        } else  {\n          fl = \"\";\n          for (String s : fields.getRequestedFieldNames()) {\n            fl += s + \",\";\n          }\n        }\n      }\n      if (!fields.wantsField(keyFieldName))  {\n        // the user has not requested the unique key but\n        // we still need to add it otherwise mergeIds can't work\n        if (fl.endsWith(\",\")) {\n          fl += keyFieldName;\n        } else  {\n          fl += \",\" + keyFieldName;\n        }\n      }\n      sreq.params.set(CommonParams.FL, updateFl(fl, shardQueryIncludeScore));\n    } else {\n      // in this first phase, request only the unique key field and any fields needed for merging.\n      if (shardQueryIncludeScore) {\n        sreq.params.set(CommonParams.FL, keyFieldName + \",score\");\n      } else {\n        sreq.params.set(CommonParams.FL, keyFieldName);\n      }\n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    if(fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    // in this first phase, request only the unique key field\n    // and any fields needed for merging.\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    if ( (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES)!=0 || rb.getSortSpec().includesScore()) {\n      sreq.params.set(CommonParams.FL, keyFieldName + \",score\");\n    } else {\n      sreq.params.set(CommonParams.FL, keyFieldName);\n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":null,"bugIntro":["659bd5da21bf2e51b42e1ad49c7107ad4ff1803f","575cbc4cfd0766ac94f3329777fc87ad16bace2f","0fd29060ef78d73cb2d3f2ba2b318785363e3a4e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"659bd5da21bf2e51b42e1ad49c7107ad4ff1803f","date":1412786163,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    if (distribSinglePass) {\n      String fl = rb.req.getParams().get(CommonParams.FL);\n      if (fl == null) {\n        if (fields.getRequestedFieldNames() == null && fields.wantsAllFields()) {\n          fl = \"*\";\n        } else  {\n          fl = \"\";\n          for (String s : fields.getRequestedFieldNames()) {\n            fl += s + \",\";\n          }\n        }\n      }\n      if (!fields.wantsField(keyFieldName))  {\n        // the user has not requested the unique key but\n        // we still need to add it otherwise mergeIds can't work\n        if (fl.endsWith(\",\")) {\n          fl += keyFieldName;\n        } else  {\n          fl += \",\" + keyFieldName;\n        }\n      }\n      sreq.params.set(CommonParams.FL, updateFl(fl, shardQueryIncludeScore));\n    } else {\n      // in this first phase, request only the unique key field and any fields needed for merging.\n      if (shardQueryIncludeScore) {\n        sreq.params.set(CommonParams.FL, keyFieldName + \",score\");\n      } else {\n        sreq.params.set(CommonParams.FL, keyFieldName);\n      }\n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames()))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    if (distribSinglePass) {\n      String fl = rb.req.getParams().get(CommonParams.FL);\n      if (fl == null) {\n        if (fields.getRequestedFieldNames() == null && fields.wantsAllFields()) {\n          fl = \"*\";\n        } else  {\n          fl = \"\";\n          for (String s : fields.getRequestedFieldNames()) {\n            fl += s + \",\";\n          }\n        }\n      }\n      if (!fields.wantsField(keyFieldName))  {\n        // the user has not requested the unique key but\n        // we still need to add it otherwise mergeIds can't work\n        if (fl.endsWith(\",\")) {\n          fl += keyFieldName;\n        } else  {\n          fl += \",\" + keyFieldName;\n        }\n      }\n      sreq.params.set(CommonParams.FL, updateFl(fl, shardQueryIncludeScore));\n    } else {\n      // in this first phase, request only the unique key field and any fields needed for merging.\n      if (shardQueryIncludeScore) {\n        sreq.params.set(CommonParams.FL, keyFieldName + \",score\");\n      } else {\n        sreq.params.set(CommonParams.FL, keyFieldName);\n      }\n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":["5ba39ba201a572fd944ed71d888de0cd4f2957af"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    if (distribSinglePass) {\n      String fl = rb.req.getParams().get(CommonParams.FL);\n      if (fl == null) {\n        if (fields.getRequestedFieldNames() == null && fields.wantsAllFields()) {\n          fl = \"*\";\n        } else  {\n          fl = \"\";\n          for (String s : fields.getRequestedFieldNames()) {\n            fl += s + \",\";\n          }\n        }\n      }\n      if (!fields.wantsField(keyFieldName))  {\n        // the user has not requested the unique key but\n        // we still need to add it otherwise mergeIds can't work\n        if (fl.endsWith(\",\")) {\n          fl += keyFieldName;\n        } else  {\n          fl += \",\" + keyFieldName;\n        }\n      }\n      sreq.params.set(CommonParams.FL, updateFl(fl, shardQueryIncludeScore));\n    } else {\n      // in this first phase, request only the unique key field and any fields needed for merging.\n      if (shardQueryIncludeScore) {\n        sreq.params.set(CommonParams.FL, keyFieldName + \",score\");\n      } else {\n        sreq.params.set(CommonParams.FL, keyFieldName);\n      }\n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames()))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    if (distribSinglePass) {\n      String fl = rb.req.getParams().get(CommonParams.FL);\n      if (fl == null) {\n        if (fields.getRequestedFieldNames() == null && fields.wantsAllFields()) {\n          fl = \"*\";\n        } else  {\n          fl = \"\";\n          for (String s : fields.getRequestedFieldNames()) {\n            fl += s + \",\";\n          }\n        }\n      }\n      if (!fields.wantsField(keyFieldName))  {\n        // the user has not requested the unique key but\n        // we still need to add it otherwise mergeIds can't work\n        if (fl.endsWith(\",\")) {\n          fl += keyFieldName;\n        } else  {\n          fl += \",\" + keyFieldName;\n        }\n      }\n      sreq.params.set(CommonParams.FL, updateFl(fl, shardQueryIncludeScore));\n    } else {\n      // in this first phase, request only the unique key field and any fields needed for merging.\n      if (shardQueryIncludeScore) {\n        sreq.params.set(CommonParams.FL, keyFieldName + \",score\");\n      } else {\n        sreq.params.set(CommonParams.FL, keyFieldName);\n      }\n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0fd29060ef78d73cb2d3f2ba2b318785363e3a4e","date":1417529075,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    if (distribSinglePass) {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n    }\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (!distribSinglePass || !fields.wantsField(keyFieldName)) \n      additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n    if ((!distribSinglePass || !fields.wantsScore()) && shardQueryIncludeScore) \n      additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    if (distribSinglePass) {\n      String fl = rb.req.getParams().get(CommonParams.FL);\n      if (fl == null) {\n        if (fields.getRequestedFieldNames() == null && fields.wantsAllFields()) {\n          fl = \"*\";\n        } else  {\n          fl = \"\";\n          for (String s : fields.getRequestedFieldNames()) {\n            fl += s + \",\";\n          }\n        }\n      }\n      if (!fields.wantsField(keyFieldName))  {\n        // the user has not requested the unique key but\n        // we still need to add it otherwise mergeIds can't work\n        if (fl.endsWith(\",\")) {\n          fl += keyFieldName;\n        } else  {\n          fl += \",\" + keyFieldName;\n        }\n      }\n      sreq.params.set(CommonParams.FL, updateFl(fl, shardQueryIncludeScore));\n    } else {\n      // in this first phase, request only the unique key field and any fields needed for merging.\n      if (shardQueryIncludeScore) {\n        sreq.params.set(CommonParams.FL, keyFieldName + \",score\");\n      } else {\n        sreq.params.set(CommonParams.FL, keyFieldName);\n      }\n    }\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":["5ba39ba201a572fd944ed71d888de0cd4f2957af","5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"bugIntro":["575cbc4cfd0766ac94f3329777fc87ad16bace2f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a94e45463a0089149b0d148ae5369140e7f54b8c","date":1419231934,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n    if ( (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES)!=0 || rb.getSortSpec().includesScore()) {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName() + \",score\");\n      StatsCache statsCache = rb.req.getCore().getStatsCache();\n      statsCache.sendGlobalStats(rb, sreq);\n    }\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    if (distribSinglePass) {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n    }\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (!distribSinglePass || !fields.wantsField(keyFieldName)) \n      additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n    if ((!distribSinglePass || !fields.wantsScore()) && shardQueryIncludeScore) \n      additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    if (distribSinglePass) {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n    }\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (!distribSinglePass || !fields.wantsField(keyFieldName)) \n      additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n    if ((!distribSinglePass || !fields.wantsScore()) && shardQueryIncludeScore) \n      additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":null,"bugIntro":["575cbc4cfd0766ac94f3329777fc87ad16bace2f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a05704e317032f0bcc6bc978b6c6c5af1cba5cd9","date":1424933272,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    if (shardQueryIncludeScore) {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName() + \",score\");\n      StatsCache statsCache = rb.req.getCore().getStatsCache();\n      statsCache.sendGlobalStats(rb, sreq);\n    } else  {\n      // reset so that only unique key is requested in shard requests\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());\n    }\n\n    if (distribSinglePass) {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n    }\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (!distribSinglePass || !fields.wantsField(keyFieldName))\n      additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n    if ((!distribSinglePass || !fields.wantsScore()) && shardQueryIncludeScore) \n      additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n    if ( (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES)!=0 || rb.getSortSpec().includesScore()) {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName() + \",score\");\n      StatsCache statsCache = rb.req.getCore().getStatsCache();\n      statsCache.sendGlobalStats(rb, sreq);\n    }\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    if (distribSinglePass) {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n    }\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (!distribSinglePass || !fields.wantsField(keyFieldName)) \n      additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n    if ((!distribSinglePass || !fields.wantsScore()) && shardQueryIncludeScore) \n      additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":null,"bugIntro":["575cbc4cfd0766ac94f3329777fc87ad16bace2f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"575cbc4cfd0766ac94f3329777fc87ad16bace2f","date":1425052207,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (distribSinglePass)  {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n        if (!fields.wantsField(keyFieldName))  {\n          additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n        }\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n      if (!fields.wantsScore() && shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    } else {\n      // reset so that only unique key is requested in shard requests\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());\n      if (shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    }\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n\n    if (shardQueryIncludeScore) {\n      StatsCache statsCache = rb.req.getCore().getStatsCache();\n      statsCache.sendGlobalStats(rb, sreq);\n    }\n\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    if (shardQueryIncludeScore) {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName() + \",score\");\n      StatsCache statsCache = rb.req.getCore().getStatsCache();\n      statsCache.sendGlobalStats(rb, sreq);\n    } else  {\n      // reset so that only unique key is requested in shard requests\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());\n    }\n\n    if (distribSinglePass) {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n    }\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (!distribSinglePass || !fields.wantsField(keyFieldName))\n      additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n    if ((!distribSinglePass || !fields.wantsScore()) && shardQueryIncludeScore) \n      additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":["a94e45463a0089149b0d148ae5369140e7f54b8c","0fd29060ef78d73cb2d3f2ba2b318785363e3a4e","a05704e317032f0bcc6bc978b6c6c5af1cba5cd9","5ba39ba201a572fd944ed71d888de0cd4f2957af"],"bugIntro":["df72a23fb74bebe914e3f3972063a884327c0436"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (distribSinglePass)  {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n        if (!fields.wantsField(keyFieldName))  {\n          additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n        }\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n      if (!fields.wantsScore() && shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    } else {\n      // reset so that only unique key is requested in shard requests\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());\n      if (shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    }\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n\n    if (shardQueryIncludeScore) {\n      StatsCache statsCache = rb.req.getCore().getStatsCache();\n      statsCache.sendGlobalStats(rb, sreq);\n    }\n\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n    if ( (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES)!=0 || rb.getSortSpec().includesScore()) {\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName() + \",score\");\n      StatsCache statsCache = rb.req.getCore().getStatsCache();\n      statsCache.sendGlobalStats(rb, sreq);\n    }\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    if (distribSinglePass) {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n    }\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (!distribSinglePass || !fields.wantsField(keyFieldName)) \n      additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n    if ((!distribSinglePass || !fields.wantsScore()) && shardQueryIncludeScore) \n      additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"35d59689803f4ad27f96148bb7c7167e373c6770","date":1454297137,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  protected void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (distribSinglePass)  {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n        if (!fields.wantsField(keyFieldName))  {\n          additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n        }\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n      if (!fields.wantsScore() && shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    } else {\n      // reset so that only unique key is requested in shard requests\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());\n      if (shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    }\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n\n    if (shardQueryIncludeScore) {\n      StatsCache statsCache = rb.req.getCore().getStatsCache();\n      statsCache.sendGlobalStats(rb, sreq);\n    }\n\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (distribSinglePass)  {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n        if (!fields.wantsField(keyFieldName))  {\n          additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n        }\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n      if (!fields.wantsScore() && shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    } else {\n      // reset so that only unique key is requested in shard requests\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());\n      if (shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    }\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n\n    if (shardQueryIncludeScore) {\n      StatsCache statsCache = rb.req.getCore().getStatsCache();\n      statsCache.sendGlobalStats(rb, sreq);\n    }\n\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  protected void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (distribSinglePass)  {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n        if (!fields.wantsField(keyFieldName))  {\n          additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n        }\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n      if (!fields.wantsScore() && shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    } else {\n      // reset so that only unique key is requested in shard requests\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());\n      if (shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    }\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n\n    if (shardQueryIncludeScore) {\n      StatsCache statsCache = rb.req.getCore().getStatsCache();\n      statsCache.sendGlobalStats(rb, sreq);\n    }\n\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  private void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (distribSinglePass)  {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n        if (!fields.wantsField(keyFieldName))  {\n          additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n        }\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n      if (!fields.wantsScore() && shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    } else {\n      // reset so that only unique key is requested in shard requests\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());\n      if (shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    }\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n\n    if (shardQueryIncludeScore) {\n      StatsCache statsCache = rb.req.getCore().getStatsCache();\n      statsCache.sendGlobalStats(rb, sreq);\n    }\n\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1313c74c6d619d0d98d1284bc17513c9a4b40345","date":1562035273,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  protected void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      // what if rows<0 as it is allowed for grouped request??\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (distribSinglePass)  {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n        if (!fields.wantsField(keyFieldName))  {\n          additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n        }\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n      if (!fields.wantsScore() && shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    } else {\n      // reset so that only unique key is requested in shard requests\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());\n      if (shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    }\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n\n    if (shardQueryIncludeScore) {\n      StatsCache statsCache = rb.req.getCore().getStatsCache();\n      statsCache.sendGlobalStats(rb, sreq);\n    }\n\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  protected void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (distribSinglePass)  {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n        if (!fields.wantsField(keyFieldName))  {\n          additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n        }\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n      if (!fields.wantsScore() && shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    } else {\n      // reset so that only unique key is requested in shard requests\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());\n      if (shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    }\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n\n    if (shardQueryIncludeScore) {\n      StatsCache statsCache = rb.req.getCore().getStatsCache();\n      statsCache.sendGlobalStats(rb, sreq);\n    }\n\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"df72a23fb74bebe914e3f3972063a884327c0436","date":1570470832,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  protected void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      // what if rows<0 as it is allowed for grouped request??\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (distribSinglePass)  {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n        if (!fields.wantsField(keyFieldName))  {\n          additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n        }\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n      if (!fields.wantsScore() && shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    } else {\n      // reset so that only unique key is requested in shard requests\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());\n      if (shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    }\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n\n    if (shardQueryIncludeScore || rb.isDebug()) {\n      StatsCache statsCache = rb.req.getSearcher().getStatsCache();\n      sreq.purpose |= ShardRequest.PURPOSE_SET_TERM_STATS;\n      statsCache.sendGlobalStats(rb, sreq);\n    }\n\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  protected void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      // what if rows<0 as it is allowed for grouped request??\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (distribSinglePass)  {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n        if (!fields.wantsField(keyFieldName))  {\n          additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n        }\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n      if (!fields.wantsScore() && shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    } else {\n      // reset so that only unique key is requested in shard requests\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());\n      if (shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    }\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n\n    if (shardQueryIncludeScore) {\n      StatsCache statsCache = rb.req.getCore().getStatsCache();\n      statsCache.sendGlobalStats(rb, sreq);\n    }\n\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":["575cbc4cfd0766ac94f3329777fc87ad16bace2f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#createMainQuery(ResponseBuilder).mjava","sourceNew":"  protected void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      // what if rows<0 as it is allowed for grouped request??\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (distribSinglePass)  {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n        if (!fields.wantsField(keyFieldName))  {\n          additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n        }\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n      if (!fields.wantsScore() && shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    } else {\n      // reset so that only unique key is requested in shard requests\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());\n      if (shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    }\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n\n    if (shardQueryIncludeScore || rb.isDebug()) {\n      StatsCache statsCache = rb.req.getSearcher().getStatsCache();\n      sreq.purpose |= ShardRequest.PURPOSE_SET_TERM_STATS;\n      statsCache.sendGlobalStats(rb, sreq);\n    }\n\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","sourceOld":"  protected void createMainQuery(ResponseBuilder rb) {\n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;\n\n    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();\n\n    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score\n    ReturnFields fields = rb.rsp.getReturnFields();\n\n    // distrib.singlePass=true forces a one-pass query regardless of requested fields\n    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);\n\n    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)\n        && fields.getRequestedFieldNames() != null  \n        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, \"score\").containsAll(fields.getRequestedFieldNames())))) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;\n      rb.onePassDistributedQuery = true;\n    }\n\n    sreq.params = new ModifiableSolrParams(rb.req.getParams());\n    // TODO: base on current params or original params?\n\n    // don't pass through any shards param\n    sreq.params.remove(ShardParams.SHARDS);\n\n    // set the start (offset) to 0 for each shard request so we can properly merge\n    // results from the start.\n    if(rb.shards_start > -1) {\n      // if the client set shards.start set this explicitly\n      sreq.params.set(CommonParams.START,rb.shards_start);\n    } else {\n      sreq.params.set(CommonParams.START, \"0\");\n    }\n    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and\n    // perhaps we shouldn't attempt to parse the query at this level?\n    // Alternate Idea: instead of specifying all these things at the upper level,\n    // we could just specify that this is a shard request.\n    if(rb.shards_rows > -1) {\n      // if the client set shards.rows set this explicity\n      sreq.params.set(CommonParams.ROWS,rb.shards_rows);\n    } else {\n      // what if rows<0 as it is allowed for grouped request??\n      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());\n    }\n\n    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,\"true\");\n\n    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();\n    StringBuilder additionalFL = new StringBuilder();\n    boolean additionalAdded = false;\n    if (distribSinglePass)  {\n      String[] fls = rb.req.getParams().getParams(CommonParams.FL);\n      if (fls != null && fls.length > 0 && (fls.length != 1 || !fls[0].isEmpty())) {\n        // If the outer request contains actual FL's use them...\n        sreq.params.set(CommonParams.FL, fls);\n        if (!fields.wantsField(keyFieldName))  {\n          additionalAdded = addFL(additionalFL, keyFieldName, additionalAdded);\n        }\n      } else {\n        // ... else we need to explicitly ask for all fields, because we are going to add\n        // additional fields below\n        sreq.params.set(CommonParams.FL, \"*\");\n      }\n      if (!fields.wantsScore() && shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    } else {\n      // reset so that only unique key is requested in shard requests\n      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());\n      if (shardQueryIncludeScore) {\n        additionalAdded = addFL(additionalFL, \"score\", additionalAdded);\n      }\n    }\n\n    // TODO: should this really sendGlobalDfs if just includeScore?\n\n    if (shardQueryIncludeScore) {\n      StatsCache statsCache = rb.req.getCore().getStatsCache();\n      statsCache.sendGlobalStats(rb, sreq);\n    }\n\n    if (additionalAdded) sreq.params.add(CommonParams.FL, additionalFL.toString());\n\n    rb.addRequest(this, sreq);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1313c74c6d619d0d98d1284bc17513c9a4b40345":["35d59689803f4ad27f96148bb7c7167e373c6770"],"a05704e317032f0bcc6bc978b6c6c5af1cba5cd9":["a94e45463a0089149b0d148ae5369140e7f54b8c"],"659bd5da21bf2e51b42e1ad49c7107ad4ff1803f":["5ba39ba201a572fd944ed71d888de0cd4f2957af"],"55980207f1977bd1463465de1659b821347e2fa8":["5ba39ba201a572fd944ed71d888de0cd4f2957af","659bd5da21bf2e51b42e1ad49c7107ad4ff1803f"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"575cbc4cfd0766ac94f3329777fc87ad16bace2f":["a05704e317032f0bcc6bc978b6c6c5af1cba5cd9"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["575cbc4cfd0766ac94f3329777fc87ad16bace2f","35d59689803f4ad27f96148bb7c7167e373c6770"],"df72a23fb74bebe914e3f3972063a884327c0436":["1313c74c6d619d0d98d1284bc17513c9a4b40345"],"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8":["c26f00b574427b55127e869b935845554afde1fa","a6446ce810056afd1a06b7a7239ec3cb3b65e31e"],"a6446ce810056afd1a06b7a7239ec3cb3b65e31e":["c26f00b574427b55127e869b935845554afde1fa"],"a94e45463a0089149b0d148ae5369140e7f54b8c":["0fd29060ef78d73cb2d3f2ba2b318785363e3a4e"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a94e45463a0089149b0d148ae5369140e7f54b8c","575cbc4cfd0766ac94f3329777fc87ad16bace2f"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"35d59689803f4ad27f96148bb7c7167e373c6770":["575cbc4cfd0766ac94f3329777fc87ad16bace2f"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0fd29060ef78d73cb2d3f2ba2b318785363e3a4e":["659bd5da21bf2e51b42e1ad49c7107ad4ff1803f"],"5ba39ba201a572fd944ed71d888de0cd4f2957af":["a6446ce810056afd1a06b7a7239ec3cb3b65e31e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["df72a23fb74bebe914e3f3972063a884327c0436"],"b0b597c65628ca9e73913a07e81691f8229bae35":["1313c74c6d619d0d98d1284bc17513c9a4b40345","df72a23fb74bebe914e3f3972063a884327c0436"]},"commit2Childs":{"1313c74c6d619d0d98d1284bc17513c9a4b40345":["df72a23fb74bebe914e3f3972063a884327c0436","b0b597c65628ca9e73913a07e81691f8229bae35"],"a05704e317032f0bcc6bc978b6c6c5af1cba5cd9":["575cbc4cfd0766ac94f3329777fc87ad16bace2f"],"659bd5da21bf2e51b42e1ad49c7107ad4ff1803f":["55980207f1977bd1463465de1659b821347e2fa8","0fd29060ef78d73cb2d3f2ba2b318785363e3a4e"],"55980207f1977bd1463465de1659b821347e2fa8":[],"c26f00b574427b55127e869b935845554afde1fa":["13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","a6446ce810056afd1a06b7a7239ec3cb3b65e31e"],"575cbc4cfd0766ac94f3329777fc87ad16bace2f":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","35d59689803f4ad27f96148bb7c7167e373c6770"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"df72a23fb74bebe914e3f3972063a884327c0436":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8":[],"a6446ce810056afd1a06b7a7239ec3cb3b65e31e":["13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","5ba39ba201a572fd944ed71d888de0cd4f2957af"],"a94e45463a0089149b0d148ae5369140e7f54b8c":["a05704e317032f0bcc6bc978b6c6c5af1cba5cd9","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"35d59689803f4ad27f96148bb7c7167e373c6770":["1313c74c6d619d0d98d1284bc17513c9a4b40345","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"5ba39ba201a572fd944ed71d888de0cd4f2957af":["659bd5da21bf2e51b42e1ad49c7107ad4ff1803f","55980207f1977bd1463465de1659b821347e2fa8"],"0fd29060ef78d73cb2d3f2ba2b318785363e3a4e":["a94e45463a0089149b0d148ae5369140e7f54b8c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","1e6acbaae7af722f17204ceccf0f7db5753eccf3","13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}