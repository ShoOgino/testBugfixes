{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#Vector(double,double,double,double,double,double).mjava","commits":[{"id":"6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1","date":1518533584,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#Vector(double,double,double,double,double,double).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Construct a vector that is perpendicular to\n   * two other (non-zero) vectors.  If the vectors are parallel,\n   * IllegalArgumentException will be thrown.\n   * Produces a normalized final vector.\n   *\n   * @param AX is the X value of the first \n   * @param AY is the Y value of the first\n   * @param AZ is the Z value of the first\n   * @param BX is the X value of the second \n   * @param BY is the Y value of the second\n   * @param BZ is the Z value of the second\n   */\n  public Vector(final double AX, final double AY, final double AZ, final double BX, final double BY, final double BZ) {\n    // We're really looking at two vectors and computing a perpendicular one from that.\n    // We can think of this as having three points -- the origin, and two points that aren't the origin.\n    // Normally, we can compute the perpendicular vector this way:\n    // x = u2v3 - u3v2\n    // y = u3v1 - u1v3\n    // z = u1v2 - u2v1\n    // Sometimes that produces a plane that does not contain the original three points, however, due to\n    // numerical precision issues.  Then we continue making the answer more precise using the\n    // Gram-Schmidt process: https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process\n    \n    // Compute the naive perpendicular\n    final double thisX = AY * BZ - AZ * BY;\n    final double thisY = AZ * BX - AX * BZ;\n    final double thisZ = AX * BY - AY * BX;\n    \n    final double magnitude = magnitude(thisX, thisY, thisZ);\n    if (magnitude < MINIMUM_RESOLUTION) {\n      throw new IllegalArgumentException(\"Degenerate/parallel vector constructed\");\n    }\n    \n    final double inverseMagnitude = 1.0/magnitude;\n    \n    double normalizeX = thisX * inverseMagnitude;\n    double normalizeY = thisY * inverseMagnitude;\n    double normalizeZ = thisZ * inverseMagnitude;\n    // For a plane to work, the dot product between the normal vector\n    // and the points needs to be less than the minimum resolution.\n    // This is sometimes not true for points that are very close. Therefore\n    // we need to adjust\n    int i = 0;\n    while (true) {\n      final double currentDotProdA = AX * normalizeX + AY * normalizeY + AZ * normalizeZ;\n      final double currentDotProdB = BX * normalizeX + BY * normalizeY + BZ * normalizeZ;\n      if (Math.abs(currentDotProdA) < MINIMUM_RESOLUTION && Math.abs(currentDotProdB) < MINIMUM_RESOLUTION) {\n        break;\n      }\n      // Converge on the one that has largest dot product\n      final double currentVectorX;\n      final double currentVectorY;\n      final double currentVectorZ;\n      final double currentDotProd;\n      if (Math.abs(currentDotProdA) > Math.abs(currentDotProdB)) {\n        currentVectorX = AX;\n        currentVectorY = AY;\n        currentVectorZ = AZ;\n        currentDotProd = currentDotProdA;\n      } else {\n        currentVectorX = BX;\n        currentVectorY = BY;\n        currentVectorZ = BZ;\n        currentDotProd = currentDotProdB;\n      }\n\n      // Adjust\n      normalizeX = normalizeX - currentDotProd * currentVectorX;\n      normalizeY = normalizeY - currentDotProd * currentVectorY;\n      normalizeZ = normalizeZ - currentDotProd * currentVectorZ;\n      // Normalize\n      final double correctedMagnitude = magnitude(normalizeX, normalizeY, normalizeZ);\n      final double inverseCorrectedMagnitude = 1.0 / correctedMagnitude;\n      normalizeX = normalizeX * inverseCorrectedMagnitude;\n      normalizeY = normalizeY * inverseCorrectedMagnitude;\n      normalizeZ = normalizeZ * inverseCorrectedMagnitude;\n      //This is  probably not needed as the method seems to converge\n      //quite quickly. But it is safer to have a way out.\n      if (i++ > 10) {\n        throw new IllegalArgumentException(\"Plane could not be constructed! Could not find a normal vector.\");\n      }\n    }\n    this.x = normalizeX;\n    this.y = normalizeY;\n    this.z = normalizeZ;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["566f5a2735bf9ff5bc8467c9cdfba990e135ecae"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6c5ec98cafd4cdf3b8d5a3a4277183c05c4fa3f3","date":1518535873,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#Vector(double,double,double,double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#Vector(double,double,double,double,double,double).mjava","sourceNew":"  /**\n   * Construct a vector that is perpendicular to\n   * two other (non-zero) vectors.  If the vectors are parallel,\n   * IllegalArgumentException will be thrown.\n   * Produces a normalized final vector.\n   *\n   * @param AX is the X value of the first \n   * @param AY is the Y value of the first\n   * @param AZ is the Z value of the first\n   * @param BX is the X value of the second \n   * @param BY is the Y value of the second\n   * @param BZ is the Z value of the second\n   */\n  public Vector(final double AX, final double AY, final double AZ, final double BX, final double BY, final double BZ) {\n    // We're really looking at two vectors and computing a perpendicular one from that.\n    // We can think of this as having three points -- the origin, and two points that aren't the origin.\n    // Normally, we can compute the perpendicular vector this way:\n    // x = u2v3 - u3v2\n    // y = u3v1 - u1v3\n    // z = u1v2 - u2v1\n    // Sometimes that produces a plane that does not contain the original three points, however, due to\n    // numerical precision issues.  Then we continue making the answer more precise using the\n    // Gram-Schmidt process: https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process\n    \n    // Compute the naive perpendicular\n    final double thisX = AY * BZ - AZ * BY;\n    final double thisY = AZ * BX - AX * BZ;\n    final double thisZ = AX * BY - AY * BX;\n    \n    final double magnitude = magnitude(thisX, thisY, thisZ);\n    if (magnitude == 0.0) {\n      throw new IllegalArgumentException(\"Degenerate/parallel vector constructed\");\n    }\n    final double inverseMagnitude = 1.0/magnitude;\n    \n    double normalizeX = thisX * inverseMagnitude;\n    double normalizeY = thisY * inverseMagnitude;\n    double normalizeZ = thisZ * inverseMagnitude;\n    // For a plane to work, the dot product between the normal vector\n    // and the points needs to be less than the minimum resolution.\n    // This is sometimes not true for points that are very close. Therefore\n    // we need to adjust\n    int i = 0;\n    while (true) {\n      final double currentDotProdA = AX * normalizeX + AY * normalizeY + AZ * normalizeZ;\n      final double currentDotProdB = BX * normalizeX + BY * normalizeY + BZ * normalizeZ;\n      if (Math.abs(currentDotProdA) < MINIMUM_RESOLUTION && Math.abs(currentDotProdB) < MINIMUM_RESOLUTION) {\n        break;\n      }\n      // Converge on the one that has largest dot product\n      final double currentVectorX;\n      final double currentVectorY;\n      final double currentVectorZ;\n      final double currentDotProd;\n      if (Math.abs(currentDotProdA) > Math.abs(currentDotProdB)) {\n        currentVectorX = AX;\n        currentVectorY = AY;\n        currentVectorZ = AZ;\n        currentDotProd = currentDotProdA;\n      } else {\n        currentVectorX = BX;\n        currentVectorY = BY;\n        currentVectorZ = BZ;\n        currentDotProd = currentDotProdB;\n      }\n\n      // Adjust\n      normalizeX = normalizeX - currentDotProd * currentVectorX;\n      normalizeY = normalizeY - currentDotProd * currentVectorY;\n      normalizeZ = normalizeZ - currentDotProd * currentVectorZ;\n      // Normalize\n      final double correctedMagnitude = magnitude(normalizeX, normalizeY, normalizeZ);\n      final double inverseCorrectedMagnitude = 1.0 / correctedMagnitude;\n      normalizeX = normalizeX * inverseCorrectedMagnitude;\n      normalizeY = normalizeY * inverseCorrectedMagnitude;\n      normalizeZ = normalizeZ * inverseCorrectedMagnitude;\n      //This is  probably not needed as the method seems to converge\n      //quite quickly. But it is safer to have a way out.\n      if (i++ > 10) {\n        throw new IllegalArgumentException(\"Plane could not be constructed! Could not find a normal vector.\");\n      }\n    }\n    this.x = normalizeX;\n    this.y = normalizeY;\n    this.z = normalizeZ;\n  }\n\n","sourceOld":"  /**\n   * Construct a vector that is perpendicular to\n   * two other (non-zero) vectors.  If the vectors are parallel,\n   * IllegalArgumentException will be thrown.\n   * Produces a normalized final vector.\n   *\n   * @param AX is the X value of the first \n   * @param AY is the Y value of the first\n   * @param AZ is the Z value of the first\n   * @param BX is the X value of the second \n   * @param BY is the Y value of the second\n   * @param BZ is the Z value of the second\n   */\n  public Vector(final double AX, final double AY, final double AZ, final double BX, final double BY, final double BZ) {\n    // We're really looking at two vectors and computing a perpendicular one from that.\n    // We can think of this as having three points -- the origin, and two points that aren't the origin.\n    // Normally, we can compute the perpendicular vector this way:\n    // x = u2v3 - u3v2\n    // y = u3v1 - u1v3\n    // z = u1v2 - u2v1\n    // Sometimes that produces a plane that does not contain the original three points, however, due to\n    // numerical precision issues.  Then we continue making the answer more precise using the\n    // Gram-Schmidt process: https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process\n    \n    // Compute the naive perpendicular\n    final double thisX = AY * BZ - AZ * BY;\n    final double thisY = AZ * BX - AX * BZ;\n    final double thisZ = AX * BY - AY * BX;\n    \n    final double magnitude = magnitude(thisX, thisY, thisZ);\n    if (magnitude < MINIMUM_RESOLUTION) {\n      throw new IllegalArgumentException(\"Degenerate/parallel vector constructed\");\n    }\n    \n    final double inverseMagnitude = 1.0/magnitude;\n    \n    double normalizeX = thisX * inverseMagnitude;\n    double normalizeY = thisY * inverseMagnitude;\n    double normalizeZ = thisZ * inverseMagnitude;\n    // For a plane to work, the dot product between the normal vector\n    // and the points needs to be less than the minimum resolution.\n    // This is sometimes not true for points that are very close. Therefore\n    // we need to adjust\n    int i = 0;\n    while (true) {\n      final double currentDotProdA = AX * normalizeX + AY * normalizeY + AZ * normalizeZ;\n      final double currentDotProdB = BX * normalizeX + BY * normalizeY + BZ * normalizeZ;\n      if (Math.abs(currentDotProdA) < MINIMUM_RESOLUTION && Math.abs(currentDotProdB) < MINIMUM_RESOLUTION) {\n        break;\n      }\n      // Converge on the one that has largest dot product\n      final double currentVectorX;\n      final double currentVectorY;\n      final double currentVectorZ;\n      final double currentDotProd;\n      if (Math.abs(currentDotProdA) > Math.abs(currentDotProdB)) {\n        currentVectorX = AX;\n        currentVectorY = AY;\n        currentVectorZ = AZ;\n        currentDotProd = currentDotProdA;\n      } else {\n        currentVectorX = BX;\n        currentVectorY = BY;\n        currentVectorZ = BZ;\n        currentDotProd = currentDotProdB;\n      }\n\n      // Adjust\n      normalizeX = normalizeX - currentDotProd * currentVectorX;\n      normalizeY = normalizeY - currentDotProd * currentVectorY;\n      normalizeZ = normalizeZ - currentDotProd * currentVectorZ;\n      // Normalize\n      final double correctedMagnitude = magnitude(normalizeX, normalizeY, normalizeZ);\n      final double inverseCorrectedMagnitude = 1.0 / correctedMagnitude;\n      normalizeX = normalizeX * inverseCorrectedMagnitude;\n      normalizeY = normalizeY * inverseCorrectedMagnitude;\n      normalizeZ = normalizeZ * inverseCorrectedMagnitude;\n      //This is  probably not needed as the method seems to converge\n      //quite quickly. But it is safer to have a way out.\n      if (i++ > 10) {\n        throw new IllegalArgumentException(\"Plane could not be constructed! Could not find a normal vector.\");\n      }\n    }\n    this.x = normalizeX;\n    this.y = normalizeY;\n    this.z = normalizeZ;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"566f5a2735bf9ff5bc8467c9cdfba990e135ecae","date":1518559218,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#Vector(double,double,double,double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#Vector(double,double,double,double,double,double).mjava","sourceNew":"  /**\n   * Construct a vector that is perpendicular to\n   * two other (non-zero) vectors.  If the vectors are parallel,\n   * IllegalArgumentException will be thrown.\n   * Produces a normalized final vector.\n   *\n   * @param AX is the X value of the first \n   * @param AY is the Y value of the first\n   * @param AZ is the Z value of the first\n   * @param BX is the X value of the second \n   * @param BY is the Y value of the second\n   * @param BZ is the Z value of the second\n   */\n  public Vector(final double AX, final double AY, final double AZ, final double BX, final double BY, final double BZ) {\n    // We're really looking at two vectors and computing a perpendicular one from that.\n    // We can think of this as having three points -- the origin, and two points that aren't the origin.\n    // Normally, we can compute the perpendicular vector this way:\n    // x = u2v3 - u3v2\n    // y = u3v1 - u1v3\n    // z = u1v2 - u2v1\n    // Sometimes that produces a plane that does not contain the original three points, however, due to\n    // numerical precision issues.  Then we continue making the answer more precise using the\n    // Gram-Schmidt process: https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process\n    \n    // Compute the naive perpendicular\n    final double thisX = AY * BZ - AZ * BY;\n    final double thisY = AZ * BX - AX * BZ;\n    final double thisZ = AX * BY - AY * BX;\n    \n    final double magnitude = magnitude(thisX, thisY, thisZ);\n    if (magnitude == 0.0) {\n      throw new IllegalArgumentException(\"Degenerate/parallel vector constructed\");\n    }\n    final double inverseMagnitude = 1.0/magnitude;\n    \n    double normalizeX = thisX * inverseMagnitude;\n    double normalizeY = thisY * inverseMagnitude;\n    double normalizeZ = thisZ * inverseMagnitude;\n    // For a plane to work, the dot product between the normal vector\n    // and the points needs to be less than the minimum resolution.\n    // This is sometimes not true for points that are very close. Therefore\n    // we need to adjust\n    int i = 0;\n    while (true) {\n      final double currentDotProdA = AX * normalizeX + AY * normalizeY + AZ * normalizeZ;\n      final double currentDotProdB = BX * normalizeX + BY * normalizeY + BZ * normalizeZ;\n      if (Math.abs(currentDotProdA) < MINIMUM_GRAM_SCHMIDT_ENVELOPE && Math.abs(currentDotProdB) < MINIMUM_GRAM_SCHMIDT_ENVELOPE) {\n        break;\n      }\n      // Converge on the one that has largest dot product\n      final double currentVectorX;\n      final double currentVectorY;\n      final double currentVectorZ;\n      final double currentDotProd;\n      if (Math.abs(currentDotProdA) > Math.abs(currentDotProdB)) {\n        currentVectorX = AX;\n        currentVectorY = AY;\n        currentVectorZ = AZ;\n        currentDotProd = currentDotProdA;\n      } else {\n        currentVectorX = BX;\n        currentVectorY = BY;\n        currentVectorZ = BZ;\n        currentDotProd = currentDotProdB;\n      }\n\n      // Adjust\n      normalizeX = normalizeX - currentDotProd * currentVectorX;\n      normalizeY = normalizeY - currentDotProd * currentVectorY;\n      normalizeZ = normalizeZ - currentDotProd * currentVectorZ;\n      // Normalize\n      final double correctedMagnitude = magnitude(normalizeX, normalizeY, normalizeZ);\n      final double inverseCorrectedMagnitude = 1.0 / correctedMagnitude;\n      normalizeX = normalizeX * inverseCorrectedMagnitude;\n      normalizeY = normalizeY * inverseCorrectedMagnitude;\n      normalizeZ = normalizeZ * inverseCorrectedMagnitude;\n      //This is  probably not needed as the method seems to converge\n      //quite quickly. But it is safer to have a way out.\n      if (i++ > 10) {\n        throw new IllegalArgumentException(\"Plane could not be constructed! Could not find a normal vector.\");\n      }\n    }\n    this.x = normalizeX;\n    this.y = normalizeY;\n    this.z = normalizeZ;\n  }\n\n","sourceOld":"  /**\n   * Construct a vector that is perpendicular to\n   * two other (non-zero) vectors.  If the vectors are parallel,\n   * IllegalArgumentException will be thrown.\n   * Produces a normalized final vector.\n   *\n   * @param AX is the X value of the first \n   * @param AY is the Y value of the first\n   * @param AZ is the Z value of the first\n   * @param BX is the X value of the second \n   * @param BY is the Y value of the second\n   * @param BZ is the Z value of the second\n   */\n  public Vector(final double AX, final double AY, final double AZ, final double BX, final double BY, final double BZ) {\n    // We're really looking at two vectors and computing a perpendicular one from that.\n    // We can think of this as having three points -- the origin, and two points that aren't the origin.\n    // Normally, we can compute the perpendicular vector this way:\n    // x = u2v3 - u3v2\n    // y = u3v1 - u1v3\n    // z = u1v2 - u2v1\n    // Sometimes that produces a plane that does not contain the original three points, however, due to\n    // numerical precision issues.  Then we continue making the answer more precise using the\n    // Gram-Schmidt process: https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process\n    \n    // Compute the naive perpendicular\n    final double thisX = AY * BZ - AZ * BY;\n    final double thisY = AZ * BX - AX * BZ;\n    final double thisZ = AX * BY - AY * BX;\n    \n    final double magnitude = magnitude(thisX, thisY, thisZ);\n    if (magnitude == 0.0) {\n      throw new IllegalArgumentException(\"Degenerate/parallel vector constructed\");\n    }\n    final double inverseMagnitude = 1.0/magnitude;\n    \n    double normalizeX = thisX * inverseMagnitude;\n    double normalizeY = thisY * inverseMagnitude;\n    double normalizeZ = thisZ * inverseMagnitude;\n    // For a plane to work, the dot product between the normal vector\n    // and the points needs to be less than the minimum resolution.\n    // This is sometimes not true for points that are very close. Therefore\n    // we need to adjust\n    int i = 0;\n    while (true) {\n      final double currentDotProdA = AX * normalizeX + AY * normalizeY + AZ * normalizeZ;\n      final double currentDotProdB = BX * normalizeX + BY * normalizeY + BZ * normalizeZ;\n      if (Math.abs(currentDotProdA) < MINIMUM_RESOLUTION && Math.abs(currentDotProdB) < MINIMUM_RESOLUTION) {\n        break;\n      }\n      // Converge on the one that has largest dot product\n      final double currentVectorX;\n      final double currentVectorY;\n      final double currentVectorZ;\n      final double currentDotProd;\n      if (Math.abs(currentDotProdA) > Math.abs(currentDotProdB)) {\n        currentVectorX = AX;\n        currentVectorY = AY;\n        currentVectorZ = AZ;\n        currentDotProd = currentDotProdA;\n      } else {\n        currentVectorX = BX;\n        currentVectorY = BY;\n        currentVectorZ = BZ;\n        currentDotProd = currentDotProdB;\n      }\n\n      // Adjust\n      normalizeX = normalizeX - currentDotProd * currentVectorX;\n      normalizeY = normalizeY - currentDotProd * currentVectorY;\n      normalizeZ = normalizeZ - currentDotProd * currentVectorZ;\n      // Normalize\n      final double correctedMagnitude = magnitude(normalizeX, normalizeY, normalizeZ);\n      final double inverseCorrectedMagnitude = 1.0 / correctedMagnitude;\n      normalizeX = normalizeX * inverseCorrectedMagnitude;\n      normalizeY = normalizeY * inverseCorrectedMagnitude;\n      normalizeZ = normalizeZ * inverseCorrectedMagnitude;\n      //This is  probably not needed as the method seems to converge\n      //quite quickly. But it is safer to have a way out.\n      if (i++ > 10) {\n        throw new IllegalArgumentException(\"Plane could not be constructed! Could not find a normal vector.\");\n      }\n    }\n    this.x = normalizeX;\n    this.y = normalizeY;\n    this.z = normalizeZ;\n  }\n\n","bugFix":["6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"566f5a2735bf9ff5bc8467c9cdfba990e135ecae":["6c5ec98cafd4cdf3b8d5a3a4277183c05c4fa3f3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c5ec98cafd4cdf3b8d5a3a4277183c05c4fa3f3":["6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1"],"6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["566f5a2735bf9ff5bc8467c9cdfba990e135ecae"]},"commit2Childs":{"566f5a2735bf9ff5bc8467c9cdfba990e135ecae":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1"],"6c5ec98cafd4cdf3b8d5a3a4277183c05c4fa3f3":["566f5a2735bf9ff5bc8467c9cdfba990e135ecae"],"6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1":["6c5ec98cafd4cdf3b8d5a3a4277183c05c4fa3f3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}