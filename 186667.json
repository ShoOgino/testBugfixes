{"path":"lucene/facet/src/java/org/apache/lucene/facet/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","commits":[{"id":"bd3ed8c8fa2a4b995f5dfca3f00e5ce80161de0e","date":1385900513,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"/dev/null","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    // TODO: test if this is faster (in the past it was\n    // faster to do MatchingDocs on the inside) ... see\n    // patches on LUCENE-4965):\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          \n          double v = fv.doubleVal(doc);\n\n          // TODO: if all ranges are non-overlapping, we\n          // should instead do a bin-search up front\n          // (really, a specialized case of the interval\n          // tree)\n          // TODO: use interval tree instead of linear search:\n          for (int j = 0; j < ranges.length; j++) {\n            if (ranges[j].accept(v)) {\n              counts[j]++;\n            }\n          }\n        }\n\n        doc++;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9264c0cc71ca63967ca4c832e5d3514c000b55e6","date":1386094934,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    // Compute min & max over all ranges:\n    double minIncl = Double.POSITIVE_INFINITY;\n    double maxIncl = Double.NEGATIVE_INFINITY;\n    for(DoubleRange range : ranges) {\n      minIncl = Math.min(minIncl, range.minIncl);\n      maxIncl = Math.max(maxIncl, range.maxIncl);\n    }\n\n    // TODO: test if this is faster (in the past it was\n    // faster to do MatchingDocs on the inside) ... see\n    // patches on LUCENE-4965):\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          \n          double v = fv.doubleVal(doc);\n          if (v < minIncl || v > maxIncl) {\n            doc++;\n            continue;\n          }\n\n          // TODO: if all ranges are non-overlapping, we\n          // should instead do a bin-search up front\n          // (really, a specialized case of the interval\n          // tree)\n          // TODO: use interval tree instead of linear search:\n          for (int j = 0; j < ranges.length; j++) {\n            if (ranges[j].accept(v)) {\n              counts[j]++;\n            }\n          }\n        }\n\n        doc++;\n      }\n    }\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    // TODO: test if this is faster (in the past it was\n    // faster to do MatchingDocs on the inside) ... see\n    // patches on LUCENE-4965):\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          \n          double v = fv.doubleVal(doc);\n\n          // TODO: if all ranges are non-overlapping, we\n          // should instead do a bin-search up front\n          // (really, a specialized case of the interval\n          // tree)\n          // TODO: use interval tree instead of linear search:\n          for (int j = 0; j < ranges.length; j++) {\n            if (ranges[j].accept(v)) {\n              counts[j]++;\n            }\n          }\n        }\n\n        doc++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6119ef33e3fbd8582640c23b3f5b3fbb22ba8d30","date":1387399235,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    // Compute min & max over all ranges:\n    double minIncl = Double.POSITIVE_INFINITY;\n    double maxIncl = Double.NEGATIVE_INFINITY;\n    for(DoubleRange range : ranges) {\n      minIncl = Math.min(minIncl, range.minIncl);\n      maxIncl = Math.max(maxIncl, range.maxIncl);\n    }\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n        doc++;\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    // Compute min & max over all ranges:\n    double minIncl = Double.POSITIVE_INFINITY;\n    double maxIncl = Double.NEGATIVE_INFINITY;\n    for(DoubleRange range : ranges) {\n      minIncl = Math.min(minIncl, range.minIncl);\n      maxIncl = Math.max(maxIncl, range.maxIncl);\n    }\n\n    // TODO: test if this is faster (in the past it was\n    // faster to do MatchingDocs on the inside) ... see\n    // patches on LUCENE-4965):\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          \n          double v = fv.doubleVal(doc);\n          if (v < minIncl || v > maxIncl) {\n            doc++;\n            continue;\n          }\n\n          // TODO: if all ranges are non-overlapping, we\n          // should instead do a bin-search up front\n          // (really, a specialized case of the interval\n          // tree)\n          // TODO: use interval tree instead of linear search:\n          for (int j = 0; j < ranges.length; j++) {\n            if (ranges[j].accept(v)) {\n              counts[j]++;\n            }\n          }\n        }\n\n        doc++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4edc984f0f4ac77c37e48ace2932f780f888453c","date":1388475218,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    // Compute min & max over all ranges:\n    double minIncl = Double.POSITIVE_INFINITY;\n    double maxIncl = Double.NEGATIVE_INFINITY;\n    for(DoubleRange range : ranges) {\n      minIncl = Math.min(minIncl, range.minIncl);\n      maxIncl = Math.max(maxIncl, range.maxIncl);\n    }\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n        doc++;\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    // Compute min & max over all ranges:\n    double minIncl = Double.POSITIVE_INFINITY;\n    double maxIncl = Double.NEGATIVE_INFINITY;\n    for(DoubleRange range : ranges) {\n      minIncl = Math.min(minIncl, range.minIncl);\n      maxIncl = Math.max(maxIncl, range.maxIncl);\n    }\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n        doc++;\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9264c0cc71ca63967ca4c832e5d3514c000b55e6":["bd3ed8c8fa2a4b995f5dfca3f00e5ce80161de0e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4edc984f0f4ac77c37e48ace2932f780f888453c":["6119ef33e3fbd8582640c23b3f5b3fbb22ba8d30"],"bd3ed8c8fa2a4b995f5dfca3f00e5ce80161de0e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6119ef33e3fbd8582640c23b3f5b3fbb22ba8d30":["9264c0cc71ca63967ca4c832e5d3514c000b55e6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"9264c0cc71ca63967ca4c832e5d3514c000b55e6":["6119ef33e3fbd8582640c23b3f5b3fbb22ba8d30"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bd3ed8c8fa2a4b995f5dfca3f00e5ce80161de0e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bd3ed8c8fa2a4b995f5dfca3f00e5ce80161de0e":["9264c0cc71ca63967ca4c832e5d3514c000b55e6"],"4edc984f0f4ac77c37e48ace2932f780f888453c":[],"6119ef33e3fbd8582640c23b3f5b3fbb22ba8d30":["4edc984f0f4ac77c37e48ace2932f780f888453c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4edc984f0f4ac77c37e48ace2932f780f888453c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}