{"path":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor.Req#trackRequestResult(org.eclipse.jetty.client.api.Response,InputStream,boolean).mjava","commits":[{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":1,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor.Req#trackRequestResult(org.eclipse.jetty.client.api.Response,InputStream,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrCmdDistributor.Req#trackRequestResult(HttpResponse,boolean).mjava","sourceNew":"    // Called whenever we get results back from a sub-request.\n    // The only ambiguity is if I have _both_ a rollup tracker and a leader tracker. In that case we need to handle\n    // both requests returning from leaders of other shards _and_ from my followers. This happens if a leader happens\n    // to be the aggregator too.\n    //\n    // This isn't really a problem because only responses _from_ some leader will have the \"rf\" parameter, in which case\n    // we need to add the data to the rollup tracker.\n    //\n    // In the case of a leaderTracker and rollupTracker both being present, then we need to take care when assembling\n    // the final response to check both the rollup and leader trackers on the aggregator node.\n    public void trackRequestResult(org.eclipse.jetty.client.api.Response resp, InputStream respBody, boolean success) {\n\n      // Returning Integer.MAX_VALUE here means there was no \"rf\" on the response, therefore we just need to increment\n      // our achieved rf if we are a leader, i.e. have a leaderTracker.\n      int rfFromResp = getRfFromResponse(respBody);\n\n      if (leaderTracker != null && rfFromResp == Integer.MAX_VALUE) {\n        leaderTracker.trackRequestResult(node, success);\n      }\n\n      if (rollupTracker != null) {\n        rollupTracker.testAndSetAchievedRf(rfFromResp);\n      }\n    }\n\n","sourceOld":"    // Called whenever we get results back from a sub-request.\n    // The only ambiguity is if I have _both_ a rollup tracker and a leader tracker. In that case we need to handle\n    // both requests returning from leaders of other shards _and_ from my followers. This happens if a leader happens\n    // to be the aggregator too.\n    //\n    // This isn't really a problem because only responses _from_ some leader will have the \"rf\" parameter, in which case\n    // we need to add the data to the rollup tracker.\n    //\n    // In the case of a leaderTracker and rollupTracker both being present, then we need to take care when assembling\n    // the final response to check both the rollup and leader trackers on the aggregator node.\n    public void trackRequestResult(HttpResponse resp, boolean success) {\n      \n      // Returning Integer.MAX_VALUE here means there was no \"rf\" on the response, therefore we just need to increment\n      // our achieved rf if we are a leader, i.e. have a leaderTracker.\n      int rfFromResp = getRfFromResponse(resp);\n\n      if (leaderTracker != null && rfFromResp == Integer.MAX_VALUE) {\n        leaderTracker.trackRequestResult(node, success);\n      }\n\n      if (rollupTracker != null) {\n        rollupTracker.testAndSetAchievedRf(rfFromResp);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"]},"commit2Childs":{"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}