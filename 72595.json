{"path":"solr/core/src/java/org/apache/solr/handler/component/PhrasesIdentificationComponent#finishStage(ResponseBuilder).mjava","commits":[{"id":"0d1411e62d30c460b09c6f3643df82daa10a27cc","date":1536256256,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PhrasesIdentificationComponent#finishStage(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    // NOTE: we don't do this after STAGE_EXECUTE_QUERY because if we're also being used with\n    // QueryComponent, we don't want to add our results to the response until *after*\n    // QueryComponent adds the main DocList\n    \n    final PhrasesContextData contextData = (PhrasesContextData) rb.req.getContext().get(this.getClass());\n    if (null == contextData || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) {\n      // if prepare didn't give us anything to work with, or this isn't our stage, then do nothing\n      return;\n    }\n      \n    // sanity check: the shard requests we use/piggy-back on should only hapen once per shard,\n    // but let's future proof ourselves against the possibility that some shards might get/respond\n    // to the same request \"purpose\" multiple times...\n    final BitSet shardsHandled = new BitSet(rb.shards.length);\n    \n    // Collect Shard responses\n    for (ShardRequest sreq : rb.finished) {\n      if (0 != (sreq.purpose & SHARD_PURPOSE)) {\n        for (ShardResponse shardRsp : sreq.responses) {\n          final int shardNum = rb.getShardNum(shardRsp.getShard());\n          if (! shardsHandled.get(shardNum)) {\n            shardsHandled.set(shardNum);\n            // shards.tolerant=true can cause nulls on exceptions/errors\n            // if we don't get phrases/stats from a shard, just ignore that shard\n            final SolrResponse rsp = shardRsp.getSolrResponse();\n            if (null == rsp) continue;\n            final NamedList<Object> top = rsp.getResponse();\n            if (null == top) continue;\n            final NamedList<Object> phrasesWrapper = (NamedList<Object>) top.get(\"phrases\");\n            if (null == phrasesWrapper) continue;\n            final List<NamedList<Object>> shardPhrases = (List<NamedList<Object>>) phrasesWrapper.get(\"_all\");\n            if (null == shardPhrases) continue;\n            \n            Phrase.populateStats(contextData.allPhrases, shardPhrases);\n          }\n        }\n      }\n    }\n    scoreAndAddResultsToResponse(rb, contextData);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8582f07e9350eaeb33bf6c4617b8c9895d99c839","date":1591307386,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PhrasesIdentificationComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PhrasesIdentificationComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    // NOTE: we don't do this after STAGE_EXECUTE_QUERY because if we're also being used with\n    // QueryComponent, we don't want to add our results to the response until *after*\n    // QueryComponent adds the main DocList\n    \n    final PhrasesContextData contextData = (PhrasesContextData) rb.req.getContext().get(this.getClass());\n    if (null == contextData || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) {\n      // if prepare didn't give us anything to work with, or this isn't our stage, then do nothing\n      return;\n    }\n      \n    // sanity check: the shard requests we use/piggy-back on should only hapen once per shard,\n    // but let's future proof ourselves against the possibility that some shards might get/respond\n    // to the same request \"purpose\" multiple times...\n    final BitSet shardsHandled = new BitSet(rb.shards.length);\n    \n    // Collect Shard responses\n    for (ShardRequest sreq : rb.finished) {\n      if (0 != (sreq.purpose & SHARD_PURPOSE)) {\n        for (ShardResponse shardRsp : sreq.responses) {\n          final int shardNum = rb.getShardNum(shardRsp.getShard());\n          if (! shardsHandled.get(shardNum)) {\n            shardsHandled.set(shardNum);\n            // shards.tolerant=true can cause nulls on exceptions/errors\n            // if we don't get phrases/stats from a shard, just ignore that shard\n            final SolrResponse rsp = shardRsp.getSolrResponse();\n            if (null == rsp) continue;\n            final NamedList<Object> top = rsp.getResponse();\n            if (null == top) continue;\n            @SuppressWarnings({\"unchecked\"})\n            final NamedList<Object> phrasesWrapper = (NamedList<Object>) top.get(\"phrases\");\n            if (null == phrasesWrapper) continue;\n            @SuppressWarnings({\"unchecked\"})\n            final List<NamedList<Object>> shardPhrases = (List<NamedList<Object>>) phrasesWrapper.get(\"_all\");\n            if (null == shardPhrases) continue;\n            \n            Phrase.populateStats(contextData.allPhrases, shardPhrases);\n          }\n        }\n      }\n    }\n    scoreAndAddResultsToResponse(rb, contextData);\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    // NOTE: we don't do this after STAGE_EXECUTE_QUERY because if we're also being used with\n    // QueryComponent, we don't want to add our results to the response until *after*\n    // QueryComponent adds the main DocList\n    \n    final PhrasesContextData contextData = (PhrasesContextData) rb.req.getContext().get(this.getClass());\n    if (null == contextData || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) {\n      // if prepare didn't give us anything to work with, or this isn't our stage, then do nothing\n      return;\n    }\n      \n    // sanity check: the shard requests we use/piggy-back on should only hapen once per shard,\n    // but let's future proof ourselves against the possibility that some shards might get/respond\n    // to the same request \"purpose\" multiple times...\n    final BitSet shardsHandled = new BitSet(rb.shards.length);\n    \n    // Collect Shard responses\n    for (ShardRequest sreq : rb.finished) {\n      if (0 != (sreq.purpose & SHARD_PURPOSE)) {\n        for (ShardResponse shardRsp : sreq.responses) {\n          final int shardNum = rb.getShardNum(shardRsp.getShard());\n          if (! shardsHandled.get(shardNum)) {\n            shardsHandled.set(shardNum);\n            // shards.tolerant=true can cause nulls on exceptions/errors\n            // if we don't get phrases/stats from a shard, just ignore that shard\n            final SolrResponse rsp = shardRsp.getSolrResponse();\n            if (null == rsp) continue;\n            final NamedList<Object> top = rsp.getResponse();\n            if (null == top) continue;\n            final NamedList<Object> phrasesWrapper = (NamedList<Object>) top.get(\"phrases\");\n            if (null == phrasesWrapper) continue;\n            final List<NamedList<Object>> shardPhrases = (List<NamedList<Object>>) phrasesWrapper.get(\"_all\");\n            if (null == shardPhrases) continue;\n            \n            Phrase.populateStats(contextData.allPhrases, shardPhrases);\n          }\n        }\n      }\n    }\n    scoreAndAddResultsToResponse(rb, contextData);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0d1411e62d30c460b09c6f3643df82daa10a27cc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["0d1411e62d30c460b09c6f3643df82daa10a27cc"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d1411e62d30c460b09c6f3643df82daa10a27cc"],"0d1411e62d30c460b09c6f3643df82daa10a27cc":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}