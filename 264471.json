{"path":"lucene/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","pathOld":"modules/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","sourceNew":"  public String slowSynMatcher(String doc, List<OneSyn> syns, int maxOutputLength) {\n    assertTrue(doc.length() % 2 == 0);\n    final int numInputs = doc.length()/2;\n    boolean[] keepOrigs = new boolean[numInputs];\n    boolean[] hasMatch = new boolean[numInputs];\n    Arrays.fill(keepOrigs, false);\n    String[] outputs = new String[numInputs + maxOutputLength];\n    OneSyn[] matches = new OneSyn[numInputs];\n    for(OneSyn syn : syns) {\n      int idx = -1;\n      while(true) {\n        idx = doc.indexOf(syn.in, 1+idx);\n        if (idx == -1) {\n          break;\n        }\n        assertTrue(idx % 2 == 0);\n        final int matchIDX = idx/2;\n        assertTrue(syn.in.length() % 2 == 1);\n        if (matches[matchIDX] == null) {\n          matches[matchIDX] = syn;\n        } else if (syn.in.length() > matches[matchIDX].in.length()) {\n          // Greedy conflict resolution: longer match wins:\n          matches[matchIDX] = syn;\n        } else {\n          assertTrue(syn.in.length() < matches[matchIDX].in.length());\n        }\n      }\n    }\n\n    // Greedy conflict resolution: if syn matches a range of inputs,\n    // it prevents other syns from matching that range\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn match = matches[inputIDX];\n      if (match != null) {\n        final int synInLength = (1+match.in.length())/2;\n        for(int nextInputIDX=inputIDX+1;nextInputIDX<numInputs && nextInputIDX<(inputIDX+synInLength);nextInputIDX++) {\n          matches[nextInputIDX] = null;\n        }\n      }\n    }\n\n    // Fill overlapping outputs:\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn syn = matches[inputIDX];\n      if (syn == null) {\n        continue;\n      }\n      for(int idx=0;idx<(1+syn.in.length())/2;idx++) {\n        hasMatch[inputIDX+idx] = true;\n        keepOrigs[inputIDX+idx] |= syn.keepOrig;\n      }\n      for(String synOut : syn.out) {\n        final String[] synOutputs = synOut.split(\" \");\n        assertEquals(synOutputs.length, (1+synOut.length())/2);\n        final int matchEnd = inputIDX + synOutputs.length;\n        int synUpto = 0;\n        for(int matchIDX=inputIDX;matchIDX<matchEnd;matchIDX++) {\n          if (outputs[matchIDX] == null) {\n            outputs[matchIDX] = synOutputs[synUpto++];\n          } else {\n            outputs[matchIDX] = outputs[matchIDX] + \"/\" + synOutputs[synUpto++];\n          }\n          final int endOffset;\n          if (matchIDX < numInputs) {\n            final int posLen;\n            if (synOutputs.length == 1) {\n              // Add full endOffset\n              endOffset = (inputIDX*2) + syn.in.length();\n              posLen = (1+syn.in.length())/2;\n            } else {\n              // Add endOffset matching input token's\n              endOffset = (matchIDX*2) + 1;\n              posLen = 1;\n            }\n            outputs[matchIDX] = outputs[matchIDX] + \":\" + endOffset + \"_\" + posLen;\n          }\n        }\n      }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    String[] inputTokens = doc.split(\" \");\n    final int limit = inputTokens.length + maxOutputLength;\n    for(int inputIDX=0;inputIDX<limit;inputIDX++) {\n      boolean posHasOutput = false;\n      if (inputIDX >= numInputs && outputs[inputIDX] == null) {\n        break;\n      }\n      if (inputIDX < numInputs && (!hasMatch[inputIDX] || keepOrigs[inputIDX])) {\n        assertTrue(inputTokens[inputIDX].length() != 0);\n        sb.append(inputTokens[inputIDX]);\n        posHasOutput = true;\n      }\n      \n      if (outputs[inputIDX] != null) {\n        if (posHasOutput) {\n          sb.append('/');\n        }\n        sb.append(outputs[inputIDX]);\n      } else if (!posHasOutput) {\n        continue;\n      }\n      if (inputIDX < limit-1) {\n        sb.append(' ');\n      }\n    }\n\n    return sb.toString();\n  }\n\n","sourceOld":"  public String slowSynMatcher(String doc, List<OneSyn> syns, int maxOutputLength) {\n    assertTrue(doc.length() % 2 == 0);\n    final int numInputs = doc.length()/2;\n    boolean[] keepOrigs = new boolean[numInputs];\n    boolean[] hasMatch = new boolean[numInputs];\n    Arrays.fill(keepOrigs, false);\n    String[] outputs = new String[numInputs + maxOutputLength];\n    OneSyn[] matches = new OneSyn[numInputs];\n    for(OneSyn syn : syns) {\n      int idx = -1;\n      while(true) {\n        idx = doc.indexOf(syn.in, 1+idx);\n        if (idx == -1) {\n          break;\n        }\n        assertTrue(idx % 2 == 0);\n        final int matchIDX = idx/2;\n        assertTrue(syn.in.length() % 2 == 1);\n        if (matches[matchIDX] == null) {\n          matches[matchIDX] = syn;\n        } else if (syn.in.length() > matches[matchIDX].in.length()) {\n          // Greedy conflict resolution: longer match wins:\n          matches[matchIDX] = syn;\n        } else {\n          assertTrue(syn.in.length() < matches[matchIDX].in.length());\n        }\n      }\n    }\n\n    // Greedy conflict resolution: if syn matches a range of inputs,\n    // it prevents other syns from matching that range\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn match = matches[inputIDX];\n      if (match != null) {\n        final int synInLength = (1+match.in.length())/2;\n        for(int nextInputIDX=inputIDX+1;nextInputIDX<numInputs && nextInputIDX<(inputIDX+synInLength);nextInputIDX++) {\n          matches[nextInputIDX] = null;\n        }\n      }\n    }\n\n    // Fill overlapping outputs:\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn syn = matches[inputIDX];\n      if (syn == null) {\n        continue;\n      }\n      for(int idx=0;idx<(1+syn.in.length())/2;idx++) {\n        hasMatch[inputIDX+idx] = true;\n        keepOrigs[inputIDX+idx] |= syn.keepOrig;\n      }\n      for(String synOut : syn.out) {\n        final String[] synOutputs = synOut.split(\" \");\n        assertEquals(synOutputs.length, (1+synOut.length())/2);\n        final int matchEnd = inputIDX + synOutputs.length;\n        int synUpto = 0;\n        for(int matchIDX=inputIDX;matchIDX<matchEnd;matchIDX++) {\n          if (outputs[matchIDX] == null) {\n            outputs[matchIDX] = synOutputs[synUpto++];\n          } else {\n            outputs[matchIDX] = outputs[matchIDX] + \"/\" + synOutputs[synUpto++];\n          }\n          final int endOffset;\n          if (matchIDX < numInputs) {\n            final int posLen;\n            if (synOutputs.length == 1) {\n              // Add full endOffset\n              endOffset = (inputIDX*2) + syn.in.length();\n              posLen = (1+syn.in.length())/2;\n            } else {\n              // Add endOffset matching input token's\n              endOffset = (matchIDX*2) + 1;\n              posLen = 1;\n            }\n            outputs[matchIDX] = outputs[matchIDX] + \":\" + endOffset + \"_\" + posLen;\n          }\n        }\n      }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    String[] inputTokens = doc.split(\" \");\n    final int limit = inputTokens.length + maxOutputLength;\n    for(int inputIDX=0;inputIDX<limit;inputIDX++) {\n      boolean posHasOutput = false;\n      if (inputIDX >= numInputs && outputs[inputIDX] == null) {\n        break;\n      }\n      if (inputIDX < numInputs && (!hasMatch[inputIDX] || keepOrigs[inputIDX])) {\n        assertTrue(inputTokens[inputIDX].length() != 0);\n        sb.append(inputTokens[inputIDX]);\n        posHasOutput = true;\n      }\n      \n      if (outputs[inputIDX] != null) {\n        if (posHasOutput) {\n          sb.append('/');\n        }\n        sb.append(outputs[inputIDX]);\n      } else if (!posHasOutput) {\n        continue;\n      }\n      if (inputIDX < limit-1) {\n        sb.append(' ');\n      }\n    }\n\n    return sb.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3938e891050232a07c92a8acfa853c5a5e2a8259","date":1348763107,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymMapFilter#slowSynMatcher(String,List[OneSyn],int).mjava","sourceNew":"  public String slowSynMatcher(String doc, List<OneSyn> syns, int maxOutputLength) {\n    assertTrue(doc.length() % 2 == 0);\n    final int numInputs = doc.length()/2;\n    boolean[] keepOrigs = new boolean[numInputs];\n    boolean[] hasMatch = new boolean[numInputs];\n    Arrays.fill(keepOrigs, false);\n    String[] outputs = new String[numInputs + maxOutputLength];\n    OneSyn[] matches = new OneSyn[numInputs];\n    for(OneSyn syn : syns) {\n      int idx = -1;\n      while(true) {\n        idx = doc.indexOf(syn.in, 1+idx);\n        if (idx == -1) {\n          break;\n        }\n        assertTrue(idx % 2 == 0);\n        final int matchIDX = idx/2;\n        assertTrue(syn.in.length() % 2 == 1);\n        if (matches[matchIDX] == null) {\n          matches[matchIDX] = syn;\n        } else if (syn.in.length() > matches[matchIDX].in.length()) {\n          // Greedy conflict resolution: longer match wins:\n          matches[matchIDX] = syn;\n        } else {\n          assertTrue(syn.in.length() < matches[matchIDX].in.length());\n        }\n      }\n    }\n\n    // Greedy conflict resolution: if syn matches a range of inputs,\n    // it prevents other syns from matching that range\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn match = matches[inputIDX];\n      if (match != null) {\n        final int synInLength = (1+match.in.length())/2;\n        for(int nextInputIDX=inputIDX+1;nextInputIDX<numInputs && nextInputIDX<(inputIDX+synInLength);nextInputIDX++) {\n          matches[nextInputIDX] = null;\n        }\n      }\n    }\n\n    // Fill overlapping outputs:\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn syn = matches[inputIDX];\n      if (syn == null) {\n        continue;\n      }\n      for(int idx=0;idx<(1+syn.in.length())/2;idx++) {\n        hasMatch[inputIDX+idx] = true;\n        keepOrigs[inputIDX+idx] |= syn.keepOrig;\n      }\n      for(String synOut : syn.out) {\n        final String[] synOutputs = synOut.split(\" \");\n        assertEquals(synOutputs.length, (1+synOut.length())/2);\n        final int matchEnd = inputIDX + synOutputs.length;\n        int synUpto = 0;\n        for(int matchIDX=inputIDX;matchIDX<matchEnd;matchIDX++) {\n          if (outputs[matchIDX] == null) {\n            outputs[matchIDX] = synOutputs[synUpto++];\n          } else {\n            outputs[matchIDX] = outputs[matchIDX] + \"/\" + synOutputs[synUpto++];\n          }\n          final int endOffset;\n          if (matchIDX < numInputs) {\n            final int posLen;\n            if (synOutputs.length == 1) {\n              // Add full endOffset\n              endOffset = (inputIDX*2) + syn.in.length();\n              posLen = syn.keepOrig ? (1+syn.in.length())/2 : 1;\n            } else {\n              // Add endOffset matching input token's\n              endOffset = (matchIDX*2) + 1;\n              posLen = 1;\n            }\n            outputs[matchIDX] = outputs[matchIDX] + \":\" + endOffset + \"_\" + posLen;\n          }\n        }\n      }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    String[] inputTokens = doc.split(\" \");\n    final int limit = inputTokens.length + maxOutputLength;\n    for(int inputIDX=0;inputIDX<limit;inputIDX++) {\n      boolean posHasOutput = false;\n      if (inputIDX >= numInputs && outputs[inputIDX] == null) {\n        break;\n      }\n      if (inputIDX < numInputs && (!hasMatch[inputIDX] || keepOrigs[inputIDX])) {\n        assertTrue(inputTokens[inputIDX].length() != 0);\n        sb.append(inputTokens[inputIDX]);\n        posHasOutput = true;\n      }\n      \n      if (outputs[inputIDX] != null) {\n        if (posHasOutput) {\n          sb.append('/');\n        }\n        sb.append(outputs[inputIDX]);\n      } else if (!posHasOutput) {\n        continue;\n      }\n      if (inputIDX < limit-1) {\n        sb.append(' ');\n      }\n    }\n\n    return sb.toString();\n  }\n\n","sourceOld":"  public String slowSynMatcher(String doc, List<OneSyn> syns, int maxOutputLength) {\n    assertTrue(doc.length() % 2 == 0);\n    final int numInputs = doc.length()/2;\n    boolean[] keepOrigs = new boolean[numInputs];\n    boolean[] hasMatch = new boolean[numInputs];\n    Arrays.fill(keepOrigs, false);\n    String[] outputs = new String[numInputs + maxOutputLength];\n    OneSyn[] matches = new OneSyn[numInputs];\n    for(OneSyn syn : syns) {\n      int idx = -1;\n      while(true) {\n        idx = doc.indexOf(syn.in, 1+idx);\n        if (idx == -1) {\n          break;\n        }\n        assertTrue(idx % 2 == 0);\n        final int matchIDX = idx/2;\n        assertTrue(syn.in.length() % 2 == 1);\n        if (matches[matchIDX] == null) {\n          matches[matchIDX] = syn;\n        } else if (syn.in.length() > matches[matchIDX].in.length()) {\n          // Greedy conflict resolution: longer match wins:\n          matches[matchIDX] = syn;\n        } else {\n          assertTrue(syn.in.length() < matches[matchIDX].in.length());\n        }\n      }\n    }\n\n    // Greedy conflict resolution: if syn matches a range of inputs,\n    // it prevents other syns from matching that range\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn match = matches[inputIDX];\n      if (match != null) {\n        final int synInLength = (1+match.in.length())/2;\n        for(int nextInputIDX=inputIDX+1;nextInputIDX<numInputs && nextInputIDX<(inputIDX+synInLength);nextInputIDX++) {\n          matches[nextInputIDX] = null;\n        }\n      }\n    }\n\n    // Fill overlapping outputs:\n    for(int inputIDX=0;inputIDX<numInputs;inputIDX++) {\n      final OneSyn syn = matches[inputIDX];\n      if (syn == null) {\n        continue;\n      }\n      for(int idx=0;idx<(1+syn.in.length())/2;idx++) {\n        hasMatch[inputIDX+idx] = true;\n        keepOrigs[inputIDX+idx] |= syn.keepOrig;\n      }\n      for(String synOut : syn.out) {\n        final String[] synOutputs = synOut.split(\" \");\n        assertEquals(synOutputs.length, (1+synOut.length())/2);\n        final int matchEnd = inputIDX + synOutputs.length;\n        int synUpto = 0;\n        for(int matchIDX=inputIDX;matchIDX<matchEnd;matchIDX++) {\n          if (outputs[matchIDX] == null) {\n            outputs[matchIDX] = synOutputs[synUpto++];\n          } else {\n            outputs[matchIDX] = outputs[matchIDX] + \"/\" + synOutputs[synUpto++];\n          }\n          final int endOffset;\n          if (matchIDX < numInputs) {\n            final int posLen;\n            if (synOutputs.length == 1) {\n              // Add full endOffset\n              endOffset = (inputIDX*2) + syn.in.length();\n              posLen = (1+syn.in.length())/2;\n            } else {\n              // Add endOffset matching input token's\n              endOffset = (matchIDX*2) + 1;\n              posLen = 1;\n            }\n            outputs[matchIDX] = outputs[matchIDX] + \":\" + endOffset + \"_\" + posLen;\n          }\n        }\n      }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    String[] inputTokens = doc.split(\" \");\n    final int limit = inputTokens.length + maxOutputLength;\n    for(int inputIDX=0;inputIDX<limit;inputIDX++) {\n      boolean posHasOutput = false;\n      if (inputIDX >= numInputs && outputs[inputIDX] == null) {\n        break;\n      }\n      if (inputIDX < numInputs && (!hasMatch[inputIDX] || keepOrigs[inputIDX])) {\n        assertTrue(inputTokens[inputIDX].length() != 0);\n        sb.append(inputTokens[inputIDX]);\n        posHasOutput = true;\n      }\n      \n      if (outputs[inputIDX] != null) {\n        if (posHasOutput) {\n          sb.append('/');\n        }\n        sb.append(outputs[inputIDX]);\n      } else if (!posHasOutput) {\n        continue;\n      }\n      if (inputIDX < limit-1) {\n        sb.append(' ');\n      }\n    }\n\n    return sb.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3938e891050232a07c92a8acfa853c5a5e2a8259":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3938e891050232a07c92a8acfa853c5a5e2a8259"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["3938e891050232a07c92a8acfa853c5a5e2a8259"],"3938e891050232a07c92a8acfa853c5a5e2a8259":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}