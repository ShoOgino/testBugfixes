{"path":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#finishApply(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean,Set[String]).mjava","commits":[{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#finishApply(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean,Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  private void finishApply(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates,\n                           boolean success, Set<String> delFiles) throws IOException {\n    synchronized (writer) {\n\n      BufferedUpdatesStream.ApplyDeletesResult result;\n      try {\n        result = writer.bufferedUpdatesStream.closeSegmentStates(writer.readerPool, segStates, success);\n      } finally {\n        // Matches the incRef we did above, but we must do the decRef after closing segment states else\n        // IFD can't delete still-open files\n        writer.deleter.decRef(delFiles);\n      }\n\n      if (result.anyDeletes) {\n        writer.maybeMerge.set(true);\n        writer.checkpoint();\n      }\n\n      if (writer.keepFullyDeletedSegments == false && result.allDeleted != null) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"drop 100% deleted segments: \" + writer.segString(result.allDeleted));\n        }\n        for (SegmentCommitInfo info : result.allDeleted) {\n          writer.dropDeletedSegment(info);\n        }\n        writer.checkpoint();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#finishApply(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean,Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  private void finishApply(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates,\n                           boolean success, Set<String> delFiles) throws IOException {\n    synchronized (writer) {\n\n      BufferedUpdatesStream.ApplyDeletesResult result;\n      try {\n        result = writer.bufferedUpdatesStream.closeSegmentStates(writer.readerPool, segStates, success);\n      } finally {\n        // Matches the incRef we did above, but we must do the decRef after closing segment states else\n        // IFD can't delete still-open files\n        writer.deleter.decRef(delFiles);\n      }\n\n      if (result.anyDeletes) {\n        writer.maybeMerge.set(true);\n        writer.checkpoint();\n      }\n\n      if (writer.keepFullyDeletedSegments == false && result.allDeleted != null) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"drop 100% deleted segments: \" + writer.segString(result.allDeleted));\n        }\n        for (SegmentCommitInfo info : result.allDeleted) {\n          writer.dropDeletedSegment(info);\n        }\n        writer.checkpoint();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#finishApply(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean,Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  private void finishApply(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates,\n                           boolean success, Set<String> delFiles) throws IOException {\n    synchronized (writer) {\n\n      BufferedUpdatesStream.ApplyDeletesResult result;\n      try {\n        result = writer.bufferedUpdatesStream.closeSegmentStates(writer.readerPool, segStates, success);\n      } finally {\n        // Matches the incRef we did above, but we must do the decRef after closing segment states else\n        // IFD can't delete still-open files\n        writer.deleter.decRef(delFiles);\n      }\n\n      if (result.anyDeletes) {\n        writer.maybeMerge.set(true);\n        writer.checkpoint();\n      }\n\n      if (writer.keepFullyDeletedSegments == false && result.allDeleted != null) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"drop 100% deleted segments: \" + writer.segString(result.allDeleted));\n        }\n        for (SegmentCommitInfo info : result.allDeleted) {\n          writer.dropDeletedSegment(info);\n        }\n        writer.checkpoint();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ee0394b8176abd7c90a4be8c05465be1879db79","date":1522842314,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#finishApply(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#finishApply(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean,Set[String]).mjava","sourceNew":"  private void finishApply(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates,\n                           boolean success, Set<String> delFiles) throws IOException {\n    synchronized (writer) {\n\n      BufferedUpdatesStream.ApplyDeletesResult result;\n      try {\n        result = writer.bufferedUpdatesStream.closeSegmentStates(writer.readerPool, segStates, success);\n      } finally {\n        // Matches the incRef we did above, but we must do the decRef after closing segment states else\n        // IFD can't delete still-open files\n        writer.deleter.decRef(delFiles);\n      }\n\n      if (result.anyDeletes) {\n        writer.maybeMerge.set(true);\n        writer.checkpoint();\n      }\n\n      if (result.allDeleted != null) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"drop 100% deleted segments: \" + writer.segString(result.allDeleted));\n        }\n        for (SegmentCommitInfo info : result.allDeleted) {\n          writer.dropDeletedSegment(info);\n        }\n        writer.checkpoint();\n      }\n    }\n  }\n\n","sourceOld":"  private void finishApply(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates,\n                           boolean success, Set<String> delFiles) throws IOException {\n    synchronized (writer) {\n\n      BufferedUpdatesStream.ApplyDeletesResult result;\n      try {\n        result = writer.bufferedUpdatesStream.closeSegmentStates(writer.readerPool, segStates, success);\n      } finally {\n        // Matches the incRef we did above, but we must do the decRef after closing segment states else\n        // IFD can't delete still-open files\n        writer.deleter.decRef(delFiles);\n      }\n\n      if (result.anyDeletes) {\n        writer.maybeMerge.set(true);\n        writer.checkpoint();\n      }\n\n      if (writer.keepFullyDeletedSegments == false && result.allDeleted != null) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"drop 100% deleted segments: \" + writer.segString(result.allDeleted));\n        }\n        for (SegmentCommitInfo info : result.allDeleted) {\n          writer.dropDeletedSegment(info);\n        }\n        writer.checkpoint();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1926100d9b67becc9701c54266fee3ba7878a5f0","date":1524472150,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#finishApply(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#finishApply(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean,Set[String]).mjava","sourceNew":"  private void finishApply(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates,\n                           boolean success, Set<String> delFiles) throws IOException {\n    synchronized (writer) {\n\n      BufferedUpdatesStream.ApplyDeletesResult result;\n      try {\n        result = writer.bufferedUpdatesStream.closeSegmentStates(segStates, success);\n      } finally {\n        // Matches the incRef we did above, but we must do the decRef after closing segment states else\n        // IFD can't delete still-open files\n        writer.deleter.decRef(delFiles);\n      }\n\n      if (result.anyDeletes) {\n        writer.maybeMerge.set(true);\n        writer.checkpoint();\n      }\n\n      if (result.allDeleted != null) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"drop 100% deleted segments: \" + writer.segString(result.allDeleted));\n        }\n        for (SegmentCommitInfo info : result.allDeleted) {\n          writer.dropDeletedSegment(info);\n        }\n        writer.checkpoint();\n      }\n    }\n  }\n\n","sourceOld":"  private void finishApply(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates,\n                           boolean success, Set<String> delFiles) throws IOException {\n    synchronized (writer) {\n\n      BufferedUpdatesStream.ApplyDeletesResult result;\n      try {\n        result = writer.bufferedUpdatesStream.closeSegmentStates(writer.readerPool, segStates, success);\n      } finally {\n        // Matches the incRef we did above, but we must do the decRef after closing segment states else\n        // IFD can't delete still-open files\n        writer.deleter.decRef(delFiles);\n      }\n\n      if (result.anyDeletes) {\n        writer.maybeMerge.set(true);\n        writer.checkpoint();\n      }\n\n      if (result.allDeleted != null) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"drop 100% deleted segments: \" + writer.segString(result.allDeleted));\n        }\n        for (SegmentCommitInfo info : result.allDeleted) {\n          writer.dropDeletedSegment(info);\n        }\n        writer.checkpoint();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7","date":1524496660,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#finishApply(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#finishApply(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean,Set[String]).mjava","sourceNew":"  private void finishApply(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates,\n                           boolean success, Set<String> delFiles) throws IOException {\n    synchronized (writer) {\n\n      BufferedUpdatesStream.ApplyDeletesResult result;\n      try {\n        result = closeSegmentStates(writer, segStates, success);\n      } finally {\n        // Matches the incRef we did above, but we must do the decRef after closing segment states else\n        // IFD can't delete still-open files\n        writer.deleter.decRef(delFiles);\n      }\n\n      if (result.anyDeletes) {\n          writer.maybeMerge.set(true);\n          writer.checkpoint();\n      }\n\n      if (result.allDeleted != null) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"drop 100% deleted segments: \" + writer.segString(result.allDeleted));\n        }\n        for (SegmentCommitInfo info : result.allDeleted) {\n          writer.dropDeletedSegment(info);\n        }\n        writer.checkpoint();\n      }\n    }\n  }\n\n","sourceOld":"  private void finishApply(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates,\n                           boolean success, Set<String> delFiles) throws IOException {\n    synchronized (writer) {\n\n      BufferedUpdatesStream.ApplyDeletesResult result;\n      try {\n        result = writer.bufferedUpdatesStream.closeSegmentStates(segStates, success);\n      } finally {\n        // Matches the incRef we did above, but we must do the decRef after closing segment states else\n        // IFD can't delete still-open files\n        writer.deleter.decRef(delFiles);\n      }\n\n      if (result.anyDeletes) {\n        writer.maybeMerge.set(true);\n        writer.checkpoint();\n      }\n\n      if (result.allDeleted != null) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"drop 100% deleted segments: \" + writer.segString(result.allDeleted));\n        }\n        for (SegmentCommitInfo info : result.allDeleted) {\n          writer.dropDeletedSegment(info);\n        }\n        writer.checkpoint();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"72332a99ce230f8edf8404d6043ac18a0e26dfeb","date":1542806419,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#finishApply(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#finishApply(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean,Set[String]).mjava","sourceNew":"  private void finishApply(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates,\n                           boolean success, Set<String> delFiles) throws IOException {\n    assert applyLock.isHeldByCurrentThread();\n    synchronized (writer) {\n\n      BufferedUpdatesStream.ApplyDeletesResult result;\n      try {\n        result = closeSegmentStates(writer, segStates, success);\n      } finally {\n        // Matches the incRef we did above, but we must do the decRef after closing segment states else\n        // IFD can't delete still-open files\n        writer.deleter.decRef(delFiles);\n      }\n\n      if (result.anyDeletes) {\n          writer.maybeMerge.set(true);\n          writer.checkpoint();\n      }\n\n      if (result.allDeleted != null) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"drop 100% deleted segments: \" + writer.segString(result.allDeleted));\n        }\n        for (SegmentCommitInfo info : result.allDeleted) {\n          writer.dropDeletedSegment(info);\n        }\n        writer.checkpoint();\n      }\n    }\n  }\n\n","sourceOld":"  private void finishApply(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates,\n                           boolean success, Set<String> delFiles) throws IOException {\n    synchronized (writer) {\n\n      BufferedUpdatesStream.ApplyDeletesResult result;\n      try {\n        result = closeSegmentStates(writer, segStates, success);\n      } finally {\n        // Matches the incRef we did above, but we must do the decRef after closing segment states else\n        // IFD can't delete still-open files\n        writer.deleter.decRef(delFiles);\n      }\n\n      if (result.anyDeletes) {\n          writer.maybeMerge.set(true);\n          writer.checkpoint();\n      }\n\n      if (result.allDeleted != null) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"drop 100% deleted segments: \" + writer.segString(result.allDeleted));\n        }\n        for (SegmentCommitInfo info : result.allDeleted) {\n          writer.dropDeletedSegment(info);\n        }\n        writer.checkpoint();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f21f1920c232db2352489eed260fe5c1f39e5a0","date":1587748041,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishApply(BufferedUpdatesStream.SegmentState[],boolean,Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FrozenBufferedUpdates#finishApply(IndexWriter,BufferedUpdatesStream.SegmentState[],boolean,Set[String]).mjava","sourceNew":"  private void finishApply(BufferedUpdatesStream.SegmentState[] segStates,\n                           boolean success, Set<String> delFiles) throws IOException {\n    synchronized (this) {\n\n      BufferedUpdatesStream.ApplyDeletesResult result;\n      try {\n        result = closeSegmentStates(segStates, success);\n      } finally {\n        // Matches the incRef we did above, but we must do the decRef after closing segment states else\n        // IFD can't delete still-open files\n        deleter.decRef(delFiles);\n      }\n\n      if (result.anyDeletes) {\n        maybeMerge.set(true);\n        checkpoint();\n      }\n\n      if (result.allDeleted != null) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"drop 100% deleted segments: \" + segString(result.allDeleted));\n        }\n        for (SegmentCommitInfo info : result.allDeleted) {\n          dropDeletedSegment(info);\n        }\n        checkpoint();\n      }\n    }\n  }\n\n","sourceOld":"  private void finishApply(IndexWriter writer, BufferedUpdatesStream.SegmentState[] segStates,\n                           boolean success, Set<String> delFiles) throws IOException {\n    assert applyLock.isHeldByCurrentThread();\n    synchronized (writer) {\n\n      BufferedUpdatesStream.ApplyDeletesResult result;\n      try {\n        result = closeSegmentStates(writer, segStates, success);\n      } finally {\n        // Matches the incRef we did above, but we must do the decRef after closing segment states else\n        // IFD can't delete still-open files\n        writer.deleter.decRef(delFiles);\n      }\n\n      if (result.anyDeletes) {\n          writer.maybeMerge.set(true);\n          writer.checkpoint();\n      }\n\n      if (result.allDeleted != null) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"drop 100% deleted segments: \" + writer.segString(result.allDeleted));\n        }\n        for (SegmentCommitInfo info : result.allDeleted) {\n          writer.dropDeletedSegment(info);\n        }\n        writer.checkpoint();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9f21f1920c232db2352489eed260fe5c1f39e5a0":["72332a99ce230f8edf8404d6043ac18a0e26dfeb"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1926100d9b67becc9701c54266fee3ba7878a5f0":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"72332a99ce230f8edf8404d6043ac18a0e26dfeb":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9f21f1920c232db2352489eed260fe5c1f39e5a0"]},"commit2Childs":{"9f21f1920c232db2352489eed260fe5c1f39e5a0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["72332a99ce230f8edf8404d6043ac18a0e26dfeb"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"72332a99ce230f8edf8404d6043ac18a0e26dfeb":["9f21f1920c232db2352489eed260fe5c1f39e5a0"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}