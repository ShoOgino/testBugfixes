{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene80/IndexedDISI#rankSkip(IndexedDISI,int).mjava","commits":[{"id":"03e17b020972a0d6e8d6823f545571a66646a167","date":1547847724,"type":0,"author":"Toke Eskildsen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene80/IndexedDISI#rankSkip(IndexedDISI,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * If the distance between the current position and the target is > 8 words, the rank cache will\n   * be used to guarantee a worst-case of 1 rank-lookup and 7 word-read-and-count-bits operations.\n   * Note: This does not guarantee a skip up to target, only up to nearest rank boundary. It is the\n   * responsibility of the caller to iterate further to reach target.\n   * @param disi standard DISI.\n   * @param target the wanted docID for which to calculate set-flag and index.\n   * @throws IOException if a DISI seek failed.\n   */\n  private static void rankSkip(IndexedDISI disi, int target) throws IOException {\n    if (disi.denseRankPower == -1) { // No rank for the current structure\n      return;\n    }\n\n    final int targetInBlock = target & 0xFFFF;       // Lower 16 bits\n    final int targetWordIndex = targetInBlock >>> 6; // long: 2^6 = 64\n\n    // If the distance between the current position and the target is < rank-longs\n    // there is no sense in using rank\n    if (targetWordIndex - disi.wordIndex < (1 << (disi.denseRankPower-6) )) {\n      return;\n    }\n\n    // Resolve the rank as close to targetInBlock as possible (maximum distance is 8 longs)\n    // Note: rankOrigoOffset is tracked on block open, so it is absolute (e.g. don't add origo)\n    final int rankIndex = targetInBlock >> disi.denseRankPower; // Default is 9 (8 longs: 2^3 * 2^6 = 512 docIDs)\n\n    final int rank =\n        (disi.denseRankTable[rankIndex<<1] & 0xFF) << 8 |\n        (disi.denseRankTable[(rankIndex<<1)+1] & 0xFF);\n\n    // Position the counting logic just after the rank point\n    final int rankAlignedWordIndex = rankIndex << disi.denseRankPower >> 6;\n    disi.slice.seek(disi.denseBitmapOffset + rankAlignedWordIndex*Long.BYTES);\n    long rankWord = disi.slice.readLong();\n    int denseNOO = rank + Long.bitCount(rankWord);\n\n    disi.wordIndex = rankAlignedWordIndex;\n    disi.word = rankWord;\n    disi.numberOfOnes = disi.denseOrigoIndex + denseNOO;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c89f1ef80a9432f4eabaeda9a1e135cd72e60836","date":1547972642,"type":0,"author":"Tommaso Teofili","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene80/IndexedDISI#rankSkip(IndexedDISI,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * If the distance between the current position and the target is > 8 words, the rank cache will\n   * be used to guarantee a worst-case of 1 rank-lookup and 7 word-read-and-count-bits operations.\n   * Note: This does not guarantee a skip up to target, only up to nearest rank boundary. It is the\n   * responsibility of the caller to iterate further to reach target.\n   * @param disi standard DISI.\n   * @param target the wanted docID for which to calculate set-flag and index.\n   * @throws IOException if a DISI seek failed.\n   */\n  private static void rankSkip(IndexedDISI disi, int target) throws IOException {\n    if (disi.denseRankPower == -1) { // No rank for the current structure\n      return;\n    }\n\n    final int targetInBlock = target & 0xFFFF;       // Lower 16 bits\n    final int targetWordIndex = targetInBlock >>> 6; // long: 2^6 = 64\n\n    // If the distance between the current position and the target is < rank-longs\n    // there is no sense in using rank\n    if (targetWordIndex - disi.wordIndex < (1 << (disi.denseRankPower-6) )) {\n      return;\n    }\n\n    // Resolve the rank as close to targetInBlock as possible (maximum distance is 8 longs)\n    // Note: rankOrigoOffset is tracked on block open, so it is absolute (e.g. don't add origo)\n    final int rankIndex = targetInBlock >> disi.denseRankPower; // Default is 9 (8 longs: 2^3 * 2^6 = 512 docIDs)\n\n    final int rank =\n        (disi.denseRankTable[rankIndex<<1] & 0xFF) << 8 |\n        (disi.denseRankTable[(rankIndex<<1)+1] & 0xFF);\n\n    // Position the counting logic just after the rank point\n    final int rankAlignedWordIndex = rankIndex << disi.denseRankPower >> 6;\n    disi.slice.seek(disi.denseBitmapOffset + rankAlignedWordIndex*Long.BYTES);\n    long rankWord = disi.slice.readLong();\n    int denseNOO = rank + Long.bitCount(rankWord);\n\n    disi.wordIndex = rankAlignedWordIndex;\n    disi.word = rankWord;\n    disi.numberOfOnes = disi.denseOrigoIndex + denseNOO;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"26fda260a5f1862f1f99f4daaab835c54c12adac","date":1548408108,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene80/IndexedDISI#rankSkip(IndexedDISI,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene80/IndexedDISI#rankSkip(IndexedDISI,int).mjava","sourceNew":"  /**\n   * If the distance between the current position and the target is > 8 words, the rank cache will\n   * be used to guarantee a worst-case of 1 rank-lookup and 7 word-read-and-count-bits operations.\n   * Note: This does not guarantee a skip up to target, only up to nearest rank boundary. It is the\n   * responsibility of the caller to iterate further to reach target.\n   * @param disi standard DISI.\n   * @param targetInBlock lower 16 bits of the target\n   * @throws IOException if a DISI seek failed.\n   */\n  private static void rankSkip(IndexedDISI disi, int targetInBlock) throws IOException {\n    assert disi.denseRankPower >= 0 : disi.denseRankPower;\n    // Resolve the rank as close to targetInBlock as possible (maximum distance is 8 longs)\n    // Note: rankOrigoOffset is tracked on block open, so it is absolute (e.g. don't add origo)\n    final int rankIndex = targetInBlock >> disi.denseRankPower; // Default is 9 (8 longs: 2^3 * 2^6 = 512 docIDs)\n\n    final int rank =\n        (disi.denseRankTable[rankIndex<<1] & 0xFF) << 8 |\n        (disi.denseRankTable[(rankIndex<<1)+1] & 0xFF);\n\n    // Position the counting logic just after the rank point\n    final int rankAlignedWordIndex = rankIndex << disi.denseRankPower >> 6;\n    disi.slice.seek(disi.denseBitmapOffset + rankAlignedWordIndex*Long.BYTES);\n    long rankWord = disi.slice.readLong();\n    int denseNOO = rank + Long.bitCount(rankWord);\n\n    disi.wordIndex = rankAlignedWordIndex;\n    disi.word = rankWord;\n    disi.numberOfOnes = disi.denseOrigoIndex + denseNOO;\n  }\n\n","sourceOld":"  /**\n   * If the distance between the current position and the target is > 8 words, the rank cache will\n   * be used to guarantee a worst-case of 1 rank-lookup and 7 word-read-and-count-bits operations.\n   * Note: This does not guarantee a skip up to target, only up to nearest rank boundary. It is the\n   * responsibility of the caller to iterate further to reach target.\n   * @param disi standard DISI.\n   * @param target the wanted docID for which to calculate set-flag and index.\n   * @throws IOException if a DISI seek failed.\n   */\n  private static void rankSkip(IndexedDISI disi, int target) throws IOException {\n    if (disi.denseRankPower == -1) { // No rank for the current structure\n      return;\n    }\n\n    final int targetInBlock = target & 0xFFFF;       // Lower 16 bits\n    final int targetWordIndex = targetInBlock >>> 6; // long: 2^6 = 64\n\n    // If the distance between the current position and the target is < rank-longs\n    // there is no sense in using rank\n    if (targetWordIndex - disi.wordIndex < (1 << (disi.denseRankPower-6) )) {\n      return;\n    }\n\n    // Resolve the rank as close to targetInBlock as possible (maximum distance is 8 longs)\n    // Note: rankOrigoOffset is tracked on block open, so it is absolute (e.g. don't add origo)\n    final int rankIndex = targetInBlock >> disi.denseRankPower; // Default is 9 (8 longs: 2^3 * 2^6 = 512 docIDs)\n\n    final int rank =\n        (disi.denseRankTable[rankIndex<<1] & 0xFF) << 8 |\n        (disi.denseRankTable[(rankIndex<<1)+1] & 0xFF);\n\n    // Position the counting logic just after the rank point\n    final int rankAlignedWordIndex = rankIndex << disi.denseRankPower >> 6;\n    disi.slice.seek(disi.denseBitmapOffset + rankAlignedWordIndex*Long.BYTES);\n    long rankWord = disi.slice.readLong();\n    int denseNOO = rank + Long.bitCount(rankWord);\n\n    disi.wordIndex = rankAlignedWordIndex;\n    disi.word = rankWord;\n    disi.numberOfOnes = disi.denseOrigoIndex + denseNOO;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"03e17b020972a0d6e8d6823f545571a66646a167":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c89f1ef80a9432f4eabaeda9a1e135cd72e60836":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","03e17b020972a0d6e8d6823f545571a66646a167"],"26fda260a5f1862f1f99f4daaab835c54c12adac":["03e17b020972a0d6e8d6823f545571a66646a167"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["26fda260a5f1862f1f99f4daaab835c54c12adac"]},"commit2Childs":{"03e17b020972a0d6e8d6823f545571a66646a167":["c89f1ef80a9432f4eabaeda9a1e135cd72e60836","26fda260a5f1862f1f99f4daaab835c54c12adac"],"c89f1ef80a9432f4eabaeda9a1e135cd72e60836":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["03e17b020972a0d6e8d6823f545571a66646a167","c89f1ef80a9432f4eabaeda9a1e135cd72e60836"],"26fda260a5f1862f1f99f4daaab835c54c12adac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c89f1ef80a9432f4eabaeda9a1e135cd72e60836","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}