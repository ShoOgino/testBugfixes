{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","pathOld":"solr/src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        do {\n          try {\n            RequestEntity request = new RequestEntity() {\n              // we don't know the length\n              public long getContentLength() { return -1; }\n              public String getContentType() { return ClientUtils.TEXT_XML; }\n              public boolean isRepeatable()  { return false; }\n      \n              public void writeRequest(OutputStream out) throws IOException {\n                try {\n                  OutputStreamWriter writer = new OutputStreamWriter(out, \"UTF-8\");\n                  writer.append( \"<stream>\" ); // can be anything...\n                  UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n                  while( req != null ) {\n                    log.debug( \"sending: {}\" , req );\n                    req.writeXML( writer ); \n                    \n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if( params != null ) {\n                      String fmt = null;\n                      if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                      }\n                      else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                      }\n                      if( fmt != null ) {\n                        log.info( fmt );\n                        writer.write( String.format( fmt, \n                            params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\") );\n                      }\n                    }\n                    \n                    writer.flush();\n                    req = queue.poll( 250, TimeUnit.MILLISECONDS );\n                  }\n                  writer.append( \"</stream>\" );\n                  writer.flush();\n                }\n                catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            };\n          \n            method = new PostMethod(_baseURL+updateUrl );\n            method.setRequestEntity( request );\n            method.setFollowRedirects( false );\n            method.addRequestHeader( \"User-Agent\", AGENT );\n            \n            int statusCode = getHttpClient().executeMethod(method);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append( method.getStatusLine().getReasonPhrase() );\n              msg.append( \"\\n\\n\" );\n              msg.append( method.getStatusText() );\n              msg.append( \"\\n\\n\" );\n              msg.append( \"request: \"+method.getURI() );\n              handleError( new Exception( msg.toString() ) );\n            }\n          } finally {\n            try {\n              // make sure to release the connection\n              if(method != null)\n                method.releaseConnection();\n            }\n            catch( Exception ex ){}\n          }\n        } while( ! queue.isEmpty());\n      }\n      catch (Throwable e) {\n        handleError( e );\n      }\n      finally {\n\n        // remove it from the list of running things unless we are the last runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no runners to handle it.\n        // This case has been further handled by using offer instead of put, and using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n           // keep this runner alive\n           scheduler.execute(this);\n          } else {\n            runners.remove( this );\n          }\n        }\n\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        do {\n          try {\n            RequestEntity request = new RequestEntity() {\n              // we don't know the length\n              public long getContentLength() { return -1; }\n              public String getContentType() { return ClientUtils.TEXT_XML; }\n              public boolean isRepeatable()  { return false; }\n      \n              public void writeRequest(OutputStream out) throws IOException {\n                try {\n                  OutputStreamWriter writer = new OutputStreamWriter(out, \"UTF-8\");\n                  writer.append( \"<stream>\" ); // can be anything...\n                  UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n                  while( req != null ) {\n                    log.debug( \"sending: {}\" , req );\n                    req.writeXML( writer ); \n                    \n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if( params != null ) {\n                      String fmt = null;\n                      if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                      }\n                      else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                      }\n                      if( fmt != null ) {\n                        log.info( fmt );\n                        writer.write( String.format( fmt, \n                            params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\") );\n                      }\n                    }\n                    \n                    writer.flush();\n                    req = queue.poll( 250, TimeUnit.MILLISECONDS );\n                  }\n                  writer.append( \"</stream>\" );\n                  writer.flush();\n                }\n                catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            };\n          \n            method = new PostMethod(_baseURL+updateUrl );\n            method.setRequestEntity( request );\n            method.setFollowRedirects( false );\n            method.addRequestHeader( \"User-Agent\", AGENT );\n            \n            int statusCode = getHttpClient().executeMethod(method);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append( method.getStatusLine().getReasonPhrase() );\n              msg.append( \"\\n\\n\" );\n              msg.append( method.getStatusText() );\n              msg.append( \"\\n\\n\" );\n              msg.append( \"request: \"+method.getURI() );\n              handleError( new Exception( msg.toString() ) );\n            }\n          } finally {\n            try {\n              // make sure to release the connection\n              if(method != null)\n                method.releaseConnection();\n            }\n            catch( Exception ex ){}\n          }\n        } while( ! queue.isEmpty());\n      }\n      catch (Throwable e) {\n        handleError( e );\n      }\n      finally {\n\n        // remove it from the list of running things unless we are the last runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no runners to handle it.\n        // This case has been further handled by using offer instead of put, and using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n           // keep this runner alive\n           scheduler.execute(this);\n          } else {\n            runners.remove( this );\n          }\n        }\n\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","pathOld":"solr/src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        do {\n          try {\n            RequestEntity request = new RequestEntity() {\n              // we don't know the length\n              public long getContentLength() { return -1; }\n              public String getContentType() { return ClientUtils.TEXT_XML; }\n              public boolean isRepeatable()  { return false; }\n      \n              public void writeRequest(OutputStream out) throws IOException {\n                try {\n                  OutputStreamWriter writer = new OutputStreamWriter(out, \"UTF-8\");\n                  writer.append( \"<stream>\" ); // can be anything...\n                  UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n                  while( req != null ) {\n                    log.debug( \"sending: {}\" , req );\n                    req.writeXML( writer ); \n                    \n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if( params != null ) {\n                      String fmt = null;\n                      if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                      }\n                      else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                      }\n                      if( fmt != null ) {\n                        log.info( fmt );\n                        writer.write( String.format( fmt, \n                            params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\") );\n                      }\n                    }\n                    \n                    writer.flush();\n                    req = queue.poll( 250, TimeUnit.MILLISECONDS );\n                  }\n                  writer.append( \"</stream>\" );\n                  writer.flush();\n                }\n                catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            };\n          \n            method = new PostMethod(_baseURL+updateUrl );\n            method.setRequestEntity( request );\n            method.setFollowRedirects( false );\n            method.addRequestHeader( \"User-Agent\", AGENT );\n            \n            int statusCode = getHttpClient().executeMethod(method);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append( method.getStatusLine().getReasonPhrase() );\n              msg.append( \"\\n\\n\" );\n              msg.append( method.getStatusText() );\n              msg.append( \"\\n\\n\" );\n              msg.append( \"request: \"+method.getURI() );\n              handleError( new Exception( msg.toString() ) );\n            }\n          } finally {\n            try {\n              // make sure to release the connection\n              if(method != null)\n                method.releaseConnection();\n            }\n            catch( Exception ex ){}\n          }\n        } while( ! queue.isEmpty());\n      }\n      catch (Throwable e) {\n        handleError( e );\n      }\n      finally {\n\n        // remove it from the list of running things unless we are the last runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no runners to handle it.\n        // This case has been further handled by using offer instead of put, and using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n           // keep this runner alive\n           scheduler.execute(this);\n          } else {\n            runners.remove( this );\n          }\n        }\n\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        do {\n          try {\n            RequestEntity request = new RequestEntity() {\n              // we don't know the length\n              public long getContentLength() { return -1; }\n              public String getContentType() { return ClientUtils.TEXT_XML; }\n              public boolean isRepeatable()  { return false; }\n      \n              public void writeRequest(OutputStream out) throws IOException {\n                try {\n                  OutputStreamWriter writer = new OutputStreamWriter(out, \"UTF-8\");\n                  writer.append( \"<stream>\" ); // can be anything...\n                  UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n                  while( req != null ) {\n                    log.debug( \"sending: {}\" , req );\n                    req.writeXML( writer ); \n                    \n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if( params != null ) {\n                      String fmt = null;\n                      if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                      }\n                      else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                      }\n                      if( fmt != null ) {\n                        log.info( fmt );\n                        writer.write( String.format( fmt, \n                            params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\") );\n                      }\n                    }\n                    \n                    writer.flush();\n                    req = queue.poll( 250, TimeUnit.MILLISECONDS );\n                  }\n                  writer.append( \"</stream>\" );\n                  writer.flush();\n                }\n                catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            };\n          \n            method = new PostMethod(_baseURL+updateUrl );\n            method.setRequestEntity( request );\n            method.setFollowRedirects( false );\n            method.addRequestHeader( \"User-Agent\", AGENT );\n            \n            int statusCode = getHttpClient().executeMethod(method);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append( method.getStatusLine().getReasonPhrase() );\n              msg.append( \"\\n\\n\" );\n              msg.append( method.getStatusText() );\n              msg.append( \"\\n\\n\" );\n              msg.append( \"request: \"+method.getURI() );\n              handleError( new Exception( msg.toString() ) );\n            }\n          } finally {\n            try {\n              // make sure to release the connection\n              if(method != null)\n                method.releaseConnection();\n            }\n            catch( Exception ex ){}\n          }\n        } while( ! queue.isEmpty());\n      }\n      catch (Throwable e) {\n        handleError( e );\n      }\n      finally {\n\n        // remove it from the list of running things unless we are the last runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no runners to handle it.\n        // This case has been further handled by using offer instead of put, and using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n           // keep this runner alive\n           scheduler.execute(this);\n          } else {\n            runners.remove( this );\n          }\n        }\n\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","pathOld":"solr/src/solrj/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        do {\n          try {\n            RequestEntity request = new RequestEntity() {\n              // we don't know the length\n              public long getContentLength() { return -1; }\n              public String getContentType() { return ClientUtils.TEXT_XML; }\n              public boolean isRepeatable()  { return false; }\n      \n              public void writeRequest(OutputStream out) throws IOException {\n                try {\n                  OutputStreamWriter writer = new OutputStreamWriter(out, \"UTF-8\");\n                  writer.append( \"<stream>\" ); // can be anything...\n                  UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n                  while( req != null ) {\n                    log.debug( \"sending: {}\" , req );\n                    req.writeXML( writer ); \n                    \n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if( params != null ) {\n                      String fmt = null;\n                      if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                      }\n                      else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                      }\n                      if( fmt != null ) {\n                        log.info( fmt );\n                        writer.write( String.format( fmt, \n                            params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\") );\n                      }\n                    }\n                    \n                    writer.flush();\n                    req = queue.poll( 250, TimeUnit.MILLISECONDS );\n                  }\n                  writer.append( \"</stream>\" );\n                  writer.flush();\n                }\n                catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            };\n          \n            method = new PostMethod(_baseURL+updateUrl );\n            method.setRequestEntity( request );\n            method.setFollowRedirects( false );\n            method.addRequestHeader( \"User-Agent\", AGENT );\n            \n            int statusCode = getHttpClient().executeMethod(method);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append( method.getStatusLine().getReasonPhrase() );\n              msg.append( \"\\n\\n\" );\n              msg.append( method.getStatusText() );\n              msg.append( \"\\n\\n\" );\n              msg.append( \"request: \"+method.getURI() );\n              handleError( new Exception( msg.toString() ) );\n            }\n          } finally {\n            try {\n              // make sure to release the connection\n              if(method != null)\n                method.releaseConnection();\n            }\n            catch( Exception ex ){}\n          }\n        } while( ! queue.isEmpty());\n      }\n      catch (Throwable e) {\n        handleError( e );\n      }\n      finally {\n\n        // remove it from the list of running things unless we are the last runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no runners to handle it.\n        // This case has been further handled by using offer instead of put, and using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n           // keep this runner alive\n           scheduler.execute(this);\n          } else {\n            runners.remove( this );\n          }\n        }\n\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        do {\n          try {\n            RequestEntity request = new RequestEntity() {\n              // we don't know the length\n              public long getContentLength() { return -1; }\n              public String getContentType() { return ClientUtils.TEXT_XML; }\n              public boolean isRepeatable()  { return false; }\n      \n              public void writeRequest(OutputStream out) throws IOException {\n                try {\n                  OutputStreamWriter writer = new OutputStreamWriter(out, \"UTF-8\");\n                  writer.append( \"<stream>\" ); // can be anything...\n                  UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n                  while( req != null ) {\n                    log.debug( \"sending: {}\" , req );\n                    req.writeXML( writer ); \n                    \n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if( params != null ) {\n                      String fmt = null;\n                      if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                      }\n                      else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                      }\n                      if( fmt != null ) {\n                        log.info( fmt );\n                        writer.write( String.format( fmt, \n                            params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\") );\n                      }\n                    }\n                    \n                    writer.flush();\n                    req = queue.poll( 250, TimeUnit.MILLISECONDS );\n                  }\n                  writer.append( \"</stream>\" );\n                  writer.flush();\n                }\n                catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            };\n          \n            method = new PostMethod(_baseURL+updateUrl );\n            method.setRequestEntity( request );\n            method.setFollowRedirects( false );\n            method.addRequestHeader( \"User-Agent\", AGENT );\n            \n            int statusCode = getHttpClient().executeMethod(method);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append( method.getStatusLine().getReasonPhrase() );\n              msg.append( \"\\n\\n\" );\n              msg.append( method.getStatusText() );\n              msg.append( \"\\n\\n\" );\n              msg.append( \"request: \"+method.getURI() );\n              handleError( new Exception( msg.toString() ) );\n            }\n          } finally {\n            try {\n              // make sure to release the connection\n              if(method != null)\n                method.releaseConnection();\n            }\n            catch( Exception ex ){}\n          }\n        } while( ! queue.isEmpty());\n      }\n      catch (Throwable e) {\n        handleError( e );\n      }\n      finally {\n\n        // remove it from the list of running things unless we are the last runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no runners to handle it.\n        // This case has been further handled by using offer instead of put, and using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n           // keep this runner alive\n           scheduler.execute(this);\n          } else {\n            runners.remove( this );\n          }\n        }\n\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"020841d13e26cb8a592671f1fc6faafeb69bda4a","date":1322041194,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        while (!queue.isEmpty())  {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250, TimeUnit.MILLISECONDS);\n            if (updateRequest == null) break;\n            RequestEntity request = new RequestEntity() {\n              // we don't know the length\n              public long getContentLength() { return -1; }\n              public String getContentType() { return requestWriter.getUpdateContentType(); }\n              public boolean isRepeatable()  { return false; }\n\n              public void writeRequest(OutputStream out) throws IOException {\n                try {\n                  if (ClientUtils.TEXT_XML.equals(requestWriter.getUpdateContentType())) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    requestWriter.write(req, out);\n                    if (ClientUtils.TEXT_XML.equals(requestWriter.getUpdateContentType())) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false) + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (ClientUtils.TEXT_XML.equals(requestWriter.getUpdateContentType())) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n                  out.flush();\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            };\n\n            String path = ClientUtils.TEXT_XML.equals(requestWriter.getUpdateContentType()) ? \"/update\" : \"/update/javabin\";\n\n            method = new PostMethod(_baseURL+path );\n            method.setRequestEntity( request );\n            method.setFollowRedirects( false );\n            method.addRequestHeader( \"User-Agent\", AGENT );\n            \n            int statusCode = getHttpClient().executeMethod(method);\n            log.info(\"Status for: \" + updateRequest.getDocuments().get(0).getFieldValue(\"id\") + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append( method.getStatusLine().getReasonPhrase() );\n              msg.append( \"\\n\\n\" );\n              msg.append( method.getStatusText() );\n              msg.append( \"\\n\\n\" );\n              msg.append(\"request: \").append(method.getURI());\n              handleError( new Exception( msg.toString() ) );\n            }\n          } finally {\n            try {\n              // make sure to release the connection\n              if(method != null)\n                method.releaseConnection();\n            }\n            catch( Exception ex ){}\n          }\n        }\n      }\n      catch (Throwable e) {\n        handleError( e );\n      }\n      finally {\n\n        // remove it from the list of running things unless we are the last runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no runners to handle it.\n        // This case has been further handled by using offer instead of put, and using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n           // keep this runner alive\n           scheduler.execute(this);\n          } else {\n            runners.remove( this );\n          }\n        }\n\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        do {\n          try {\n            RequestEntity request = new RequestEntity() {\n              // we don't know the length\n              public long getContentLength() { return -1; }\n              public String getContentType() { return ClientUtils.TEXT_XML; }\n              public boolean isRepeatable()  { return false; }\n      \n              public void writeRequest(OutputStream out) throws IOException {\n                try {\n                  OutputStreamWriter writer = new OutputStreamWriter(out, \"UTF-8\");\n                  writer.append( \"<stream>\" ); // can be anything...\n                  UpdateRequest req = queue.poll( 250, TimeUnit.MILLISECONDS );\n                  while( req != null ) {\n                    log.debug( \"sending: {}\" , req );\n                    req.writeXML( writer ); \n                    \n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if( params != null ) {\n                      String fmt = null;\n                      if( params.getBool( UpdateParams.OPTIMIZE, false ) ) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                      }\n                      else if( params.getBool( UpdateParams.COMMIT, false ) ) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                      }\n                      if( fmt != null ) {\n                        log.info( fmt );\n                        writer.write( String.format( fmt, \n                            params.getBool( UpdateParams.WAIT_SEARCHER, false )+\"\") );\n                      }\n                    }\n                    \n                    writer.flush();\n                    req = queue.poll( 250, TimeUnit.MILLISECONDS );\n                  }\n                  writer.append( \"</stream>\" );\n                  writer.flush();\n                }\n                catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            };\n          \n            method = new PostMethod(_baseURL+updateUrl );\n            method.setRequestEntity( request );\n            method.setFollowRedirects( false );\n            method.addRequestHeader( \"User-Agent\", AGENT );\n            \n            int statusCode = getHttpClient().executeMethod(method);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append( method.getStatusLine().getReasonPhrase() );\n              msg.append( \"\\n\\n\" );\n              msg.append( method.getStatusText() );\n              msg.append( \"\\n\\n\" );\n              msg.append( \"request: \"+method.getURI() );\n              handleError( new Exception( msg.toString() ) );\n            }\n          } finally {\n            try {\n              // make sure to release the connection\n              if(method != null)\n                method.releaseConnection();\n            }\n            catch( Exception ex ){}\n          }\n        } while( ! queue.isEmpty());\n      }\n      catch (Throwable e) {\n        handleError( e );\n      }\n      finally {\n\n        // remove it from the list of running things unless we are the last runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no runners to handle it.\n        // This case has been further handled by using offer instead of put, and using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n           // keep this runner alive\n           scheduler.execute(this);\n          } else {\n            runners.remove( this );\n          }\n        }\n\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7321b77a7bc3edfebd637ef273e9dfaa9969eba6","date":1333023097,"type":5,"author":"Sami Siren","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (ClientUtils.TEXT_XML.equals(server.requestWriter\n                      .getUpdateContentType())) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    server.requestWriter.write(req, out);\n                    if (ClientUtils.TEXT_XML.equals(server.requestWriter\n                        .getUpdateContentType())) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (ClientUtils.TEXT_XML.equals(server.requestWriter\n                      .getUpdateContentType())) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n\n            String path = ClientUtils.TEXT_XML.equals(server.requestWriter\n                .getUpdateContentType()) ? \"/update\" : \"/update/javabin\";\n\n            method = new HttpPost(server.getBaseURL() + path);\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        while (!queue.isEmpty())  {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250, TimeUnit.MILLISECONDS);\n            if (updateRequest == null) break;\n            RequestEntity request = new RequestEntity() {\n              // we don't know the length\n              public long getContentLength() { return -1; }\n              public String getContentType() { return requestWriter.getUpdateContentType(); }\n              public boolean isRepeatable()  { return false; }\n\n              public void writeRequest(OutputStream out) throws IOException {\n                try {\n                  if (ClientUtils.TEXT_XML.equals(requestWriter.getUpdateContentType())) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    requestWriter.write(req, out);\n                    if (ClientUtils.TEXT_XML.equals(requestWriter.getUpdateContentType())) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false) + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (ClientUtils.TEXT_XML.equals(requestWriter.getUpdateContentType())) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n                  out.flush();\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            };\n\n            String path = ClientUtils.TEXT_XML.equals(requestWriter.getUpdateContentType()) ? \"/update\" : \"/update/javabin\";\n\n            method = new PostMethod(_baseURL+path );\n            method.setRequestEntity( request );\n            method.setFollowRedirects( false );\n            method.addRequestHeader( \"User-Agent\", AGENT );\n            \n            int statusCode = getHttpClient().executeMethod(method);\n            log.info(\"Status for: \" + updateRequest.getDocuments().get(0).getFieldValue(\"id\") + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append( method.getStatusLine().getReasonPhrase() );\n              msg.append( \"\\n\\n\" );\n              msg.append( method.getStatusText() );\n              msg.append( \"\\n\\n\" );\n              msg.append(\"request: \").append(method.getURI());\n              handleError( new Exception( msg.toString() ) );\n            }\n          } finally {\n            try {\n              // make sure to release the connection\n              if(method != null)\n                method.releaseConnection();\n            }\n            catch( Exception ex ){}\n          }\n        }\n      }\n      catch (Throwable e) {\n        handleError( e );\n      }\n      finally {\n\n        // remove it from the list of running things unless we are the last runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no runners to handle it.\n        // This case has been further handled by using offer instead of put, and using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n           // keep this runner alive\n           scheduler.execute(this);\n          } else {\n            runners.remove( this );\n          }\n        }\n\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":["1ed88f2d1f6a64c8b31ace51541448a0b2f29606","945902ae43d8dd7e920418efe36981403c2ee669","91e069c492cf4895697ef7b81df0ffb9a8bd4b48","ed0dd3d82be806ac8ab4e15bf5b89310270c0210"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"020841d13e26cb8a592671f1fc6faafeb69bda4a":["c26f00b574427b55127e869b935845554afde1fa"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["020841d13e26cb8a592671f1fc6faafeb69bda4a"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"]},"commit2Childs":{"020841d13e26cb8a592671f1fc6faafeb69bda4a":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["020841d13e26cb8a592671f1fc6faafeb69bda4a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee"],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}