{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#numDeletesToMerge(SegmentCommitInfo).mjava","commits":[{"id":"9ae87c7be37e537f40fa3bb2c35fa4a368d12a72","date":1523453225,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#numDeletesToMerge(SegmentCommitInfo).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns the number of deletes a merge would claim back if the given segment is merged.\n   * @see MergePolicy#numDeletesToMerge(SegmentCommitInfo, int, org.apache.lucene.util.IOSupplier)\n   * @param info the segment to get the number of deletes for\n   * @lucene.experimental\n   */\n  public final int numDeletesToMerge(SegmentCommitInfo info) throws IOException {\n    MergePolicy mergePolicy = config.getMergePolicy();\n    final ReadersAndUpdates rld = readerPool.get(info, false);\n    int numDeletesToMerge;\n    if (rld != null) {\n      numDeletesToMerge = rld.numDeletesToMerge(mergePolicy);\n    } else {\n      numDeletesToMerge = mergePolicy.numDeletesToMerge(info,  0, null);\n    }\n    assert numDeletesToMerge <= info.info.maxDoc() :\n    \"numDeletesToMerge: \" + numDeletesToMerge + \" > maxDoc: \" + info.info.maxDoc();\n    return numDeletesToMerge;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43345f1452f9510f8aaadae6156fe0c834e7d957","date":1523483670,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#numDeletesToMerge(SegmentCommitInfo).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns the number of deletes a merge would claim back if the given segment is merged.\n   * @see MergePolicy#numDeletesToMerge(SegmentCommitInfo, int, org.apache.lucene.util.IOSupplier)\n   * @param info the segment to get the number of deletes for\n   * @lucene.experimental\n   */\n  public final int numDeletesToMerge(SegmentCommitInfo info) throws IOException {\n    MergePolicy mergePolicy = config.getMergePolicy();\n    final ReadersAndUpdates rld = readerPool.get(info, false);\n    int numDeletesToMerge;\n    if (rld != null) {\n      numDeletesToMerge = rld.numDeletesToMerge(mergePolicy);\n    } else {\n      numDeletesToMerge = mergePolicy.numDeletesToMerge(info,  0, null);\n    }\n    assert numDeletesToMerge <= info.info.maxDoc() :\n    \"numDeletesToMerge: \" + numDeletesToMerge + \" > maxDoc: \" + info.info.maxDoc();\n    return numDeletesToMerge;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36d13f271b6649357e07f71f7e46559479f69b5b","date":1523888226,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#numDeletesToMerge(SegmentCommitInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#numDeletesToMerge(SegmentCommitInfo).mjava","sourceNew":"  /**\n   * Returns the number of deletes a merge would claim back if the given segment is merged.\n   * @see MergePolicy#numDeletesToMerge(SegmentCommitInfo, int, org.apache.lucene.util.IOSupplier)\n   * @param info the segment to get the number of deletes for\n   * @lucene.experimental\n   */\n  public final int numDeletesToMerge(SegmentCommitInfo info) throws IOException {\n    MergePolicy mergePolicy = config.getMergePolicy();\n    final ReadersAndUpdates rld = readerPool.get(info, true);\n    try {\n      int numDeletesToMerge = rld.numDeletesToMerge(mergePolicy);\n      assert numDeletesToMerge <= info.info.maxDoc() :\n          \"numDeletesToMerge: \" + numDeletesToMerge + \" > maxDoc: \" + info.info.maxDoc();\n      return numDeletesToMerge;\n    } finally {\n      readerPool.release(rld);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Returns the number of deletes a merge would claim back if the given segment is merged.\n   * @see MergePolicy#numDeletesToMerge(SegmentCommitInfo, int, org.apache.lucene.util.IOSupplier)\n   * @param info the segment to get the number of deletes for\n   * @lucene.experimental\n   */\n  public final int numDeletesToMerge(SegmentCommitInfo info) throws IOException {\n    MergePolicy mergePolicy = config.getMergePolicy();\n    final ReadersAndUpdates rld = readerPool.get(info, false);\n    int numDeletesToMerge;\n    if (rld != null) {\n      numDeletesToMerge = rld.numDeletesToMerge(mergePolicy);\n    } else {\n      numDeletesToMerge = mergePolicy.numDeletesToMerge(info,  0, null);\n    }\n    assert numDeletesToMerge <= info.info.maxDoc() :\n    \"numDeletesToMerge: \" + numDeletesToMerge + \" > maxDoc: \" + info.info.maxDoc();\n    return numDeletesToMerge;\n  }\n\n","bugFix":null,"bugIntro":["15e716649e2bd79a98b5e68c464154ea4c44677a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15e716649e2bd79a98b5e68c464154ea4c44677a","date":1523975212,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#numDeletesToMerge(SegmentCommitInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#numDeletesToMerge(SegmentCommitInfo).mjava","sourceNew":"  /**\n   * Returns the number of deletes a merge would claim back if the given segment is merged.\n   * @see MergePolicy#numDeletesToMerge(SegmentCommitInfo, int, org.apache.lucene.util.IOSupplier)\n   * @param info the segment to get the number of deletes for\n   * @lucene.experimental\n   */\n  public final int numDeletesToMerge(SegmentCommitInfo info) throws IOException {\n    MergePolicy mergePolicy = config.getMergePolicy();\n    final ReadersAndUpdates rld = readerPool.get(info, false);\n    int numDeletesToMerge;\n    if (rld != null) {\n      numDeletesToMerge = rld.numDeletesToMerge(mergePolicy);\n    } else {\n      // if we don't have a  pooled instance lets just return the hard deletes, this is safe!\n      numDeletesToMerge = info.getDelCount();\n    }\n    assert numDeletesToMerge <= info.info.maxDoc() :\n        \"numDeletesToMerge: \" + numDeletesToMerge + \" > maxDoc: \" + info.info.maxDoc();\n    return numDeletesToMerge;\n\n  }\n\n","sourceOld":"  /**\n   * Returns the number of deletes a merge would claim back if the given segment is merged.\n   * @see MergePolicy#numDeletesToMerge(SegmentCommitInfo, int, org.apache.lucene.util.IOSupplier)\n   * @param info the segment to get the number of deletes for\n   * @lucene.experimental\n   */\n  public final int numDeletesToMerge(SegmentCommitInfo info) throws IOException {\n    MergePolicy mergePolicy = config.getMergePolicy();\n    final ReadersAndUpdates rld = readerPool.get(info, true);\n    try {\n      int numDeletesToMerge = rld.numDeletesToMerge(mergePolicy);\n      assert numDeletesToMerge <= info.info.maxDoc() :\n          \"numDeletesToMerge: \" + numDeletesToMerge + \" > maxDoc: \" + info.info.maxDoc();\n      return numDeletesToMerge;\n    } finally {\n      readerPool.release(rld);\n    }\n\n  }\n\n","bugFix":["36d13f271b6649357e07f71f7e46559479f69b5b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1926100d9b67becc9701c54266fee3ba7878a5f0","date":1524472150,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#numDeletesToMerge(SegmentCommitInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#numDeletesToMerge(SegmentCommitInfo).mjava","sourceNew":"  /**\n   * Returns the number of deletes a merge would claim back if the given segment is merged.\n   * @see MergePolicy#numDeletesToMerge(SegmentCommitInfo, int, org.apache.lucene.util.IOSupplier)\n   * @param info the segment to get the number of deletes for\n   * @lucene.experimental\n   */\n  public final int numDeletesToMerge(SegmentCommitInfo info) throws IOException {\n    ensureOpen(false);\n    MergePolicy mergePolicy = config.getMergePolicy();\n    final ReadersAndUpdates rld = getPooledInstance(info, false);\n    int numDeletesToMerge;\n    if (rld != null) {\n      numDeletesToMerge = rld.numDeletesToMerge(mergePolicy);\n    } else {\n      // if we don't have a  pooled instance lets just return the hard deletes, this is safe!\n      numDeletesToMerge = info.getDelCount();\n    }\n    assert numDeletesToMerge <= info.info.maxDoc() :\n        \"numDeletesToMerge: \" + numDeletesToMerge + \" > maxDoc: \" + info.info.maxDoc();\n    return numDeletesToMerge;\n  }\n\n","sourceOld":"  /**\n   * Returns the number of deletes a merge would claim back if the given segment is merged.\n   * @see MergePolicy#numDeletesToMerge(SegmentCommitInfo, int, org.apache.lucene.util.IOSupplier)\n   * @param info the segment to get the number of deletes for\n   * @lucene.experimental\n   */\n  public final int numDeletesToMerge(SegmentCommitInfo info) throws IOException {\n    MergePolicy mergePolicy = config.getMergePolicy();\n    final ReadersAndUpdates rld = readerPool.get(info, false);\n    int numDeletesToMerge;\n    if (rld != null) {\n      numDeletesToMerge = rld.numDeletesToMerge(mergePolicy);\n    } else {\n      // if we don't have a  pooled instance lets just return the hard deletes, this is safe!\n      numDeletesToMerge = info.getDelCount();\n    }\n    assert numDeletesToMerge <= info.info.maxDoc() :\n        \"numDeletesToMerge: \" + numDeletesToMerge + \" > maxDoc: \" + info.info.maxDoc();\n    return numDeletesToMerge;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d28f215464f76024caf026606f8ea51a5319c53","date":1527226629,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#numDeletesToMerge(SegmentCommitInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#numDeletesToMerge(SegmentCommitInfo).mjava","sourceNew":"  /**\n   * Returns the number of deletes a merge would claim back if the given segment is merged.\n   * @see MergePolicy#numDeletesToMerge(SegmentCommitInfo, int, org.apache.lucene.util.IOSupplier)\n   * @param info the segment to get the number of deletes for\n   * @lucene.experimental\n   */\n  @Override\n  public final int numDeletesToMerge(SegmentCommitInfo info) throws IOException {\n    ensureOpen(false);\n    validate(info);\n    MergePolicy mergePolicy = config.getMergePolicy();\n    final ReadersAndUpdates rld = getPooledInstance(info, false);\n    int numDeletesToMerge;\n    if (rld != null) {\n      numDeletesToMerge = rld.numDeletesToMerge(mergePolicy);\n    } else {\n      // if we don't have a  pooled instance lets just return the hard deletes, this is safe!\n      numDeletesToMerge = info.getDelCount();\n    }\n    assert numDeletesToMerge <= info.info.maxDoc() :\n        \"numDeletesToMerge: \" + numDeletesToMerge + \" > maxDoc: \" + info.info.maxDoc();\n    return numDeletesToMerge;\n  }\n\n","sourceOld":"  /**\n   * Returns the number of deletes a merge would claim back if the given segment is merged.\n   * @see MergePolicy#numDeletesToMerge(SegmentCommitInfo, int, org.apache.lucene.util.IOSupplier)\n   * @param info the segment to get the number of deletes for\n   * @lucene.experimental\n   */\n  public final int numDeletesToMerge(SegmentCommitInfo info) throws IOException {\n    ensureOpen(false);\n    MergePolicy mergePolicy = config.getMergePolicy();\n    final ReadersAndUpdates rld = getPooledInstance(info, false);\n    int numDeletesToMerge;\n    if (rld != null) {\n      numDeletesToMerge = rld.numDeletesToMerge(mergePolicy);\n    } else {\n      // if we don't have a  pooled instance lets just return the hard deletes, this is safe!\n      numDeletesToMerge = info.getDelCount();\n    }\n    assert numDeletesToMerge <= info.info.maxDoc() :\n        \"numDeletesToMerge: \" + numDeletesToMerge + \" > maxDoc: \" + info.info.maxDoc();\n    return numDeletesToMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9ae87c7be37e537f40fa3bb2c35fa4a368d12a72":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1d28f215464f76024caf026606f8ea51a5319c53":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"36d13f271b6649357e07f71f7e46559479f69b5b":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"15e716649e2bd79a98b5e68c464154ea4c44677a":["36d13f271b6649357e07f71f7e46559479f69b5b"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["15e716649e2bd79a98b5e68c464154ea4c44677a"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9ae87c7be37e537f40fa3bb2c35fa4a368d12a72"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1d28f215464f76024caf026606f8ea51a5319c53"]},"commit2Childs":{"9ae87c7be37e537f40fa3bb2c35fa4a368d12a72":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ae87c7be37e537f40fa3bb2c35fa4a368d12a72","43345f1452f9510f8aaadae6156fe0c834e7d957"],"1d28f215464f76024caf026606f8ea51a5319c53":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"36d13f271b6649357e07f71f7e46559479f69b5b":["15e716649e2bd79a98b5e68c464154ea4c44677a"],"15e716649e2bd79a98b5e68c464154ea4c44677a":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["1d28f215464f76024caf026606f8ea51a5319c53"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["36d13f271b6649357e07f71f7e46559479f69b5b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}