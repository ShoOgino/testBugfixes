{"path":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#[T]_keywordTokenStream(Collection[T]).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#[T]_keywordTokenStream(Collection[T]).mjava","pathOld":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#[T]_keywordTokenStream(Collection[T]).mjava","sourceNew":"  /**\n   * Convenience method; Creates and returns a token stream that generates a\n   * token for each keyword in the given collection, \"as is\", without any\n   * transforming text analysis. The resulting token stream can be fed into\n   * {@link #addField(String, TokenStream)}, perhaps wrapped into another\n   * {@link org.apache.lucene.analysis.TokenFilter}, as desired.\n   * \n   * @param keywords\n   *            the keywords to generate tokens for\n   * @return the corresponding token stream\n   */\n  public <T> TokenStream keywordTokenStream(final Collection<T> keywords) {\n    // TODO: deprecate & move this method into AnalyzerUtil?\n    if (keywords == null)\n      throw new IllegalArgumentException(\"keywords must not be null\");\n    \n    return new TokenStream() {\n      private Iterator<T> iter = keywords.iterator();\n      private int start = 0;\n      private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);\n      private final OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);\n      \n      @Override\n      public boolean incrementToken() {\n        if (!iter.hasNext()) return false;\n        \n        T obj = iter.next();\n        if (obj == null) \n          throw new IllegalArgumentException(\"keyword must not be null\");\n        \n        String term = obj.toString();\n        clearAttributes();\n        termAtt.setEmpty().append(term);\n        offsetAtt.setOffset(start, start+termAtt.length());\n        start += term.length() + 1; // separate words by 1 (blank) character\n        return true;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Convenience method; Creates and returns a token stream that generates a\n   * token for each keyword in the given collection, \"as is\", without any\n   * transforming text analysis. The resulting token stream can be fed into\n   * {@link #addField(String, TokenStream)}, perhaps wrapped into another\n   * {@link org.apache.lucene.analysis.TokenFilter}, as desired.\n   * \n   * @param keywords\n   *            the keywords to generate tokens for\n   * @return the corresponding token stream\n   */\n  public <T> TokenStream keywordTokenStream(final Collection<T> keywords) {\n    // TODO: deprecate & move this method into AnalyzerUtil?\n    if (keywords == null)\n      throw new IllegalArgumentException(\"keywords must not be null\");\n    \n    return new TokenStream() {\n      private Iterator<T> iter = keywords.iterator();\n      private int start = 0;\n      private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);\n      private final OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);\n      \n      @Override\n      public boolean incrementToken() {\n        if (!iter.hasNext()) return false;\n        \n        T obj = iter.next();\n        if (obj == null) \n          throw new IllegalArgumentException(\"keyword must not be null\");\n        \n        String term = obj.toString();\n        clearAttributes();\n        termAtt.setEmpty().append(term);\n        offsetAtt.setOffset(start, start+termAtt.length());\n        start += term.length() + 1; // separate words by 1 (blank) character\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}