{"path":"solr/core/src/test/org/apache/solr/cloud/TestCloudPivotFacet#assertPivotStats(String,PivotField,QueryResponse).mjava","commits":[{"id":"4c18a95e9168a30be855f5d5e7d61a863186fdc5","date":1415142581,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudPivotFacet#assertPivotStats(String,PivotField,QueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Compare top level stats in response with stats from pivot constraint\n   */\n  private void assertPivotStats(String message, PivotField constraint, QueryResponse response) throws SolrServerException {\n\n    if (null == constraint.getFieldStatsInfo()) {\n      // no stats for this pivot, nothing to check\n\n      // TODO: use a trace param to know if/how-many to expect ?\n      log.info(\"No stats to check for => \" + message);\n      return;\n    }\n    \n    Map<String, FieldStatsInfo> actualFieldStatsInfoMap = response.getFieldStatsInfo();\n\n    for (FieldStatsInfo pivotStats : constraint.getFieldStatsInfo().values()) {\n      String statsKey = pivotStats.getName();\n\n      FieldStatsInfo actualStats = actualFieldStatsInfoMap.get(statsKey);\n\n      if (actualStats == null) {\n        // handle case for not found stats (using stats query)\n        //\n        // these has to be a special case check due to the legacy behavior of \"top level\" \n        // StatsComponent results being \"null\" (and not even included in the \n        // getFieldStatsInfo() Map due to specila SolrJ logic) \n\n        log.info(\"Requested stats missing in verification query, pivot stats: \" + pivotStats);\n        assertEquals(\"Special Count\", 0L, pivotStats.getCount().longValue());\n        assertEquals(\"Special Missing\", \n                     constraint.getCount(), pivotStats.getMissing().longValue());\n\n      } else {\n        // regular stats, compare everything...\n\n        assert actualStats != null;\n        String msg = \" of \" + statsKey + \" => \" + message;\n        \n        assertEquals(\"Min\" + msg, pivotStats.getMin(), actualStats.getMin());\n        assertEquals(\"Max\" + msg, pivotStats.getMax(), actualStats.getMax());\n        assertEquals(\"Mean\" + msg, pivotStats.getMean(), actualStats.getMean());\n        assertEquals(\"Sum\" + msg, pivotStats.getSum(), actualStats.getSum());\n        assertEquals(\"Count\" + msg, pivotStats.getCount(), actualStats.getCount());\n        assertEquals(\"Missing\" + msg, pivotStats.getMissing(), actualStats.getMissing());\n        \n        assertDoubles(\"Stddev\" + msg, pivotStats.getStddev(), actualStats.getStddev());\n        assertDoubles(\"SumOfSquares\" + msg, \n                      pivotStats.getSumOfSquares(), actualStats.getSumOfSquares());\n      }\n    }\n\n    if (constraint.getFieldStatsInfo().containsKey(\"sk2\")) { // cheeseball hack\n      // if \"sk2\" was one of hte stats we computed, then we must have also seen\n      // sk1 or sk3 because of the way the tags are fixed\n      assertEquals(\"had stats sk2, but not another stat?\", \n                   2, constraint.getFieldStatsInfo().size());\n    } else {\n      // if we did not see \"sk2\", then 1 of the others must be alone\n      assertEquals(\"only expected 1 stat\",\n                   1, constraint.getFieldStatsInfo().size());\n      assertTrue(\"not sk1 or sk3\", \n                 constraint.getFieldStatsInfo().containsKey(\"sk1\") ||\n                 constraint.getFieldStatsInfo().containsKey(\"sk3\"));\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["dbdfda95da145c32af2267b537c92481acc7a522"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dbdfda95da145c32af2267b537c92481acc7a522","date":1435597588,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudPivotFacet#assertPivotStats(String,PivotField,QueryResponse).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudPivotFacet#assertPivotStats(String,PivotField,QueryResponse).mjava","sourceNew":"  /**\n   * Compare top level stats in response with stats from pivot constraint\n   */\n  private void assertPivotStats(String message, PivotField constraint, QueryResponse response) throws SolrServerException {\n\n    if (null == constraint.getFieldStatsInfo()) {\n      // no stats for this pivot, nothing to check\n\n      // TODO: use a trace param to know if/how-many to expect ?\n      log.info(\"No stats to check for => \" + message);\n      return;\n    }\n    \n    Map<String, FieldStatsInfo> actualFieldStatsInfoMap = response.getFieldStatsInfo();\n\n    for (FieldStatsInfo pivotStats : constraint.getFieldStatsInfo().values()) {\n      String statsKey = pivotStats.getName();\n\n      FieldStatsInfo actualStats = actualFieldStatsInfoMap.get(statsKey);\n\n      if (actualStats == null) {\n        // handle case for not found stats (using stats query)\n        //\n        // these has to be a special case check due to the legacy behavior of \"top level\" \n        // StatsComponent results being \"null\" (and not even included in the \n        // getFieldStatsInfo() Map due to specila SolrJ logic) \n\n        log.info(\"Requested stats missing in verification query, pivot stats: \" + pivotStats);\n        assertEquals(\"Special Count\", 0L, pivotStats.getCount().longValue());\n        assertEquals(\"Special Missing\", \n                     constraint.getCount(), pivotStats.getMissing().longValue());\n\n      } else {\n        // regular stats, compare everything...\n\n        assert actualStats != null;\n        String msg = \" of \" + statsKey + \" => \" + message;\n\n        // no wiggle room, these should always be exactly equals, regardless of field type\n        assertEquals(\"Count\" + msg, pivotStats.getCount(), actualStats.getCount());\n        assertEquals(\"Missing\" + msg, pivotStats.getMissing(), actualStats.getMissing());\n        assertEquals(\"Min\" + msg, pivotStats.getMin(), actualStats.getMin());\n        assertEquals(\"Max\" + msg, pivotStats.getMax(), actualStats.getMax());\n\n        // precision loss can affect these in some field types depending on shards used\n        // and the order that values are accumulated\n        assertNumerics(\"Sum\" + msg, pivotStats.getSum(), actualStats.getSum());\n        assertNumerics(\"Mean\" + msg, pivotStats.getMean(), actualStats.getMean());\n        assertNumerics(\"Stddev\" + msg, pivotStats.getStddev(), actualStats.getStddev());\n        assertNumerics(\"SumOfSquares\" + msg, \n                      pivotStats.getSumOfSquares(), actualStats.getSumOfSquares());\n      }\n    }\n\n    if (constraint.getFieldStatsInfo().containsKey(\"sk2\")) { // cheeseball hack\n      // if \"sk2\" was one of hte stats we computed, then we must have also seen\n      // sk1 or sk3 because of the way the tags are fixed\n      assertEquals(\"had stats sk2, but not another stat?\", \n                   2, constraint.getFieldStatsInfo().size());\n    } else {\n      // if we did not see \"sk2\", then 1 of the others must be alone\n      assertEquals(\"only expected 1 stat\",\n                   1, constraint.getFieldStatsInfo().size());\n      assertTrue(\"not sk1 or sk3\", \n                 constraint.getFieldStatsInfo().containsKey(\"sk1\") ||\n                 constraint.getFieldStatsInfo().containsKey(\"sk3\"));\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Compare top level stats in response with stats from pivot constraint\n   */\n  private void assertPivotStats(String message, PivotField constraint, QueryResponse response) throws SolrServerException {\n\n    if (null == constraint.getFieldStatsInfo()) {\n      // no stats for this pivot, nothing to check\n\n      // TODO: use a trace param to know if/how-many to expect ?\n      log.info(\"No stats to check for => \" + message);\n      return;\n    }\n    \n    Map<String, FieldStatsInfo> actualFieldStatsInfoMap = response.getFieldStatsInfo();\n\n    for (FieldStatsInfo pivotStats : constraint.getFieldStatsInfo().values()) {\n      String statsKey = pivotStats.getName();\n\n      FieldStatsInfo actualStats = actualFieldStatsInfoMap.get(statsKey);\n\n      if (actualStats == null) {\n        // handle case for not found stats (using stats query)\n        //\n        // these has to be a special case check due to the legacy behavior of \"top level\" \n        // StatsComponent results being \"null\" (and not even included in the \n        // getFieldStatsInfo() Map due to specila SolrJ logic) \n\n        log.info(\"Requested stats missing in verification query, pivot stats: \" + pivotStats);\n        assertEquals(\"Special Count\", 0L, pivotStats.getCount().longValue());\n        assertEquals(\"Special Missing\", \n                     constraint.getCount(), pivotStats.getMissing().longValue());\n\n      } else {\n        // regular stats, compare everything...\n\n        assert actualStats != null;\n        String msg = \" of \" + statsKey + \" => \" + message;\n        \n        assertEquals(\"Min\" + msg, pivotStats.getMin(), actualStats.getMin());\n        assertEquals(\"Max\" + msg, pivotStats.getMax(), actualStats.getMax());\n        assertEquals(\"Mean\" + msg, pivotStats.getMean(), actualStats.getMean());\n        assertEquals(\"Sum\" + msg, pivotStats.getSum(), actualStats.getSum());\n        assertEquals(\"Count\" + msg, pivotStats.getCount(), actualStats.getCount());\n        assertEquals(\"Missing\" + msg, pivotStats.getMissing(), actualStats.getMissing());\n        \n        assertDoubles(\"Stddev\" + msg, pivotStats.getStddev(), actualStats.getStddev());\n        assertDoubles(\"SumOfSquares\" + msg, \n                      pivotStats.getSumOfSquares(), actualStats.getSumOfSquares());\n      }\n    }\n\n    if (constraint.getFieldStatsInfo().containsKey(\"sk2\")) { // cheeseball hack\n      // if \"sk2\" was one of hte stats we computed, then we must have also seen\n      // sk1 or sk3 because of the way the tags are fixed\n      assertEquals(\"had stats sk2, but not another stat?\", \n                   2, constraint.getFieldStatsInfo().size());\n    } else {\n      // if we did not see \"sk2\", then 1 of the others must be alone\n      assertEquals(\"only expected 1 stat\",\n                   1, constraint.getFieldStatsInfo().size());\n      assertTrue(\"not sk1 or sk3\", \n                 constraint.getFieldStatsInfo().containsKey(\"sk1\") ||\n                 constraint.getFieldStatsInfo().containsKey(\"sk3\"));\n    }\n\n  }\n\n","bugFix":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac9de183adbc9483681f275ac1e2d92ed19f52e1","date":1452414626,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudPivotFacet#assertPivotStats(String,PivotField,QueryResponse).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudPivotFacet#assertPivotStats(String,PivotField,QueryResponse).mjava","sourceNew":"  /**\n   * Compare top level stats in response with stats from pivot constraint\n   */\n  private void assertPivotStats(String message, PivotField constraint, QueryResponse response) {\n\n    if (null == constraint.getFieldStatsInfo()) {\n      // no stats for this pivot, nothing to check\n\n      // TODO: use a trace param to know if/how-many to expect ?\n      log.info(\"No stats to check for => \" + message);\n      return;\n    }\n    \n    Map<String, FieldStatsInfo> actualFieldStatsInfoMap = response.getFieldStatsInfo();\n\n    for (FieldStatsInfo pivotStats : constraint.getFieldStatsInfo().values()) {\n      String statsKey = pivotStats.getName();\n\n      FieldStatsInfo actualStats = actualFieldStatsInfoMap.get(statsKey);\n\n      if (actualStats == null) {\n        // handle case for not found stats (using stats query)\n        //\n        // these has to be a special case check due to the legacy behavior of \"top level\" \n        // StatsComponent results being \"null\" (and not even included in the \n        // getFieldStatsInfo() Map due to specila SolrJ logic) \n\n        log.info(\"Requested stats missing in verification query, pivot stats: \" + pivotStats);\n        assertEquals(\"Special Count\", 0L, pivotStats.getCount().longValue());\n        assertEquals(\"Special Missing\", \n                     constraint.getCount(), pivotStats.getMissing().longValue());\n\n      } else {\n        // regular stats, compare everything...\n\n        assert actualStats != null;\n        String msg = \" of \" + statsKey + \" => \" + message;\n\n        // no wiggle room, these should always be exactly equals, regardless of field type\n        assertEquals(\"Count\" + msg, pivotStats.getCount(), actualStats.getCount());\n        assertEquals(\"Missing\" + msg, pivotStats.getMissing(), actualStats.getMissing());\n        assertEquals(\"Min\" + msg, pivotStats.getMin(), actualStats.getMin());\n        assertEquals(\"Max\" + msg, pivotStats.getMax(), actualStats.getMax());\n\n        // precision loss can affect these in some field types depending on shards used\n        // and the order that values are accumulated\n        assertNumerics(\"Sum\" + msg, pivotStats.getSum(), actualStats.getSum());\n        assertNumerics(\"Mean\" + msg, pivotStats.getMean(), actualStats.getMean());\n        assertNumerics(\"Stddev\" + msg, pivotStats.getStddev(), actualStats.getStddev());\n        assertNumerics(\"SumOfSquares\" + msg, \n                      pivotStats.getSumOfSquares(), actualStats.getSumOfSquares());\n      }\n    }\n\n    if (constraint.getFieldStatsInfo().containsKey(\"sk2\")) { // cheeseball hack\n      // if \"sk2\" was one of hte stats we computed, then we must have also seen\n      // sk1 or sk3 because of the way the tags are fixed\n      assertEquals(\"had stats sk2, but not another stat?\", \n                   2, constraint.getFieldStatsInfo().size());\n    } else {\n      // if we did not see \"sk2\", then 1 of the others must be alone\n      assertEquals(\"only expected 1 stat\",\n                   1, constraint.getFieldStatsInfo().size());\n      assertTrue(\"not sk1 or sk3\", \n                 constraint.getFieldStatsInfo().containsKey(\"sk1\") ||\n                 constraint.getFieldStatsInfo().containsKey(\"sk3\"));\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Compare top level stats in response with stats from pivot constraint\n   */\n  private void assertPivotStats(String message, PivotField constraint, QueryResponse response) throws SolrServerException {\n\n    if (null == constraint.getFieldStatsInfo()) {\n      // no stats for this pivot, nothing to check\n\n      // TODO: use a trace param to know if/how-many to expect ?\n      log.info(\"No stats to check for => \" + message);\n      return;\n    }\n    \n    Map<String, FieldStatsInfo> actualFieldStatsInfoMap = response.getFieldStatsInfo();\n\n    for (FieldStatsInfo pivotStats : constraint.getFieldStatsInfo().values()) {\n      String statsKey = pivotStats.getName();\n\n      FieldStatsInfo actualStats = actualFieldStatsInfoMap.get(statsKey);\n\n      if (actualStats == null) {\n        // handle case for not found stats (using stats query)\n        //\n        // these has to be a special case check due to the legacy behavior of \"top level\" \n        // StatsComponent results being \"null\" (and not even included in the \n        // getFieldStatsInfo() Map due to specila SolrJ logic) \n\n        log.info(\"Requested stats missing in verification query, pivot stats: \" + pivotStats);\n        assertEquals(\"Special Count\", 0L, pivotStats.getCount().longValue());\n        assertEquals(\"Special Missing\", \n                     constraint.getCount(), pivotStats.getMissing().longValue());\n\n      } else {\n        // regular stats, compare everything...\n\n        assert actualStats != null;\n        String msg = \" of \" + statsKey + \" => \" + message;\n\n        // no wiggle room, these should always be exactly equals, regardless of field type\n        assertEquals(\"Count\" + msg, pivotStats.getCount(), actualStats.getCount());\n        assertEquals(\"Missing\" + msg, pivotStats.getMissing(), actualStats.getMissing());\n        assertEquals(\"Min\" + msg, pivotStats.getMin(), actualStats.getMin());\n        assertEquals(\"Max\" + msg, pivotStats.getMax(), actualStats.getMax());\n\n        // precision loss can affect these in some field types depending on shards used\n        // and the order that values are accumulated\n        assertNumerics(\"Sum\" + msg, pivotStats.getSum(), actualStats.getSum());\n        assertNumerics(\"Mean\" + msg, pivotStats.getMean(), actualStats.getMean());\n        assertNumerics(\"Stddev\" + msg, pivotStats.getStddev(), actualStats.getStddev());\n        assertNumerics(\"SumOfSquares\" + msg, \n                      pivotStats.getSumOfSquares(), actualStats.getSumOfSquares());\n      }\n    }\n\n    if (constraint.getFieldStatsInfo().containsKey(\"sk2\")) { // cheeseball hack\n      // if \"sk2\" was one of hte stats we computed, then we must have also seen\n      // sk1 or sk3 because of the way the tags are fixed\n      assertEquals(\"had stats sk2, but not another stat?\", \n                   2, constraint.getFieldStatsInfo().size());\n    } else {\n      // if we did not see \"sk2\", then 1 of the others must be alone\n      assertEquals(\"only expected 1 stat\",\n                   1, constraint.getFieldStatsInfo().size());\n      assertTrue(\"not sk1 or sk3\", \n                 constraint.getFieldStatsInfo().containsKey(\"sk1\") ||\n                 constraint.getFieldStatsInfo().containsKey(\"sk3\"));\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab69ebfb1ee96d15d8a6b2ed13c2ac96c82ee0d2","date":1541135000,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudPivotFacet#assertPivotStats(String,PivotField,QueryResponse).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudPivotFacet#assertPivotStats(String,PivotField,QueryResponse).mjava","sourceNew":"  /**\n   * Compare top level stats in response with stats from pivot constraint\n   */\n  private void assertPivotStats(String message, PivotField constraint, QueryResponse response) {\n\n    if (null == constraint.getFieldStatsInfo()) {\n      // no stats for this pivot, nothing to check\n\n      // TODO: use a trace param to know if/how-many to expect ?\n      log.info(\"No stats to check for => \" + message);\n      return;\n    }\n    \n    Map<String, FieldStatsInfo> actualFieldStatsInfoMap = response.getFieldStatsInfo();\n\n    for (FieldStatsInfo pivotStats : constraint.getFieldStatsInfo().values()) {\n      String statsKey = pivotStats.getName();\n\n      FieldStatsInfo actualStats = actualFieldStatsInfoMap.get(statsKey);\n\n      if (actualStats == null) {\n        // handle case for not found stats (using stats query)\n        //\n        // these has to be a special case check due to the legacy behavior of \"top level\" \n        // StatsComponent results being \"null\" (and not even included in the \n        // getFieldStatsInfo() Map due to specila SolrJ logic) \n\n        log.info(\"Requested stats missing in verification query, pivot stats: \" + pivotStats);\n        assertEquals(\"Special Count\", 0L, pivotStats.getCount().longValue());\n        assertEquals(\"Special Missing\", \n                     constraint.getCount(), pivotStats.getMissing().longValue());\n\n      } else {\n        // regular stats, compare everything...\n\n        assert actualStats != null;\n        try {\n          String msg = \" of \" + statsKey;\n          \n          // no wiggle room, these should always be exactly equals, regardless of field type\n          assertEquals(\"Count\" + msg, pivotStats.getCount(), actualStats.getCount());\n          assertEquals(\"Missing\" + msg, pivotStats.getMissing(), actualStats.getMissing());\n          assertEquals(\"Min\" + msg, pivotStats.getMin(), actualStats.getMin());\n          assertEquals(\"Max\" + msg, pivotStats.getMax(), actualStats.getMax());\n\n        } catch (AssertionError e) {\n          throw new AssertionError(\"Stats: Pivot[\" + pivotStats + \"] <==> Actual[\" + actualStats + \"]  => \" + message, e);\n        }\n      }\n    }\n\n    if (constraint.getFieldStatsInfo().containsKey(\"sk2\")) { // cheeseball hack\n      // if \"sk2\" was one of hte stats we computed, then we must have also seen\n      // sk1 or sk3 because of the way the tags are fixed\n      assertEquals(\"had stats sk2, but not another stat?\", \n                   2, constraint.getFieldStatsInfo().size());\n    } else {\n      // if we did not see \"sk2\", then 1 of the others must be alone\n      assertEquals(\"only expected 1 stat\",\n                   1, constraint.getFieldStatsInfo().size());\n      assertTrue(\"not sk1 or sk3\", \n                 constraint.getFieldStatsInfo().containsKey(\"sk1\") ||\n                 constraint.getFieldStatsInfo().containsKey(\"sk3\"));\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Compare top level stats in response with stats from pivot constraint\n   */\n  private void assertPivotStats(String message, PivotField constraint, QueryResponse response) {\n\n    if (null == constraint.getFieldStatsInfo()) {\n      // no stats for this pivot, nothing to check\n\n      // TODO: use a trace param to know if/how-many to expect ?\n      log.info(\"No stats to check for => \" + message);\n      return;\n    }\n    \n    Map<String, FieldStatsInfo> actualFieldStatsInfoMap = response.getFieldStatsInfo();\n\n    for (FieldStatsInfo pivotStats : constraint.getFieldStatsInfo().values()) {\n      String statsKey = pivotStats.getName();\n\n      FieldStatsInfo actualStats = actualFieldStatsInfoMap.get(statsKey);\n\n      if (actualStats == null) {\n        // handle case for not found stats (using stats query)\n        //\n        // these has to be a special case check due to the legacy behavior of \"top level\" \n        // StatsComponent results being \"null\" (and not even included in the \n        // getFieldStatsInfo() Map due to specila SolrJ logic) \n\n        log.info(\"Requested stats missing in verification query, pivot stats: \" + pivotStats);\n        assertEquals(\"Special Count\", 0L, pivotStats.getCount().longValue());\n        assertEquals(\"Special Missing\", \n                     constraint.getCount(), pivotStats.getMissing().longValue());\n\n      } else {\n        // regular stats, compare everything...\n\n        assert actualStats != null;\n        String msg = \" of \" + statsKey + \" => \" + message;\n\n        // no wiggle room, these should always be exactly equals, regardless of field type\n        assertEquals(\"Count\" + msg, pivotStats.getCount(), actualStats.getCount());\n        assertEquals(\"Missing\" + msg, pivotStats.getMissing(), actualStats.getMissing());\n        assertEquals(\"Min\" + msg, pivotStats.getMin(), actualStats.getMin());\n        assertEquals(\"Max\" + msg, pivotStats.getMax(), actualStats.getMax());\n\n        // precision loss can affect these in some field types depending on shards used\n        // and the order that values are accumulated\n        assertNumerics(\"Sum\" + msg, pivotStats.getSum(), actualStats.getSum());\n        assertNumerics(\"Mean\" + msg, pivotStats.getMean(), actualStats.getMean());\n        assertNumerics(\"Stddev\" + msg, pivotStats.getStddev(), actualStats.getStddev());\n        assertNumerics(\"SumOfSquares\" + msg, \n                      pivotStats.getSumOfSquares(), actualStats.getSumOfSquares());\n      }\n    }\n\n    if (constraint.getFieldStatsInfo().containsKey(\"sk2\")) { // cheeseball hack\n      // if \"sk2\" was one of hte stats we computed, then we must have also seen\n      // sk1 or sk3 because of the way the tags are fixed\n      assertEquals(\"had stats sk2, but not another stat?\", \n                   2, constraint.getFieldStatsInfo().size());\n    } else {\n      // if we did not see \"sk2\", then 1 of the others must be alone\n      assertEquals(\"only expected 1 stat\",\n                   1, constraint.getFieldStatsInfo().size());\n      assertTrue(\"not sk1 or sk3\", \n                 constraint.getFieldStatsInfo().containsKey(\"sk1\") ||\n                 constraint.getFieldStatsInfo().containsKey(\"sk3\"));\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudPivotFacet#assertPivotStats(String,PivotField,QueryResponse).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudPivotFacet#assertPivotStats(String,PivotField,QueryResponse).mjava","sourceNew":"  /**\n   * Compare top level stats in response with stats from pivot constraint\n   */\n  private void assertPivotStats(String message, PivotField constraint, QueryResponse response) {\n\n    if (null == constraint.getFieldStatsInfo()) {\n      // no stats for this pivot, nothing to check\n\n      // TODO: use a trace param to know if/how-many to expect ?\n      log.info(\"No stats to check for => {}\", message);\n      return;\n    }\n    \n    Map<String, FieldStatsInfo> actualFieldStatsInfoMap = response.getFieldStatsInfo();\n\n    for (FieldStatsInfo pivotStats : constraint.getFieldStatsInfo().values()) {\n      String statsKey = pivotStats.getName();\n\n      FieldStatsInfo actualStats = actualFieldStatsInfoMap.get(statsKey);\n\n      if (actualStats == null) {\n        // handle case for not found stats (using stats query)\n        //\n        // these has to be a special case check due to the legacy behavior of \"top level\" \n        // StatsComponent results being \"null\" (and not even included in the \n        // getFieldStatsInfo() Map due to specila SolrJ logic) \n\n        log.info(\"Requested stats missing in verification query, pivot stats: {}\", pivotStats);\n        assertEquals(\"Special Count\", 0L, pivotStats.getCount().longValue());\n        assertEquals(\"Special Missing\", \n                     constraint.getCount(), pivotStats.getMissing().longValue());\n\n      } else {\n        // regular stats, compare everything...\n\n        assert actualStats != null;\n        try {\n          String msg = \" of \" + statsKey;\n          \n          // no wiggle room, these should always be exactly equals, regardless of field type\n          assertEquals(\"Count\" + msg, pivotStats.getCount(), actualStats.getCount());\n          assertEquals(\"Missing\" + msg, pivotStats.getMissing(), actualStats.getMissing());\n          assertEquals(\"Min\" + msg, pivotStats.getMin(), actualStats.getMin());\n          assertEquals(\"Max\" + msg, pivotStats.getMax(), actualStats.getMax());\n\n        } catch (AssertionError e) {\n          throw new AssertionError(\"Stats: Pivot[\" + pivotStats + \"] <==> Actual[\" + actualStats + \"]  => \" + message, e);\n        }\n      }\n    }\n\n    if (constraint.getFieldStatsInfo().containsKey(\"sk2\")) { // cheeseball hack\n      // if \"sk2\" was one of hte stats we computed, then we must have also seen\n      // sk1 or sk3 because of the way the tags are fixed\n      assertEquals(\"had stats sk2, but not another stat?\", \n                   2, constraint.getFieldStatsInfo().size());\n    } else {\n      // if we did not see \"sk2\", then 1 of the others must be alone\n      assertEquals(\"only expected 1 stat\",\n                   1, constraint.getFieldStatsInfo().size());\n      assertTrue(\"not sk1 or sk3\", \n                 constraint.getFieldStatsInfo().containsKey(\"sk1\") ||\n                 constraint.getFieldStatsInfo().containsKey(\"sk3\"));\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Compare top level stats in response with stats from pivot constraint\n   */\n  private void assertPivotStats(String message, PivotField constraint, QueryResponse response) {\n\n    if (null == constraint.getFieldStatsInfo()) {\n      // no stats for this pivot, nothing to check\n\n      // TODO: use a trace param to know if/how-many to expect ?\n      log.info(\"No stats to check for => \" + message);\n      return;\n    }\n    \n    Map<String, FieldStatsInfo> actualFieldStatsInfoMap = response.getFieldStatsInfo();\n\n    for (FieldStatsInfo pivotStats : constraint.getFieldStatsInfo().values()) {\n      String statsKey = pivotStats.getName();\n\n      FieldStatsInfo actualStats = actualFieldStatsInfoMap.get(statsKey);\n\n      if (actualStats == null) {\n        // handle case for not found stats (using stats query)\n        //\n        // these has to be a special case check due to the legacy behavior of \"top level\" \n        // StatsComponent results being \"null\" (and not even included in the \n        // getFieldStatsInfo() Map due to specila SolrJ logic) \n\n        log.info(\"Requested stats missing in verification query, pivot stats: \" + pivotStats);\n        assertEquals(\"Special Count\", 0L, pivotStats.getCount().longValue());\n        assertEquals(\"Special Missing\", \n                     constraint.getCount(), pivotStats.getMissing().longValue());\n\n      } else {\n        // regular stats, compare everything...\n\n        assert actualStats != null;\n        try {\n          String msg = \" of \" + statsKey;\n          \n          // no wiggle room, these should always be exactly equals, regardless of field type\n          assertEquals(\"Count\" + msg, pivotStats.getCount(), actualStats.getCount());\n          assertEquals(\"Missing\" + msg, pivotStats.getMissing(), actualStats.getMissing());\n          assertEquals(\"Min\" + msg, pivotStats.getMin(), actualStats.getMin());\n          assertEquals(\"Max\" + msg, pivotStats.getMax(), actualStats.getMax());\n\n        } catch (AssertionError e) {\n          throw new AssertionError(\"Stats: Pivot[\" + pivotStats + \"] <==> Actual[\" + actualStats + \"]  => \" + message, e);\n        }\n      }\n    }\n\n    if (constraint.getFieldStatsInfo().containsKey(\"sk2\")) { // cheeseball hack\n      // if \"sk2\" was one of hte stats we computed, then we must have also seen\n      // sk1 or sk3 because of the way the tags are fixed\n      assertEquals(\"had stats sk2, but not another stat?\", \n                   2, constraint.getFieldStatsInfo().size());\n    } else {\n      // if we did not see \"sk2\", then 1 of the others must be alone\n      assertEquals(\"only expected 1 stat\",\n                   1, constraint.getFieldStatsInfo().size());\n      assertTrue(\"not sk1 or sk3\", \n                 constraint.getFieldStatsInfo().containsKey(\"sk1\") ||\n                 constraint.getFieldStatsInfo().containsKey(\"sk3\"));\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ab69ebfb1ee96d15d8a6b2ed13c2ac96c82ee0d2":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["ab69ebfb1ee96d15d8a6b2ed13c2ac96c82ee0d2"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["dbdfda95da145c32af2267b537c92481acc7a522"],"dbdfda95da145c32af2267b537c92481acc7a522":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"ab69ebfb1ee96d15d8a6b2ed13c2ac96c82ee0d2":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["dbdfda95da145c32af2267b537c92481acc7a522"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["ab69ebfb1ee96d15d8a6b2ed13c2ac96c82ee0d2"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dbdfda95da145c32af2267b537c92481acc7a522":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}