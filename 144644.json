{"path":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a78a90fc9701e511308346ea29f4f5e548bb39fe","date":1329489995,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new FloatField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new NumericField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":["fa0f44f887719e97183771e977cfc4bfb485b766"],"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random()), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random().nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new FloatField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random(), 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random, 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random.nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new FloatField(\"float\", random.nextFloat()));\n        final int intValue;\n        if (random.nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random.nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random.nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random.nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random.nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random, 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random.nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random, 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random.nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", _TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random(), 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newField(\"string\", _TestUtil.randomRealisticUnicodeString(random()), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"text\", content[random().nextInt(content.length)], TextField.TYPE_UNSTORED));\n        doc.add(new FloatField(\"float\", random().nextFloat()));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random(), 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":["a78a90fc9701e511308346ea29f4f5e548bb39fe","629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"bugIntro":["0ed6b1234af94a2693d3e6550e7b3ee41fd3f51c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", _TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final AtomicReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random(), 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", _TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      subSearchers = new ShardSearcher[compCTX.leaves().length];\n      docStarts = new int[compCTX.leaves().length];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) { \n        subSearchers[searcherIDX] = new ShardSearcher(compCTX.leaves()[searcherIDX], compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += compCTX.leaves()[searcherIDX].reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random(), 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final AtomicReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = _TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", _TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final AtomicReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[_TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = _TestUtil.nextInt(random(), 1, numDocs+5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      _TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["0ed6b1234af94a2693d3e6550e7b3ee41fd3f51c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final AtomicReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final AtomicReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<SortField>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a74d5a8515f3d6fa070474ac1cc0f86dbd1485a5","date":1395042605,"type":5,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge#testSort().mjava","sourceNew":"  void testSort(boolean useFrom) throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n\n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final AtomicReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      int from = -1;\n      int size = -1;\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        if (useFrom) {\n          TopScoreDocCollector c = TopScoreDocCollector.create(numHits, random().nextBoolean());\n          searcher.search(query, c);\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = searcher.search(query, numHits);\n        }\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        if (useFrom) {\n          from = TestUtil.nextInt(random(), 0, numHits - 1);\n          size = numHits - from;\n          TopDocs tempTopHits = c.topDocs();\n          if (from < tempTopHits.scoreDocs.length) {\n            // Can't use TopDocs#topDocs(start, howMany), since it has different behaviour when start >= hitCount\n            // than TopDocs#merge currently has\n            ScoreDoc[] newScoreDocs = new ScoreDoc[Math.min(size, tempTopHits.scoreDocs.length - from)];\n            System.arraycopy(tempTopHits.scoreDocs, from, newScoreDocs, 0, newScoreDocs.length);\n            tempTopHits.scoreDocs = newScoreDocs;\n            topHits = tempTopHits;\n          } else {\n            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());\n          }\n        } else {\n          topHits = c.topDocs(0, numHits);\n        }\n      }\n\n      if (VERBOSE) {\n        if (useFrom) {\n          System.out.println(\"from=\" + from + \" size=\" + size);\n        }\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length + \" maxScore=\" + topHits.getMaxScore()));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits;\n      if (useFrom) {\n        mergedHits = TopDocs.merge(sort, from, size, shardHits);\n      } else {\n        mergedHits = TopDocs.merge(sort, numHits, shardHits);\n      }\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n\n    IndexReader reader = null;\n    Directory dir = null;\n\n    final int numDocs = atLeast(1000);\n    //final int numDocs = atLeast(50);\n\n    final String[] tokens = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: make index\");\n    }\n\n    {\n      dir = newDirectory();\n      final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n      // w.setDoRandomForceMerge(false);\n\n      // w.w.getConfig().setMaxBufferedDocs(atLeast(100));\n\n      final String[] content = new String[atLeast(20)];\n\n      for(int contentIDX=0;contentIDX<content.length;contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        final int numTokens = TestUtil.nextInt(random(), 1, 10);\n        for(int tokenIDX=0;tokenIDX<numTokens;tokenIDX++) {\n          sb.append(tokens[random().nextInt(tokens.length)]).append(' ');\n        }\n        content[contentIDX] = sb.toString();\n      }\n\n      for(int docIDX=0;docIDX<numDocs;docIDX++) {\n        final Document doc = new Document();\n        doc.add(newStringField(\"string\", TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));\n        doc.add(newTextField(\"text\", content[random().nextInt(content.length)], Field.Store.NO));\n        doc.add(new FloatField(\"float\", random().nextFloat(), Field.Store.NO));\n        final int intValue;\n        if (random().nextInt(100) == 17) {\n          intValue = Integer.MIN_VALUE;\n        } else if (random().nextInt(100) == 17) {\n          intValue = Integer.MAX_VALUE;\n        } else {\n          intValue = random().nextInt();\n        }\n        doc.add(new IntField(\"int\", intValue, Field.Store.NO));\n        if (VERBOSE) {\n          System.out.println(\"  doc=\" + doc);\n        }\n        w.addDocument(doc);\n      }\n\n      reader = w.getReader();\n      w.close();\n    }\n\n    // NOTE: sometimes reader has just one segment, which is\n    // important to test\n    final IndexSearcher searcher = newSearcher(reader);\n    final IndexReaderContext ctx = searcher.getTopReaderContext();\n\n    final ShardSearcher[] subSearchers;\n    final int[] docStarts;\n    \n    if (ctx instanceof AtomicReaderContext) {\n      subSearchers = new ShardSearcher[1];\n      docStarts = new int[1];\n      subSearchers[0] = new ShardSearcher((AtomicReaderContext) ctx, ctx);\n      docStarts[0] = 0;\n    } else {\n      final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;\n      final int size = compCTX.leaves().size();\n      subSearchers = new ShardSearcher[size];\n      docStarts = new int[size];\n      int docBase = 0;\n      for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {\n        final AtomicReaderContext leave = compCTX.leaves().get(searcherIDX);\n        subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);\n        docStarts[searcherIDX] = docBase;\n        docBase += leave.reader().maxDoc();\n      }\n    }\n\n    final List<SortField> sortFields = new ArrayList<>();\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, true));\n    sortFields.add(new SortField(\"string\", SortField.Type.STRING, false));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, true));\n    sortFields.add(new SortField(\"int\", SortField.Type.INT, false));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, true));\n    sortFields.add(new SortField(\"float\", SortField.Type.FLOAT, false));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, true));\n    sortFields.add(new SortField(null, SortField.Type.SCORE, false));\n    sortFields.add(new SortField(null, SortField.Type.DOC, true));\n    sortFields.add(new SortField(null, SortField.Type.DOC, false));\n\n    for(int iter=0;iter<1000*RANDOM_MULTIPLIER;iter++) {\n\n      // TODO: custom FieldComp...\n      final Query query = new TermQuery(new Term(\"text\", tokens[random().nextInt(tokens.length)]));\n\n      final Sort sort;\n      if (random().nextInt(10) == 4) {\n        // Sort by score\n        sort = null;\n      } else {\n        final SortField[] randomSortFields = new SortField[TestUtil.nextInt(random(), 1, 3)];\n        for(int sortIDX=0;sortIDX<randomSortFields.length;sortIDX++) {\n          randomSortFields[sortIDX] = sortFields.get(random().nextInt(sortFields.size()));\n        }\n        sort = new Sort(randomSortFields);\n      }\n\n      final int numHits = TestUtil.nextInt(random(), 1, numDocs + 5);\n      //final int numHits = 5;\n      \n      if (VERBOSE) {\n        System.out.println(\"TEST: search query=\" + query + \" sort=\" + sort + \" numHits=\" + numHits);\n      }\n\n      // First search on whole index:\n      final TopDocs topHits;\n      if (sort == null) {\n        topHits = searcher.search(query, numHits);\n      } else {\n        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n        searcher.search(query, c);\n        topHits = c.topDocs(0, numHits);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  top search: \" + topHits.totalHits + \" totalHits; hits=\" + (topHits.scoreDocs == null ? \"null\" : topHits.scoreDocs.length));\n        if (topHits.scoreDocs != null) {\n          for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {\n            final ScoreDoc sd = topHits.scoreDocs[hitIDX];\n            System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n          }\n        }\n      }\n\n      // ... then all shards:\n      final Weight w = searcher.createNormalizedWeight(query);\n\n      final TopDocs[] shardHits = new TopDocs[subSearchers.length];\n      for(int shardIDX=0;shardIDX<subSearchers.length;shardIDX++) {\n        final TopDocs subHits;\n        final ShardSearcher subSearcher = subSearchers[shardIDX];\n        if (sort == null) {\n          subHits = subSearcher.search(w, numHits);\n        } else {\n          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, random().nextBoolean());\n          subSearcher.search(w, c);\n          subHits = c.topDocs(0, numHits);\n        }\n\n        shardHits[shardIDX] = subHits;\n        if (VERBOSE) {\n          System.out.println(\"  shard=\" + shardIDX + \" \" + subHits.totalHits + \" totalHits hits=\" + (subHits.scoreDocs == null ? \"null\" : subHits.scoreDocs.length));\n          if (subHits.scoreDocs != null) {\n            for(ScoreDoc sd : subHits.scoreDocs) {\n              System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n            }\n          }\n        }\n      }\n\n      // Merge:\n      final TopDocs mergedHits = TopDocs.merge(sort, numHits, shardHits);\n\n      if (mergedHits.scoreDocs != null) {\n        // Make sure the returned shards are correct:\n        for(int hitIDX=0;hitIDX<mergedHits.scoreDocs.length;hitIDX++) {\n          final ScoreDoc sd = mergedHits.scoreDocs[hitIDX];\n          assertEquals(\"doc=\" + sd.doc + \" wrong shard\",\n                       ReaderUtil.subIndex(sd.doc, docStarts),\n                       sd.shardIndex);\n        }\n      }\n\n      TestUtil.assertEquals(topHits, mergedHits);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a74d5a8515f3d6fa070474ac1cc0f86dbd1485a5":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"6613659748fe4411a7dcf85266e55db1f95f7315":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a74d5a8515f3d6fa070474ac1cc0f86dbd1485a5"]},"commit2Childs":{"a74d5a8515f3d6fa070474ac1cc0f86dbd1485a5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a74d5a8515f3d6fa070474ac1cc0f86dbd1485a5"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["6613659748fe4411a7dcf85266e55db1f95f7315"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}