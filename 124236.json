{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#crossProductEvaluateIsZero(Vector,Vector,Vector).mjava","commits":[{"id":"4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8","date":1518267216,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#crossProductEvaluateIsZero(Vector,Vector,Vector).mjava","pathOld":"/dev/null","sourceNew":"  /**\n    * Evaluate the cross product of two vectors against a point.\n    * If the dot product of the resultant vector resolves to \"zero\", then\n    * return true.\n    * @param A is the first vector to use for the cross product.\n    * @param B is the second vector to use for the cross product.\n    * @param point is the point to evaluate.\n    * @return true if we get a zero dot product.\n    */\n  public static boolean crossProductEvaluateIsZero(final Vector A, final Vector B, final Vector point) {\n    // Include Gram-Schmidt in-line so we avoid creating objects unnecessarily\n    // Compute the naive perpendicular\n    final double thisX = A.y * B.z - A.z * B.y;\n    final double thisY = A.z * B.x - A.x * B.z;\n    final double thisZ = A.x * B.y - A.y * B.x;\n    \n    final double magnitude = magnitude(thisX, thisY, thisZ);\n    if (magnitude < MINIMUM_RESOLUTION) {\n      return true;\n    }\n    \n    final double inverseMagnitude = 1.0/magnitude;\n    \n    double normalizeX = thisX * inverseMagnitude;\n    double normalizeY = thisY * inverseMagnitude;\n    double normalizeZ = thisZ * inverseMagnitude;\n    // For a plane to work, the dot product between the normal vector\n    // and the points needs to be less than the minimum resolution.\n    // This is sometimes not true for points that are very close. Therefore\n    // we need to adjust\n    int i = 0;\n    while (true) {\n      final double currentDotProdA = A.x * normalizeX + A.y * normalizeY + A.z * normalizeZ;\n      final double currentDotProdB = B.x * normalizeX + B.y * normalizeY + B.z * normalizeZ;\n      if (Math.abs(currentDotProdA) < MINIMUM_RESOLUTION && Math.abs(currentDotProdB) < MINIMUM_RESOLUTION) {\n        break;\n      }\n      // Converge on the one that has largest dot product\n      final double currentVectorX;\n      final double currentVectorY;\n      final double currentVectorZ;\n      final double currentDotProd;\n      if (Math.abs(currentDotProdA) > Math.abs(currentDotProdB)) {\n        currentVectorX = A.x;\n        currentVectorY = A.y;\n        currentVectorZ = A.z;\n        currentDotProd = currentDotProdA;\n      } else {\n        currentVectorX = B.x;\n        currentVectorY = B.y;\n        currentVectorZ = B.z;\n        currentDotProd = currentDotProdB;\n      }\n\n      // Adjust\n      normalizeX = normalizeX - currentDotProd * currentVectorX;\n      normalizeY = normalizeY - currentDotProd * currentVectorY;\n      normalizeZ = normalizeZ - currentDotProd * currentVectorZ;\n      // Normalize\n      final double correctedMagnitude = magnitude(normalizeX, normalizeY, normalizeZ);\n      final double inverseCorrectedMagnitude = 1.0 / correctedMagnitude;\n      normalizeX = normalizeX * inverseCorrectedMagnitude;\n      normalizeY = normalizeY * inverseCorrectedMagnitude;\n      normalizeZ = normalizeZ * inverseCorrectedMagnitude;\n      //This is  probably not needed as the method seems to converge\n      //quite quickly. But it is safer to have a way out.\n      if (i++ > 10) {\n        throw new IllegalArgumentException(\"Plane could not be constructed! Could not find a normal vector.\");\n      }\n    }\n    return Math.abs(normalizeX * point.x + normalizeY * point.y + normalizeZ * point.z) < MINIMUM_RESOLUTION;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["566f5a2735bf9ff5bc8467c9cdfba990e135ecae"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6c5ec98cafd4cdf3b8d5a3a4277183c05c4fa3f3","date":1518535873,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#crossProductEvaluateIsZero(Vector,Vector,Vector).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#crossProductEvaluateIsZero(Vector,Vector,Vector).mjava","sourceNew":"  /**\n    * Evaluate the cross product of two vectors against a point.\n    * If the dot product of the resultant vector resolves to \"zero\", then\n    * return true.\n    * @param A is the first vector to use for the cross product.\n    * @param B is the second vector to use for the cross product.\n    * @param point is the point to evaluate.\n    * @return true if we get a zero dot product.\n    */\n  public static boolean crossProductEvaluateIsZero(final Vector A, final Vector B, final Vector point) {\n    // Include Gram-Schmidt in-line so we avoid creating objects unnecessarily\n    // Compute the naive perpendicular\n    final double thisX = A.y * B.z - A.z * B.y;\n    final double thisY = A.z * B.x - A.x * B.z;\n    final double thisZ = A.x * B.y - A.y * B.x;\n    \n    final double magnitude = magnitude(thisX, thisY, thisZ);\n    if (magnitude == 0.0) {\n      return true;\n    }\n    \n    final double inverseMagnitude = 1.0/magnitude;\n    \n    double normalizeX = thisX * inverseMagnitude;\n    double normalizeY = thisY * inverseMagnitude;\n    double normalizeZ = thisZ * inverseMagnitude;\n    // For a plane to work, the dot product between the normal vector\n    // and the points needs to be less than the minimum resolution.\n    // This is sometimes not true for points that are very close. Therefore\n    // we need to adjust\n    int i = 0;\n    while (true) {\n      final double currentDotProdA = A.x * normalizeX + A.y * normalizeY + A.z * normalizeZ;\n      final double currentDotProdB = B.x * normalizeX + B.y * normalizeY + B.z * normalizeZ;\n      if (Math.abs(currentDotProdA) < MINIMUM_RESOLUTION && Math.abs(currentDotProdB) < MINIMUM_RESOLUTION) {\n        break;\n      }\n      // Converge on the one that has largest dot product\n      final double currentVectorX;\n      final double currentVectorY;\n      final double currentVectorZ;\n      final double currentDotProd;\n      if (Math.abs(currentDotProdA) > Math.abs(currentDotProdB)) {\n        currentVectorX = A.x;\n        currentVectorY = A.y;\n        currentVectorZ = A.z;\n        currentDotProd = currentDotProdA;\n      } else {\n        currentVectorX = B.x;\n        currentVectorY = B.y;\n        currentVectorZ = B.z;\n        currentDotProd = currentDotProdB;\n      }\n\n      // Adjust\n      normalizeX = normalizeX - currentDotProd * currentVectorX;\n      normalizeY = normalizeY - currentDotProd * currentVectorY;\n      normalizeZ = normalizeZ - currentDotProd * currentVectorZ;\n      // Normalize\n      final double correctedMagnitude = magnitude(normalizeX, normalizeY, normalizeZ);\n      final double inverseCorrectedMagnitude = 1.0 / correctedMagnitude;\n      normalizeX = normalizeX * inverseCorrectedMagnitude;\n      normalizeY = normalizeY * inverseCorrectedMagnitude;\n      normalizeZ = normalizeZ * inverseCorrectedMagnitude;\n      //This is  probably not needed as the method seems to converge\n      //quite quickly. But it is safer to have a way out.\n      if (i++ > 10) {\n        throw new IllegalArgumentException(\"Plane could not be constructed! Could not find a normal vector.\");\n      }\n    }\n    return Math.abs(normalizeX * point.x + normalizeY * point.y + normalizeZ * point.z) < MINIMUM_RESOLUTION;\n  }\n\n","sourceOld":"  /**\n    * Evaluate the cross product of two vectors against a point.\n    * If the dot product of the resultant vector resolves to \"zero\", then\n    * return true.\n    * @param A is the first vector to use for the cross product.\n    * @param B is the second vector to use for the cross product.\n    * @param point is the point to evaluate.\n    * @return true if we get a zero dot product.\n    */\n  public static boolean crossProductEvaluateIsZero(final Vector A, final Vector B, final Vector point) {\n    // Include Gram-Schmidt in-line so we avoid creating objects unnecessarily\n    // Compute the naive perpendicular\n    final double thisX = A.y * B.z - A.z * B.y;\n    final double thisY = A.z * B.x - A.x * B.z;\n    final double thisZ = A.x * B.y - A.y * B.x;\n    \n    final double magnitude = magnitude(thisX, thisY, thisZ);\n    if (magnitude < MINIMUM_RESOLUTION) {\n      return true;\n    }\n    \n    final double inverseMagnitude = 1.0/magnitude;\n    \n    double normalizeX = thisX * inverseMagnitude;\n    double normalizeY = thisY * inverseMagnitude;\n    double normalizeZ = thisZ * inverseMagnitude;\n    // For a plane to work, the dot product between the normal vector\n    // and the points needs to be less than the minimum resolution.\n    // This is sometimes not true for points that are very close. Therefore\n    // we need to adjust\n    int i = 0;\n    while (true) {\n      final double currentDotProdA = A.x * normalizeX + A.y * normalizeY + A.z * normalizeZ;\n      final double currentDotProdB = B.x * normalizeX + B.y * normalizeY + B.z * normalizeZ;\n      if (Math.abs(currentDotProdA) < MINIMUM_RESOLUTION && Math.abs(currentDotProdB) < MINIMUM_RESOLUTION) {\n        break;\n      }\n      // Converge on the one that has largest dot product\n      final double currentVectorX;\n      final double currentVectorY;\n      final double currentVectorZ;\n      final double currentDotProd;\n      if (Math.abs(currentDotProdA) > Math.abs(currentDotProdB)) {\n        currentVectorX = A.x;\n        currentVectorY = A.y;\n        currentVectorZ = A.z;\n        currentDotProd = currentDotProdA;\n      } else {\n        currentVectorX = B.x;\n        currentVectorY = B.y;\n        currentVectorZ = B.z;\n        currentDotProd = currentDotProdB;\n      }\n\n      // Adjust\n      normalizeX = normalizeX - currentDotProd * currentVectorX;\n      normalizeY = normalizeY - currentDotProd * currentVectorY;\n      normalizeZ = normalizeZ - currentDotProd * currentVectorZ;\n      // Normalize\n      final double correctedMagnitude = magnitude(normalizeX, normalizeY, normalizeZ);\n      final double inverseCorrectedMagnitude = 1.0 / correctedMagnitude;\n      normalizeX = normalizeX * inverseCorrectedMagnitude;\n      normalizeY = normalizeY * inverseCorrectedMagnitude;\n      normalizeZ = normalizeZ * inverseCorrectedMagnitude;\n      //This is  probably not needed as the method seems to converge\n      //quite quickly. But it is safer to have a way out.\n      if (i++ > 10) {\n        throw new IllegalArgumentException(\"Plane could not be constructed! Could not find a normal vector.\");\n      }\n    }\n    return Math.abs(normalizeX * point.x + normalizeY * point.y + normalizeZ * point.z) < MINIMUM_RESOLUTION;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"566f5a2735bf9ff5bc8467c9cdfba990e135ecae","date":1518559218,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#crossProductEvaluateIsZero(Vector,Vector,Vector).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#crossProductEvaluateIsZero(Vector,Vector,Vector).mjava","sourceNew":"  /**\n    * Evaluate the cross product of two vectors against a point.\n    * If the dot product of the resultant vector resolves to \"zero\", then\n    * return true.\n    * @param A is the first vector to use for the cross product.\n    * @param B is the second vector to use for the cross product.\n    * @param point is the point to evaluate.\n    * @return true if we get a zero dot product.\n    */\n  public static boolean crossProductEvaluateIsZero(final Vector A, final Vector B, final Vector point) {\n    // Include Gram-Schmidt in-line so we avoid creating objects unnecessarily\n    // Compute the naive perpendicular\n    final double thisX = A.y * B.z - A.z * B.y;\n    final double thisY = A.z * B.x - A.x * B.z;\n    final double thisZ = A.x * B.y - A.y * B.x;\n    \n    final double magnitude = magnitude(thisX, thisY, thisZ);\n    if (magnitude == 0.0) {\n      return true;\n    }\n    \n    final double inverseMagnitude = 1.0/magnitude;\n    \n    double normalizeX = thisX * inverseMagnitude;\n    double normalizeY = thisY * inverseMagnitude;\n    double normalizeZ = thisZ * inverseMagnitude;\n    // For a plane to work, the dot product between the normal vector\n    // and the points needs to be less than the minimum resolution.\n    // This is sometimes not true for points that are very close. Therefore\n    // we need to adjust\n    int i = 0;\n    while (true) {\n      final double currentDotProdA = A.x * normalizeX + A.y * normalizeY + A.z * normalizeZ;\n      final double currentDotProdB = B.x * normalizeX + B.y * normalizeY + B.z * normalizeZ;\n      if (Math.abs(currentDotProdA) < MINIMUM_GRAM_SCHMIDT_ENVELOPE && Math.abs(currentDotProdB) < MINIMUM_GRAM_SCHMIDT_ENVELOPE) {\n        break;\n      }\n      // Converge on the one that has largest dot product\n      final double currentVectorX;\n      final double currentVectorY;\n      final double currentVectorZ;\n      final double currentDotProd;\n      if (Math.abs(currentDotProdA) > Math.abs(currentDotProdB)) {\n        currentVectorX = A.x;\n        currentVectorY = A.y;\n        currentVectorZ = A.z;\n        currentDotProd = currentDotProdA;\n      } else {\n        currentVectorX = B.x;\n        currentVectorY = B.y;\n        currentVectorZ = B.z;\n        currentDotProd = currentDotProdB;\n      }\n\n      // Adjust\n      normalizeX = normalizeX - currentDotProd * currentVectorX;\n      normalizeY = normalizeY - currentDotProd * currentVectorY;\n      normalizeZ = normalizeZ - currentDotProd * currentVectorZ;\n      // Normalize\n      final double correctedMagnitude = magnitude(normalizeX, normalizeY, normalizeZ);\n      final double inverseCorrectedMagnitude = 1.0 / correctedMagnitude;\n      normalizeX = normalizeX * inverseCorrectedMagnitude;\n      normalizeY = normalizeY * inverseCorrectedMagnitude;\n      normalizeZ = normalizeZ * inverseCorrectedMagnitude;\n      //This is  probably not needed as the method seems to converge\n      //quite quickly. But it is safer to have a way out.\n      if (i++ > 10) {\n        throw new IllegalArgumentException(\"Plane could not be constructed! Could not find a normal vector.\");\n      }\n    }\n    return Math.abs(normalizeX * point.x + normalizeY * point.y + normalizeZ * point.z) < MINIMUM_RESOLUTION;\n  }\n\n","sourceOld":"  /**\n    * Evaluate the cross product of two vectors against a point.\n    * If the dot product of the resultant vector resolves to \"zero\", then\n    * return true.\n    * @param A is the first vector to use for the cross product.\n    * @param B is the second vector to use for the cross product.\n    * @param point is the point to evaluate.\n    * @return true if we get a zero dot product.\n    */\n  public static boolean crossProductEvaluateIsZero(final Vector A, final Vector B, final Vector point) {\n    // Include Gram-Schmidt in-line so we avoid creating objects unnecessarily\n    // Compute the naive perpendicular\n    final double thisX = A.y * B.z - A.z * B.y;\n    final double thisY = A.z * B.x - A.x * B.z;\n    final double thisZ = A.x * B.y - A.y * B.x;\n    \n    final double magnitude = magnitude(thisX, thisY, thisZ);\n    if (magnitude == 0.0) {\n      return true;\n    }\n    \n    final double inverseMagnitude = 1.0/magnitude;\n    \n    double normalizeX = thisX * inverseMagnitude;\n    double normalizeY = thisY * inverseMagnitude;\n    double normalizeZ = thisZ * inverseMagnitude;\n    // For a plane to work, the dot product between the normal vector\n    // and the points needs to be less than the minimum resolution.\n    // This is sometimes not true for points that are very close. Therefore\n    // we need to adjust\n    int i = 0;\n    while (true) {\n      final double currentDotProdA = A.x * normalizeX + A.y * normalizeY + A.z * normalizeZ;\n      final double currentDotProdB = B.x * normalizeX + B.y * normalizeY + B.z * normalizeZ;\n      if (Math.abs(currentDotProdA) < MINIMUM_RESOLUTION && Math.abs(currentDotProdB) < MINIMUM_RESOLUTION) {\n        break;\n      }\n      // Converge on the one that has largest dot product\n      final double currentVectorX;\n      final double currentVectorY;\n      final double currentVectorZ;\n      final double currentDotProd;\n      if (Math.abs(currentDotProdA) > Math.abs(currentDotProdB)) {\n        currentVectorX = A.x;\n        currentVectorY = A.y;\n        currentVectorZ = A.z;\n        currentDotProd = currentDotProdA;\n      } else {\n        currentVectorX = B.x;\n        currentVectorY = B.y;\n        currentVectorZ = B.z;\n        currentDotProd = currentDotProdB;\n      }\n\n      // Adjust\n      normalizeX = normalizeX - currentDotProd * currentVectorX;\n      normalizeY = normalizeY - currentDotProd * currentVectorY;\n      normalizeZ = normalizeZ - currentDotProd * currentVectorZ;\n      // Normalize\n      final double correctedMagnitude = magnitude(normalizeX, normalizeY, normalizeZ);\n      final double inverseCorrectedMagnitude = 1.0 / correctedMagnitude;\n      normalizeX = normalizeX * inverseCorrectedMagnitude;\n      normalizeY = normalizeY * inverseCorrectedMagnitude;\n      normalizeZ = normalizeZ * inverseCorrectedMagnitude;\n      //This is  probably not needed as the method seems to converge\n      //quite quickly. But it is safer to have a way out.\n      if (i++ > 10) {\n        throw new IllegalArgumentException(\"Plane could not be constructed! Could not find a normal vector.\");\n      }\n    }\n    return Math.abs(normalizeX * point.x + normalizeY * point.y + normalizeZ * point.z) < MINIMUM_RESOLUTION;\n  }\n\n","bugFix":["4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"566f5a2735bf9ff5bc8467c9cdfba990e135ecae":["6c5ec98cafd4cdf3b8d5a3a4277183c05c4fa3f3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c5ec98cafd4cdf3b8d5a3a4277183c05c4fa3f3":["4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["566f5a2735bf9ff5bc8467c9cdfba990e135ecae"]},"commit2Childs":{"4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8":["6c5ec98cafd4cdf3b8d5a3a4277183c05c4fa3f3"],"566f5a2735bf9ff5bc8467c9cdfba990e135ecae":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8"],"6c5ec98cafd4cdf3b8d5a3a4277183c05c4fa3f3":["566f5a2735bf9ff5bc8467c9cdfba990e135ecae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}