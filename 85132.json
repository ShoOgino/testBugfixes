{"path":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#addField0(String,String,boolean,boolean,int).mjava","commits":[{"id":"d6a43d4d79c846f6b9308b9adc72dd8de0ab6bdb","date":1233863590,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#addField0(String,String,boolean,boolean,int).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#addField0(String,String,boolean,boolean).mjava","sourceNew":"  private void addField0(String xpath, String name, boolean multiValued,\n                         boolean isRecord, int flags) {\n    List<String> paths = new LinkedList<String>(Arrays.asList(xpath.split(\"/\")));\n    if (\"\".equals(paths.get(0).trim()))\n      paths.remove(0);\n    rootNode.build(paths, name, multiValued, isRecord, flags);\n  }\n\n","sourceOld":"  private void addField0(String xpath, String name, boolean multiValued,\n                         boolean isRecord) {\n    List<String> paths = new LinkedList<String>(Arrays.asList(xpath.split(\"/\")));\n    if (\"\".equals(paths.get(0).trim()))\n      paths.remove(0);\n    rootNode.build(paths, name, multiValued, isRecord);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3edfeec51825f0aa5e0f17705c86810302f6385e","date":1235652068,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#addField0(String,String,boolean,boolean,int).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#addField0(String,String,boolean,boolean,int).mjava","sourceNew":"  private void addField0(String xpath, String name, boolean multiValued,\n                         boolean isRecord, int flags) {\n    List<String> paths = splitEscapeQuote(xpath);\n    if (\"\".equals(paths.get(0).trim()))\n      paths.remove(0);\n    rootNode.build(paths, name, multiValued, isRecord, flags);\n  }\n\n","sourceOld":"  private void addField0(String xpath, String name, boolean multiValued,\n                         boolean isRecord, int flags) {\n    List<String> paths = new LinkedList<String>(Arrays.asList(xpath.split(\"/\")));\n    if (\"\".equals(paths.get(0).trim()))\n      paths.remove(0);\n    rootNode.build(paths, name, multiValued, isRecord, flags);\n  }\n\n","bugFix":["4d4f1b2c5601680b01c4bb95a43fe6fb73f03103"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b14ccda0bdb398cf86bc3804e1c136a615dbd89b","date":1253269935,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#addField0(String,String,boolean,boolean,int).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#addField0(String,String,boolean,boolean,int).mjava","sourceNew":"  /**\n   * Splits the XPATH into a List of xpath segments and calls build() to\n   * construct a tree of Nodes representing xpath segments. The resulting\n   * tree structure ends up describing all the Xpaths we are interested in.\n   *\n   * @param xpath The xpath expression for this field\n   * @param name The name for this field in the emitted record\n   * @param multiValued If 'true' then the emitted record will have values in \n   *                    a List<String>\n   * @param isRecord When 'true' flags that this XPATH is from a forEach statement\n   * @param flags The only supported flag is 'FLATTEN'\n   */\n  private void addField0(String xpath, String name, boolean multiValued,\n                         boolean isRecord, int flags) {\n    List<String> paths = splitEscapeQuote(xpath);\n    if (\"\".equals(paths.get(0).trim()))\n      paths.remove(0);\n    rootNode.build(paths, name, multiValued, isRecord, flags);\n  }\n\n","sourceOld":"  private void addField0(String xpath, String name, boolean multiValued,\n                         boolean isRecord, int flags) {\n    List<String> paths = splitEscapeQuote(xpath);\n    if (\"\".equals(paths.get(0).trim()))\n      paths.remove(0);\n    rootNode.build(paths, name, multiValued, isRecord, flags);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f2a93a28913071a0b713be1d4b8a1181388d550","date":1254814948,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#addField0(String,String,boolean,boolean,int).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#addField0(String,String,boolean,boolean,int).mjava","sourceNew":"  /**\n   * Splits the XPATH into a List of xpath segments and calls build() to\n   * construct a tree of Nodes representing xpath segments. The resulting\n   * tree structure ends up describing all the Xpaths we are interested in.\n   *\n   * @param xpath The xpath expression for this field\n   * @param name The name for this field in the emitted record\n   * @param multiValued If 'true' then the emitted record will have values in \n   *                    a List<String>\n   * @param isRecord Flags that this XPATH is from a forEach statement\n   * @param flags The only supported flag is 'FLATTEN'\n   */\n  private void addField0(String xpath, String name, boolean multiValued,\n                         boolean isRecord, int flags) {\n    if (!xpath.startsWith(\"/\"))\n      throw new RuntimeException(\"xpath must start with '/' : \" + xpath);\n    List<String> paths = splitEscapeQuote(xpath);\n    // deal with how split behaves when seperator starts a string!\n    if (\"\".equals(paths.get(0).trim()))\n      paths.remove(0);\n    rootNode.build(paths, name, multiValued, isRecord, flags);\n    rootNode.buildOptimise(null);\n  }\n\n","sourceOld":"  /**\n   * Splits the XPATH into a List of xpath segments and calls build() to\n   * construct a tree of Nodes representing xpath segments. The resulting\n   * tree structure ends up describing all the Xpaths we are interested in.\n   *\n   * @param xpath The xpath expression for this field\n   * @param name The name for this field in the emitted record\n   * @param multiValued If 'true' then the emitted record will have values in \n   *                    a List<String>\n   * @param isRecord When 'true' flags that this XPATH is from a forEach statement\n   * @param flags The only supported flag is 'FLATTEN'\n   */\n  private void addField0(String xpath, String name, boolean multiValued,\n                         boolean isRecord, int flags) {\n    List<String> paths = splitEscapeQuote(xpath);\n    if (\"\".equals(paths.get(0).trim()))\n      paths.remove(0);\n    rootNode.build(paths, name, multiValued, isRecord, flags);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#addField0(String,String,boolean,boolean,int).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#addField0(String,String,boolean,boolean,int).mjava","sourceNew":"  /**\n   * Splits the XPATH into a List of xpath segments and calls build() to\n   * construct a tree of Nodes representing xpath segments. The resulting\n   * tree structure ends up describing all the Xpaths we are interested in.\n   *\n   * @param xpath The xpath expression for this field\n   * @param name The name for this field in the emitted record\n   * @param multiValued If 'true' then the emitted record will have values in \n   *                    a List<String>\n   * @param isRecord Flags that this XPATH is from a forEach statement\n   * @param flags The only supported flag is 'FLATTEN'\n   */\n  private void addField0(String xpath, String name, boolean multiValued,\n                         boolean isRecord, int flags) {\n    if (!xpath.startsWith(\"/\"))\n      throw new RuntimeException(\"xpath must start with '/' : \" + xpath);\n    List<String> paths = splitEscapeQuote(xpath);\n    // deal with how split behaves when seperator starts a string!\n    if (\"\".equals(paths.get(0).trim()))\n      paths.remove(0);\n    rootNode.build(paths, name, multiValued, isRecord, flags);\n    rootNode.buildOptimise(null);\n  }\n\n","sourceOld":"  /**\n   * Splits the XPATH into a List of xpath segments and calls build() to\n   * construct a tree of Nodes representing xpath segments. The resulting\n   * tree structure ends up describing all the Xpaths we are interested in.\n   *\n   * @param xpath The xpath expression for this field\n   * @param name The name for this field in the emitted record\n   * @param multiValued If 'true' then the emitted record will have values in \n   *                    a List<String>\n   * @param isRecord Flags that this XPATH is from a forEach statement\n   * @param flags The only supported flag is 'FLATTEN'\n   */\n  private void addField0(String xpath, String name, boolean multiValued,\n                         boolean isRecord, int flags) {\n    if (!xpath.startsWith(\"/\"))\n      throw new RuntimeException(\"xpath must start with '/' : \" + xpath);\n    List<String> paths = splitEscapeQuote(xpath);\n    // deal with how split behaves when seperator starts a string!\n    if (\"\".equals(paths.get(0).trim()))\n      paths.remove(0);\n    rootNode.build(paths, name, multiValued, isRecord, flags);\n    rootNode.buildOptimise(null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3edfeec51825f0aa5e0f17705c86810302f6385e":["d6a43d4d79c846f6b9308b9adc72dd8de0ab6bdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["7f2a93a28913071a0b713be1d4b8a1181388d550"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7f2a93a28913071a0b713be1d4b8a1181388d550":["b14ccda0bdb398cf86bc3804e1c136a615dbd89b"],"b14ccda0bdb398cf86bc3804e1c136a615dbd89b":["3edfeec51825f0aa5e0f17705c86810302f6385e"],"d6a43d4d79c846f6b9308b9adc72dd8de0ab6bdb":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"]},"commit2Childs":{"3edfeec51825f0aa5e0f17705c86810302f6385e":["b14ccda0bdb398cf86bc3804e1c136a615dbd89b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["d6a43d4d79c846f6b9308b9adc72dd8de0ab6bdb"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"d6a43d4d79c846f6b9308b9adc72dd8de0ab6bdb":["3edfeec51825f0aa5e0f17705c86810302f6385e"],"7f2a93a28913071a0b713be1d4b8a1181388d550":["ad94625fb8d088209f46650c8097196fec67f00c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b14ccda0bdb398cf86bc3804e1c136a615dbd89b":["7f2a93a28913071a0b713be1d4b8a1181388d550"]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}