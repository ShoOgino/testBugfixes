{"path":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyNumericDocValueUpdates(Iterable[NumericUpdate],ReadersAndLiveDocs,SegmentReader).mjava","commits":[{"id":"e072d0b1fc19e0533d8ce432eed245196bca6fde","date":1379265112,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyNumericDocValueUpdates(Iterable[NumericUpdate],ReadersAndLiveDocs,SegmentReader).mjava","pathOld":"/dev/null","sourceNew":"  // NumericDocValue Updates\n  private synchronized boolean applyNumericDocValueUpdates(Iterable<NumericUpdate> updates, ReadersAndLiveDocs rld, SegmentReader reader) throws IOException {\n    Fields fields = reader.fields();\n    if (fields == null) {\n      // This reader has no postings\n      return false;\n    }\n\n    TermsEnum termsEnum = null;\n    DocsEnum docs = null;\n    boolean any = false;\n    //System.out.println(Thread.currentThread().getName() + \" numericDVUpdate reader=\" + reader);\n    for (NumericUpdate update : updates) {\n      Term term = update.term;\n      int limit = update.docIDUpto;\n      \n      // TODO: we rely on the map being ordered by updates order, not by terms order.\n      // we need that so that if two terms update the same document, the one that came\n      // last wins.\n      // alternatively, we could keep a map from doc->lastUpto and apply the update\n      // in terms order, where an update is applied only if its docIDUpto is greater\n      // than lastUpto.\n      // but, since app can send two updates, in order, which will have same upto, we\n      // cannot rely solely on docIDUpto, and need to have our own gen, which is\n      // incremented with every update.\n      \n      // Unlike applyTermDeletes, we visit terms in update order, not term order.\n      // Therefore we cannot assume we can only seek forwards and must ask for a\n      // new TermsEnum\n      Terms terms = fields.terms(term.field);\n      if (terms == null) { // no terms in that field\n        termsEnum = null;\n        continue;\n      }\n      \n      termsEnum = terms.iterator(termsEnum);\n\n      // System.out.println(\"  term=\" + term);\n\n      if (termsEnum.seekExact(term.bytes())) {\n        // we don't need term frequencies for this\n        DocsEnum docsEnum = termsEnum.docs(rld.getLiveDocs(), docs, DocsEnum.FLAG_NONE);\n      \n        //System.out.println(\"BDS: got docsEnum=\" + docsEnum);\n\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          //System.out.println(Thread.currentThread().getName() + \" numericDVUpdate term=\" + term + \" doc=\" + docID);\n          if (doc >= limit) {\n            break; // no more docs that can be updated for this term\n          }\n          rld.updateNumericDocValue(update.field, doc, update.value);\n          any = true;\n        }\n      }\n    }\n    return any;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe","date":1381909398,"type":4,"author":"Shai Erera","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyNumericDocValueUpdates(Iterable[NumericUpdate],ReadersAndLiveDocs,SegmentReader).mjava","sourceNew":null,"sourceOld":"  // NumericDocValue Updates\n  private synchronized boolean applyNumericDocValueUpdates(Iterable<NumericUpdate> updates, ReadersAndLiveDocs rld, SegmentReader reader) throws IOException {\n    Fields fields = reader.fields();\n    if (fields == null) {\n      // This reader has no postings\n      return false;\n    }\n\n    TermsEnum termsEnum = null;\n    DocsEnum docs = null;\n    boolean any = false;\n    //System.out.println(Thread.currentThread().getName() + \" numericDVUpdate reader=\" + reader);\n    for (NumericUpdate update : updates) {\n      Term term = update.term;\n      int limit = update.docIDUpto;\n      \n      // TODO: we rely on the map being ordered by updates order, not by terms order.\n      // we need that so that if two terms update the same document, the one that came\n      // last wins.\n      // alternatively, we could keep a map from doc->lastUpto and apply the update\n      // in terms order, where an update is applied only if its docIDUpto is greater\n      // than lastUpto.\n      // but, since app can send two updates, in order, which will have same upto, we\n      // cannot rely solely on docIDUpto, and need to have our own gen, which is\n      // incremented with every update.\n      \n      // Unlike applyTermDeletes, we visit terms in update order, not term order.\n      // Therefore we cannot assume we can only seek forwards and must ask for a\n      // new TermsEnum\n      Terms terms = fields.terms(term.field);\n      if (terms == null) { // no terms in that field\n        termsEnum = null;\n        continue;\n      }\n      \n      termsEnum = terms.iterator(termsEnum);\n\n      // System.out.println(\"  term=\" + term);\n\n      if (termsEnum.seekExact(term.bytes())) {\n        // we don't need term frequencies for this\n        DocsEnum docsEnum = termsEnum.docs(rld.getLiveDocs(), docs, DocsEnum.FLAG_NONE);\n      \n        //System.out.println(\"BDS: got docsEnum=\" + docsEnum);\n\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          //System.out.println(Thread.currentThread().getName() + \" numericDVUpdate term=\" + term + \" doc=\" + docID);\n          if (doc >= limit) {\n            break; // no more docs that can be updated for this term\n          }\n          rld.updateNumericDocValue(update.field, doc, update.value);\n          any = true;\n        }\n      }\n    }\n    return any;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e072d0b1fc19e0533d8ce432eed245196bca6fde":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe"]},"commit2Childs":{"e072d0b1fc19e0533d8ce432eed245196bca6fde":["1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe"],"1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}