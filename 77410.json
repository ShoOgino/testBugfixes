{"path":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x64_128(byte[],int,int,int,LongPair).mjava","commits":[{"id":"2ddd9456ddbc1edc62d5a14a84ad0e4fcd74a008","date":1431878853,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x64_128(byte[],int,int,int,LongPair).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the MurmurHash3_x64_128 hash, placing the result in \"out\". */\n  public static void murmurhash3_x64_128(byte[] key, int offset, int len, int seed, LongPair out) {\n    // The original algorithm does have a 32 bit unsigned seed.\n    // We have to mask to match the behavior of the unsigned types and prevent sign extension.\n    long h1 = seed & 0x00000000FFFFFFFFL;\n    long h2 = seed & 0x00000000FFFFFFFFL;\n\n    final long c1 = 0x87c37b91114253d5L;\n    final long c2 = 0x4cf5ad432745937fL;\n\n    int roundedEnd = offset + (len & 0xFFFFFFF0);  // round down to 16 byte block\n    for (int i=offset; i<roundedEnd; i+=16) {\n      long k1 = getLongLittleEndian(key, i);\n      long k2 = getLongLittleEndian(key, i+8);\n      k1 *= c1; k1  = Long.rotateLeft(k1,31); k1 *= c2; h1 ^= k1;\n      h1 = Long.rotateLeft(h1,27); h1 += h2; h1 = h1*5+0x52dce729;\n      k2 *= c2; k2  = Long.rotateLeft(k2,33); k2 *= c1; h2 ^= k2;\n      h2 = Long.rotateLeft(h2,31); h2 += h1; h2 = h2*5+0x38495ab5;\n    }\n\n    long k1 = 0;\n    long k2 = 0;\n\n    switch (len & 15) {\n      case 15: k2  = (key[roundedEnd+14] & 0xffL) << 48;\n      case 14: k2 |= (key[roundedEnd+13] & 0xffL) << 40;\n      case 13: k2 |= (key[roundedEnd+12] & 0xffL) << 32;\n      case 12: k2 |= (key[roundedEnd+11] & 0xffL) << 24;\n      case 11: k2 |= (key[roundedEnd+10] & 0xffL) << 16;\n      case 10: k2 |= (key[roundedEnd+ 9] & 0xffL) << 8;\n      case  9: k2 |= (key[roundedEnd+ 8] & 0xffL);\n        k2 *= c2; k2  = Long.rotateLeft(k2, 33); k2 *= c1; h2 ^= k2;\n      case  8: k1  = ((long)key[roundedEnd+7]) << 56;\n      case  7: k1 |= (key[roundedEnd+6] & 0xffL) << 48;\n      case  6: k1 |= (key[roundedEnd+5] & 0xffL) << 40;\n      case  5: k1 |= (key[roundedEnd+4] & 0xffL) << 32;\n      case  4: k1 |= (key[roundedEnd+3] & 0xffL) << 24;\n      case  3: k1 |= (key[roundedEnd+2] & 0xffL) << 16;\n      case  2: k1 |= (key[roundedEnd+1] & 0xffL) << 8;\n      case  1: k1 |= (key[roundedEnd  ] & 0xffL);\n        k1 *= c1; k1  = Long.rotateLeft(k1,31); k1 *= c2; h1 ^= k1;\n    }\n\n    //----------\n    // finalization\n\n    h1 ^= len; h2 ^= len;\n\n    h1 += h2;\n    h2 += h1;\n\n    h1 = fmix64(h1);\n    h2 = fmix64(h2);\n\n    h1 += h2;\n    h2 += h1;\n\n    out.val1 = h1;\n    out.val2 = h2;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7dfea4f7c80813344b0152e37fc18b31369e8ff","date":1592136683,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x64_128(byte[],int,int,int,LongPair).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x64_128(byte[],int,int,int,LongPair).mjava","sourceNew":"  /** Returns the MurmurHash3_x64_128 hash, placing the result in \"out\". */\n  @SuppressWarnings({\"fallthrough\"})\n  public static void murmurhash3_x64_128(byte[] key, int offset, int len, int seed, LongPair out) {\n    // The original algorithm does have a 32 bit unsigned seed.\n    // We have to mask to match the behavior of the unsigned types and prevent sign extension.\n    long h1 = seed & 0x00000000FFFFFFFFL;\n    long h2 = seed & 0x00000000FFFFFFFFL;\n\n    final long c1 = 0x87c37b91114253d5L;\n    final long c2 = 0x4cf5ad432745937fL;\n\n    int roundedEnd = offset + (len & 0xFFFFFFF0);  // round down to 16 byte block\n    for (int i=offset; i<roundedEnd; i+=16) {\n      long k1 = getLongLittleEndian(key, i);\n      long k2 = getLongLittleEndian(key, i+8);\n      k1 *= c1; k1  = Long.rotateLeft(k1,31); k1 *= c2; h1 ^= k1;\n      h1 = Long.rotateLeft(h1,27); h1 += h2; h1 = h1*5+0x52dce729;\n      k2 *= c2; k2  = Long.rotateLeft(k2,33); k2 *= c1; h2 ^= k2;\n      h2 = Long.rotateLeft(h2,31); h2 += h1; h2 = h2*5+0x38495ab5;\n    }\n\n    long k1 = 0;\n    long k2 = 0;\n\n    switch (len & 15) {\n      case 15: k2  = (key[roundedEnd+14] & 0xffL) << 48;\n      case 14: k2 |= (key[roundedEnd+13] & 0xffL) << 40;\n      case 13: k2 |= (key[roundedEnd+12] & 0xffL) << 32;\n      case 12: k2 |= (key[roundedEnd+11] & 0xffL) << 24;\n      case 11: k2 |= (key[roundedEnd+10] & 0xffL) << 16;\n      case 10: k2 |= (key[roundedEnd+ 9] & 0xffL) << 8;\n      case  9: k2 |= (key[roundedEnd+ 8] & 0xffL);\n        k2 *= c2; k2  = Long.rotateLeft(k2, 33); k2 *= c1; h2 ^= k2;\n      case  8: k1  = ((long)key[roundedEnd+7]) << 56;\n      case  7: k1 |= (key[roundedEnd+6] & 0xffL) << 48;\n      case  6: k1 |= (key[roundedEnd+5] & 0xffL) << 40;\n      case  5: k1 |= (key[roundedEnd+4] & 0xffL) << 32;\n      case  4: k1 |= (key[roundedEnd+3] & 0xffL) << 24;\n      case  3: k1 |= (key[roundedEnd+2] & 0xffL) << 16;\n      case  2: k1 |= (key[roundedEnd+1] & 0xffL) << 8;\n      case  1: k1 |= (key[roundedEnd  ] & 0xffL);\n        k1 *= c1; k1  = Long.rotateLeft(k1,31); k1 *= c2; h1 ^= k1;\n    }\n\n    //----------\n    // finalization\n\n    h1 ^= len; h2 ^= len;\n\n    h1 += h2;\n    h2 += h1;\n\n    h1 = fmix64(h1);\n    h2 = fmix64(h2);\n\n    h1 += h2;\n    h2 += h1;\n\n    out.val1 = h1;\n    out.val2 = h2;\n  }\n\n","sourceOld":"  /** Returns the MurmurHash3_x64_128 hash, placing the result in \"out\". */\n  public static void murmurhash3_x64_128(byte[] key, int offset, int len, int seed, LongPair out) {\n    // The original algorithm does have a 32 bit unsigned seed.\n    // We have to mask to match the behavior of the unsigned types and prevent sign extension.\n    long h1 = seed & 0x00000000FFFFFFFFL;\n    long h2 = seed & 0x00000000FFFFFFFFL;\n\n    final long c1 = 0x87c37b91114253d5L;\n    final long c2 = 0x4cf5ad432745937fL;\n\n    int roundedEnd = offset + (len & 0xFFFFFFF0);  // round down to 16 byte block\n    for (int i=offset; i<roundedEnd; i+=16) {\n      long k1 = getLongLittleEndian(key, i);\n      long k2 = getLongLittleEndian(key, i+8);\n      k1 *= c1; k1  = Long.rotateLeft(k1,31); k1 *= c2; h1 ^= k1;\n      h1 = Long.rotateLeft(h1,27); h1 += h2; h1 = h1*5+0x52dce729;\n      k2 *= c2; k2  = Long.rotateLeft(k2,33); k2 *= c1; h2 ^= k2;\n      h2 = Long.rotateLeft(h2,31); h2 += h1; h2 = h2*5+0x38495ab5;\n    }\n\n    long k1 = 0;\n    long k2 = 0;\n\n    switch (len & 15) {\n      case 15: k2  = (key[roundedEnd+14] & 0xffL) << 48;\n      case 14: k2 |= (key[roundedEnd+13] & 0xffL) << 40;\n      case 13: k2 |= (key[roundedEnd+12] & 0xffL) << 32;\n      case 12: k2 |= (key[roundedEnd+11] & 0xffL) << 24;\n      case 11: k2 |= (key[roundedEnd+10] & 0xffL) << 16;\n      case 10: k2 |= (key[roundedEnd+ 9] & 0xffL) << 8;\n      case  9: k2 |= (key[roundedEnd+ 8] & 0xffL);\n        k2 *= c2; k2  = Long.rotateLeft(k2, 33); k2 *= c1; h2 ^= k2;\n      case  8: k1  = ((long)key[roundedEnd+7]) << 56;\n      case  7: k1 |= (key[roundedEnd+6] & 0xffL) << 48;\n      case  6: k1 |= (key[roundedEnd+5] & 0xffL) << 40;\n      case  5: k1 |= (key[roundedEnd+4] & 0xffL) << 32;\n      case  4: k1 |= (key[roundedEnd+3] & 0xffL) << 24;\n      case  3: k1 |= (key[roundedEnd+2] & 0xffL) << 16;\n      case  2: k1 |= (key[roundedEnd+1] & 0xffL) << 8;\n      case  1: k1 |= (key[roundedEnd  ] & 0xffL);\n        k1 *= c1; k1  = Long.rotateLeft(k1,31); k1 *= c2; h1 ^= k1;\n    }\n\n    //----------\n    // finalization\n\n    h1 ^= len; h2 ^= len;\n\n    h1 += h2;\n    h2 += h1;\n\n    h1 = fmix64(h1);\n    h2 = fmix64(h2);\n\n    h1 += h2;\n    h2 += h1;\n\n    out.val1 = h1;\n    out.val2 = h2;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["2ddd9456ddbc1edc62d5a14a84ad0e4fcd74a008"],"2ddd9456ddbc1edc62d5a14a84ad0e4fcd74a008":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a7dfea4f7c80813344b0152e37fc18b31369e8ff"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2ddd9456ddbc1edc62d5a14a84ad0e4fcd74a008"],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2ddd9456ddbc1edc62d5a14a84ad0e4fcd74a008":["a7dfea4f7c80813344b0152e37fc18b31369e8ff"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}