{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","commits":[{"id":"9272a617a9cbebf86be127014bbbacd7cf8f8e83","date":1467480344,"type":1,"author":"Erick","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkConfigManager#downloadFromZK(String,Path).mjava","sourceNew":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path dir) throws IOException {\n    try {\n      List<String> files = zkClient.getChildren(zkPath, null, true);\n      Files.createDirectories(dir);\n      for (String file : files) {\n        List<String> children = zkClient.getChildren(zkPath + \"/\" + file, null, true);\n        if (children.size() == 0) {\n          byte[] data = zkClient.getData(zkPath + \"/\" + file, null, null, true);\n          Path filename = dir.resolve(file);\n          log.info(\"Writing file {}\", filename);\n          Files.write(filename, data);\n        } else {\n          downloadFromZK(zkClient, zkPath + \"/\" + file, dir.resolve(file));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + dir.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","sourceOld":"  private void downloadFromZK(String zkPath, Path dir) throws IOException {\n    try {\n      List<String> files = zkClient.getChildren(zkPath, null, true);\n      Files.createDirectories(dir);\n      for (String file : files) {\n        List<String> children = zkClient.getChildren(zkPath + \"/\" + file, null, true);\n        if (children.size() == 0) {\n          byte[] data = zkClient.getData(zkPath + \"/\" + file, null, null, true);\n          Path filename = dir.resolve(file);\n          logger.info(\"Writing file {}\", filename);\n          Files.write(filename, data);\n        } else {\n          downloadFromZK(zkPath + \"/\" + file, dir.resolve(file));\n        }\n      }\n    }\n    catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + dir.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","pathOld":"/dev/null","sourceNew":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path dir) throws IOException {\n    try {\n      List<String> files = zkClient.getChildren(zkPath, null, true);\n      Files.createDirectories(dir);\n      for (String file : files) {\n        List<String> children = zkClient.getChildren(zkPath + \"/\" + file, null, true);\n        if (children.size() == 0) {\n          byte[] data = zkClient.getData(zkPath + \"/\" + file, null, null, true);\n          Path filename = dir.resolve(file);\n          log.info(\"Writing file {}\", filename);\n          Files.write(filename, data);\n        } else {\n          downloadFromZK(zkClient, zkPath + \"/\" + file, dir.resolve(file));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + dir.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4dbb79e6da9d3d2ef8d3890b5619da3c1fba62e","date":1490642105,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","sourceNew":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path file) throws IOException {\n    try {\n      List<String> children = zkClient.getChildren(zkPath, null, true);\n      // If it has no children, it's a leaf node, write the assoicated data from the ZNode. \n      // Otherwise, continue recursing, but write the associated data to a special file if any\n      if (children.size() == 0) {\n        // If we didn't copy data down, then we also didn't create the file. But we still need a marker on the local\n        // disk so create a dir.\n        if (copyDataDown(zkClient, zkPath, file.toFile()) == 0) {\n          Files.createDirectories(file);\n        }\n      } else {\n        Files.createDirectories(file); // Make parent dir.\n        // ZK nodes, whether leaf or not can have data. If it's a non-leaf node and\n        // has associated data write it into the special file.\n        copyDataDown(zkClient, zkPath, new File(file.toFile(), ZKNODE_DATA_FILE));\n\n        for (String child : children) {\n          String zkChild = zkPath;\n          if (zkChild.endsWith(\"/\") == false) zkChild += \"/\";\n          zkChild += child;\n          if (isEphemeral(zkClient, zkChild)) { // Don't copy ephemeral nodes\n            continue;\n          }\n          // Go deeper into the tree now\n          downloadFromZK(zkClient, zkChild, file.resolve(child));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + file.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","sourceOld":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path dir) throws IOException {\n    try {\n      List<String> files = zkClient.getChildren(zkPath, null, true);\n      Files.createDirectories(dir);\n      for (String file : files) {\n        List<String> children = zkClient.getChildren(zkPath + \"/\" + file, null, true);\n        if (children.size() == 0) {\n          byte[] data = zkClient.getData(zkPath + \"/\" + file, null, null, true);\n          Path filename = dir.resolve(file);\n          log.info(\"Writing file {}\", filename);\n          Files.write(filename, data);\n        } else {\n          downloadFromZK(zkClient, zkPath + \"/\" + file, dir.resolve(file));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + dir.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7b3180545c5d5e137529b5474e018af04e07615","date":1490873944,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","sourceNew":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path file) throws IOException {\n    try {\n      List<String> children = zkClient.getChildren(zkPath, null, true);\n      // If it has no children, it's a leaf node, write the assoicated data from the ZNode. \n      // Otherwise, continue recursing, but write the associated data to a special file if any\n      if (children.size() == 0) {\n        // If we didn't copy data down, then we also didn't create the file. But we still need a marker on the local\n        // disk so create a dir.\n        if (copyDataDown(zkClient, zkPath, file.toFile()) == 0) {\n          Files.createDirectories(file);\n        }\n      } else {\n        Files.createDirectories(file); // Make parent dir.\n        // ZK nodes, whether leaf or not can have data. If it's a non-leaf node and\n        // has associated data write it into the special file.\n        copyDataDown(zkClient, zkPath, new File(file.toFile(), ZKNODE_DATA_FILE));\n\n        for (String child : children) {\n          String zkChild = zkPath;\n          if (zkChild.endsWith(\"/\") == false) zkChild += \"/\";\n          zkChild += child;\n          if (isEphemeral(zkClient, zkChild)) { // Don't copy ephemeral nodes\n            continue;\n          }\n          // Go deeper into the tree now\n          downloadFromZK(zkClient, zkChild, file.resolve(child));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + file.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","sourceOld":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path dir) throws IOException {\n    try {\n      List<String> files = zkClient.getChildren(zkPath, null, true);\n      Files.createDirectories(dir);\n      for (String file : files) {\n        List<String> children = zkClient.getChildren(zkPath + \"/\" + file, null, true);\n        if (children.size() == 0) {\n          byte[] data = zkClient.getData(zkPath + \"/\" + file, null, null, true);\n          Path filename = dir.resolve(file);\n          log.info(\"Writing file {}\", filename);\n          Files.write(filename, data);\n        } else {\n          downloadFromZK(zkClient, zkPath + \"/\" + file, dir.resolve(file));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + dir.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33e11d49e1ce128772bc8ecfdcf22b4ed0be0b37","date":1502038096,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","sourceNew":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path file) throws IOException {\n    try {\n      List<String> children = zkClient.getChildren(zkPath, null, true);\n      // If it has no children, it's a leaf node, write the associated data from the ZNode.\n      // Otherwise, continue recursing, but write the associated data to a special file if any\n      if (children.size() == 0) {\n        // If we didn't copy data down, then we also didn't create the file. But we still need a marker on the local\n        // disk so create an empty file.\n        if (copyDataDown(zkClient, zkPath, file.toFile()) == 0) {\n          Files.createFile(file);\n        }\n      } else {\n        Files.createDirectories(file); // Make parent dir.\n        // ZK nodes, whether leaf or not can have data. If it's a non-leaf node and\n        // has associated data write it into the special file.\n        copyDataDown(zkClient, zkPath, new File(file.toFile(), ZKNODE_DATA_FILE));\n\n        for (String child : children) {\n          String zkChild = zkPath;\n          if (zkChild.endsWith(\"/\") == false) zkChild += \"/\";\n          zkChild += child;\n          if (isEphemeral(zkClient, zkChild)) { // Don't copy ephemeral nodes\n            continue;\n          }\n          // Go deeper into the tree now\n          downloadFromZK(zkClient, zkChild, file.resolve(child));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + file.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","sourceOld":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path file) throws IOException {\n    try {\n      List<String> children = zkClient.getChildren(zkPath, null, true);\n      // If it has no children, it's a leaf node, write the assoicated data from the ZNode. \n      // Otherwise, continue recursing, but write the associated data to a special file if any\n      if (children.size() == 0) {\n        // If we didn't copy data down, then we also didn't create the file. But we still need a marker on the local\n        // disk so create a dir.\n        if (copyDataDown(zkClient, zkPath, file.toFile()) == 0) {\n          Files.createDirectories(file);\n        }\n      } else {\n        Files.createDirectories(file); // Make parent dir.\n        // ZK nodes, whether leaf or not can have data. If it's a non-leaf node and\n        // has associated data write it into the special file.\n        copyDataDown(zkClient, zkPath, new File(file.toFile(), ZKNODE_DATA_FILE));\n\n        for (String child : children) {\n          String zkChild = zkPath;\n          if (zkChild.endsWith(\"/\") == false) zkChild += \"/\";\n          zkChild += child;\n          if (isEphemeral(zkClient, zkChild)) { // Don't copy ephemeral nodes\n            continue;\n          }\n          // Go deeper into the tree now\n          downloadFromZK(zkClient, zkChild, file.resolve(child));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + file.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1101e23841a13358cc2facc363fd887c9200ddfd","date":1502068908,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","sourceNew":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path file) throws IOException {\n    try {\n      List<String> children = zkClient.getChildren(zkPath, null, true);\n      // If it has no children, it's a leaf node, write the associated data from the ZNode.\n      // Otherwise, continue recursing, but write the associated data to a special file if any\n      if (children.size() == 0) {\n        // If we didn't copy data down, then we also didn't create the file. But we still need a marker on the local\n        // disk so create an empty file.\n        if (copyDataDown(zkClient, zkPath, file.toFile()) == 0) {\n          log.info(\"EOE Creating  file at (var 1)\" + file.toAbsolutePath().toString()); // TODO remove me EOE\n          log.info(\"EOE Creating  file at (var2) \" + file.toFile().getAbsolutePath()); // TODO remove me EOE\n          Files.createFile(file);\n          log.info(\"EOE Creating file exists: \" + Boolean.toString(file.toFile().exists()));\n          log.info(\"EOE Creating isFile: \" + Boolean.toString(file.toFile().isFile()));\n          log.info(\"EOE Creating isDirectory: \" + Boolean.toString(file.toFile().isDirectory())); //TODO: remove me EOE to here.\n        }\n      } else {\n        Files.createDirectories(file); // Make parent dir.\n        // ZK nodes, whether leaf or not can have data. If it's a non-leaf node and\n        // has associated data write it into the special file.\n        copyDataDown(zkClient, zkPath, new File(file.toFile(), ZKNODE_DATA_FILE));\n\n        for (String child : children) {\n          String zkChild = zkPath;\n          if (zkChild.endsWith(\"/\") == false) zkChild += \"/\";\n          zkChild += child;\n          if (isEphemeral(zkClient, zkChild)) { // Don't copy ephemeral nodes\n            continue;\n          }\n          // Go deeper into the tree now\n          downloadFromZK(zkClient, zkChild, file.resolve(child));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + file.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","sourceOld":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path file) throws IOException {\n    try {\n      List<String> children = zkClient.getChildren(zkPath, null, true);\n      // If it has no children, it's a leaf node, write the associated data from the ZNode.\n      // Otherwise, continue recursing, but write the associated data to a special file if any\n      if (children.size() == 0) {\n        // If we didn't copy data down, then we also didn't create the file. But we still need a marker on the local\n        // disk so create an empty file.\n        if (copyDataDown(zkClient, zkPath, file.toFile()) == 0) {\n          Files.createFile(file);\n        }\n      } else {\n        Files.createDirectories(file); // Make parent dir.\n        // ZK nodes, whether leaf or not can have data. If it's a non-leaf node and\n        // has associated data write it into the special file.\n        copyDataDown(zkClient, zkPath, new File(file.toFile(), ZKNODE_DATA_FILE));\n\n        for (String child : children) {\n          String zkChild = zkPath;\n          if (zkChild.endsWith(\"/\") == false) zkChild += \"/\";\n          zkChild += child;\n          if (isEphemeral(zkClient, zkChild)) { // Don't copy ephemeral nodes\n            continue;\n          }\n          // Go deeper into the tree now\n          downloadFromZK(zkClient, zkChild, file.resolve(child));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + file.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","bugFix":null,"bugIntro":["6f896d10632f33e14c708179f4c5d5ec442a1287"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"566112f6115904d848cbf09462ebd8bf1304257b","date":1502103699,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","sourceNew":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path file) throws IOException {\n    try {\n      List<String> children = zkClient.getChildren(zkPath, null, true);\n      // If it has no children, it's a leaf node, write the associated data from the ZNode.\n      // Otherwise, continue recursing, but write the associated data to a special file if any\n      if (children.size() == 0) {\n        // If we didn't copy data down, then we also didn't create the file. But we still need a marker on the local\n        // disk so create an empty file.\n        if (copyDataDown(zkClient, zkPath, file.toFile()) == 0) {\n          log.info(\"EOE Creating  file at (var 1)\" + file.toAbsolutePath().toString()); // TODO remove me EOE\n          log.info(\"EOE Creating  file at (var2) \" + file.toFile().getAbsolutePath()); // TODO remove me EOE\n          Files.createFile(file);\n          log.info(\"EOE Creating file exists: \" + Boolean.toString(file.toFile().exists()));\n          log.info(\"EOE Creating isFile: \" + Boolean.toString(file.toFile().isFile()));\n          log.info(\"EOE Creating isDirectory: \" + Boolean.toString(file.toFile().isDirectory())); //TODO: remove me EOE to here.\n        }\n      } else {\n        Files.createDirectories(file); // Make parent dir.\n        // ZK nodes, whether leaf or not can have data. If it's a non-leaf node and\n        // has associated data write it into the special file.\n        copyDataDown(zkClient, zkPath, new File(file.toFile(), ZKNODE_DATA_FILE));\n\n        for (String child : children) {\n          String zkChild = zkPath;\n          if (zkChild.endsWith(\"/\") == false) zkChild += \"/\";\n          zkChild += child;\n          if (isEphemeral(zkClient, zkChild)) { // Don't copy ephemeral nodes\n            continue;\n          }\n          // Go deeper into the tree now\n          downloadFromZK(zkClient, zkChild, file.resolve(child));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + file.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","sourceOld":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path file) throws IOException {\n    try {\n      List<String> children = zkClient.getChildren(zkPath, null, true);\n      // If it has no children, it's a leaf node, write the assoicated data from the ZNode. \n      // Otherwise, continue recursing, but write the associated data to a special file if any\n      if (children.size() == 0) {\n        // If we didn't copy data down, then we also didn't create the file. But we still need a marker on the local\n        // disk so create a dir.\n        if (copyDataDown(zkClient, zkPath, file.toFile()) == 0) {\n          Files.createDirectories(file);\n        }\n      } else {\n        Files.createDirectories(file); // Make parent dir.\n        // ZK nodes, whether leaf or not can have data. If it's a non-leaf node and\n        // has associated data write it into the special file.\n        copyDataDown(zkClient, zkPath, new File(file.toFile(), ZKNODE_DATA_FILE));\n\n        for (String child : children) {\n          String zkChild = zkPath;\n          if (zkChild.endsWith(\"/\") == false) zkChild += \"/\";\n          zkChild += child;\n          if (isEphemeral(zkClient, zkChild)) { // Don't copy ephemeral nodes\n            continue;\n          }\n          // Go deeper into the tree now\n          downloadFromZK(zkClient, zkChild, file.resolve(child));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + file.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6f896d10632f33e14c708179f4c5d5ec442a1287","date":1502125058,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","sourceNew":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path file) throws IOException {\n    try {\n      List<String> children = zkClient.getChildren(zkPath, null, true);\n      // If it has no children, it's a leaf node, write the associated data from the ZNode.\n      // Otherwise, continue recursing, but write the associated data to a special file if any\n      if (children.size() == 0) {\n        // If we didn't copy data down, then we also didn't create the file. But we still need a marker on the local\n        // disk so create an empty file.\n        if (copyDataDown(zkClient, zkPath, file.toFile()) == 0) {\n          Files.createFile(file);\n        }\n      } else {\n        Files.createDirectories(file); // Make parent dir.\n        // ZK nodes, whether leaf or not can have data. If it's a non-leaf node and\n        // has associated data write it into the special file.\n        copyDataDown(zkClient, zkPath, new File(file.toFile(), ZKNODE_DATA_FILE));\n\n        for (String child : children) {\n          String zkChild = zkPath;\n          if (zkChild.endsWith(\"/\") == false) zkChild += \"/\";\n          zkChild += child;\n          if (isEphemeral(zkClient, zkChild)) { // Don't copy ephemeral nodes\n            continue;\n          }\n          // Go deeper into the tree now\n          downloadFromZK(zkClient, zkChild, file.resolve(child));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + file.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","sourceOld":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path file) throws IOException {\n    try {\n      List<String> children = zkClient.getChildren(zkPath, null, true);\n      // If it has no children, it's a leaf node, write the associated data from the ZNode.\n      // Otherwise, continue recursing, but write the associated data to a special file if any\n      if (children.size() == 0) {\n        // If we didn't copy data down, then we also didn't create the file. But we still need a marker on the local\n        // disk so create an empty file.\n        if (copyDataDown(zkClient, zkPath, file.toFile()) == 0) {\n          log.info(\"EOE Creating  file at (var 1)\" + file.toAbsolutePath().toString()); // TODO remove me EOE\n          log.info(\"EOE Creating  file at (var2) \" + file.toFile().getAbsolutePath()); // TODO remove me EOE\n          Files.createFile(file);\n          log.info(\"EOE Creating file exists: \" + Boolean.toString(file.toFile().exists()));\n          log.info(\"EOE Creating isFile: \" + Boolean.toString(file.toFile().isFile()));\n          log.info(\"EOE Creating isDirectory: \" + Boolean.toString(file.toFile().isDirectory())); //TODO: remove me EOE to here.\n        }\n      } else {\n        Files.createDirectories(file); // Make parent dir.\n        // ZK nodes, whether leaf or not can have data. If it's a non-leaf node and\n        // has associated data write it into the special file.\n        copyDataDown(zkClient, zkPath, new File(file.toFile(), ZKNODE_DATA_FILE));\n\n        for (String child : children) {\n          String zkChild = zkPath;\n          if (zkChild.endsWith(\"/\") == false) zkChild += \"/\";\n          zkChild += child;\n          if (isEphemeral(zkClient, zkChild)) { // Don't copy ephemeral nodes\n            continue;\n          }\n          // Go deeper into the tree now\n          downloadFromZK(zkClient, zkChild, file.resolve(child));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + file.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","bugFix":["1101e23841a13358cc2facc363fd887c9200ddfd"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","sourceNew":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path file) throws IOException {\n    try {\n      List<String> children = zkClient.getChildren(zkPath, null, true);\n      // If it has no children, it's a leaf node, write the associated data from the ZNode.\n      // Otherwise, continue recursing, but write the associated data to a special file if any\n      if (children.size() == 0) {\n        // If we didn't copy data down, then we also didn't create the file. But we still need a marker on the local\n        // disk so create an empty file.\n        if (copyDataDown(zkClient, zkPath, file.toFile()) == 0) {\n          Files.createFile(file);\n        }\n      } else {\n        Files.createDirectories(file); // Make parent dir.\n        // ZK nodes, whether leaf or not can have data. If it's a non-leaf node and\n        // has associated data write it into the special file.\n        copyDataDown(zkClient, zkPath, new File(file.toFile(), ZKNODE_DATA_FILE));\n\n        for (String child : children) {\n          String zkChild = zkPath;\n          if (zkChild.endsWith(\"/\") == false) zkChild += \"/\";\n          zkChild += child;\n          if (isEphemeral(zkClient, zkChild)) { // Don't copy ephemeral nodes\n            continue;\n          }\n          // Go deeper into the tree now\n          downloadFromZK(zkClient, zkChild, file.resolve(child));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + file.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","sourceOld":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path file) throws IOException {\n    try {\n      List<String> children = zkClient.getChildren(zkPath, null, true);\n      // If it has no children, it's a leaf node, write the assoicated data from the ZNode. \n      // Otherwise, continue recursing, but write the associated data to a special file if any\n      if (children.size() == 0) {\n        // If we didn't copy data down, then we also didn't create the file. But we still need a marker on the local\n        // disk so create a dir.\n        if (copyDataDown(zkClient, zkPath, file.toFile()) == 0) {\n          Files.createDirectories(file);\n        }\n      } else {\n        Files.createDirectories(file); // Make parent dir.\n        // ZK nodes, whether leaf or not can have data. If it's a non-leaf node and\n        // has associated data write it into the special file.\n        copyDataDown(zkClient, zkPath, new File(file.toFile(), ZKNODE_DATA_FILE));\n\n        for (String child : children) {\n          String zkChild = zkPath;\n          if (zkChild.endsWith(\"/\") == false) zkChild += \"/\";\n          zkChild += child;\n          if (isEphemeral(zkClient, zkChild)) { // Don't copy ephemeral nodes\n            continue;\n          }\n          // Go deeper into the tree now\n          downloadFromZK(zkClient, zkChild, file.resolve(child));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + file.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58884af1f68e9d61c217c753fbd6266d86a63b14","date":1502363401,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkMaintenanceUtils#downloadFromZK(SolrZkClient,String,Path).mjava","sourceNew":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path file) throws IOException {\n    try {\n      List<String> children = zkClient.getChildren(zkPath, null, true);\n      // If it has no children, it's a leaf node, write the associated data from the ZNode.\n      // Otherwise, continue recursing, but write the associated data to a special file if any\n      if (children.size() == 0) {\n        // If we didn't copy data down, then we also didn't create the file. But we still need a marker on the local\n        // disk so create an empty file.\n        if (copyDataDown(zkClient, zkPath, file.toFile()) == 0) {\n          Files.createFile(file);\n        }\n      } else {\n        Files.createDirectories(file); // Make parent dir.\n        // ZK nodes, whether leaf or not can have data. If it's a non-leaf node and\n        // has associated data write it into the special file.\n        copyDataDown(zkClient, zkPath, new File(file.toFile(), ZKNODE_DATA_FILE));\n\n        for (String child : children) {\n          String zkChild = zkPath;\n          if (zkChild.endsWith(\"/\") == false) zkChild += \"/\";\n          zkChild += child;\n          if (isEphemeral(zkClient, zkChild)) { // Don't copy ephemeral nodes\n            continue;\n          }\n          // Go deeper into the tree now\n          downloadFromZK(zkClient, zkChild, file.resolve(child));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + file.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","sourceOld":"  public static void downloadFromZK(SolrZkClient zkClient, String zkPath, Path file) throws IOException {\n    try {\n      List<String> children = zkClient.getChildren(zkPath, null, true);\n      // If it has no children, it's a leaf node, write the associated data from the ZNode.\n      // Otherwise, continue recursing, but write the associated data to a special file if any\n      if (children.size() == 0) {\n        // If we didn't copy data down, then we also didn't create the file. But we still need a marker on the local\n        // disk so create an empty file.\n        if (copyDataDown(zkClient, zkPath, file.toFile()) == 0) {\n          log.info(\"EOE Creating  file at (var 1)\" + file.toAbsolutePath().toString()); // TODO remove me EOE\n          log.info(\"EOE Creating  file at (var2) \" + file.toFile().getAbsolutePath()); // TODO remove me EOE\n          Files.createFile(file);\n          log.info(\"EOE Creating file exists: \" + Boolean.toString(file.toFile().exists()));\n          log.info(\"EOE Creating isFile: \" + Boolean.toString(file.toFile().isFile()));\n          log.info(\"EOE Creating isDirectory: \" + Boolean.toString(file.toFile().isDirectory())); //TODO: remove me EOE to here.\n        }\n      } else {\n        Files.createDirectories(file); // Make parent dir.\n        // ZK nodes, whether leaf or not can have data. If it's a non-leaf node and\n        // has associated data write it into the special file.\n        copyDataDown(zkClient, zkPath, new File(file.toFile(), ZKNODE_DATA_FILE));\n\n        for (String child : children) {\n          String zkChild = zkPath;\n          if (zkChild.endsWith(\"/\") == false) zkChild += \"/\";\n          zkChild += child;\n          if (isEphemeral(zkClient, zkChild)) { // Don't copy ephemeral nodes\n            continue;\n          }\n          // Go deeper into the tree now\n          downloadFromZK(zkClient, zkChild, file.resolve(child));\n        }\n      }\n    } catch (KeeperException | InterruptedException e) {\n      throw new IOException(\"Error downloading files from zookeeper path \" + zkPath + \" to \" + file.toString(),\n          SolrZkClient.checkInterrupted(e));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7b3180545c5d5e137529b5474e018af04e07615":["9272a617a9cbebf86be127014bbbacd7cf8f8e83"],"58884af1f68e9d61c217c753fbd6266d86a63b14":["566112f6115904d848cbf09462ebd8bf1304257b","6f896d10632f33e14c708179f4c5d5ec442a1287"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["c7b3180545c5d5e137529b5474e018af04e07615","6f896d10632f33e14c708179f4c5d5ec442a1287"],"f4dbb79e6da9d3d2ef8d3890b5619da3c1fba62e":["9272a617a9cbebf86be127014bbbacd7cf8f8e83"],"566112f6115904d848cbf09462ebd8bf1304257b":["f4dbb79e6da9d3d2ef8d3890b5619da3c1fba62e","1101e23841a13358cc2facc363fd887c9200ddfd"],"6f896d10632f33e14c708179f4c5d5ec442a1287":["566112f6115904d848cbf09462ebd8bf1304257b"],"9272a617a9cbebf86be127014bbbacd7cf8f8e83":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1101e23841a13358cc2facc363fd887c9200ddfd":["33e11d49e1ce128772bc8ecfdcf22b4ed0be0b37"],"33e11d49e1ce128772bc8ecfdcf22b4ed0be0b37":["f4dbb79e6da9d3d2ef8d3890b5619da3c1fba62e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9272a617a9cbebf86be127014bbbacd7cf8f8e83"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6f896d10632f33e14c708179f4c5d5ec442a1287"]},"commit2Childs":{"c7b3180545c5d5e137529b5474e018af04e07615":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"58884af1f68e9d61c217c753fbd6266d86a63b14":[],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"f4dbb79e6da9d3d2ef8d3890b5619da3c1fba62e":["566112f6115904d848cbf09462ebd8bf1304257b","33e11d49e1ce128772bc8ecfdcf22b4ed0be0b37"],"566112f6115904d848cbf09462ebd8bf1304257b":["58884af1f68e9d61c217c753fbd6266d86a63b14","6f896d10632f33e14c708179f4c5d5ec442a1287"],"6f896d10632f33e14c708179f4c5d5ec442a1287":["58884af1f68e9d61c217c753fbd6266d86a63b14","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9272a617a9cbebf86be127014bbbacd7cf8f8e83":["c7b3180545c5d5e137529b5474e018af04e07615","f4dbb79e6da9d3d2ef8d3890b5619da3c1fba62e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"1101e23841a13358cc2facc363fd887c9200ddfd":["566112f6115904d848cbf09462ebd8bf1304257b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9272a617a9cbebf86be127014bbbacd7cf8f8e83","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"33e11d49e1ce128772bc8ecfdcf22b4ed0be0b37":["1101e23841a13358cc2facc363fd887c9200ddfd"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["58884af1f68e9d61c217c753fbd6266d86a63b14","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}