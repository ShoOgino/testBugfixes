{"path":"contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","commits":[{"id":"d3c3c2404d1200c39220fa15054fae854db4e1ee","date":1140827958,"type":0,"author":"Mark Harwood","isMerge":false,"pathNew":"contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"    public Query rewrite(IndexReader reader) throws IOException\r\n    {\r\n        if(rewrittenQuery!=null)\r\n        {\r\n            return rewrittenQuery;\r\n        }\r\n        //load up the list of possible terms\r\n        for (Iterator iter = fieldVals.iterator(); iter.hasNext();)\r\n\t\t{\r\n\t\t\tFieldVals f = (FieldVals) iter.next();\r\n\t\t\taddTerms(reader,f);\t\t\t\r\n\t\t}\r\n        //clear the list of fields\r\n        fieldVals.clear();\r\n        \r\n        BooleanQuery bq=new BooleanQuery();\r\n        \r\n        \r\n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\r\n        // has no coord factor\r\n        //Step 1: sort the termqueries by term/field\r\n        HashMap variantQueries=new HashMap();\r\n        int size = q.size();\r\n        for(int i = 0; i < size; i++)\r\n        {\r\n          ScoreTerm st = (ScoreTerm) q.pop();\r\n          ArrayList l=(ArrayList) variantQueries.get(st.fuzziedSourceTerm);\r\n          if(l==null)\r\n          {\r\n              l=new ArrayList();\r\n              variantQueries.put(st.fuzziedSourceTerm,l);\r\n          }\r\n          l.add(st);\r\n        }\r\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\r\n        for (Iterator iter = variantQueries.values().iterator(); iter.hasNext();)\r\n        {\r\n            ArrayList variants = (ArrayList) iter.next();\r\n            if(variants.size()==1)\r\n            {\r\n                //optimize where only one selected variant\r\n                ScoreTerm st=(ScoreTerm) variants.get(0);\r\n                TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);\r\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\r\n                bq.add(tq, BooleanClause.Occur.SHOULD); \r\n            }\r\n            else\r\n            {\r\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\r\n                for (Iterator iterator2 = variants.iterator(); iterator2\r\n                        .hasNext();)\r\n                {\r\n                    ScoreTerm st = (ScoreTerm) iterator2.next();\r\n                    TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);      // found a match\r\n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\r\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \r\n                }\r\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\r\n            }\r\n        }\r\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\r\n        // booleans with a minimum-should-match of NumFields-1?\r\n        \r\n        this.rewrittenQuery=bq;\r\n        return bq;\r\n    }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8612fbb01d2dc5842b9930a4984ffa841342c56e","date":1167956312,"type":3,"author":"Mark Harwood","isMerge":false,"pathNew":"contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","sourceNew":"    public Query rewrite(IndexReader reader) throws IOException\r\n    {\r\n        if(rewrittenQuery!=null)\r\n        {\r\n            return rewrittenQuery;\r\n        }\r\n        //load up the list of possible terms\r\n        for (Iterator iter = fieldVals.iterator(); iter.hasNext();)\r\n\t\t{\r\n\t\t\tFieldVals f = (FieldVals) iter.next();\r\n\t\t\taddTerms(reader,f);\t\t\t\r\n\t\t}\r\n        //clear the list of fields\r\n        fieldVals.clear();\r\n        \r\n        BooleanQuery bq=new BooleanQuery();\r\n        \r\n        \r\n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\r\n        // has no coord factor\r\n        //Step 1: sort the termqueries by term/field\r\n        HashMap variantQueries=new HashMap();\r\n        int size = q.size();\r\n        for(int i = 0; i < size; i++)\r\n        {\r\n          ScoreTerm st = (ScoreTerm) q.pop();\r\n          ArrayList l=(ArrayList) variantQueries.get(st.fuzziedSourceTerm);\r\n          if(l==null)\r\n          {\r\n              l=new ArrayList();\r\n              variantQueries.put(st.fuzziedSourceTerm,l);\r\n          }\r\n          l.add(st);\r\n        }\r\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\r\n        for (Iterator iter = variantQueries.values().iterator(); iter.hasNext();)\r\n        {\r\n            ArrayList variants = (ArrayList) iter.next();\r\n            if(variants.size()==1)\r\n            {\r\n                //optimize where only one selected variant\r\n                ScoreTerm st=(ScoreTerm) variants.get(0);\r\n                TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);\r\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\r\n                bq.add(tq, BooleanClause.Occur.SHOULD); \r\n            }\r\n            else\r\n            {\r\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\r\n                for (Iterator iterator2 = variants.iterator(); iterator2\r\n                        .hasNext();)\r\n                {\r\n                    ScoreTerm st = (ScoreTerm) iterator2.next();\r\n                    TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);      // found a match\r\n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\r\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \r\n                }\r\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\r\n            }\r\n        }\r\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\r\n        // booleans with a minimum-should-match of NumFields-1?\r\n        bq.setBoost(getBoost());\r\n        this.rewrittenQuery=bq;\r\n        return bq;\r\n    }\r\n\n","sourceOld":"    public Query rewrite(IndexReader reader) throws IOException\r\n    {\r\n        if(rewrittenQuery!=null)\r\n        {\r\n            return rewrittenQuery;\r\n        }\r\n        //load up the list of possible terms\r\n        for (Iterator iter = fieldVals.iterator(); iter.hasNext();)\r\n\t\t{\r\n\t\t\tFieldVals f = (FieldVals) iter.next();\r\n\t\t\taddTerms(reader,f);\t\t\t\r\n\t\t}\r\n        //clear the list of fields\r\n        fieldVals.clear();\r\n        \r\n        BooleanQuery bq=new BooleanQuery();\r\n        \r\n        \r\n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\r\n        // has no coord factor\r\n        //Step 1: sort the termqueries by term/field\r\n        HashMap variantQueries=new HashMap();\r\n        int size = q.size();\r\n        for(int i = 0; i < size; i++)\r\n        {\r\n          ScoreTerm st = (ScoreTerm) q.pop();\r\n          ArrayList l=(ArrayList) variantQueries.get(st.fuzziedSourceTerm);\r\n          if(l==null)\r\n          {\r\n              l=new ArrayList();\r\n              variantQueries.put(st.fuzziedSourceTerm,l);\r\n          }\r\n          l.add(st);\r\n        }\r\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\r\n        for (Iterator iter = variantQueries.values().iterator(); iter.hasNext();)\r\n        {\r\n            ArrayList variants = (ArrayList) iter.next();\r\n            if(variants.size()==1)\r\n            {\r\n                //optimize where only one selected variant\r\n                ScoreTerm st=(ScoreTerm) variants.get(0);\r\n                TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);\r\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\r\n                bq.add(tq, BooleanClause.Occur.SHOULD); \r\n            }\r\n            else\r\n            {\r\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\r\n                for (Iterator iterator2 = variants.iterator(); iterator2\r\n                        .hasNext();)\r\n                {\r\n                    ScoreTerm st = (ScoreTerm) iterator2.next();\r\n                    TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);      // found a match\r\n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\r\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \r\n                }\r\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\r\n            }\r\n        }\r\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\r\n        // booleans with a minimum-should-match of NumFields-1?\r\n        \r\n        this.rewrittenQuery=bq;\r\n        return bq;\r\n    }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a361a621b184d9b73c9c9a37323a9845b8f8260","date":1226370946,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","sourceNew":"    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = (FieldVals) iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap variantQueries=new HashMap();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = (ScoreTerm) q.pop();\n          ArrayList l=(ArrayList) variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList variants = (ArrayList) iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st=(ScoreTerm) variants.get(0);\n                TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = (ScoreTerm) iterator2.next();\n                    TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);      // found a match\n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","sourceOld":"    public Query rewrite(IndexReader reader) throws IOException\r\n    {\r\n        if(rewrittenQuery!=null)\r\n        {\r\n            return rewrittenQuery;\r\n        }\r\n        //load up the list of possible terms\r\n        for (Iterator iter = fieldVals.iterator(); iter.hasNext();)\r\n\t\t{\r\n\t\t\tFieldVals f = (FieldVals) iter.next();\r\n\t\t\taddTerms(reader,f);\t\t\t\r\n\t\t}\r\n        //clear the list of fields\r\n        fieldVals.clear();\r\n        \r\n        BooleanQuery bq=new BooleanQuery();\r\n        \r\n        \r\n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\r\n        // has no coord factor\r\n        //Step 1: sort the termqueries by term/field\r\n        HashMap variantQueries=new HashMap();\r\n        int size = q.size();\r\n        for(int i = 0; i < size; i++)\r\n        {\r\n          ScoreTerm st = (ScoreTerm) q.pop();\r\n          ArrayList l=(ArrayList) variantQueries.get(st.fuzziedSourceTerm);\r\n          if(l==null)\r\n          {\r\n              l=new ArrayList();\r\n              variantQueries.put(st.fuzziedSourceTerm,l);\r\n          }\r\n          l.add(st);\r\n        }\r\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\r\n        for (Iterator iter = variantQueries.values().iterator(); iter.hasNext();)\r\n        {\r\n            ArrayList variants = (ArrayList) iter.next();\r\n            if(variants.size()==1)\r\n            {\r\n                //optimize where only one selected variant\r\n                ScoreTerm st=(ScoreTerm) variants.get(0);\r\n                TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);\r\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\r\n                bq.add(tq, BooleanClause.Occur.SHOULD); \r\n            }\r\n            else\r\n            {\r\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\r\n                for (Iterator iterator2 = variants.iterator(); iterator2\r\n                        .hasNext();)\r\n                {\r\n                    ScoreTerm st = (ScoreTerm) iterator2.next();\r\n                    TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);      // found a match\r\n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\r\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \r\n                }\r\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\r\n            }\r\n        }\r\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\r\n        // booleans with a minimum-should-match of NumFields-1?\r\n        bq.setBoost(getBoost());\r\n        this.rewrittenQuery=bq;\r\n        return bq;\r\n    }\r\n\n","bugFix":null,"bugIntro":["683697c94be5a13ed67b070f48f5c5499ee8f6ea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d57eb7c98c08c03af6e4cd83509df31c81ac16af","date":1257684312,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = (FieldVals) iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap variantQueries=new HashMap();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = (ScoreTerm) q.pop();\n          ArrayList l=(ArrayList) variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList variants = (ArrayList) iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st=(ScoreTerm) variants.get(0);\n                TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = (ScoreTerm) iterator2.next();\n                    TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);      // found a match\n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","sourceOld":"    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = (FieldVals) iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap variantQueries=new HashMap();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = (ScoreTerm) q.pop();\n          ArrayList l=(ArrayList) variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList variants = (ArrayList) iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st=(ScoreTerm) variants.get(0);\n                TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = (ScoreTerm) iterator2.next();\n                    TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);      // found a match\n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"60cdc0e643184821eb066795a8791cd82559f46e","date":1257941914,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);      // found a match\n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = (FieldVals) iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap variantQueries=new HashMap();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = (ScoreTerm) q.pop();\n          ArrayList l=(ArrayList) variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList variants = (ArrayList) iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st=(ScoreTerm) variants.get(0);\n                TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = (ScoreTerm) iterator2.next();\n                    TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);      // found a match\n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","pathOld":"contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);      // found a match\n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException\n    {\n        if(rewrittenQuery!=null)\n        {\n            return rewrittenQuery;\n        }\n        //load up the list of possible terms\n        for (Iterator<FieldVals> iter = fieldVals.iterator(); iter.hasNext();)\n\t\t{\n\t\t\tFieldVals f = iter.next();\n\t\t\taddTerms(reader,f);\t\t\t\n\t\t}\n        //clear the list of fields\n        fieldVals.clear();\n        \n        BooleanQuery bq=new BooleanQuery();\n        \n        \n        //create BooleanQueries to hold the variants for each token/field pair and ensure it\n        // has no coord factor\n        //Step 1: sort the termqueries by term/field\n        HashMap<Term,ArrayList<ScoreTerm>> variantQueries=new HashMap<Term,ArrayList<ScoreTerm>>();\n        int size = q.size();\n        for(int i = 0; i < size; i++)\n        {\n          ScoreTerm st = q.pop();\n          ArrayList<ScoreTerm> l= variantQueries.get(st.fuzziedSourceTerm);\n          if(l==null)\n          {\n              l=new ArrayList<ScoreTerm>();\n              variantQueries.put(st.fuzziedSourceTerm,l);\n          }\n          l.add(st);\n        }\n        //Step 2: Organize the sorted termqueries into zero-coord scoring boolean queries\n        for (Iterator<ArrayList<ScoreTerm>> iter = variantQueries.values().iterator(); iter.hasNext();)\n        {\n            ArrayList<ScoreTerm> variants = iter.next();\n            if(variants.size()==1)\n            {\n                //optimize where only one selected variant\n                ScoreTerm st= variants.get(0);\n                TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);\n                tq.setBoost(st.score); // set the boost to a mix of IDF and score\n                bq.add(tq, BooleanClause.Occur.SHOULD); \n            }\n            else\n            {\n                BooleanQuery termVariants=new BooleanQuery(true); //disable coord and IDF for these term variants\n                for (Iterator<ScoreTerm> iterator2 = variants.iterator(); iterator2\n                        .hasNext();)\n                {\n                    ScoreTerm st = iterator2.next();\n                    TermQuery tq = new FuzzyTermQuery(st.term,ignoreTF);      // found a match\n                    tq.setBoost(st.score); // set the boost using the ScoreTerm's score\n                    termVariants.add(tq, BooleanClause.Occur.SHOULD);          // add to query                    \n                }\n                bq.add(termVariants, BooleanClause.Occur.SHOULD);          // add to query\n            }\n        }\n        //TODO possible alternative step 3 - organize above booleans into a new layer of field-based\n        // booleans with a minimum-should-match of NumFields-1?\n        bq.setBoost(getBoost());\n        this.rewrittenQuery=bq;\n        return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"60cdc0e643184821eb066795a8791cd82559f46e":["d57eb7c98c08c03af6e4cd83509df31c81ac16af"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d57eb7c98c08c03af6e4cd83509df31c81ac16af":["6a361a621b184d9b73c9c9a37323a9845b8f8260"],"6a361a621b184d9b73c9c9a37323a9845b8f8260":["8612fbb01d2dc5842b9930a4984ffa841342c56e"],"d3c3c2404d1200c39220fa15054fae854db4e1ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8612fbb01d2dc5842b9930a4984ffa841342c56e":["d3c3c2404d1200c39220fa15054fae854db4e1ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["60cdc0e643184821eb066795a8791cd82559f46e"]},"commit2Childs":{"60cdc0e643184821eb066795a8791cd82559f46e":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d3c3c2404d1200c39220fa15054fae854db4e1ee"],"d57eb7c98c08c03af6e4cd83509df31c81ac16af":["60cdc0e643184821eb066795a8791cd82559f46e"],"6a361a621b184d9b73c9c9a37323a9845b8f8260":["d57eb7c98c08c03af6e4cd83509df31c81ac16af"],"d3c3c2404d1200c39220fa15054fae854db4e1ee":["8612fbb01d2dc5842b9930a4984ffa841342c56e"],"8612fbb01d2dc5842b9930a4984ffa841342c56e":["6a361a621b184d9b73c9c9a37323a9845b8f8260"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}