{"path":"solr/core/src/test/org/apache/solr/handler/admin/ThreadDumpHandlerTest#doTestMonitor(boolean).mjava","commits":[{"id":"e38b745e9eee882a51b0b965cc5ba8daf1009891","date":1594668544,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/admin/ThreadDumpHandlerTest#doTestMonitor(boolean).mjava","pathOld":"/dev/null","sourceNew":"  public void doTestMonitor(final boolean checkBlockedThreadViaPolling) throws Exception {\n    assumeTrue(\"monitor checking not supported on this JVM\",\n               ManagementFactory.getThreadMXBean().isObjectMonitorUsageSupported());\n    \n    /** unique class name to show up as a lock class name in output */\n    final class TestMonitorStruct { /* empty */ }\n    \n    final List<String> failures = new ArrayList<>();\n    final CountDownLatch lockIsHeldLatch = new CountDownLatch(1);\n    final CountDownLatch doneWithTestLatch = new CountDownLatch(1);\n    final Object monitor = new TestMonitorStruct();\n    final Thread ownerT = new Thread(() -> {\n        synchronized (monitor) {\n          lockIsHeldLatch.countDown();\n          log.info(\"monitor ownerT waiting for doneWithTestLatch to release me...\");\n          try {\n            if ( ! doneWithTestLatch.await(30, TimeUnit.SECONDS ) ){\n              failures.add(\"ownerT: never saw doneWithTestLatch released\");\n            }\n          } catch (InterruptedException ie) {\n            failures.add(\"ownerT: \" + ie.toString());\n          }\n        }\n      }, \"test-thread-monitor-owner\");\n\n    // only used if checkBlockedThreadViaPolling\n    // don't start until after lockIsHeldLatch fires    \n    final Thread blockedT = new Thread(() -> {\n        log.info(\"blockedT waiting for monitor...\");\n        synchronized (monitor) {\n          log.info(\"monitor now unblocked\");\n        }\n      }, \"test-thread-monitor-blocked\");\n    \n    try {\n      ownerT.start();\n      if ( ! lockIsHeldLatch.await(30, TimeUnit.SECONDS ) ){\n        failures.add(\"never saw lockIsHeldLatch released\");\n        return;\n      }\n      assertQ(req(\"qt\", \"/admin/threads\", \"indent\", \"true\")\n              // monitor owner 'ownerT'\n              // (which *MAY* also be waiting on doneWithTestLatch, but may not have reached that line yet)\n              , \"//lst[@name='thread'][str[@name='name'][.='test-thread-monitor-owner']]\"\n              + \"                     [arr[@name='monitors-locked']/str[contains(.,'TestMonitorStruct')]]\"\n              );\n\n      if (checkBlockedThreadViaPolling) {\n        log.info(\"Also checking with blockedT thread setup via polling...\");\n        try {\n          blockedT.setPriority(Thread.MAX_PRIORITY);\n        } catch (Exception e) {\n          log.warn(\"Couldn't set blockedT priority\", e);\n        }\n        blockedT.start();\n        // there is no way to \"await\" on the situation of the 'blockedT' thread actually reaching the\n        // \"synchronized\" block and becoming BLOCKED ... we just have to Poll for it...\n        for (int i = 0; i < 500 && (! Thread.State.BLOCKED.equals(blockedT.getState())); i++) {\n          Thread.sleep(10); // 10ms at a time, at most 5 sec total\n        }\n        if (Thread.State.BLOCKED.equals(blockedT.getState())) {\n          assertQ(req(\"qt\", \"/admin/threads\", \"indent\", \"true\")\n                  // same monitor owner 'ownerT'\n                  , \"//lst[@name='thread'][str[@name='name'][.='test-thread-monitor-owner']]\"\n                  + \"                     [arr[@name='monitors-locked']/str[contains(.,'TestMonitorStruct')]]\"\n                  // blocked thread 'blockedT', waiting on the monitor\n                  , \"//lst[@name='thread'][str[@name='name'][.='test-thread-monitor-blocked']]\"\n                  + \"                     [str[@name='state'][.='BLOCKED']]\"\n                  + \"                     [lst[@name='lock-waiting'][lst[@name='owner']/str[.='test-thread-monitor-owner']]]\"\n                  );\n        }\n      }\n    } finally {\n      lockIsHeldLatch.countDown();\n      doneWithTestLatch.countDown();\n      ownerT.join(1000);\n      assertFalse(\"ownerT is still alive\", ownerT.isAlive());\n      blockedT.join(1000);\n      assertFalse(\"blockedT is still alive\", blockedT.isAlive());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e38b745e9eee882a51b0b965cc5ba8daf1009891":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e38b745e9eee882a51b0b965cc5ba8daf1009891"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e38b745e9eee882a51b0b965cc5ba8daf1009891"],"e38b745e9eee882a51b0b965cc5ba8daf1009891":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}