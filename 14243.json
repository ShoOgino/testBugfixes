{"path":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#writeHeader(DataOutput,String,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#writeHeader(DataOutput,String,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/CodecUtil#writeHeader(DataOutput,String,int).mjava","sourceNew":"  public static void writeHeader(DataOutput out, String codec, int version)\n    throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","sourceOld":"  public static void writeHeader(DataOutput out, String codec, int version)\n    throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc26e52010f57ac92820f8d306f030144ab7b9d4","date":1335539557,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#writeHeader(DataOutput,String,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#writeHeader(DataOutput,String,int).mjava","sourceNew":"  /**\n   * Writes a codec header, which records both a string to\n   * identify the file and a version number. This header can\n   * be parsed and validated with \n   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.\n   * <p>\n   * CodecHeader --&gt; Magic,CodecName,Version\n   * <ul>\n   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This\n   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.\n   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This\n   *        is a string to identify this file.\n   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records\n   *        the version of the file.\n   * </ul>\n   * <p>\n   * Note that the length of a codec header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   */\n  public static void writeHeader(DataOutput out, String codec, int version)\n    throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","sourceOld":"  public static void writeHeader(DataOutput out, String codec, int version)\n    throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bcce0e518c0546269a896ca6124ba4313059185f","date":1340381078,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeHeader(DataOutput,String,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#writeHeader(DataOutput,String,int).mjava","sourceNew":"  /**\n   * Writes a codec header, which records both a string to\n   * identify the file and a version number. This header can\n   * be parsed and validated with \n   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.\n   * <p>\n   * CodecHeader --&gt; Magic,CodecName,Version\n   * <ul>\n   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This\n   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.\n   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This\n   *        is a string to identify this file.\n   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records\n   *        the version of the file.\n   * </ul>\n   * <p>\n   * Note that the length of a codec header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   */\n  public static void writeHeader(DataOutput out, String codec, int version)\n    throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","sourceOld":"  /**\n   * Writes a codec header, which records both a string to\n   * identify the file and a version number. This header can\n   * be parsed and validated with \n   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.\n   * <p>\n   * CodecHeader --&gt; Magic,CodecName,Version\n   * <ul>\n   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This\n   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.\n   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This\n   *        is a string to identify this file.\n   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records\n   *        the version of the file.\n   * </ul>\n   * <p>\n   * Note that the length of a codec header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   */\n  public static void writeHeader(DataOutput out, String codec, int version)\n    throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeHeader(DataOutput,String,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#writeHeader(DataOutput,String,int).mjava","sourceNew":"  /**\n   * Writes a codec header, which records both a string to\n   * identify the file and a version number. This header can\n   * be parsed and validated with \n   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.\n   * <p>\n   * CodecHeader --&gt; Magic,CodecName,Version\n   * <ul>\n   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This\n   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.\n   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This\n   *        is a string to identify this file.\n   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records\n   *        the version of the file.\n   * </ul>\n   * <p>\n   * Note that the length of a codec header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   */\n  public static void writeHeader(DataOutput out, String codec, int version)\n    throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","sourceOld":"  /**\n   * Writes a codec header, which records both a string to\n   * identify the file and a version number. This header can\n   * be parsed and validated with \n   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.\n   * <p>\n   * CodecHeader --&gt; Magic,CodecName,Version\n   * <ul>\n   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This\n   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.\n   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This\n   *        is a string to identify this file.\n   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records\n   *        the version of the file.\n   * </ul>\n   * <p>\n   * Note that the length of a codec header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   */\n  public static void writeHeader(DataOutput out, String codec, int version)\n    throws IOException {\n    BytesRef bytes = new BytesRef(codec);\n    if (bytes.length != codec.length() || bytes.length >= 128) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 128 characters in length [got \" + codec + \"]\");\n    }\n    out.writeInt(CODEC_MAGIC);\n    out.writeString(codec);\n    out.writeInt(version);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bcce0e518c0546269a896ca6124ba4313059185f":["fc26e52010f57ac92820f8d306f030144ab7b9d4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["fc26e52010f57ac92820f8d306f030144ab7b9d4","bcce0e518c0546269a896ca6124ba4313059185f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fc26e52010f57ac92820f8d306f030144ab7b9d4":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bcce0e518c0546269a896ca6124ba4313059185f"]},"commit2Childs":{"bcce0e518c0546269a896ca6124ba4313059185f":["fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["fc26e52010f57ac92820f8d306f030144ab7b9d4"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"fc26e52010f57ac92820f8d306f030144ab7b9d4":["bcce0e518c0546269a896ca6124ba4313059185f","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}