{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.AliasesManager#process(WatchedEvent).mjava","commits":[{"id":"215e40821821b2df2e69355e208532c05ef095a5","date":1510858642,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.AliasesManager#process(WatchedEvent).mjava","pathOld":"/dev/null","sourceNew":"    // ZK Watcher interface\n    @Override\n    public void process(WatchedEvent event) {\n      // session events are not change events, and do not remove the watcher\n      if (EventType.None.equals(event.getType())) {\n        return;\n      }\n      try {\n        LOG.debug(\"Aliases: updating\");\n\n        // re-register the watch\n        Stat stat = new Stat();\n        final byte[] data = zkClient.getData(ALIASES, this, stat, true);\n        // note: it'd be nice to avoid possibly needlessly parsing if we don't update aliases but not a big deal\n        setIfNewer(Aliases.fromJSON(data, stat.getVersion()));\n      } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n        LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        LOG.error(\"A ZK error has occurred\", e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        LOG.warn(\"Interrupted\", e);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3de3780a0f74036499aad4df2a73159b14fbad2","date":1529604012,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.AliasesManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.AliasesManager#process(WatchedEvent).mjava","sourceNew":"    // ZK Watcher interface\n    @Override\n    public void process(WatchedEvent event) {\n      // session events are not change events, and do not remove the watcher\n      if (EventType.None.equals(event.getType())) {\n        return;\n      }\n      try {\n        LOG.debug(\"Aliases: updating\");\n\n        // re-register the watch\n        Stat stat = new Stat();\n        final byte[] data = zkClient.getData(ALIASES, this, stat, true);\n        // note: it'd be nice to avoid possibly needlessly parsing if we don't update aliases but not a big deal\n        setIfNewer(Aliases.fromJSON(data, stat.getVersion()));\n      } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n        // note: aliases.json is required to be present\n        LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        LOG.error(\"A ZK error has occurred\", e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        LOG.warn(\"Interrupted\", e);\n      }\n    }\n\n","sourceOld":"    // ZK Watcher interface\n    @Override\n    public void process(WatchedEvent event) {\n      // session events are not change events, and do not remove the watcher\n      if (EventType.None.equals(event.getType())) {\n        return;\n      }\n      try {\n        LOG.debug(\"Aliases: updating\");\n\n        // re-register the watch\n        Stat stat = new Stat();\n        final byte[] data = zkClient.getData(ALIASES, this, stat, true);\n        // note: it'd be nice to avoid possibly needlessly parsing if we don't update aliases but not a big deal\n        setIfNewer(Aliases.fromJSON(data, stat.getVersion()));\n      } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n        LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        LOG.error(\"A ZK error has occurred\", e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        LOG.warn(\"Interrupted\", e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe736fc2dca4bb2af36fa478366c29db9e31a1f9","date":1529608800,"type":3,"author":"Chris Hostetter","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.AliasesManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.AliasesManager#process(WatchedEvent).mjava","sourceNew":"    // ZK Watcher interface\n    @Override\n    public void process(WatchedEvent event) {\n      // session events are not change events, and do not remove the watcher\n      if (EventType.None.equals(event.getType())) {\n        return;\n      }\n      try {\n        LOG.debug(\"Aliases: updating\");\n\n        // re-register the watch\n        Stat stat = new Stat();\n        final byte[] data = zkClient.getData(ALIASES, this, stat, true);\n        // note: it'd be nice to avoid possibly needlessly parsing if we don't update aliases but not a big deal\n        setIfNewer(Aliases.fromJSON(data, stat.getVersion()));\n      } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n        // note: aliases.json is required to be present\n        LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        LOG.error(\"A ZK error has occurred\", e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        LOG.warn(\"Interrupted\", e);\n      }\n    }\n\n","sourceOld":"    // ZK Watcher interface\n    @Override\n    public void process(WatchedEvent event) {\n      // session events are not change events, and do not remove the watcher\n      if (EventType.None.equals(event.getType())) {\n        return;\n      }\n      try {\n        LOG.debug(\"Aliases: updating\");\n\n        // re-register the watch\n        Stat stat = new Stat();\n        final byte[] data = zkClient.getData(ALIASES, this, stat, true);\n        // note: it'd be nice to avoid possibly needlessly parsing if we don't update aliases but not a big deal\n        setIfNewer(Aliases.fromJSON(data, stat.getVersion()));\n      } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n        LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        LOG.error(\"A ZK error has occurred\", e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        LOG.warn(\"Interrupted\", e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.AliasesManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.AliasesManager#process(WatchedEvent).mjava","sourceNew":"    // ZK Watcher interface\n    @Override\n    public void process(WatchedEvent event) {\n      // session events are not change events, and do not remove the watcher\n      if (EventType.None.equals(event.getType())) {\n        return;\n      }\n      try {\n        LOG.debug(\"Aliases: updating\");\n\n        // re-register the watch\n        Stat stat = new Stat();\n        final byte[] data = zkClient.getData(ALIASES, this, stat, true);\n        // note: it'd be nice to avoid possibly needlessly parsing if we don't update aliases but not a big deal\n        setIfNewer(Aliases.fromJSON(data, stat.getVersion()));\n      } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n        // note: aliases.json is required to be present\n        LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        LOG.error(\"A ZK error has occurred\", e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        LOG.warn(\"Interrupted\", e);\n      }\n    }\n\n","sourceOld":"    // ZK Watcher interface\n    @Override\n    public void process(WatchedEvent event) {\n      // session events are not change events, and do not remove the watcher\n      if (EventType.None.equals(event.getType())) {\n        return;\n      }\n      try {\n        LOG.debug(\"Aliases: updating\");\n\n        // re-register the watch\n        Stat stat = new Stat();\n        final byte[] data = zkClient.getData(ALIASES, this, stat, true);\n        // note: it'd be nice to avoid possibly needlessly parsing if we don't update aliases but not a big deal\n        setIfNewer(Aliases.fromJSON(data, stat.getVersion()));\n      } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n        LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        LOG.error(\"A ZK error has occurred\", e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        LOG.warn(\"Interrupted\", e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.AliasesManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.AliasesManager#process(WatchedEvent).mjava","sourceNew":"    // ZK Watcher interface\n    @Override\n    public void process(WatchedEvent event) {\n      // session events are not change events, and do not remove the watcher\n      if (EventType.None.equals(event.getType())) {\n        return;\n      }\n      try {\n        LOG.debug(\"Aliases: updating\");\n\n        // re-register the watch\n        Stat stat = new Stat();\n        final byte[] data = zkClient.getData(ALIASES, this, stat, true);\n        // note: it'd be nice to avoid possibly needlessly parsing if we don't update aliases but not a big deal\n        setIfNewer(Aliases.fromJSON(data, stat.getVersion()));\n      } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n        // note: aliases.json is required to be present\n        LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        LOG.error(\"A ZK error has occurred\", e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        LOG.warn(\"Interrupted\", e);\n      }\n    }\n\n","sourceOld":"    // ZK Watcher interface\n    @Override\n    public void process(WatchedEvent event) {\n      // session events are not change events, and do not remove the watcher\n      if (EventType.None.equals(event.getType())) {\n        return;\n      }\n      try {\n        LOG.debug(\"Aliases: updating\");\n\n        // re-register the watch\n        Stat stat = new Stat();\n        final byte[] data = zkClient.getData(ALIASES, this, stat, true);\n        // note: it'd be nice to avoid possibly needlessly parsing if we don't update aliases but not a big deal\n        setIfNewer(Aliases.fromJSON(data, stat.getVersion()));\n      } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n        LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        LOG.error(\"A ZK error has occurred\", e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        LOG.warn(\"Interrupted\", e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.AliasesManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.AliasesManager#process(WatchedEvent).mjava","sourceNew":"    // ZK Watcher interface\n    @Override\n    public void process(WatchedEvent event) {\n      // session events are not change events, and do not remove the watcher\n      if (EventType.None.equals(event.getType())) {\n        return;\n      }\n      try {\n        log.debug(\"Aliases: updating\");\n\n        // re-register the watch\n        Stat stat = new Stat();\n        final byte[] data = zkClient.getData(ALIASES, this, stat, true);\n        // note: it'd be nice to avoid possibly needlessly parsing if we don't update aliases but not a big deal\n        setIfNewer(Aliases.fromJSON(data, stat.getVersion()));\n      } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n        // note: aliases.json is required to be present\n        log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        log.error(\"A ZK error has occurred\", e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"Interrupted\", e);\n      }\n    }\n\n","sourceOld":"    // ZK Watcher interface\n    @Override\n    public void process(WatchedEvent event) {\n      // session events are not change events, and do not remove the watcher\n      if (EventType.None.equals(event.getType())) {\n        return;\n      }\n      try {\n        LOG.debug(\"Aliases: updating\");\n\n        // re-register the watch\n        Stat stat = new Stat();\n        final byte[] data = zkClient.getData(ALIASES, this, stat, true);\n        // note: it'd be nice to avoid possibly needlessly parsing if we don't update aliases but not a big deal\n        setIfNewer(Aliases.fromJSON(data, stat.getVersion()));\n      } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n        // note: aliases.json is required to be present\n        LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        LOG.error(\"A ZK error has occurred\", e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        LOG.warn(\"Interrupted\", e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.AliasesManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.AliasesManager#process(WatchedEvent).mjava","sourceNew":"    // ZK Watcher interface\n    @Override\n    public void process(WatchedEvent event) {\n      // session events are not change events, and do not remove the watcher\n      if (EventType.None.equals(event.getType())) {\n        return;\n      }\n      try {\n        log.debug(\"Aliases: updating\");\n\n        // re-register the watch\n        Stat stat = new Stat();\n        final byte[] data = zkClient.getData(ALIASES, this, stat, true);\n        // note: it'd be nice to avoid possibly needlessly parsing if we don't update aliases but not a big deal\n        setIfNewer(Aliases.fromJSON(data, stat.getVersion()));\n      } catch (NoNodeException e) {\n        // /aliases.json will not always exist\n      } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n        // note: aliases.json is required to be present\n        log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        log.error(\"A ZK error has occurred\", e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"Interrupted\", e);\n      }\n    }\n\n","sourceOld":"    // ZK Watcher interface\n    @Override\n    public void process(WatchedEvent event) {\n      // session events are not change events, and do not remove the watcher\n      if (EventType.None.equals(event.getType())) {\n        return;\n      }\n      try {\n        log.debug(\"Aliases: updating\");\n\n        // re-register the watch\n        Stat stat = new Stat();\n        final byte[] data = zkClient.getData(ALIASES, this, stat, true);\n        // note: it'd be nice to avoid possibly needlessly parsing if we don't update aliases but not a big deal\n        setIfNewer(Aliases.fromJSON(data, stat.getVersion()));\n      } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n        // note: aliases.json is required to be present\n        log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        log.error(\"A ZK error has occurred\", e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"Interrupted\", e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c238f5fb83803b49b37b3a1a12224a64d47542","date":1593655679,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.AliasesManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.AliasesManager#process(WatchedEvent).mjava","sourceNew":"    // ZK Watcher interface\n    @Override\n    public void process(WatchedEvent event) {\n      // session events are not change events, and do not remove the watcher\n      if (EventType.None.equals(event.getType())) {\n        return;\n      }\n      try {\n        log.debug(\"Aliases: updating\");\n\n        // re-register the watch\n        Stat stat = new Stat();\n        final byte[] data = zkClient.getData(ALIASES, this, stat, true);\n        // note: it'd be nice to avoid possibly needlessly parsing if we don't update aliases but not a big deal\n        setIfNewer(Aliases.fromJSON(data, stat.getVersion()));\n      } catch (NoNodeException e) {\n        // /aliases.json will not always exist\n      } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n        // note: aliases.json is required to be present\n        log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: \", e);\n      } catch (KeeperException e) {\n        log.error(\"A ZK error has occurred\", e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"Interrupted\", e);\n      }\n    }\n\n","sourceOld":"    // ZK Watcher interface\n    @Override\n    public void process(WatchedEvent event) {\n      // session events are not change events, and do not remove the watcher\n      if (EventType.None.equals(event.getType())) {\n        return;\n      }\n      try {\n        log.debug(\"Aliases: updating\");\n\n        // re-register the watch\n        Stat stat = new Stat();\n        final byte[] data = zkClient.getData(ALIASES, this, stat, true);\n        // note: it'd be nice to avoid possibly needlessly parsing if we don't update aliases but not a big deal\n        setIfNewer(Aliases.fromJSON(data, stat.getVersion()));\n      } catch (NoNodeException e) {\n        // /aliases.json will not always exist\n      } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n        // note: aliases.json is required to be present\n        log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n      } catch (KeeperException e) {\n        log.error(\"A ZK error has occurred\", e);\n        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        log.warn(\"Interrupted\", e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fe736fc2dca4bb2af36fa478366c29db9e31a1f9":["215e40821821b2df2e69355e208532c05ef095a5","d3de3780a0f74036499aad4df2a73159b14fbad2"],"d3de3780a0f74036499aad4df2a73159b14fbad2":["215e40821821b2df2e69355e208532c05ef095a5"],"215e40821821b2df2e69355e208532c05ef095a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["215e40821821b2df2e69355e208532c05ef095a5","fe736fc2dca4bb2af36fa478366c29db9e31a1f9"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"57c238f5fb83803b49b37b3a1a12224a64d47542":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["fe736fc2dca4bb2af36fa478366c29db9e31a1f9"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["215e40821821b2df2e69355e208532c05ef095a5","fe736fc2dca4bb2af36fa478366c29db9e31a1f9"]},"commit2Childs":{"fe736fc2dca4bb2af36fa478366c29db9e31a1f9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"d3de3780a0f74036499aad4df2a73159b14fbad2":["fe736fc2dca4bb2af36fa478366c29db9e31a1f9"],"215e40821821b2df2e69355e208532c05ef095a5":["fe736fc2dca4bb2af36fa478366c29db9e31a1f9","d3de3780a0f74036499aad4df2a73159b14fbad2","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["215e40821821b2df2e69355e208532c05ef095a5"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}