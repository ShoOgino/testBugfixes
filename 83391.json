{"path":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","commits":[{"id":"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce","date":1297021734,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":1,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n\n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n\n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n\n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n\n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n\n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n\n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n\n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n\n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n\n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n\n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"068303c7eefa006e42a6e790e1e51b5d26ffa02f","date":1311518223,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      \n      initRandom();\n      Random r = new Random(random.nextLong());\n\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n\n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n\n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      // sort the test methods first before shuffling them, so that the shuffle is consistent\n      // across different implementations that might order the methods different originally.\n      Collections.sort(testMethods, new Comparator<FrameworkMethod>() {\n        @Override\n        public int compare(FrameworkMethod f1, FrameworkMethod f2) {\n          return f1.getName().compareTo(f2.getName());\n        }\n      });\n      Collections.shuffle(testMethods, r);\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n\n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n\n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":["b88f145033cba453c8f65cc86eb444c625ee86c0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b88f145033cba453c8f65cc86eb444c625ee86c0","date":1312803337,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      \n      Random r = new Random(runnerSeed);\n\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n\n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n\n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      // sort the test methods first before shuffling them, so that the shuffle is consistent\n      // across different implementations that might order the methods different originally.\n      Collections.sort(testMethods, new Comparator<FrameworkMethod>() {\n        @Override\n        public int compare(FrameworkMethod f1, FrameworkMethod f2) {\n          return f1.getName().compareTo(f2.getName());\n        }\n      });\n      Collections.shuffle(testMethods, r);\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      \n      initRandom();\n      Random r = new Random(random.nextLong());\n\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n\n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n\n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      // sort the test methods first before shuffling them, so that the shuffle is consistent\n      // across different implementations that might order the methods different originally.\n      Collections.sort(testMethods, new Comparator<FrameworkMethod>() {\n        @Override\n        public int compare(FrameworkMethod f1, FrameworkMethod f2) {\n          return f1.getName().compareTo(f2.getName());\n        }\n      });\n      Collections.shuffle(testMethods, r);\n      return testMethods;\n    }\n\n","bugFix":["068303c7eefa006e42a6e790e1e51b5d26ffa02f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb2037f0b6c95cf65a182dc85883bca429889705","date":1314326112,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":null,"sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      \n      Random r = new Random(runnerSeed);\n\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n\n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n\n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      // sort the test methods first before shuffling them, so that the shuffle is consistent\n      // across different implementations that might order the methods different originally.\n      Collections.sort(testMethods, new Comparator<FrameworkMethod>() {\n        @Override\n        public int compare(FrameworkMethod f1, FrameworkMethod f2) {\n          return f1.getName().compareTo(f2.getName());\n        }\n      });\n      Collections.shuffle(testMethods, r);\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"068303c7eefa006e42a6e790e1e51b5d26ffa02f":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"a3776dccca01c11e7046323cfad46a3b4a471233":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["29ef99d61cda9641b6250bf9567329a6e65f901d","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"eb2037f0b6c95cf65a182dc85883bca429889705":["b88f145033cba453c8f65cc86eb444c625ee86c0"],"b88f145033cba453c8f65cc86eb444c625ee86c0":["068303c7eefa006e42a6e790e1e51b5d26ffa02f"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["eb2037f0b6c95cf65a182dc85883bca429889705"],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"068303c7eefa006e42a6e790e1e51b5d26ffa02f":["b88f145033cba453c8f65cc86eb444c625ee86c0"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"29ef99d61cda9641b6250bf9567329a6e65f901d":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":[],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["068303c7eefa006e42a6e790e1e51b5d26ffa02f","a3776dccca01c11e7046323cfad46a3b4a471233","135621f3a0670a9394eb563224a3b76cc4dddc0f"],"eb2037f0b6c95cf65a182dc85883bca429889705":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b88f145033cba453c8f65cc86eb444c625ee86c0":["eb2037f0b6c95cf65a182dc85883bca429889705"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["a3776dccca01c11e7046323cfad46a3b4a471233","29ef99d61cda9641b6250bf9567329a6e65f901d","b3e06be49006ecac364d39d12b9c9f74882f9b9f","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a3776dccca01c11e7046323cfad46a3b4a471233","135621f3a0670a9394eb563224a3b76cc4dddc0f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}