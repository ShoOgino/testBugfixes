{"path":"contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageQuery#entryQuery(List[String],String,ExtensionProfile).mjava","commits":[{"id":"5d43e216d757e2276d180eba8a192e300c4bfadb","date":1149717385,"type":0,"author":"Doug Cutting","isMerge":false,"pathNew":"contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageQuery#entryQuery(List[String],String,ExtensionProfile).mjava","pathOld":"/dev/null","sourceNew":"    /** \n     * Fetches the requested entries from the storage. The given list contains \n     * entry ids to be looked up in the storage. First the {@link StorageBuffer} \n     * will be queried for the entry ids. If not all of the entries remain in \n     * the buffer the underlaying lucene index will be searched. The entries are \n     * not guaranteed to be in the same order as they are in the given id list. \n     * Entry ID's not found in the index or the buffer will be omitted. \n     * <p> \n     * The entries will be searched in a feed context specified by the given \n     * feed ID \n     * </p> \n     *  \n     * @param entryIds - \n     *            the entriy ids to fetch. \n     * @param feedId - \n     *            the feed id eg. feed context. \n     * @param profil - \n     *            the extension profile used to create the entry instances. \n     * @return - the list of entries corresponding to the given entry id list. \n     * @throws IOException - \n     *             if the index could not be queries or the entries could not be \n     *             build \n     * @throws FeedNotFoundException - \n     *             if the requested feed is not registered \n     * @throws ParseException - \n     *             if an entry could not be parsed while building it from the \n     *             Lucene Document. \n     */ \n    public List<BaseEntry> entryQuery(List<String> entryIds, \n            final String feedId, final ExtensionProfile profil) \n            throws IOException, FeedNotFoundException, ParseException { \n        List<BaseEntry> resultList = new ArrayList<BaseEntry>(entryIds.size()); \n        List<String> searchList = new ArrayList<String>(entryIds.size()); \n        for (String entry : entryIds) { \n \n            StorageEntryWrapper bufferedEntry = this.buffer.getEntry(entry, \n                    feedId); \n            if (bufferedEntry != null) { \n                resultList.add(bufferedEntry.getEntry()); \n            } else \n                searchList.add(entry); \n        } \n        if (searchList.isEmpty()) \n            return resultList; \n \n        Hits hits = storageQuery(searchList); \n        Iterator hitIterator = hits.iterator(); \n        while (hitIterator.hasNext()) { \n            Hit hit = (Hit) hitIterator.next(); \n            Document doc = hit.getDocument(); \n            BaseEntry entry = buildEntryFromLuceneDocument(doc, profil); \n            resultList.add(entry); \n \n        } \n \n        return resultList; \n \n    } \n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"52754a40a1550056d5637c8992b4076b5ed77328","date":1151345693,"type":5,"author":"Yonik Seeley","isMerge":false,"pathNew":"contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageQuery#entryQuery(List[String],String,ProvidedService).mjava","pathOld":"contrib/gdata-server/src/java/org/apache/lucene/gdata/storage/lucenestorage/StorageQuery#entryQuery(List[String],String,ExtensionProfile).mjava","sourceNew":"    /**\n     * Fetches the requested entries from the storage. The given list contains\n     * entry ids to be looked up in the storage. First the {@link StorageBuffer}\n     * will be queried for the entry ids. If not all of the entries remain in\n     * the buffer the underlaying lucene index will be searched. The entries are\n     * not guaranteed to be in the same order as they are in the given id list.\n     * Entry ID's not found in the index or the buffer will be omitted.\n     * <p>\n     * The entries will be searched in a feed context specified by the given\n     * feed ID\n     * </p>\n     * \n     * @param entryIds -\n     *            the entriy ids to fetch.\n     * @param feedId -\n     *            the feed id eg. feed context.\n     * @param config -\n     *            the FeedInstanceConfiguration contaning extension profile used\n     *            to create the entriy instances\n     * \n     * @return - the list of entries corresponding to the given entry id list.\n     * @throws IOException -\n     *             if the index could not be queries or the entries could not be\n     *             build\n     * @throws ParseException -\n     *             if an entry could not be parsed while building it from the\n     *             Lucene Document.\n     */\n    public List<BaseEntry> entryQuery(List<String> entryIds,\n            final String feedId, final ProvidedService config)\n            throws IOException, ParseException {\n        List<BaseEntry> resultList = new ArrayList<BaseEntry>(entryIds.size());\n        List<String> searchList = new ArrayList<String>(entryIds.size());\n        for (String entry : entryIds) {\n\n            StorageEntryWrapper bufferedEntry = this.buffer.getEntry(entry,\n                    feedId);\n            if (bufferedEntry != null) {\n                resultList.add(bufferedEntry.getEntry());\n            } else\n                searchList.add(entry);\n        }\n        if (searchList.isEmpty())\n            return resultList;\n\n        Hits hits = storageQuery(searchList);\n        Iterator hitIterator = hits.iterator();\n        while (hitIterator.hasNext()) {\n            Hit hit = (Hit) hitIterator.next();\n            Document doc = hit.getDocument();\n            BaseEntry entry = buildEntryFromLuceneDocument(doc, config);\n            resultList.add(entry);\n\n        }\n\n        return resultList;\n\n    }\n\n","sourceOld":"    /** \n     * Fetches the requested entries from the storage. The given list contains \n     * entry ids to be looked up in the storage. First the {@link StorageBuffer} \n     * will be queried for the entry ids. If not all of the entries remain in \n     * the buffer the underlaying lucene index will be searched. The entries are \n     * not guaranteed to be in the same order as they are in the given id list. \n     * Entry ID's not found in the index or the buffer will be omitted. \n     * <p> \n     * The entries will be searched in a feed context specified by the given \n     * feed ID \n     * </p> \n     *  \n     * @param entryIds - \n     *            the entriy ids to fetch. \n     * @param feedId - \n     *            the feed id eg. feed context. \n     * @param profil - \n     *            the extension profile used to create the entry instances. \n     * @return - the list of entries corresponding to the given entry id list. \n     * @throws IOException - \n     *             if the index could not be queries or the entries could not be \n     *             build \n     * @throws FeedNotFoundException - \n     *             if the requested feed is not registered \n     * @throws ParseException - \n     *             if an entry could not be parsed while building it from the \n     *             Lucene Document. \n     */ \n    public List<BaseEntry> entryQuery(List<String> entryIds, \n            final String feedId, final ExtensionProfile profil) \n            throws IOException, FeedNotFoundException, ParseException { \n        List<BaseEntry> resultList = new ArrayList<BaseEntry>(entryIds.size()); \n        List<String> searchList = new ArrayList<String>(entryIds.size()); \n        for (String entry : entryIds) { \n \n            StorageEntryWrapper bufferedEntry = this.buffer.getEntry(entry, \n                    feedId); \n            if (bufferedEntry != null) { \n                resultList.add(bufferedEntry.getEntry()); \n            } else \n                searchList.add(entry); \n        } \n        if (searchList.isEmpty()) \n            return resultList; \n \n        Hits hits = storageQuery(searchList); \n        Iterator hitIterator = hits.iterator(); \n        while (hitIterator.hasNext()) { \n            Hit hit = (Hit) hitIterator.next(); \n            Document doc = hit.getDocument(); \n            BaseEntry entry = buildEntryFromLuceneDocument(doc, profil); \n            resultList.add(entry); \n \n        } \n \n        return resultList; \n \n    } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5d43e216d757e2276d180eba8a192e300c4bfadb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["52754a40a1550056d5637c8992b4076b5ed77328"],"52754a40a1550056d5637c8992b4076b5ed77328":["5d43e216d757e2276d180eba8a192e300c4bfadb"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5d43e216d757e2276d180eba8a192e300c4bfadb"],"5d43e216d757e2276d180eba8a192e300c4bfadb":["52754a40a1550056d5637c8992b4076b5ed77328"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"52754a40a1550056d5637c8992b4076b5ed77328":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}