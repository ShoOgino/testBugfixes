{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","commits":[{"id":"f492fe129985750df09c8dac738aecc503158bb3","date":1464099630,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","pathOld":"/dev/null","sourceNew":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    // nocommit use RandomIndexWriter\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n    final IndexWriter w = new IndexWriter(dir, iwc);\n    final int numThreads = TestUtil.nextInt(random(), 2, 5);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n    final AtomicInteger opsSinceCommit = new AtomicInteger();\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    // nocommit why does this sometimes fail :)\n                    //if (w.hasUncommittedChanges()) {\n                    if (opsSinceCommit.get() > numThreads) {\n                      op.seqNo = w.commit();\n                      commits.add(op);\n                      opsSinceCommit.set(0);\n                    }\n                    //System.out.println(\"done commit seqNo=\" + op.seqNo);\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    op.seqNo = w.deleteDocuments(idTerm);\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    op.seqNo = w.updateDocument(idTerm, doc);\n                    op.what = 2;\n                  }\n                  ops.add(op);\n                  opsSinceCommit.getAndIncrement();\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    synchronized(commitLock) {\n      commitOp.seqNo = w.commit();\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 2) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo >= lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f6df47cbfd656ea50ca2996361f7954531ee18b","date":1464133540,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","sourceNew":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    // nocommit use RandomIndexWriter\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n    final IndexWriter w = new IndexWriter(dir, iwc);\n    final int numThreads = TestUtil.nextInt(random(), 2, 5);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    if (w.hasUncommittedChanges()) {\n                      op.seqNo = w.commit();\n                      commits.add(op);\n                    }\n                    //System.out.println(\"done commit seqNo=\" + op.seqNo);\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 2;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    /*\n    // nocommit: why does this make the assertEquals angry...?\n    if (w.hasUncommittedChanges()) {\n      Operation commitOp = new Operation();\n      commitOp.seqNo = w.commit();\n      commits.add(commitOp);\n    }\n    */\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 2) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo >= lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    // nocommit use RandomIndexWriter\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n    final IndexWriter w = new IndexWriter(dir, iwc);\n    final int numThreads = TestUtil.nextInt(random(), 2, 5);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n    final AtomicInteger opsSinceCommit = new AtomicInteger();\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    // nocommit why does this sometimes fail :)\n                    //if (w.hasUncommittedChanges()) {\n                    if (opsSinceCommit.get() > numThreads) {\n                      op.seqNo = w.commit();\n                      commits.add(op);\n                      opsSinceCommit.set(0);\n                    }\n                    //System.out.println(\"done commit seqNo=\" + op.seqNo);\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    op.seqNo = w.deleteDocuments(idTerm);\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    op.seqNo = w.updateDocument(idTerm, doc);\n                    op.what = 2;\n                  }\n                  ops.add(op);\n                  opsSinceCommit.getAndIncrement();\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    synchronized(commitLock) {\n      commitOp.seqNo = w.commit();\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 2) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo >= lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9972d96003bc59c07a44e73de3cdd505dc08fd17","date":1464216081,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","sourceNew":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 5);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 2;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 2) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo >= lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    // nocommit use RandomIndexWriter\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n    final IndexWriter w = new IndexWriter(dir, iwc);\n    final int numThreads = TestUtil.nextInt(random(), 2, 5);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    if (w.hasUncommittedChanges()) {\n                      op.seqNo = w.commit();\n                      commits.add(op);\n                    }\n                    //System.out.println(\"done commit seqNo=\" + op.seqNo);\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 2;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    /*\n    // nocommit: why does this make the assertEquals angry...?\n    if (w.hasUncommittedChanges()) {\n      Operation commitOp = new Operation();\n      commitOp.seqNo = w.commit();\n      commits.add(commitOp);\n    }\n    */\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 2) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo >= lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16ebfabc294f23b88b6a39722a02c9d39b353195","date":1464343867,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","sourceNew":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 5);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 2;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 2) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 5);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 2;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 2) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo >= lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"122251c49e5a9fa95f056ea257ae3ab452099fc7","date":1464820065,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","sourceNew":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 2;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 2) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 5);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 2;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 2) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"00ec2a9d45723405cf333adce768d97877bc24a6","date":1464821414,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","sourceNew":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 2;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 2) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","date":1464821470,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","sourceNew":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 5);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 2;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 2) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19d35c01593b75b98b751866e41b1b24983ff42e","date":1464861489,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","sourceNew":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6483e4260c08168709c02238ae083a51519a28dd","date":1465117546,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","pathOld":"/dev/null","sourceNew":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"191128ac5b85671b1671e2c857437694283b6ebf","date":1465297861,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","pathOld":"/dev/null","sourceNew":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9dea8da13fd1a227ae1071e8f4ce66bff42174de","date":1471439735,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","sourceNew":"  @Slow\n  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","date":1471496851,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","sourceNew":"  @Slow\n  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","sourceNew":"  @Slow\n  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","pathOld":"/dev/null","sourceNew":"  @Slow\n  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","sourceNew":"  @Slow\n  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits.value);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits.value != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits.value + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits.value);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  @Slow\n  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f","date":1579652839,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentCommit().mjava","sourceNew":"  @Nightly\n  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits.value);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits.value != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits.value + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits.value);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  @Slow\n  public void testStressConcurrentCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops = new ArrayList<>();\n      threadOps.add(ops);\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  if (random().nextInt(10) == 1) {\n                    op.what = 1;\n                    if (random().nextBoolean()) {\n                      op.seqNo = w.deleteDocuments(idTerm);\n                    } else {\n                      op.seqNo = w.deleteDocuments(new TermQuery(idTerm));\n                    }\n                  } else {\n                    Document doc = new Document();\n                    doc.add(new StoredField(\"thread\", threadID));\n                    doc.add(new StringField(\"id\", \"\" + op.id, Field.Store.NO));\n                    if (random().nextBoolean()) {\n                      List<Document> docs = new ArrayList<>();\n                      docs.add(doc);\n                      op.seqNo = w.updateDocuments(idTerm, docs);\n                    } else {\n                      op.seqNo = w.updateDocument(idTerm, doc);\n                    }\n                    op.what = 0;\n                  }\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            } else {\n              expectedThreadIDs[op.id] = -1;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits.value);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          int actualThreadID = doc.getField(\"thread\").numericValue().intValue();\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits.value != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits.value + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits.value);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"00ec2a9d45723405cf333adce768d97877bc24a6":["122251c49e5a9fa95f056ea257ae3ab452099fc7"],"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["191128ac5b85671b1671e2c857437694283b6ebf","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"6483e4260c08168709c02238ae083a51519a28dd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","19d35c01593b75b98b751866e41b1b24983ff42e"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["191128ac5b85671b1671e2c857437694283b6ebf","9dea8da13fd1a227ae1071e8f4ce66bff42174de"],"191128ac5b85671b1671e2c857437694283b6ebf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6483e4260c08168709c02238ae083a51519a28dd"],"9dea8da13fd1a227ae1071e8f4ce66bff42174de":["191128ac5b85671b1671e2c857437694283b6ebf"],"16ebfabc294f23b88b6a39722a02c9d39b353195":["9972d96003bc59c07a44e73de3cdd505dc08fd17"],"19d35c01593b75b98b751866e41b1b24983ff42e":["b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":["16ebfabc294f23b88b6a39722a02c9d39b353195","00ec2a9d45723405cf333adce768d97877bc24a6"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","403d05f7f8d69b65659157eff1bc1d2717f04c66"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f492fe129985750df09c8dac738aecc503158bb3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"9972d96003bc59c07a44e73de3cdd505dc08fd17":["0f6df47cbfd656ea50ca2996361f7954531ee18b"],"0f6df47cbfd656ea50ca2996361f7954531ee18b":["f492fe129985750df09c8dac738aecc503158bb3"],"122251c49e5a9fa95f056ea257ae3ab452099fc7":["16ebfabc294f23b88b6a39722a02c9d39b353195"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"]},"commit2Childs":{"00ec2a9d45723405cf333adce768d97877bc24a6":["b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","83788ad129a5154d5c6562c4e8ce3db48793aada"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"6483e4260c08168709c02238ae083a51519a28dd":["191128ac5b85671b1671e2c857437694283b6ebf"],"191128ac5b85671b1671e2c857437694283b6ebf":["403d05f7f8d69b65659157eff1bc1d2717f04c66","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","9dea8da13fd1a227ae1071e8f4ce66bff42174de"],"9dea8da13fd1a227ae1071e8f4ce66bff42174de":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"16ebfabc294f23b88b6a39722a02c9d39b353195":["b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","122251c49e5a9fa95f056ea257ae3ab452099fc7"],"19d35c01593b75b98b751866e41b1b24983ff42e":["6483e4260c08168709c02238ae083a51519a28dd"],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":["19d35c01593b75b98b751866e41b1b24983ff42e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6483e4260c08168709c02238ae083a51519a28dd","191128ac5b85671b1671e2c857437694283b6ebf","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","f492fe129985750df09c8dac738aecc503158bb3"],"f492fe129985750df09c8dac738aecc503158bb3":["0f6df47cbfd656ea50ca2996361f7954531ee18b"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"],"9972d96003bc59c07a44e73de3cdd505dc08fd17":["16ebfabc294f23b88b6a39722a02c9d39b353195"],"0f6df47cbfd656ea50ca2996361f7954531ee18b":["9972d96003bc59c07a44e73de3cdd505dc08fd17"],"122251c49e5a9fa95f056ea257ae3ab452099fc7":["00ec2a9d45723405cf333adce768d97877bc24a6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}