{"path":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#initDeleteExpiredDocsScheduler(SolrCore).mjava","commits":[{"id":"ca70fffb953aae4d27efbfc28758033a317f39b1","date":1396371342,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#initDeleteExpiredDocsScheduler(SolrCore).mjava","pathOld":"/dev/null","sourceNew":"  private void initDeleteExpiredDocsScheduler(SolrCore core) {\n    executor = new ScheduledThreadPoolExecutor\n      (1, new DefaultSolrThreadFactory(\"autoExpireDocs\"),\n       new RejectedExecutionHandler() {\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n          log.warn(\"Skipping execution of '{}' using '{}'\", r, e);\n        }\n      });\n\n    core.addCloseHook(new CloseHook() {\n      public void postClose(SolrCore core) {\n        // update handler is gone, hard terminiate anything that's left.\n\n        if (executor.isTerminating()) {\n          log.info(\"Triggering hard shutdown of DocExpiration Executor\");\n          executor.shutdownNow();\n        }\n      }\n      public void preClose(SolrCore core) {\n        log.info(\"Triggering Graceful shutdown of DocExpiration Executor\");\n        executor.shutdown();\n      }\n    });\n\n    executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    executor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n    // we don't want this firing right away, since the core may not be ready\n    final long initialDelay = deletePeriodSeconds;\n    // TODO: should we make initialDelay configurable\n    // TODO: should we make initialDelay some fraction of the period?\n    executor.scheduleAtFixedRate(new DeleteExpiredDocsRunnable(this), \n                                 deletePeriodSeconds,\n                                 deletePeriodSeconds,\n                                 TimeUnit.SECONDS);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#initDeleteExpiredDocsScheduler(SolrCore).mjava","pathOld":"/dev/null","sourceNew":"  private void initDeleteExpiredDocsScheduler(SolrCore core) {\n    executor = new ScheduledThreadPoolExecutor\n      (1, new DefaultSolrThreadFactory(\"autoExpireDocs\"),\n       new RejectedExecutionHandler() {\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n          log.warn(\"Skipping execution of '{}' using '{}'\", r, e);\n        }\n      });\n\n    core.addCloseHook(new CloseHook() {\n      public void postClose(SolrCore core) {\n        // update handler is gone, hard terminiate anything that's left.\n\n        if (executor.isTerminating()) {\n          log.info(\"Triggering hard shutdown of DocExpiration Executor\");\n          executor.shutdownNow();\n        }\n      }\n      public void preClose(SolrCore core) {\n        log.info(\"Triggering Graceful shutdown of DocExpiration Executor\");\n        executor.shutdown();\n      }\n    });\n\n    executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    executor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n    // we don't want this firing right away, since the core may not be ready\n    final long initialDelay = deletePeriodSeconds;\n    // TODO: should we make initialDelay configurable\n    // TODO: should we make initialDelay some fraction of the period?\n    executor.scheduleAtFixedRate(new DeleteExpiredDocsRunnable(this), \n                                 deletePeriodSeconds,\n                                 deletePeriodSeconds,\n                                 TimeUnit.SECONDS);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#initDeleteExpiredDocsScheduler(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#initDeleteExpiredDocsScheduler(SolrCore).mjava","sourceNew":"  private void initDeleteExpiredDocsScheduler(SolrCore core) {\n    executor = new ScheduledThreadPoolExecutor\n      (1, new DefaultSolrThreadFactory(\"autoExpireDocs\"),\n       new RejectedExecutionHandler() {\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n          log.warn(\"Skipping execution of '{}' using '{}'\", r, e);\n        }\n      });\n\n    core.addCloseHook(new CloseHook() {\n      public void postClose(SolrCore core) {\n        // update handler is gone, hard terminiate anything that's left.\n\n        if (executor.isTerminating()) {\n          log.info(\"Triggering hard close of DocExpiration Executor\");\n          executor.shutdownNow();\n        }\n      }\n      public void preClose(SolrCore core) {\n        log.info(\"Triggering Graceful close of DocExpiration Executor\");\n        executor.shutdown();\n      }\n    });\n\n    executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    executor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n    // we don't want this firing right away, since the core may not be ready\n    final long initialDelay = deletePeriodSeconds;\n    // TODO: should we make initialDelay configurable\n    // TODO: should we make initialDelay some fraction of the period?\n    executor.scheduleAtFixedRate(new DeleteExpiredDocsRunnable(this), \n                                 deletePeriodSeconds,\n                                 deletePeriodSeconds,\n                                 TimeUnit.SECONDS);\n\n  }\n\n","sourceOld":"  private void initDeleteExpiredDocsScheduler(SolrCore core) {\n    executor = new ScheduledThreadPoolExecutor\n      (1, new DefaultSolrThreadFactory(\"autoExpireDocs\"),\n       new RejectedExecutionHandler() {\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n          log.warn(\"Skipping execution of '{}' using '{}'\", r, e);\n        }\n      });\n\n    core.addCloseHook(new CloseHook() {\n      public void postClose(SolrCore core) {\n        // update handler is gone, hard terminiate anything that's left.\n\n        if (executor.isTerminating()) {\n          log.info(\"Triggering hard shutdown of DocExpiration Executor\");\n          executor.shutdownNow();\n        }\n      }\n      public void preClose(SolrCore core) {\n        log.info(\"Triggering Graceful shutdown of DocExpiration Executor\");\n        executor.shutdown();\n      }\n    });\n\n    executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    executor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n    // we don't want this firing right away, since the core may not be ready\n    final long initialDelay = deletePeriodSeconds;\n    // TODO: should we make initialDelay configurable\n    // TODO: should we make initialDelay some fraction of the period?\n    executor.scheduleAtFixedRate(new DeleteExpiredDocsRunnable(this), \n                                 deletePeriodSeconds,\n                                 deletePeriodSeconds,\n                                 TimeUnit.SECONDS);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70d61fdc6a5871f80a74c0e2e55bb8a94e9ac59d","date":1440987729,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#initDeleteExpiredDocsScheduler(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#initDeleteExpiredDocsScheduler(SolrCore).mjava","sourceNew":"  private void initDeleteExpiredDocsScheduler(SolrCore core) {\n    executor = new ScheduledThreadPoolExecutor\n      (1, new DefaultSolrThreadFactory(\"autoExpireDocs\"),\n       new RejectedExecutionHandler() {\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n          log.warn(\"Skipping execution of '{}' using '{}'\", r, e);\n        }\n      });\n\n    core.addCloseHook(new CloseHook() {\n      public void postClose(SolrCore core) {\n        // update handler is gone, terminate anything that's left.\n\n        if (executor.isTerminating()) {\n          log.info(\"Waiting for close of DocExpiration Executor\");\n          ExecutorUtil.shutdownAndAwaitTermination(executor);\n        }\n      }\n      public void preClose(SolrCore core) {\n        log.info(\"Triggering Graceful close of DocExpiration Executor\");\n        executor.shutdown();\n      }\n    });\n\n    executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    executor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n    // we don't want this firing right away, since the core may not be ready\n    final long initialDelay = deletePeriodSeconds;\n    // TODO: should we make initialDelay configurable\n    // TODO: should we make initialDelay some fraction of the period?\n    executor.scheduleAtFixedRate(new DeleteExpiredDocsRunnable(this), \n                                 deletePeriodSeconds,\n                                 deletePeriodSeconds,\n                                 TimeUnit.SECONDS);\n\n  }\n\n","sourceOld":"  private void initDeleteExpiredDocsScheduler(SolrCore core) {\n    executor = new ScheduledThreadPoolExecutor\n      (1, new DefaultSolrThreadFactory(\"autoExpireDocs\"),\n       new RejectedExecutionHandler() {\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n          log.warn(\"Skipping execution of '{}' using '{}'\", r, e);\n        }\n      });\n\n    core.addCloseHook(new CloseHook() {\n      public void postClose(SolrCore core) {\n        // update handler is gone, hard terminiate anything that's left.\n\n        if (executor.isTerminating()) {\n          log.info(\"Triggering hard close of DocExpiration Executor\");\n          executor.shutdownNow();\n        }\n      }\n      public void preClose(SolrCore core) {\n        log.info(\"Triggering Graceful close of DocExpiration Executor\");\n        executor.shutdown();\n      }\n    });\n\n    executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    executor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n    // we don't want this firing right away, since the core may not be ready\n    final long initialDelay = deletePeriodSeconds;\n    // TODO: should we make initialDelay configurable\n    // TODO: should we make initialDelay some fraction of the period?\n    executor.scheduleAtFixedRate(new DeleteExpiredDocsRunnable(this), \n                                 deletePeriodSeconds,\n                                 deletePeriodSeconds,\n                                 TimeUnit.SECONDS);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#initDeleteExpiredDocsScheduler(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory#initDeleteExpiredDocsScheduler(SolrCore).mjava","sourceNew":"  private void initDeleteExpiredDocsScheduler(SolrCore core) {\n    executor = new ScheduledThreadPoolExecutor\n      (1, new SolrNamedThreadFactory(\"autoExpireDocs\"),\n       new RejectedExecutionHandler() {\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n          log.warn(\"Skipping execution of '{}' using '{}'\", r, e);\n        }\n      });\n\n    core.addCloseHook(new CloseHook() {\n      public void postClose(SolrCore core) {\n        // update handler is gone, terminate anything that's left.\n\n        if (executor.isTerminating()) {\n          log.info(\"Waiting for close of DocExpiration Executor\");\n          ExecutorUtil.shutdownAndAwaitTermination(executor);\n        }\n      }\n      public void preClose(SolrCore core) {\n        log.info(\"Triggering Graceful close of DocExpiration Executor\");\n        executor.shutdown();\n      }\n    });\n\n    executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    executor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n    // we don't want this firing right away, since the core may not be ready\n    final long initialDelay = deletePeriodSeconds;\n    // TODO: should we make initialDelay configurable\n    // TODO: should we make initialDelay some fraction of the period?\n    executor.scheduleAtFixedRate(new DeleteExpiredDocsRunnable(this), \n                                 deletePeriodSeconds,\n                                 deletePeriodSeconds,\n                                 TimeUnit.SECONDS);\n\n  }\n\n","sourceOld":"  private void initDeleteExpiredDocsScheduler(SolrCore core) {\n    executor = new ScheduledThreadPoolExecutor\n      (1, new DefaultSolrThreadFactory(\"autoExpireDocs\"),\n       new RejectedExecutionHandler() {\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n          log.warn(\"Skipping execution of '{}' using '{}'\", r, e);\n        }\n      });\n\n    core.addCloseHook(new CloseHook() {\n      public void postClose(SolrCore core) {\n        // update handler is gone, terminate anything that's left.\n\n        if (executor.isTerminating()) {\n          log.info(\"Waiting for close of DocExpiration Executor\");\n          ExecutorUtil.shutdownAndAwaitTermination(executor);\n        }\n      }\n      public void preClose(SolrCore core) {\n        log.info(\"Triggering Graceful close of DocExpiration Executor\");\n        executor.shutdown();\n      }\n    });\n\n    executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    executor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n    // we don't want this firing right away, since the core may not be ready\n    final long initialDelay = deletePeriodSeconds;\n    // TODO: should we make initialDelay configurable\n    // TODO: should we make initialDelay some fraction of the period?\n    executor.scheduleAtFixedRate(new DeleteExpiredDocsRunnable(this), \n                                 deletePeriodSeconds,\n                                 deletePeriodSeconds,\n                                 TimeUnit.SECONDS);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ca70fffb953aae4d27efbfc28758033a317f39b1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["70d61fdc6a5871f80a74c0e2e55bb8a94e9ac59d"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["ca70fffb953aae4d27efbfc28758033a317f39b1"],"ca70fffb953aae4d27efbfc28758033a317f39b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"70d61fdc6a5871f80a74c0e2e55bb8a94e9ac59d":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5eb2511ababf862ea11e10761c70ee560cd84510","ca70fffb953aae4d27efbfc28758033a317f39b1"],"ca70fffb953aae4d27efbfc28758033a317f39b1":["5eb2511ababf862ea11e10761c70ee560cd84510","d0ef034a4f10871667ae75181537775ddcf8ade4"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["70d61fdc6a5871f80a74c0e2e55bb8a94e9ac59d"],"70d61fdc6a5871f80a74c0e2e55bb8a94e9ac59d":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}