{"path":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#doInPlaceUpdateMerge(AddUpdateCommand,Set[String]).mjava","commits":[{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#doInPlaceUpdateMerge(AddUpdateCommand,Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Given an AddUpdateCommand containing update operations (e.g. set, inc), merge and resolve the operations into\n   * a partial document that can be used for indexing the in-place updates. The AddUpdateCommand is modified to contain\n   * the partial document (instead of the original document which contained the update operations) and also\n   * the prevVersion that this in-place update depends on.\n   * Note: updatedFields passed into the method can be changed, i.e. the version field can be added to the set.\n   * @return If in-place update cannot succeed, e.g. if the old document is deleted recently, then false is returned. A false\n   *        return indicates that this update can be re-tried as a full atomic update. Returns true if the in-place update\n   *        succeeds.\n   */\n  public boolean doInPlaceUpdateMerge(AddUpdateCommand cmd, Set<String> updatedFields) throws IOException {\n    SolrInputDocument inputDoc = cmd.getSolrInputDocument();\n    BytesRef idBytes = cmd.getIndexedId();\n\n    updatedFields.add(DistributedUpdateProcessor.VERSION_FIELD); // add the version field so that it is fetched too\n    SolrInputDocument oldDocument = RealTimeGetComponent.getInputDocument\n      (cmd.getReq().getCore(), idBytes,\n       null, // don't want the version to be returned\n       true, // avoid stored fields from index\n       updatedFields,\n       true); // resolve the full document\n                                              \n    if (oldDocument == RealTimeGetComponent.DELETED || oldDocument == null) {\n      // This doc was deleted recently. In-place update cannot work, hence a full atomic update should be tried.\n      return false;\n    }\n\n    if (oldDocument.containsKey(DistributedUpdateProcessor.VERSION_FIELD) == false) {\n      throw new SolrException (ErrorCode.INVALID_STATE, \"There is no _version_ in previous document. id=\" + \n          cmd.getPrintableId());\n    }\n    Long oldVersion = (Long) oldDocument.remove(DistributedUpdateProcessor.VERSION_FIELD).getValue();\n\n    // If the oldDocument contains any other field apart from updatedFields (or id/version field), then remove them.\n    // This can happen, despite requesting for these fields in the call to RTGC.getInputDocument, if the document was\n    // fetched from the tlog and had all these fields (possibly because it was a full document ADD operation).\n    if (updatedFields != null) {\n      Collection<String> names = new HashSet<String>(oldDocument.getFieldNames());\n      for (String fieldName: names) {\n        if (fieldName.equals(DistributedUpdateProcessor.VERSION_FIELD)==false && fieldName.equals(\"id\")==false && updatedFields.contains(fieldName)==false) {\n          oldDocument.remove(fieldName);\n        }\n      }\n    }\n    // Copy over all supported DVs from oldDocument to partialDoc\n    //\n    // Assuming multiple updates to the same doc: field 'dv1' in one update, then field 'dv2' in a second\n    // update, and then again 'dv1' in a third update (without commits in between), the last update would\n    // fetch from the tlog the partial doc for the 2nd (dv2) update. If that doc doesn't copy over the\n    // previous updates to dv1 as well, then a full resolution (by following previous pointers) would\n    // need to be done to calculate the dv1 value -- so instead copy all the potentially affected DV fields.\n    SolrInputDocument partialDoc = new SolrInputDocument();\n    String uniqueKeyField = schema.getUniqueKeyField().getName();\n    for (String fieldName : oldDocument.getFieldNames()) {\n      SchemaField schemaField = schema.getField(fieldName);\n      if (fieldName.equals(uniqueKeyField) || isSupportedFieldForInPlaceUpdate(schemaField)) {\n        partialDoc.addField(fieldName, oldDocument.getFieldValue(fieldName));\n      }\n    }\n    \n    merge(inputDoc, partialDoc);\n\n    // Populate the id field if not already populated (this can happen since stored fields were avoided during fetch from RTGC)\n    if (!partialDoc.containsKey(schema.getUniqueKeyField().getName())) {\n      partialDoc.addField(idField.getName(), \n          inputDoc.getField(schema.getUniqueKeyField().getName()).getFirstValue());\n    }\n\n    cmd.prevVersion = oldVersion;\n    cmd.solrDoc = partialDoc;\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5b5fa3584550267bf4209f334513a9d5850dd1e0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#doInPlaceUpdateMerge(AddUpdateCommand,Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Given an AddUpdateCommand containing update operations (e.g. set, inc), merge and resolve the operations into\n   * a partial document that can be used for indexing the in-place updates. The AddUpdateCommand is modified to contain\n   * the partial document (instead of the original document which contained the update operations) and also\n   * the prevVersion that this in-place update depends on.\n   * Note: updatedFields passed into the method can be changed, i.e. the version field can be added to the set.\n   * @return If in-place update cannot succeed, e.g. if the old document is deleted recently, then false is returned. A false\n   *        return indicates that this update can be re-tried as a full atomic update. Returns true if the in-place update\n   *        succeeds.\n   */\n  public boolean doInPlaceUpdateMerge(AddUpdateCommand cmd, Set<String> updatedFields) throws IOException {\n    SolrInputDocument inputDoc = cmd.getSolrInputDocument();\n    BytesRef idBytes = cmd.getIndexedId();\n\n    updatedFields.add(DistributedUpdateProcessor.VERSION_FIELD); // add the version field so that it is fetched too\n    SolrInputDocument oldDocument = RealTimeGetComponent.getInputDocument\n      (cmd.getReq().getCore(), idBytes,\n       null, // don't want the version to be returned\n       true, // avoid stored fields from index\n       updatedFields,\n       true); // resolve the full document\n                                              \n    if (oldDocument == RealTimeGetComponent.DELETED || oldDocument == null) {\n      // This doc was deleted recently. In-place update cannot work, hence a full atomic update should be tried.\n      return false;\n    }\n\n    if (oldDocument.containsKey(DistributedUpdateProcessor.VERSION_FIELD) == false) {\n      throw new SolrException (ErrorCode.INVALID_STATE, \"There is no _version_ in previous document. id=\" + \n          cmd.getPrintableId());\n    }\n    Long oldVersion = (Long) oldDocument.remove(DistributedUpdateProcessor.VERSION_FIELD).getValue();\n\n    // If the oldDocument contains any other field apart from updatedFields (or id/version field), then remove them.\n    // This can happen, despite requesting for these fields in the call to RTGC.getInputDocument, if the document was\n    // fetched from the tlog and had all these fields (possibly because it was a full document ADD operation).\n    if (updatedFields != null) {\n      Collection<String> names = new HashSet<String>(oldDocument.getFieldNames());\n      for (String fieldName: names) {\n        if (fieldName.equals(DistributedUpdateProcessor.VERSION_FIELD)==false && fieldName.equals(\"id\")==false && updatedFields.contains(fieldName)==false) {\n          oldDocument.remove(fieldName);\n        }\n      }\n    }\n    // Copy over all supported DVs from oldDocument to partialDoc\n    //\n    // Assuming multiple updates to the same doc: field 'dv1' in one update, then field 'dv2' in a second\n    // update, and then again 'dv1' in a third update (without commits in between), the last update would\n    // fetch from the tlog the partial doc for the 2nd (dv2) update. If that doc doesn't copy over the\n    // previous updates to dv1 as well, then a full resolution (by following previous pointers) would\n    // need to be done to calculate the dv1 value -- so instead copy all the potentially affected DV fields.\n    SolrInputDocument partialDoc = new SolrInputDocument();\n    String uniqueKeyField = schema.getUniqueKeyField().getName();\n    for (String fieldName : oldDocument.getFieldNames()) {\n      SchemaField schemaField = schema.getField(fieldName);\n      if (fieldName.equals(uniqueKeyField) || isSupportedFieldForInPlaceUpdate(schemaField)) {\n        partialDoc.addField(fieldName, oldDocument.getFieldValue(fieldName));\n      }\n    }\n    \n    merge(inputDoc, partialDoc);\n\n    // Populate the id field if not already populated (this can happen since stored fields were avoided during fetch from RTGC)\n    if (!partialDoc.containsKey(schema.getUniqueKeyField().getName())) {\n      partialDoc.addField(idField.getName(), \n          inputDoc.getField(schema.getUniqueKeyField().getName()).getFirstValue());\n    }\n\n    cmd.prevVersion = oldVersion;\n    cmd.solrDoc = partialDoc;\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d2dadc1f5ca8703d8659f4964961f9967935d75","date":1490231750,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#doInPlaceUpdateMerge(AddUpdateCommand,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#doInPlaceUpdateMerge(AddUpdateCommand,Set[String]).mjava","sourceNew":"  /**\n   * Given an AddUpdateCommand containing update operations (e.g. set, inc), merge and resolve the operations into\n   * a partial document that can be used for indexing the in-place updates. The AddUpdateCommand is modified to contain\n   * the partial document (instead of the original document which contained the update operations) and also\n   * the prevVersion that this in-place update depends on.\n   * Note: updatedFields passed into the method can be changed, i.e. the version field can be added to the set.\n   * @return If in-place update cannot succeed, e.g. if the old document is deleted recently, then false is returned. A false\n   *        return indicates that this update can be re-tried as a full atomic update. Returns true if the in-place update\n   *        succeeds.\n   */\n  public boolean doInPlaceUpdateMerge(AddUpdateCommand cmd, Set<String> updatedFields) throws IOException {\n    SolrInputDocument inputDoc = cmd.getSolrInputDocument();\n    BytesRef idBytes = cmd.getIndexedId();\n\n    updatedFields.add(CommonParams.VERSION_FIELD); // add the version field so that it is fetched too\n    SolrInputDocument oldDocument = RealTimeGetComponent.getInputDocument\n      (cmd.getReq().getCore(), idBytes,\n       null, // don't want the version to be returned\n       true, // avoid stored fields from index\n       updatedFields,\n       true); // resolve the full document\n                                              \n    if (oldDocument == RealTimeGetComponent.DELETED || oldDocument == null) {\n      // This doc was deleted recently. In-place update cannot work, hence a full atomic update should be tried.\n      return false;\n    }\n\n    if (oldDocument.containsKey(CommonParams.VERSION_FIELD) == false) {\n      throw new SolrException (ErrorCode.INVALID_STATE, \"There is no _version_ in previous document. id=\" + \n          cmd.getPrintableId());\n    }\n    Long oldVersion = (Long) oldDocument.remove(CommonParams.VERSION_FIELD).getValue();\n\n    // If the oldDocument contains any other field apart from updatedFields (or id/version field), then remove them.\n    // This can happen, despite requesting for these fields in the call to RTGC.getInputDocument, if the document was\n    // fetched from the tlog and had all these fields (possibly because it was a full document ADD operation).\n    if (updatedFields != null) {\n      Collection<String> names = new HashSet<String>(oldDocument.getFieldNames());\n      for (String fieldName: names) {\n        if (fieldName.equals(CommonParams.VERSION_FIELD)==false && fieldName.equals(ID)==false && updatedFields.contains(fieldName)==false) {\n          oldDocument.remove(fieldName);\n        }\n      }\n    }\n    // Copy over all supported DVs from oldDocument to partialDoc\n    //\n    // Assuming multiple updates to the same doc: field 'dv1' in one update, then field 'dv2' in a second\n    // update, and then again 'dv1' in a third update (without commits in between), the last update would\n    // fetch from the tlog the partial doc for the 2nd (dv2) update. If that doc doesn't copy over the\n    // previous updates to dv1 as well, then a full resolution (by following previous pointers) would\n    // need to be done to calculate the dv1 value -- so instead copy all the potentially affected DV fields.\n    SolrInputDocument partialDoc = new SolrInputDocument();\n    String uniqueKeyField = schema.getUniqueKeyField().getName();\n    for (String fieldName : oldDocument.getFieldNames()) {\n      SchemaField schemaField = schema.getField(fieldName);\n      if (fieldName.equals(uniqueKeyField) || isSupportedFieldForInPlaceUpdate(schemaField)) {\n        partialDoc.addField(fieldName, oldDocument.getFieldValue(fieldName));\n      }\n    }\n    \n    merge(inputDoc, partialDoc);\n\n    // Populate the id field if not already populated (this can happen since stored fields were avoided during fetch from RTGC)\n    if (!partialDoc.containsKey(schema.getUniqueKeyField().getName())) {\n      partialDoc.addField(idField.getName(), \n          inputDoc.getField(schema.getUniqueKeyField().getName()).getFirstValue());\n    }\n\n    cmd.prevVersion = oldVersion;\n    cmd.solrDoc = partialDoc;\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Given an AddUpdateCommand containing update operations (e.g. set, inc), merge and resolve the operations into\n   * a partial document that can be used for indexing the in-place updates. The AddUpdateCommand is modified to contain\n   * the partial document (instead of the original document which contained the update operations) and also\n   * the prevVersion that this in-place update depends on.\n   * Note: updatedFields passed into the method can be changed, i.e. the version field can be added to the set.\n   * @return If in-place update cannot succeed, e.g. if the old document is deleted recently, then false is returned. A false\n   *        return indicates that this update can be re-tried as a full atomic update. Returns true if the in-place update\n   *        succeeds.\n   */\n  public boolean doInPlaceUpdateMerge(AddUpdateCommand cmd, Set<String> updatedFields) throws IOException {\n    SolrInputDocument inputDoc = cmd.getSolrInputDocument();\n    BytesRef idBytes = cmd.getIndexedId();\n\n    updatedFields.add(DistributedUpdateProcessor.VERSION_FIELD); // add the version field so that it is fetched too\n    SolrInputDocument oldDocument = RealTimeGetComponent.getInputDocument\n      (cmd.getReq().getCore(), idBytes,\n       null, // don't want the version to be returned\n       true, // avoid stored fields from index\n       updatedFields,\n       true); // resolve the full document\n                                              \n    if (oldDocument == RealTimeGetComponent.DELETED || oldDocument == null) {\n      // This doc was deleted recently. In-place update cannot work, hence a full atomic update should be tried.\n      return false;\n    }\n\n    if (oldDocument.containsKey(DistributedUpdateProcessor.VERSION_FIELD) == false) {\n      throw new SolrException (ErrorCode.INVALID_STATE, \"There is no _version_ in previous document. id=\" + \n          cmd.getPrintableId());\n    }\n    Long oldVersion = (Long) oldDocument.remove(DistributedUpdateProcessor.VERSION_FIELD).getValue();\n\n    // If the oldDocument contains any other field apart from updatedFields (or id/version field), then remove them.\n    // This can happen, despite requesting for these fields in the call to RTGC.getInputDocument, if the document was\n    // fetched from the tlog and had all these fields (possibly because it was a full document ADD operation).\n    if (updatedFields != null) {\n      Collection<String> names = new HashSet<String>(oldDocument.getFieldNames());\n      for (String fieldName: names) {\n        if (fieldName.equals(DistributedUpdateProcessor.VERSION_FIELD)==false && fieldName.equals(\"id\")==false && updatedFields.contains(fieldName)==false) {\n          oldDocument.remove(fieldName);\n        }\n      }\n    }\n    // Copy over all supported DVs from oldDocument to partialDoc\n    //\n    // Assuming multiple updates to the same doc: field 'dv1' in one update, then field 'dv2' in a second\n    // update, and then again 'dv1' in a third update (without commits in between), the last update would\n    // fetch from the tlog the partial doc for the 2nd (dv2) update. If that doc doesn't copy over the\n    // previous updates to dv1 as well, then a full resolution (by following previous pointers) would\n    // need to be done to calculate the dv1 value -- so instead copy all the potentially affected DV fields.\n    SolrInputDocument partialDoc = new SolrInputDocument();\n    String uniqueKeyField = schema.getUniqueKeyField().getName();\n    for (String fieldName : oldDocument.getFieldNames()) {\n      SchemaField schemaField = schema.getField(fieldName);\n      if (fieldName.equals(uniqueKeyField) || isSupportedFieldForInPlaceUpdate(schemaField)) {\n        partialDoc.addField(fieldName, oldDocument.getFieldValue(fieldName));\n      }\n    }\n    \n    merge(inputDoc, partialDoc);\n\n    // Populate the id field if not already populated (this can happen since stored fields were avoided during fetch from RTGC)\n    if (!partialDoc.containsKey(schema.getUniqueKeyField().getName())) {\n      partialDoc.addField(idField.getName(), \n          inputDoc.getField(schema.getUniqueKeyField().getName()).getFirstValue());\n    }\n\n    cmd.prevVersion = oldVersion;\n    cmd.solrDoc = partialDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5fa6615014cd2288fe930f8c8bb726f9504961d","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#doInPlaceUpdateMerge(AddUpdateCommand,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#doInPlaceUpdateMerge(AddUpdateCommand,Set[String]).mjava","sourceNew":"  /**\n   * Given an AddUpdateCommand containing update operations (e.g. set, inc), merge and resolve the operations into\n   * a partial document that can be used for indexing the in-place updates. The AddUpdateCommand is modified to contain\n   * the partial document (instead of the original document which contained the update operations) and also\n   * the prevVersion that this in-place update depends on.\n   * Note: updatedFields passed into the method can be changed, i.e. the version field can be added to the set.\n   * @return If in-place update cannot succeed, e.g. if the old document is deleted recently, then false is returned. A false\n   *        return indicates that this update can be re-tried as a full atomic update. Returns true if the in-place update\n   *        succeeds.\n   */\n  public boolean doInPlaceUpdateMerge(AddUpdateCommand cmd, Set<String> updatedFields) throws IOException {\n    SolrInputDocument inputDoc = cmd.getSolrInputDocument();\n    BytesRef idBytes = cmd.getIndexedId();\n\n    updatedFields.add(CommonParams.VERSION_FIELD); // add the version field so that it is fetched too\n    SolrInputDocument oldDocument = RealTimeGetComponent.getInputDocument\n      (cmd.getReq().getCore(), idBytes,\n       null, // don't want the version to be returned\n       true, // avoid stored fields from index\n       updatedFields,\n       true); // resolve the full document\n                                              \n    if (oldDocument == RealTimeGetComponent.DELETED || oldDocument == null) {\n      // This doc was deleted recently. In-place update cannot work, hence a full atomic update should be tried.\n      return false;\n    }\n\n    if (oldDocument.containsKey(CommonParams.VERSION_FIELD) == false) {\n      throw new SolrException (ErrorCode.INVALID_STATE, \"There is no _version_ in previous document. id=\" + \n          cmd.getPrintableId());\n    }\n    Long oldVersion = (Long) oldDocument.remove(CommonParams.VERSION_FIELD).getValue();\n\n    // If the oldDocument contains any other field apart from updatedFields (or id/version field), then remove them.\n    // This can happen, despite requesting for these fields in the call to RTGC.getInputDocument, if the document was\n    // fetched from the tlog and had all these fields (possibly because it was a full document ADD operation).\n    if (updatedFields != null) {\n      Collection<String> names = new HashSet<String>(oldDocument.getFieldNames());\n      for (String fieldName: names) {\n        if (fieldName.equals(CommonParams.VERSION_FIELD)==false && fieldName.equals(ID)==false && updatedFields.contains(fieldName)==false) {\n          oldDocument.remove(fieldName);\n        }\n      }\n    }\n    // Copy over all supported DVs from oldDocument to partialDoc\n    //\n    // Assuming multiple updates to the same doc: field 'dv1' in one update, then field 'dv2' in a second\n    // update, and then again 'dv1' in a third update (without commits in between), the last update would\n    // fetch from the tlog the partial doc for the 2nd (dv2) update. If that doc doesn't copy over the\n    // previous updates to dv1 as well, then a full resolution (by following previous pointers) would\n    // need to be done to calculate the dv1 value -- so instead copy all the potentially affected DV fields.\n    SolrInputDocument partialDoc = new SolrInputDocument();\n    String uniqueKeyField = schema.getUniqueKeyField().getName();\n    for (String fieldName : oldDocument.getFieldNames()) {\n      SchemaField schemaField = schema.getField(fieldName);\n      if (fieldName.equals(uniqueKeyField) || isSupportedFieldForInPlaceUpdate(schemaField)) {\n        partialDoc.addField(fieldName, oldDocument.getFieldValue(fieldName));\n      }\n    }\n    \n    merge(inputDoc, partialDoc);\n\n    // Populate the id field if not already populated (this can happen since stored fields were avoided during fetch from RTGC)\n    if (!partialDoc.containsKey(schema.getUniqueKeyField().getName())) {\n      partialDoc.addField(idField.getName(), \n          inputDoc.getField(schema.getUniqueKeyField().getName()).getFirstValue());\n    }\n\n    cmd.prevVersion = oldVersion;\n    cmd.solrDoc = partialDoc;\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Given an AddUpdateCommand containing update operations (e.g. set, inc), merge and resolve the operations into\n   * a partial document that can be used for indexing the in-place updates. The AddUpdateCommand is modified to contain\n   * the partial document (instead of the original document which contained the update operations) and also\n   * the prevVersion that this in-place update depends on.\n   * Note: updatedFields passed into the method can be changed, i.e. the version field can be added to the set.\n   * @return If in-place update cannot succeed, e.g. if the old document is deleted recently, then false is returned. A false\n   *        return indicates that this update can be re-tried as a full atomic update. Returns true if the in-place update\n   *        succeeds.\n   */\n  public boolean doInPlaceUpdateMerge(AddUpdateCommand cmd, Set<String> updatedFields) throws IOException {\n    SolrInputDocument inputDoc = cmd.getSolrInputDocument();\n    BytesRef idBytes = cmd.getIndexedId();\n\n    updatedFields.add(DistributedUpdateProcessor.VERSION_FIELD); // add the version field so that it is fetched too\n    SolrInputDocument oldDocument = RealTimeGetComponent.getInputDocument\n      (cmd.getReq().getCore(), idBytes,\n       null, // don't want the version to be returned\n       true, // avoid stored fields from index\n       updatedFields,\n       true); // resolve the full document\n                                              \n    if (oldDocument == RealTimeGetComponent.DELETED || oldDocument == null) {\n      // This doc was deleted recently. In-place update cannot work, hence a full atomic update should be tried.\n      return false;\n    }\n\n    if (oldDocument.containsKey(DistributedUpdateProcessor.VERSION_FIELD) == false) {\n      throw new SolrException (ErrorCode.INVALID_STATE, \"There is no _version_ in previous document. id=\" + \n          cmd.getPrintableId());\n    }\n    Long oldVersion = (Long) oldDocument.remove(DistributedUpdateProcessor.VERSION_FIELD).getValue();\n\n    // If the oldDocument contains any other field apart from updatedFields (or id/version field), then remove them.\n    // This can happen, despite requesting for these fields in the call to RTGC.getInputDocument, if the document was\n    // fetched from the tlog and had all these fields (possibly because it was a full document ADD operation).\n    if (updatedFields != null) {\n      Collection<String> names = new HashSet<String>(oldDocument.getFieldNames());\n      for (String fieldName: names) {\n        if (fieldName.equals(DistributedUpdateProcessor.VERSION_FIELD)==false && fieldName.equals(\"id\")==false && updatedFields.contains(fieldName)==false) {\n          oldDocument.remove(fieldName);\n        }\n      }\n    }\n    // Copy over all supported DVs from oldDocument to partialDoc\n    //\n    // Assuming multiple updates to the same doc: field 'dv1' in one update, then field 'dv2' in a second\n    // update, and then again 'dv1' in a third update (without commits in between), the last update would\n    // fetch from the tlog the partial doc for the 2nd (dv2) update. If that doc doesn't copy over the\n    // previous updates to dv1 as well, then a full resolution (by following previous pointers) would\n    // need to be done to calculate the dv1 value -- so instead copy all the potentially affected DV fields.\n    SolrInputDocument partialDoc = new SolrInputDocument();\n    String uniqueKeyField = schema.getUniqueKeyField().getName();\n    for (String fieldName : oldDocument.getFieldNames()) {\n      SchemaField schemaField = schema.getField(fieldName);\n      if (fieldName.equals(uniqueKeyField) || isSupportedFieldForInPlaceUpdate(schemaField)) {\n        partialDoc.addField(fieldName, oldDocument.getFieldValue(fieldName));\n      }\n    }\n    \n    merge(inputDoc, partialDoc);\n\n    // Populate the id field if not already populated (this can happen since stored fields were avoided during fetch from RTGC)\n    if (!partialDoc.containsKey(schema.getUniqueKeyField().getName())) {\n      partialDoc.addField(idField.getName(), \n          inputDoc.getField(schema.getUniqueKeyField().getName()).getFirstValue());\n    }\n\n    cmd.prevVersion = oldVersion;\n    cmd.solrDoc = partialDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07749612bed4eb54dd05255c1434c301133310c1","date":1554879779,"type":3,"author":"Moshe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#doInPlaceUpdateMerge(AddUpdateCommand,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#doInPlaceUpdateMerge(AddUpdateCommand,Set[String]).mjava","sourceNew":"  /**\n   * Given an AddUpdateCommand containing update operations (e.g. set, inc), merge and resolve the operations into\n   * a partial document that can be used for indexing the in-place updates. The AddUpdateCommand is modified to contain\n   * the partial document (instead of the original document which contained the update operations) and also\n   * the prevVersion that this in-place update depends on.\n   * Note: updatedFields passed into the method can be changed, i.e. the version field can be added to the set.\n   * @return If in-place update cannot succeed, e.g. if the old document is deleted recently, then false is returned. A false\n   *        return indicates that this update can be re-tried as a full atomic update. Returns true if the in-place update\n   *        succeeds.\n   */\n  public boolean doInPlaceUpdateMerge(AddUpdateCommand cmd, Set<String> updatedFields) throws IOException {\n    SolrInputDocument inputDoc = cmd.getSolrInputDocument();\n    BytesRef idBytes = cmd.getIndexedId();\n\n    updatedFields.add(CommonParams.VERSION_FIELD); // add the version field so that it is fetched too\n    SolrInputDocument oldDocument = RealTimeGetComponent.getInputDocument\n      (cmd.getReq().getCore(), idBytes,\n       null, // don't want the version to be returned\n       updatedFields,\n       RealTimeGetComponent.Resolution.DOC);\n                                              \n    if (oldDocument == RealTimeGetComponent.DELETED || oldDocument == null) {\n      // This doc was deleted recently. In-place update cannot work, hence a full atomic update should be tried.\n      return false;\n    }\n\n    if (oldDocument.containsKey(CommonParams.VERSION_FIELD) == false) {\n      throw new SolrException (ErrorCode.INVALID_STATE, \"There is no _version_ in previous document. id=\" + \n          cmd.getPrintableId());\n    }\n    Long oldVersion = (Long) oldDocument.remove(CommonParams.VERSION_FIELD).getValue();\n\n    // If the oldDocument contains any other field apart from updatedFields (or id/version field), then remove them.\n    // This can happen, despite requesting for these fields in the call to RTGC.getInputDocument, if the document was\n    // fetched from the tlog and had all these fields (possibly because it was a full document ADD operation).\n    if (updatedFields != null) {\n      Collection<String> names = new HashSet<String>(oldDocument.getFieldNames());\n      for (String fieldName: names) {\n        if (fieldName.equals(CommonParams.VERSION_FIELD)==false && fieldName.equals(ID)==false && updatedFields.contains(fieldName)==false) {\n          oldDocument.remove(fieldName);\n        }\n      }\n    }\n    // Copy over all supported DVs from oldDocument to partialDoc\n    //\n    // Assuming multiple updates to the same doc: field 'dv1' in one update, then field 'dv2' in a second\n    // update, and then again 'dv1' in a third update (without commits in between), the last update would\n    // fetch from the tlog the partial doc for the 2nd (dv2) update. If that doc doesn't copy over the\n    // previous updates to dv1 as well, then a full resolution (by following previous pointers) would\n    // need to be done to calculate the dv1 value -- so instead copy all the potentially affected DV fields.\n    SolrInputDocument partialDoc = new SolrInputDocument();\n    String uniqueKeyField = schema.getUniqueKeyField().getName();\n    for (String fieldName : oldDocument.getFieldNames()) {\n      SchemaField schemaField = schema.getField(fieldName);\n      if (fieldName.equals(uniqueKeyField) || isSupportedFieldForInPlaceUpdate(schemaField)) {\n        partialDoc.addField(fieldName, oldDocument.getFieldValue(fieldName));\n      }\n    }\n    \n    merge(inputDoc, partialDoc);\n\n    // Populate the id field if not already populated (this can happen since stored fields were avoided during fetch from RTGC)\n    if (!partialDoc.containsKey(schema.getUniqueKeyField().getName())) {\n      partialDoc.addField(idField.getName(), \n          inputDoc.getField(schema.getUniqueKeyField().getName()).getFirstValue());\n    }\n\n    cmd.prevVersion = oldVersion;\n    cmd.solrDoc = partialDoc;\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Given an AddUpdateCommand containing update operations (e.g. set, inc), merge and resolve the operations into\n   * a partial document that can be used for indexing the in-place updates. The AddUpdateCommand is modified to contain\n   * the partial document (instead of the original document which contained the update operations) and also\n   * the prevVersion that this in-place update depends on.\n   * Note: updatedFields passed into the method can be changed, i.e. the version field can be added to the set.\n   * @return If in-place update cannot succeed, e.g. if the old document is deleted recently, then false is returned. A false\n   *        return indicates that this update can be re-tried as a full atomic update. Returns true if the in-place update\n   *        succeeds.\n   */\n  public boolean doInPlaceUpdateMerge(AddUpdateCommand cmd, Set<String> updatedFields) throws IOException {\n    SolrInputDocument inputDoc = cmd.getSolrInputDocument();\n    BytesRef idBytes = cmd.getIndexedId();\n\n    updatedFields.add(CommonParams.VERSION_FIELD); // add the version field so that it is fetched too\n    SolrInputDocument oldDocument = RealTimeGetComponent.getInputDocument\n      (cmd.getReq().getCore(), idBytes,\n       null, // don't want the version to be returned\n       true, // avoid stored fields from index\n       updatedFields,\n       true); // resolve the full document\n                                              \n    if (oldDocument == RealTimeGetComponent.DELETED || oldDocument == null) {\n      // This doc was deleted recently. In-place update cannot work, hence a full atomic update should be tried.\n      return false;\n    }\n\n    if (oldDocument.containsKey(CommonParams.VERSION_FIELD) == false) {\n      throw new SolrException (ErrorCode.INVALID_STATE, \"There is no _version_ in previous document. id=\" + \n          cmd.getPrintableId());\n    }\n    Long oldVersion = (Long) oldDocument.remove(CommonParams.VERSION_FIELD).getValue();\n\n    // If the oldDocument contains any other field apart from updatedFields (or id/version field), then remove them.\n    // This can happen, despite requesting for these fields in the call to RTGC.getInputDocument, if the document was\n    // fetched from the tlog and had all these fields (possibly because it was a full document ADD operation).\n    if (updatedFields != null) {\n      Collection<String> names = new HashSet<String>(oldDocument.getFieldNames());\n      for (String fieldName: names) {\n        if (fieldName.equals(CommonParams.VERSION_FIELD)==false && fieldName.equals(ID)==false && updatedFields.contains(fieldName)==false) {\n          oldDocument.remove(fieldName);\n        }\n      }\n    }\n    // Copy over all supported DVs from oldDocument to partialDoc\n    //\n    // Assuming multiple updates to the same doc: field 'dv1' in one update, then field 'dv2' in a second\n    // update, and then again 'dv1' in a third update (without commits in between), the last update would\n    // fetch from the tlog the partial doc for the 2nd (dv2) update. If that doc doesn't copy over the\n    // previous updates to dv1 as well, then a full resolution (by following previous pointers) would\n    // need to be done to calculate the dv1 value -- so instead copy all the potentially affected DV fields.\n    SolrInputDocument partialDoc = new SolrInputDocument();\n    String uniqueKeyField = schema.getUniqueKeyField().getName();\n    for (String fieldName : oldDocument.getFieldNames()) {\n      SchemaField schemaField = schema.getField(fieldName);\n      if (fieldName.equals(uniqueKeyField) || isSupportedFieldForInPlaceUpdate(schemaField)) {\n        partialDoc.addField(fieldName, oldDocument.getFieldValue(fieldName));\n      }\n    }\n    \n    merge(inputDoc, partialDoc);\n\n    // Populate the id field if not already populated (this can happen since stored fields were avoided during fetch from RTGC)\n    if (!partialDoc.containsKey(schema.getUniqueKeyField().getName())) {\n      partialDoc.addField(idField.getName(), \n          inputDoc.getField(schema.getUniqueKeyField().getName()).getFirstValue());\n    }\n\n    cmd.prevVersion = oldVersion;\n    cmd.solrDoc = partialDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5b5fa3584550267bf4209f334513a9d5850dd1e0","date":1591795784,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#doInPlaceUpdateMerge(AddUpdateCommand,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#doInPlaceUpdateMerge(AddUpdateCommand,Set[String]).mjava","sourceNew":"  /**\n   * Given an AddUpdateCommand containing update operations (e.g. set, inc), merge and resolve the operations into\n   * a partial document that can be used for indexing the in-place updates. The AddUpdateCommand is modified to contain\n   * the partial document (instead of the original document which contained the update operations) and also\n   * the prevVersion that this in-place update depends on.\n   * Note: updatedFields passed into the method can be changed, i.e. the version field can be added to the set.\n   * @return If in-place update cannot succeed, e.g. if the old document is deleted recently, then false is returned. A false\n   *        return indicates that this update can be re-tried as a full atomic update. Returns true if the in-place update\n   *        succeeds.\n   */\n  public boolean doInPlaceUpdateMerge(AddUpdateCommand cmd, Set<String> updatedFields) throws IOException {\n    SolrInputDocument inputDoc = cmd.getSolrInputDocument();\n    BytesRef idBytes = cmd.getIndexedId();\n\n    updatedFields.add(CommonParams.VERSION_FIELD); // add the version field so that it is fetched too\n    SolrInputDocument oldDocument = RealTimeGetComponent.getInputDocument\n      (cmd.getReq().getCore(), idBytes,\n       null, // don't want the version to be returned\n       updatedFields,\n       RealTimeGetComponent.Resolution.DOC);\n                                              \n    if (oldDocument == RealTimeGetComponent.DELETED || oldDocument == null) {\n      // This doc was deleted recently. In-place update cannot work, hence a full atomic update should be tried.\n      return false;\n    }\n\n    if (oldDocument.containsKey(CommonParams.VERSION_FIELD) == false) {\n      throw new SolrException (ErrorCode.INVALID_STATE, \"There is no _version_ in previous document. id=\" + \n          cmd.getPrintableId());\n    }\n    Long oldVersion = (Long) oldDocument.remove(CommonParams.VERSION_FIELD).getValue();\n\n    // If the oldDocument contains any other field apart from updatedFields (or id/version field), then remove them.\n    // This can happen, despite requesting for these fields in the call to RTGC.getInputDocument, if the document was\n    // fetched from the tlog and had all these fields (possibly because it was a full document ADD operation).\n    if (updatedFields != null) {\n      Collection<String> names = new HashSet<>(oldDocument.getFieldNames());\n      for (String fieldName: names) {\n        if (fieldName.equals(CommonParams.VERSION_FIELD)==false && fieldName.equals(ID)==false && updatedFields.contains(fieldName)==false) {\n          oldDocument.remove(fieldName);\n        }\n      }\n    }\n    // Copy over all supported DVs from oldDocument to partialDoc\n    //\n    // Assuming multiple updates to the same doc: field 'dv1' in one update, then field 'dv2' in a second\n    // update, and then again 'dv1' in a third update (without commits in between), the last update would\n    // fetch from the tlog the partial doc for the 2nd (dv2) update. If that doc doesn't copy over the\n    // previous updates to dv1 as well, then a full resolution (by following previous pointers) would\n    // need to be done to calculate the dv1 value -- so instead copy all the potentially affected DV fields.\n    SolrInputDocument partialDoc = new SolrInputDocument();\n    String uniqueKeyField = schema.getUniqueKeyField().getName();\n    for (String fieldName : oldDocument.getFieldNames()) {\n      SchemaField schemaField = schema.getField(fieldName);\n      if (fieldName.equals(uniqueKeyField) || isSupportedFieldForInPlaceUpdate(schemaField)) {\n        partialDoc.addField(fieldName, oldDocument.getFieldValue(fieldName));\n      }\n    }\n    \n    merge(inputDoc, partialDoc);\n\n    // Populate the id field if not already populated (this can happen since stored fields were avoided during fetch from RTGC)\n    if (!partialDoc.containsKey(schema.getUniqueKeyField().getName())) {\n      partialDoc.addField(idField.getName(), \n          inputDoc.getField(schema.getUniqueKeyField().getName()).getFirstValue());\n    }\n\n    cmd.prevVersion = oldVersion;\n    cmd.solrDoc = partialDoc;\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Given an AddUpdateCommand containing update operations (e.g. set, inc), merge and resolve the operations into\n   * a partial document that can be used for indexing the in-place updates. The AddUpdateCommand is modified to contain\n   * the partial document (instead of the original document which contained the update operations) and also\n   * the prevVersion that this in-place update depends on.\n   * Note: updatedFields passed into the method can be changed, i.e. the version field can be added to the set.\n   * @return If in-place update cannot succeed, e.g. if the old document is deleted recently, then false is returned. A false\n   *        return indicates that this update can be re-tried as a full atomic update. Returns true if the in-place update\n   *        succeeds.\n   */\n  public boolean doInPlaceUpdateMerge(AddUpdateCommand cmd, Set<String> updatedFields) throws IOException {\n    SolrInputDocument inputDoc = cmd.getSolrInputDocument();\n    BytesRef idBytes = cmd.getIndexedId();\n\n    updatedFields.add(CommonParams.VERSION_FIELD); // add the version field so that it is fetched too\n    SolrInputDocument oldDocument = RealTimeGetComponent.getInputDocument\n      (cmd.getReq().getCore(), idBytes,\n       null, // don't want the version to be returned\n       updatedFields,\n       RealTimeGetComponent.Resolution.DOC);\n                                              \n    if (oldDocument == RealTimeGetComponent.DELETED || oldDocument == null) {\n      // This doc was deleted recently. In-place update cannot work, hence a full atomic update should be tried.\n      return false;\n    }\n\n    if (oldDocument.containsKey(CommonParams.VERSION_FIELD) == false) {\n      throw new SolrException (ErrorCode.INVALID_STATE, \"There is no _version_ in previous document. id=\" + \n          cmd.getPrintableId());\n    }\n    Long oldVersion = (Long) oldDocument.remove(CommonParams.VERSION_FIELD).getValue();\n\n    // If the oldDocument contains any other field apart from updatedFields (or id/version field), then remove them.\n    // This can happen, despite requesting for these fields in the call to RTGC.getInputDocument, if the document was\n    // fetched from the tlog and had all these fields (possibly because it was a full document ADD operation).\n    if (updatedFields != null) {\n      Collection<String> names = new HashSet<String>(oldDocument.getFieldNames());\n      for (String fieldName: names) {\n        if (fieldName.equals(CommonParams.VERSION_FIELD)==false && fieldName.equals(ID)==false && updatedFields.contains(fieldName)==false) {\n          oldDocument.remove(fieldName);\n        }\n      }\n    }\n    // Copy over all supported DVs from oldDocument to partialDoc\n    //\n    // Assuming multiple updates to the same doc: field 'dv1' in one update, then field 'dv2' in a second\n    // update, and then again 'dv1' in a third update (without commits in between), the last update would\n    // fetch from the tlog the partial doc for the 2nd (dv2) update. If that doc doesn't copy over the\n    // previous updates to dv1 as well, then a full resolution (by following previous pointers) would\n    // need to be done to calculate the dv1 value -- so instead copy all the potentially affected DV fields.\n    SolrInputDocument partialDoc = new SolrInputDocument();\n    String uniqueKeyField = schema.getUniqueKeyField().getName();\n    for (String fieldName : oldDocument.getFieldNames()) {\n      SchemaField schemaField = schema.getField(fieldName);\n      if (fieldName.equals(uniqueKeyField) || isSupportedFieldForInPlaceUpdate(schemaField)) {\n        partialDoc.addField(fieldName, oldDocument.getFieldValue(fieldName));\n      }\n    }\n    \n    merge(inputDoc, partialDoc);\n\n    // Populate the id field if not already populated (this can happen since stored fields were avoided during fetch from RTGC)\n    if (!partialDoc.containsKey(schema.getUniqueKeyField().getName())) {\n      partialDoc.addField(idField.getName(), \n          inputDoc.getField(schema.getUniqueKeyField().getName()).getFirstValue());\n    }\n\n    cmd.prevVersion = oldVersion;\n    cmd.solrDoc = partialDoc;\n    return true;\n  }\n\n","bugFix":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"5b5fa3584550267bf4209f334513a9d5850dd1e0":["07749612bed4eb54dd05255c1434c301133310c1"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","415bbbe7da8065dd3c477bdc3c703c6425622998"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"07749612bed4eb54dd05255c1434c301133310c1":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5b5fa3584550267bf4209f334513a9d5850dd1e0"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["e5fa6615014cd2288fe930f8c8bb726f9504961d","598b5d23aa7c9732bf473c21a9cd309c44599394","6d2dadc1f5ca8703d8659f4964961f9967935d75"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":[],"5b5fa3584550267bf4209f334513a9d5850dd1e0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["07749612bed4eb54dd05255c1434c301133310c1"],"07749612bed4eb54dd05255c1434c301133310c1":["5b5fa3584550267bf4209f334513a9d5850dd1e0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e5fa6615014cd2288fe930f8c8bb726f9504961d","598b5d23aa7c9732bf473c21a9cd309c44599394","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}