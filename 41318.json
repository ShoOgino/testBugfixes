{"path":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestMaxPositionInOldIndex#testCorruptIndex().mjava","commits":[{"id":"35fb92999b9df7df2ce2b35b83a044cbede61f45","date":1429037650,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestMaxPositionInOldIndex#testCorruptIndex().mjava","pathOld":"/dev/null","sourceNew":"  public void testCorruptIndex() throws Exception {\n    Path path = createTempDir(\"maxposindex\");\n    InputStream resource = getClass().getResourceAsStream(\"maxposindex.zip\");\n    assertNotNull(\"maxposindex not found\", resource);\n    TestUtil.unzip(resource, path);\n    BaseDirectoryWrapper dir = newFSDirectory(path);\n    dir.setCheckIndexOnClose(false);\n    try {\n      TestUtil.checkIndex(dir, false, true);\n      fail(\"corruption was not detected\");\n    } catch (RuntimeException re) {\n      // expected\n      assertTrue(re.getMessage().contains(\"pos 2147483647 > IndexWriter.MAX_POSITION=2147483519\"));\n    }\n\n    // Also confirm merging detects this:\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig().setMergeScheduler(new SerialMergeScheduler()));\n    w.addDocument(new Document());\n    try {\n      w.forceMerge(1);\n    } catch (CorruptIndexException cie) {\n      // SerialMergeScheduler\n      assertTrue(cie.getMessage().contains(\"position=2147483647 is too large (> IndexWriter.MAX_POSITION=2147483519), field=\\\"foo\\\" doc=0 (resource=PerFieldPostings(segment=_0 formats=1)\"));\n    }\n\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["05fe562aa248790944d43cdd478f512572835ba0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"807f2f42d531bcd38d3c8e581ac76c8abee659b7","date":1429206011,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestMaxPositionInOldIndex#testCorruptIndex().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestMaxPositionInOldIndex#testCorruptIndex().mjava","sourceNew":"  public void testCorruptIndex() throws Exception {\n    Path path = createTempDir(\"maxposindex\");\n    InputStream resource = getClass().getResourceAsStream(\"maxposindex.zip\");\n    assertNotNull(\"maxposindex not found\", resource);\n    TestUtil.unzip(resource, path);\n    BaseDirectoryWrapper dir = newFSDirectory(path);\n    dir.setCheckIndexOnClose(false);\n    try {\n      TestUtil.checkIndex(dir, false, true);\n      fail(\"corruption was not detected\");\n    } catch (RuntimeException re) {\n      // expected\n      assertTrue(re.getMessage().contains(\"pos 2147483647 > IndexWriter.MAX_POSITION=2147483519\"));\n    }\n\n    // Also confirm merging detects this:\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    iwc.setMergePolicy(newLogMergePolicy());\n    IndexWriter w = new IndexWriter(dir, iwc);\n    w.addDocument(new Document());\n    try {\n      w.forceMerge(1);\n    } catch (CorruptIndexException cie) {\n      // SerialMergeScheduler\n      assertTrue(\"got message \" + cie.getMessage(),\n                 cie.getMessage().contains(\"position=2147483647 is too large (> IndexWriter.MAX_POSITION=2147483519), field=\\\"foo\\\" doc=0 (resource=PerFieldPostings(segment=_0 formats=1)\"));\n    }\n\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testCorruptIndex() throws Exception {\n    Path path = createTempDir(\"maxposindex\");\n    InputStream resource = getClass().getResourceAsStream(\"maxposindex.zip\");\n    assertNotNull(\"maxposindex not found\", resource);\n    TestUtil.unzip(resource, path);\n    BaseDirectoryWrapper dir = newFSDirectory(path);\n    dir.setCheckIndexOnClose(false);\n    try {\n      TestUtil.checkIndex(dir, false, true);\n      fail(\"corruption was not detected\");\n    } catch (RuntimeException re) {\n      // expected\n      assertTrue(re.getMessage().contains(\"pos 2147483647 > IndexWriter.MAX_POSITION=2147483519\"));\n    }\n\n    // Also confirm merging detects this:\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig().setMergeScheduler(new SerialMergeScheduler()));\n    w.addDocument(new Document());\n    try {\n      w.forceMerge(1);\n    } catch (CorruptIndexException cie) {\n      // SerialMergeScheduler\n      assertTrue(cie.getMessage().contains(\"position=2147483647 is too large (> IndexWriter.MAX_POSITION=2147483519), field=\\\"foo\\\" doc=0 (resource=PerFieldPostings(segment=_0 formats=1)\"));\n    }\n\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["05fe562aa248790944d43cdd478f512572835ba0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a7cd425b41357fc2d22c92654fb7c614761ca6fa","date":1438618930,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestMaxPositionInOldIndex#testCorruptIndex().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestMaxPositionInOldIndex#testCorruptIndex().mjava","sourceNew":"  public void testCorruptIndex() throws Exception {\n    Path path = createTempDir(\"maxposindex\");\n    InputStream resource = getClass().getResourceAsStream(\"maxposindex.zip\");\n    assertNotNull(\"maxposindex not found\", resource);\n    TestUtil.unzip(resource, path);\n    BaseDirectoryWrapper dir = newFSDirectory(path);\n    dir.setCheckIndexOnClose(false);\n    try {\n      TestUtil.checkIndex(dir, false, true);\n      fail(\"corruption was not detected\");\n    } catch (RuntimeException re) {\n      // expected\n      assertTrue(re.getMessage().contains(\"pos 2147483647 > IndexWriter.MAX_POSITION=2147483519\"));\n    }\n\n    // Also confirm merging detects this:\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    iwc.setMergePolicy(newLogMergePolicy());\n    IndexWriter w = new IndexWriter(dir, iwc);\n    w.addDocument(new Document());\n    try {\n      w.forceMerge(1);\n    } catch (CorruptIndexException cie) {\n      assertEquals(cie.getMessage(), new CorruptIndexException(cie.getOriginalMessage(), cie.getResourceDescription()).getMessage());\n      // SerialMergeScheduler\n      assertTrue(\"got message \" + cie.getMessage(),\n                 cie.getMessage().contains(\"position=2147483647 is too large (> IndexWriter.MAX_POSITION=2147483519), field=\\\"foo\\\" doc=0 (resource=PerFieldPostings(segment=_0 formats=1)\"));\n    }\n\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testCorruptIndex() throws Exception {\n    Path path = createTempDir(\"maxposindex\");\n    InputStream resource = getClass().getResourceAsStream(\"maxposindex.zip\");\n    assertNotNull(\"maxposindex not found\", resource);\n    TestUtil.unzip(resource, path);\n    BaseDirectoryWrapper dir = newFSDirectory(path);\n    dir.setCheckIndexOnClose(false);\n    try {\n      TestUtil.checkIndex(dir, false, true);\n      fail(\"corruption was not detected\");\n    } catch (RuntimeException re) {\n      // expected\n      assertTrue(re.getMessage().contains(\"pos 2147483647 > IndexWriter.MAX_POSITION=2147483519\"));\n    }\n\n    // Also confirm merging detects this:\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    iwc.setMergePolicy(newLogMergePolicy());\n    IndexWriter w = new IndexWriter(dir, iwc);\n    w.addDocument(new Document());\n    try {\n      w.forceMerge(1);\n    } catch (CorruptIndexException cie) {\n      // SerialMergeScheduler\n      assertTrue(\"got message \" + cie.getMessage(),\n                 cie.getMessage().contains(\"position=2147483647 is too large (> IndexWriter.MAX_POSITION=2147483519), field=\\\"foo\\\" doc=0 (resource=PerFieldPostings(segment=_0 formats=1)\"));\n    }\n\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["05fe562aa248790944d43cdd478f512572835ba0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05fe562aa248790944d43cdd478f512572835ba0","date":1455901667,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestMaxPositionInOldIndex#testCorruptIndex().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestMaxPositionInOldIndex#testCorruptIndex().mjava","sourceNew":"  public void testCorruptIndex() throws Exception {\n    Path path = createTempDir(\"maxposindex\");\n    InputStream resource = getClass().getResourceAsStream(\"maxposindex.zip\");\n    assertNotNull(\"maxposindex not found\", resource);\n    TestUtil.unzip(resource, path);\n    BaseDirectoryWrapper dir = newFSDirectory(path);\n    dir.setCheckIndexOnClose(false);\n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      TestUtil.checkIndex(dir, false, true);\n    });\n    assertTrue(expected.getMessage().contains(\"pos 2147483647 > IndexWriter.MAX_POSITION=2147483519\"));\n\n    // Also confirm merging detects this:\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    iwc.setMergePolicy(newLogMergePolicy());\n    IndexWriter w = new IndexWriter(dir, iwc);\n    w.addDocument(new Document());\n    CorruptIndexException expectedCorruption = expectThrows(CorruptIndexException.class, () -> {\n      w.forceMerge(1);\n    });\n    assertEquals(expectedCorruption.getMessage(), new CorruptIndexException(expectedCorruption.getOriginalMessage(), expectedCorruption.getResourceDescription()).getMessage());\n    // SerialMergeScheduler\n    assertTrue(\"got message \" + expectedCorruption.getMessage(),\n        expectedCorruption.getMessage().contains(\"position=2147483647 is too large (> IndexWriter.MAX_POSITION=2147483519), field=\\\"foo\\\" doc=0 (resource=PerFieldPostings(segment=_0 formats=1)\"));\n\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testCorruptIndex() throws Exception {\n    Path path = createTempDir(\"maxposindex\");\n    InputStream resource = getClass().getResourceAsStream(\"maxposindex.zip\");\n    assertNotNull(\"maxposindex not found\", resource);\n    TestUtil.unzip(resource, path);\n    BaseDirectoryWrapper dir = newFSDirectory(path);\n    dir.setCheckIndexOnClose(false);\n    try {\n      TestUtil.checkIndex(dir, false, true);\n      fail(\"corruption was not detected\");\n    } catch (RuntimeException re) {\n      // expected\n      assertTrue(re.getMessage().contains(\"pos 2147483647 > IndexWriter.MAX_POSITION=2147483519\"));\n    }\n\n    // Also confirm merging detects this:\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    iwc.setMergePolicy(newLogMergePolicy());\n    IndexWriter w = new IndexWriter(dir, iwc);\n    w.addDocument(new Document());\n    try {\n      w.forceMerge(1);\n    } catch (CorruptIndexException cie) {\n      assertEquals(cie.getMessage(), new CorruptIndexException(cie.getOriginalMessage(), cie.getResourceDescription()).getMessage());\n      // SerialMergeScheduler\n      assertTrue(\"got message \" + cie.getMessage(),\n                 cie.getMessage().contains(\"position=2147483647 is too large (> IndexWriter.MAX_POSITION=2147483519), field=\\\"foo\\\" doc=0 (resource=PerFieldPostings(segment=_0 formats=1)\"));\n    }\n\n    w.close();\n    dir.close();\n  }\n\n","bugFix":["35fb92999b9df7df2ce2b35b83a044cbede61f45","807f2f42d531bcd38d3c8e581ac76c8abee659b7","a7cd425b41357fc2d22c92654fb7c614761ca6fa"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6392c263ac1e0e2a22a7f2d50f499e76971801d","date":1456927541,"type":4,"author":"Mike McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestMaxPositionInOldIndex#testCorruptIndex().mjava","sourceNew":null,"sourceOld":"  public void testCorruptIndex() throws Exception {\n    Path path = createTempDir(\"maxposindex\");\n    InputStream resource = getClass().getResourceAsStream(\"maxposindex.zip\");\n    assertNotNull(\"maxposindex not found\", resource);\n    TestUtil.unzip(resource, path);\n    BaseDirectoryWrapper dir = newFSDirectory(path);\n    dir.setCheckIndexOnClose(false);\n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      TestUtil.checkIndex(dir, false, true);\n    });\n    assertTrue(expected.getMessage().contains(\"pos 2147483647 > IndexWriter.MAX_POSITION=2147483519\"));\n\n    // Also confirm merging detects this:\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    iwc.setMergePolicy(newLogMergePolicy());\n    IndexWriter w = new IndexWriter(dir, iwc);\n    w.addDocument(new Document());\n    CorruptIndexException expectedCorruption = expectThrows(CorruptIndexException.class, () -> {\n      w.forceMerge(1);\n    });\n    assertEquals(expectedCorruption.getMessage(), new CorruptIndexException(expectedCorruption.getOriginalMessage(), expectedCorruption.getResourceDescription()).getMessage());\n    // SerialMergeScheduler\n    assertTrue(\"got message \" + expectedCorruption.getMessage(),\n        expectedCorruption.getMessage().contains(\"position=2147483647 is too large (> IndexWriter.MAX_POSITION=2147483519), field=\\\"foo\\\" doc=0 (resource=PerFieldPostings(segment=_0 formats=1)\"));\n\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestMaxPositionInOldIndex#testCorruptIndex().mjava","sourceNew":null,"sourceOld":"  public void testCorruptIndex() throws Exception {\n    Path path = createTempDir(\"maxposindex\");\n    InputStream resource = getClass().getResourceAsStream(\"maxposindex.zip\");\n    assertNotNull(\"maxposindex not found\", resource);\n    TestUtil.unzip(resource, path);\n    BaseDirectoryWrapper dir = newFSDirectory(path);\n    dir.setCheckIndexOnClose(false);\n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      TestUtil.checkIndex(dir, false, true);\n    });\n    assertTrue(expected.getMessage().contains(\"pos 2147483647 > IndexWriter.MAX_POSITION=2147483519\"));\n\n    // Also confirm merging detects this:\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    iwc.setMergePolicy(newLogMergePolicy());\n    IndexWriter w = new IndexWriter(dir, iwc);\n    w.addDocument(new Document());\n    CorruptIndexException expectedCorruption = expectThrows(CorruptIndexException.class, () -> {\n      w.forceMerge(1);\n    });\n    assertEquals(expectedCorruption.getMessage(), new CorruptIndexException(expectedCorruption.getOriginalMessage(), expectedCorruption.getResourceDescription()).getMessage());\n    // SerialMergeScheduler\n    assertTrue(\"got message \" + expectedCorruption.getMessage(),\n        expectedCorruption.getMessage().contains(\"position=2147483647 is too large (> IndexWriter.MAX_POSITION=2147483519), field=\\\"foo\\\" doc=0 (resource=PerFieldPostings(segment=_0 formats=1)\"));\n\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a7cd425b41357fc2d22c92654fb7c614761ca6fa":["807f2f42d531bcd38d3c8e581ac76c8abee659b7"],"35fb92999b9df7df2ce2b35b83a044cbede61f45":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d6392c263ac1e0e2a22a7f2d50f499e76971801d":["05fe562aa248790944d43cdd478f512572835ba0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"05fe562aa248790944d43cdd478f512572835ba0":["a7cd425b41357fc2d22c92654fb7c614761ca6fa"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["05fe562aa248790944d43cdd478f512572835ba0","d6392c263ac1e0e2a22a7f2d50f499e76971801d"],"807f2f42d531bcd38d3c8e581ac76c8abee659b7":["35fb92999b9df7df2ce2b35b83a044cbede61f45"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"]},"commit2Childs":{"a7cd425b41357fc2d22c92654fb7c614761ca6fa":["05fe562aa248790944d43cdd478f512572835ba0"],"35fb92999b9df7df2ce2b35b83a044cbede61f45":["807f2f42d531bcd38d3c8e581ac76c8abee659b7"],"d6392c263ac1e0e2a22a7f2d50f499e76971801d":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["35fb92999b9df7df2ce2b35b83a044cbede61f45"],"05fe562aa248790944d43cdd478f512572835ba0":["d6392c263ac1e0e2a22a7f2d50f499e76971801d","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"807f2f42d531bcd38d3c8e581ac76c8abee659b7":["a7cd425b41357fc2d22c92654fb7c614761ca6fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}