{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8#convert(Automaton).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8#convert(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8#convert(Automaton).mjava","sourceNew":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public Automaton convert(Automaton utf32) {\n    if (utf32.isSingleton()) {\n      utf32 = utf32.cloneExpanded();\n    }\n\n    State[] map = new State[utf32.getNumberedStates().length];\n    List<State> pending = new ArrayList<State>();\n    State utf32State = utf32.getInitialState();\n    pending.add(utf32State);\n    Automaton utf8 = new Automaton();\n    utf8.setDeterministic(false);\n\n    State utf8State = utf8.getInitialState();\n\n    utf8States = new State[5];\n    utf8StateCount = 0;\n    utf8State.number = utf8StateCount;\n    utf8States[utf8StateCount] = utf8State;\n    utf8StateCount++;\n\n    utf8State.setAccept(utf32State.isAccept());\n\n    map[utf32State.number] = utf8State;\n    \n    while(pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State.number];\n      for(int i=0;i<utf32State.numTransitions;i++) {\n        final Transition t = utf32State.transitionsArray[i];\n        final State destUTF32 = t.to;\n        State destUTF8 = map[destUTF32.number];\n        if (destUTF8 == null) {\n          destUTF8 = newUTF8State();\n          destUTF8.accept = destUTF32.accept;\n          map[destUTF32.number] = destUTF8;\n          pending.add(destUTF32);\n        }\n        convertOneEdge(utf8State, destUTF8, t.min, t.max);\n      }\n    }\n\n    utf8.setNumberedStates(utf8States, utf8StateCount);\n\n    return utf8;\n  }\n\n","sourceOld":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public Automaton convert(Automaton utf32) {\n    if (utf32.isSingleton()) {\n      utf32 = utf32.cloneExpanded();\n    }\n\n    State[] map = new State[utf32.getNumberedStates().length];\n    List<State> pending = new ArrayList<State>();\n    State utf32State = utf32.getInitialState();\n    pending.add(utf32State);\n    Automaton utf8 = new Automaton();\n    utf8.setDeterministic(false);\n\n    State utf8State = utf8.getInitialState();\n\n    utf8States = new State[5];\n    utf8StateCount = 0;\n    utf8State.number = utf8StateCount;\n    utf8States[utf8StateCount] = utf8State;\n    utf8StateCount++;\n\n    utf8State.setAccept(utf32State.isAccept());\n\n    map[utf32State.number] = utf8State;\n    \n    while(pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State.number];\n      for(int i=0;i<utf32State.numTransitions;i++) {\n        final Transition t = utf32State.transitionsArray[i];\n        final State destUTF32 = t.to;\n        State destUTF8 = map[destUTF32.number];\n        if (destUTF8 == null) {\n          destUTF8 = newUTF8State();\n          destUTF8.accept = destUTF32.accept;\n          map[destUTF32.number] = destUTF8;\n          pending.add(destUTF32);\n        }\n        convertOneEdge(utf8State, destUTF8, t.min, t.max);\n      }\n    }\n\n    utf8.setNumberedStates(utf8States, utf8StateCount);\n\n    return utf8;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8#convert(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8#convert(Automaton).mjava","sourceNew":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public Automaton convert(Automaton utf32) {\n    if (utf32.isSingleton()) {\n      utf32 = utf32.cloneExpanded();\n    }\n\n    State[] map = new State[utf32.getNumberedStates().length];\n    List<State> pending = new ArrayList<>();\n    State utf32State = utf32.getInitialState();\n    pending.add(utf32State);\n    Automaton utf8 = new Automaton();\n    utf8.setDeterministic(false);\n\n    State utf8State = utf8.getInitialState();\n\n    utf8States = new State[5];\n    utf8StateCount = 0;\n    utf8State.number = utf8StateCount;\n    utf8States[utf8StateCount] = utf8State;\n    utf8StateCount++;\n\n    utf8State.setAccept(utf32State.isAccept());\n\n    map[utf32State.number] = utf8State;\n    \n    while(pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State.number];\n      for(int i=0;i<utf32State.numTransitions;i++) {\n        final Transition t = utf32State.transitionsArray[i];\n        final State destUTF32 = t.to;\n        State destUTF8 = map[destUTF32.number];\n        if (destUTF8 == null) {\n          destUTF8 = newUTF8State();\n          destUTF8.accept = destUTF32.accept;\n          map[destUTF32.number] = destUTF8;\n          pending.add(destUTF32);\n        }\n        convertOneEdge(utf8State, destUTF8, t.min, t.max);\n      }\n    }\n\n    utf8.setNumberedStates(utf8States, utf8StateCount);\n\n    return utf8;\n  }\n\n","sourceOld":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public Automaton convert(Automaton utf32) {\n    if (utf32.isSingleton()) {\n      utf32 = utf32.cloneExpanded();\n    }\n\n    State[] map = new State[utf32.getNumberedStates().length];\n    List<State> pending = new ArrayList<State>();\n    State utf32State = utf32.getInitialState();\n    pending.add(utf32State);\n    Automaton utf8 = new Automaton();\n    utf8.setDeterministic(false);\n\n    State utf8State = utf8.getInitialState();\n\n    utf8States = new State[5];\n    utf8StateCount = 0;\n    utf8State.number = utf8StateCount;\n    utf8States[utf8StateCount] = utf8State;\n    utf8StateCount++;\n\n    utf8State.setAccept(utf32State.isAccept());\n\n    map[utf32State.number] = utf8State;\n    \n    while(pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State.number];\n      for(int i=0;i<utf32State.numTransitions;i++) {\n        final Transition t = utf32State.transitionsArray[i];\n        final State destUTF32 = t.to;\n        State destUTF8 = map[destUTF32.number];\n        if (destUTF8 == null) {\n          destUTF8 = newUTF8State();\n          destUTF8.accept = destUTF32.accept;\n          map[destUTF32.number] = destUTF8;\n          pending.add(destUTF32);\n        }\n        convertOneEdge(utf8State, destUTF8, t.min, t.max);\n      }\n    }\n\n    utf8.setNumberedStates(utf8States, utf8StateCount);\n\n    return utf8;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f4ef381bf0c2d618c6db830d3dd668c6901c05a","date":1402592253,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8#convert(Automaton).mjava","sourceNew":null,"sourceOld":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public Automaton convert(Automaton utf32) {\n    if (utf32.isSingleton()) {\n      utf32 = utf32.cloneExpanded();\n    }\n\n    State[] map = new State[utf32.getNumberedStates().length];\n    List<State> pending = new ArrayList<>();\n    State utf32State = utf32.getInitialState();\n    pending.add(utf32State);\n    Automaton utf8 = new Automaton();\n    utf8.setDeterministic(false);\n\n    State utf8State = utf8.getInitialState();\n\n    utf8States = new State[5];\n    utf8StateCount = 0;\n    utf8State.number = utf8StateCount;\n    utf8States[utf8StateCount] = utf8State;\n    utf8StateCount++;\n\n    utf8State.setAccept(utf32State.isAccept());\n\n    map[utf32State.number] = utf8State;\n    \n    while(pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State.number];\n      for(int i=0;i<utf32State.numTransitions;i++) {\n        final Transition t = utf32State.transitionsArray[i];\n        final State destUTF32 = t.to;\n        State destUTF8 = map[destUTF32.number];\n        if (destUTF8 == null) {\n          destUTF8 = newUTF8State();\n          destUTF8.accept = destUTF32.accept;\n          map[destUTF32.number] = destUTF8;\n          pending.add(destUTF32);\n        }\n        convertOneEdge(utf8State, destUTF8, t.min, t.max);\n      }\n    }\n\n    utf8.setNumberedStates(utf8States, utf8StateCount);\n\n    return utf8;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8#convert(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8Light#convert(LightAutomaton).mjava","sourceNew":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public Automaton convert(Automaton utf32) {\n    if (utf32.getNumStates() == 0) {\n      return utf32;\n    }\n\n    int[] map = new int[utf32.getNumStates()];\n    Arrays.fill(map, -1);\n\n    List<Integer> pending = new ArrayList<>();\n    int utf32State = 0;\n    pending.add(utf32State);\n    utf8 = new Automaton.Builder();\n       \n    int utf8State = utf8.createState();\n\n    utf8.setAccept(utf8State, utf32.isAccept(utf32State));\n\n    map[utf32State] = utf8State;\n    \n    Transition scratch = new Transition();\n    \n    while (pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State];\n      assert utf8State != -1;\n\n      int numTransitions = utf32.getNumTransitions(utf32State);\n      utf32.initTransition(utf32State, scratch);\n      //System.out.println(\"  convert state=\" + utf32State + \" numTransitions=\" + numTransitions);\n      for(int i=0;i<numTransitions;i++) {\n        utf32.getNextTransition(scratch);\n        int destUTF32 = scratch.dest;\n        int destUTF8 = map[destUTF32];\n        //System.out.println(\"    transition min=\" + scratch.min + \" max=\" + scratch.max);\n        if (destUTF8 == -1) {\n          destUTF8 = utf8.createState();\n          //System.out.println(\"      create dest=\" + destUTF8 +\" accept=\" + utf32.isAccept(destUTF32));\n          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));\n          map[destUTF32] = destUTF8;\n          pending.add(destUTF32);\n        }\n\n        // Writes new transitions into pendingTransitions:\n        convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);\n      }\n    }\n\n    return utf8.finish();\n  }\n\n","sourceOld":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public LightAutomaton convert(LightAutomaton utf32) {\n    if (utf32.getNumStates() == 0) {\n      return utf32;\n    }\n\n    int[] map = new int[utf32.getNumStates()];\n    Arrays.fill(map, -1);\n\n    List<Integer> pending = new ArrayList<>();\n    int utf32State = 0;\n    pending.add(utf32State);\n    utf8 = new LightAutomaton.Builder();\n       \n    int utf8State = utf8.createState();\n\n    utf8.setAccept(utf8State, utf32.isAccept(utf32State));\n\n    map[utf32State] = utf8State;\n    \n    Transition scratch = new Transition();\n    \n    while (pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State];\n      assert utf8State != -1;\n\n      int numTransitions = utf32.getNumTransitions(utf32State);\n      utf32.initTransition(utf32State, scratch);\n      //System.out.println(\"  convert state=\" + utf32State + \" numTransitions=\" + numTransitions);\n      for(int i=0;i<numTransitions;i++) {\n        utf32.getNextTransition(scratch);\n        int destUTF32 = scratch.dest;\n        int destUTF8 = map[destUTF32];\n        //System.out.println(\"    transition min=\" + scratch.min + \" max=\" + scratch.max);\n        if (destUTF8 == -1) {\n          destUTF8 = utf8.createState();\n          //System.out.println(\"      create dest=\" + destUTF8 +\" accept=\" + utf32.isAccept(destUTF32));\n          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));\n          map[destUTF32] = destUTF8;\n          pending.add(destUTF32);\n        }\n\n        // Writes new transitions into pendingTransitions:\n        convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);\n      }\n    }\n\n    return utf8.finish();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dece2a6aa33295eda8cfdd44c17b30f2b5a68cd1","date":1403000163,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8#convert(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8#convert(Automaton).mjava","sourceNew":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public Automaton convert(Automaton utf32) {\n    if (utf32.getNumStates() == 0) {\n      return utf32;\n    }\n\n    int[] map = new int[utf32.getNumStates()];\n    Arrays.fill(map, -1);\n\n    List<Integer> pending = new ArrayList<>();\n    int utf32State = 0;\n    pending.add(utf32State);\n    utf8 = new Automaton.Builder();\n       \n    int utf8State = utf8.createState();\n\n    utf8.setAccept(utf8State, utf32.isAccept(utf32State));\n\n    map[utf32State] = utf8State;\n    \n    Transition scratch = new Transition();\n    \n    while (pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State];\n      assert utf8State != -1;\n\n      int numTransitions = utf32.getNumTransitions(utf32State);\n      utf32.initTransition(utf32State, scratch);\n      for(int i=0;i<numTransitions;i++) {\n        utf32.getNextTransition(scratch);\n        int destUTF32 = scratch.dest;\n        int destUTF8 = map[destUTF32];\n        if (destUTF8 == -1) {\n          destUTF8 = utf8.createState();\n          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));\n          map[destUTF32] = destUTF8;\n          pending.add(destUTF32);\n        }\n\n        // Writes new transitions into pendingTransitions:\n        convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);\n      }\n    }\n\n    return utf8.finish();\n  }\n\n","sourceOld":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public Automaton convert(Automaton utf32) {\n    if (utf32.getNumStates() == 0) {\n      return utf32;\n    }\n\n    int[] map = new int[utf32.getNumStates()];\n    Arrays.fill(map, -1);\n\n    List<Integer> pending = new ArrayList<>();\n    int utf32State = 0;\n    pending.add(utf32State);\n    utf8 = new Automaton.Builder();\n       \n    int utf8State = utf8.createState();\n\n    utf8.setAccept(utf8State, utf32.isAccept(utf32State));\n\n    map[utf32State] = utf8State;\n    \n    Transition scratch = new Transition();\n    \n    while (pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State];\n      assert utf8State != -1;\n\n      int numTransitions = utf32.getNumTransitions(utf32State);\n      utf32.initTransition(utf32State, scratch);\n      //System.out.println(\"  convert state=\" + utf32State + \" numTransitions=\" + numTransitions);\n      for(int i=0;i<numTransitions;i++) {\n        utf32.getNextTransition(scratch);\n        int destUTF32 = scratch.dest;\n        int destUTF8 = map[destUTF32];\n        //System.out.println(\"    transition min=\" + scratch.min + \" max=\" + scratch.max);\n        if (destUTF8 == -1) {\n          destUTF8 = utf8.createState();\n          //System.out.println(\"      create dest=\" + destUTF8 +\" accept=\" + utf32.isAccept(destUTF32));\n          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));\n          map[destUTF32] = destUTF8;\n          pending.add(destUTF32);\n        }\n\n        // Writes new transitions into pendingTransitions:\n        convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);\n      }\n    }\n\n    return utf8.finish();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8#convert(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8#convert(Automaton).mjava","sourceNew":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public Automaton convert(Automaton utf32) {\n    if (utf32.getNumStates() == 0) {\n      return utf32;\n    }\n\n    int[] map = new int[utf32.getNumStates()];\n    Arrays.fill(map, -1);\n\n    List<Integer> pending = new ArrayList<>();\n    int utf32State = 0;\n    pending.add(utf32State);\n    utf8 = new Automaton.Builder();\n       \n    int utf8State = utf8.createState();\n\n    utf8.setAccept(utf8State, utf32.isAccept(utf32State));\n\n    map[utf32State] = utf8State;\n    \n    Transition scratch = new Transition();\n    \n    while (pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State];\n      assert utf8State != -1;\n\n      int numTransitions = utf32.getNumTransitions(utf32State);\n      utf32.initTransition(utf32State, scratch);\n      for(int i=0;i<numTransitions;i++) {\n        utf32.getNextTransition(scratch);\n        int destUTF32 = scratch.dest;\n        int destUTF8 = map[destUTF32];\n        if (destUTF8 == -1) {\n          destUTF8 = utf8.createState();\n          utf8.setAccept(destUTF8, utf32.isAccept(destUTF32));\n          map[destUTF32] = destUTF8;\n          pending.add(destUTF32);\n        }\n\n        // Writes new transitions into pendingTransitions:\n        convertOneEdge(utf8State, destUTF8, scratch.min, scratch.max);\n      }\n    }\n\n    return utf8.finish();\n  }\n\n","sourceOld":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public Automaton convert(Automaton utf32) {\n    if (utf32.isSingleton()) {\n      utf32 = utf32.cloneExpanded();\n    }\n\n    State[] map = new State[utf32.getNumberedStates().length];\n    List<State> pending = new ArrayList<>();\n    State utf32State = utf32.getInitialState();\n    pending.add(utf32State);\n    Automaton utf8 = new Automaton();\n    utf8.setDeterministic(false);\n\n    State utf8State = utf8.getInitialState();\n\n    utf8States = new State[5];\n    utf8StateCount = 0;\n    utf8State.number = utf8StateCount;\n    utf8States[utf8StateCount] = utf8State;\n    utf8StateCount++;\n\n    utf8State.setAccept(utf32State.isAccept());\n\n    map[utf32State.number] = utf8State;\n    \n    while(pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State.number];\n      for(int i=0;i<utf32State.numTransitions;i++) {\n        final Transition t = utf32State.transitionsArray[i];\n        final State destUTF32 = t.to;\n        State destUTF8 = map[destUTF32.number];\n        if (destUTF8 == null) {\n          destUTF8 = newUTF8State();\n          destUTF8.accept = destUTF32.accept;\n          map[destUTF32.number] = destUTF8;\n          pending.add(destUTF32);\n        }\n        convertOneEdge(utf8State, destUTF8, t.min, t.max);\n      }\n    }\n\n    utf8.setNumberedStates(utf8States, utf8StateCount);\n\n    return utf8;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"dece2a6aa33295eda8cfdd44c17b30f2b5a68cd1":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["7f4ef381bf0c2d618c6db830d3dd668c6901c05a"],"7f4ef381bf0c2d618c6db830d3dd668c6901c05a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"5c84485629d80d203608e8975a1139de9933cc38":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","dece2a6aa33295eda8cfdd44c17b30f2b5a68cd1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5c84485629d80d203608e8975a1139de9933cc38"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7f4ef381bf0c2d618c6db830d3dd668c6901c05a","5c84485629d80d203608e8975a1139de9933cc38"],"dece2a6aa33295eda8cfdd44c17b30f2b5a68cd1":["5c84485629d80d203608e8975a1139de9933cc38"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["dece2a6aa33295eda8cfdd44c17b30f2b5a68cd1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7f4ef381bf0c2d618c6db830d3dd668c6901c05a":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"5c84485629d80d203608e8975a1139de9933cc38":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}