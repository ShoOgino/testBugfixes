{"path":"lucene/queries/src/test/org/apache/lucene/queries/TermsFilterTest#testHashCodeAndEquals().mjava","commits":[{"id":"4107dd39b127d892359c5c1d67d0f14d92f1a9bf","date":1351689723,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/TermsFilterTest#testHashCodeAndEquals().mjava","pathOld":"/dev/null","sourceNew":"  public void testHashCodeAndEquals() {\n    int num = atLeast(100);\n    final boolean singleField = random().nextBoolean();\n    List<Term> terms = new ArrayList<Term>();\n    Set<Term> uniqueTerms = new HashSet<Term>();\n    for (int i = 0; i < num; i++) {\n      String field = \"field\" + (singleField ? \"1\" : random().nextInt(100));\n      String string = _TestUtil.randomRealisticUnicodeString(random());\n      terms.add(new Term(field, string));\n      uniqueTerms.add(new Term(field, string));\n      TermsFilter left = termsFilter(singleField ? random().nextBoolean() : false, uniqueTerms);\n      Collections.shuffle(terms, random());\n      TermsFilter right = termsFilter(singleField ? random().nextBoolean() : false, terms);\n      assertEquals(right, left);\n      assertEquals(right.hashCode(), left.hashCode());\n      if (i > 0) {\n        List<Term> asList = new ArrayList<Term>(uniqueTerms);\n        asList.remove(0);\n        TermsFilter notEqual = termsFilter(singleField ? random().nextBoolean() : false, asList);\n        assertFalse(left.equals(notEqual));\n        assertFalse(right.equals(notEqual));\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2aeaa47b6bcd5681cef55dfa7701d9293d6fde01","date":1351764077,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/TermsFilterTest#testHashCodeAndEquals().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/TermsFilterTest#testHashCodeAndEquals().mjava","sourceNew":"  public void testHashCodeAndEquals() {\n    int num = atLeast(100);\n    final boolean singleField = random().nextBoolean();\n    List<Term> terms = new ArrayList<Term>();\n    Set<Term> uniqueTerms = new HashSet<Term>();\n    for (int i = 0; i < num; i++) {\n      String field = \"field\" + (singleField ? \"1\" : random().nextInt(100));\n      String string = _TestUtil.randomRealisticUnicodeString(random());\n      terms.add(new Term(field, string));\n      uniqueTerms.add(new Term(field, string));\n      TermsFilter left = termsFilter(singleField ? random().nextBoolean() : false, uniqueTerms);\n      Collections.shuffle(terms, random());\n      TermsFilter right = termsFilter(singleField ? random().nextBoolean() : false, terms);\n      assertEquals(right, left);\n      assertEquals(right.hashCode(), left.hashCode());\n      if (uniqueTerms.size() > 1) {\n        List<Term> asList = new ArrayList<Term>(uniqueTerms);\n        asList.remove(0);\n        TermsFilter notEqual = termsFilter(singleField ? random().nextBoolean() : false, asList);\n        assertFalse(left.equals(notEqual));\n        assertFalse(right.equals(notEqual));\n      }\n    }\n  }\n\n","sourceOld":"  public void testHashCodeAndEquals() {\n    int num = atLeast(100);\n    final boolean singleField = random().nextBoolean();\n    List<Term> terms = new ArrayList<Term>();\n    Set<Term> uniqueTerms = new HashSet<Term>();\n    for (int i = 0; i < num; i++) {\n      String field = \"field\" + (singleField ? \"1\" : random().nextInt(100));\n      String string = _TestUtil.randomRealisticUnicodeString(random());\n      terms.add(new Term(field, string));\n      uniqueTerms.add(new Term(field, string));\n      TermsFilter left = termsFilter(singleField ? random().nextBoolean() : false, uniqueTerms);\n      Collections.shuffle(terms, random());\n      TermsFilter right = termsFilter(singleField ? random().nextBoolean() : false, terms);\n      assertEquals(right, left);\n      assertEquals(right.hashCode(), left.hashCode());\n      if (i > 0) {\n        List<Term> asList = new ArrayList<Term>(uniqueTerms);\n        asList.remove(0);\n        TermsFilter notEqual = termsFilter(singleField ? random().nextBoolean() : false, asList);\n        assertFalse(left.equals(notEqual));\n        assertFalse(right.equals(notEqual));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/TermsFilterTest#testHashCodeAndEquals().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/TermsFilterTest#testHashCodeAndEquals().mjava","sourceNew":"  public void testHashCodeAndEquals() {\n    int num = atLeast(100);\n    final boolean singleField = random().nextBoolean();\n    List<Term> terms = new ArrayList<Term>();\n    Set<Term> uniqueTerms = new HashSet<Term>();\n    for (int i = 0; i < num; i++) {\n      String field = \"field\" + (singleField ? \"1\" : random().nextInt(100));\n      String string = TestUtil.randomRealisticUnicodeString(random());\n      terms.add(new Term(field, string));\n      uniqueTerms.add(new Term(field, string));\n      TermsFilter left = termsFilter(singleField ? random().nextBoolean() : false, uniqueTerms);\n      Collections.shuffle(terms, random());\n      TermsFilter right = termsFilter(singleField ? random().nextBoolean() : false, terms);\n      assertEquals(right, left);\n      assertEquals(right.hashCode(), left.hashCode());\n      if (uniqueTerms.size() > 1) {\n        List<Term> asList = new ArrayList<Term>(uniqueTerms);\n        asList.remove(0);\n        TermsFilter notEqual = termsFilter(singleField ? random().nextBoolean() : false, asList);\n        assertFalse(left.equals(notEqual));\n        assertFalse(right.equals(notEqual));\n      }\n    }\n  }\n\n","sourceOld":"  public void testHashCodeAndEquals() {\n    int num = atLeast(100);\n    final boolean singleField = random().nextBoolean();\n    List<Term> terms = new ArrayList<Term>();\n    Set<Term> uniqueTerms = new HashSet<Term>();\n    for (int i = 0; i < num; i++) {\n      String field = \"field\" + (singleField ? \"1\" : random().nextInt(100));\n      String string = _TestUtil.randomRealisticUnicodeString(random());\n      terms.add(new Term(field, string));\n      uniqueTerms.add(new Term(field, string));\n      TermsFilter left = termsFilter(singleField ? random().nextBoolean() : false, uniqueTerms);\n      Collections.shuffle(terms, random());\n      TermsFilter right = termsFilter(singleField ? random().nextBoolean() : false, terms);\n      assertEquals(right, left);\n      assertEquals(right.hashCode(), left.hashCode());\n      if (uniqueTerms.size() > 1) {\n        List<Term> asList = new ArrayList<Term>(uniqueTerms);\n        asList.remove(0);\n        TermsFilter notEqual = termsFilter(singleField ? random().nextBoolean() : false, asList);\n        assertFalse(left.equals(notEqual));\n        assertFalse(right.equals(notEqual));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/TermsFilterTest#testHashCodeAndEquals().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/TermsFilterTest#testHashCodeAndEquals().mjava","sourceNew":"  public void testHashCodeAndEquals() {\n    int num = atLeast(100);\n    final boolean singleField = random().nextBoolean();\n    List<Term> terms = new ArrayList<>();\n    Set<Term> uniqueTerms = new HashSet<>();\n    for (int i = 0; i < num; i++) {\n      String field = \"field\" + (singleField ? \"1\" : random().nextInt(100));\n      String string = TestUtil.randomRealisticUnicodeString(random());\n      terms.add(new Term(field, string));\n      uniqueTerms.add(new Term(field, string));\n      TermsFilter left = termsFilter(singleField ? random().nextBoolean() : false, uniqueTerms);\n      Collections.shuffle(terms, random());\n      TermsFilter right = termsFilter(singleField ? random().nextBoolean() : false, terms);\n      assertEquals(right, left);\n      assertEquals(right.hashCode(), left.hashCode());\n      if (uniqueTerms.size() > 1) {\n        List<Term> asList = new ArrayList<>(uniqueTerms);\n        asList.remove(0);\n        TermsFilter notEqual = termsFilter(singleField ? random().nextBoolean() : false, asList);\n        assertFalse(left.equals(notEqual));\n        assertFalse(right.equals(notEqual));\n      }\n    }\n  }\n\n","sourceOld":"  public void testHashCodeAndEquals() {\n    int num = atLeast(100);\n    final boolean singleField = random().nextBoolean();\n    List<Term> terms = new ArrayList<Term>();\n    Set<Term> uniqueTerms = new HashSet<Term>();\n    for (int i = 0; i < num; i++) {\n      String field = \"field\" + (singleField ? \"1\" : random().nextInt(100));\n      String string = TestUtil.randomRealisticUnicodeString(random());\n      terms.add(new Term(field, string));\n      uniqueTerms.add(new Term(field, string));\n      TermsFilter left = termsFilter(singleField ? random().nextBoolean() : false, uniqueTerms);\n      Collections.shuffle(terms, random());\n      TermsFilter right = termsFilter(singleField ? random().nextBoolean() : false, terms);\n      assertEquals(right, left);\n      assertEquals(right.hashCode(), left.hashCode());\n      if (uniqueTerms.size() > 1) {\n        List<Term> asList = new ArrayList<Term>(uniqueTerms);\n        asList.remove(0);\n        TermsFilter notEqual = termsFilter(singleField ? random().nextBoolean() : false, asList);\n        assertFalse(left.equals(notEqual));\n        assertFalse(right.equals(notEqual));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2042d3e27841c5b60112990fc33559e10ccf6dd","date":1424537395,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/TermsQueryTest#testHashCodeAndEquals().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/TermsFilterTest#testHashCodeAndEquals().mjava","sourceNew":"  public void testHashCodeAndEquals() {\n    int num = atLeast(100);\n    final boolean singleField = random().nextBoolean();\n    List<Term> terms = new ArrayList<>();\n    Set<Term> uniqueTerms = new HashSet<>();\n    for (int i = 0; i < num; i++) {\n      String field = \"field\" + (singleField ? \"1\" : random().nextInt(100));\n      String string = TestUtil.randomRealisticUnicodeString(random());\n      terms.add(new Term(field, string));\n      uniqueTerms.add(new Term(field, string));\n      TermsQuery left = termsQuery(singleField ? random().nextBoolean() : false, uniqueTerms);\n      Collections.shuffle(terms, random());\n      TermsQuery right = termsQuery(singleField ? random().nextBoolean() : false, terms);\n      assertEquals(right, left);\n      assertEquals(right.hashCode(), left.hashCode());\n      if (uniqueTerms.size() > 1) {\n        List<Term> asList = new ArrayList<>(uniqueTerms);\n        asList.remove(0);\n        TermsQuery notEqual = termsQuery(singleField ? random().nextBoolean() : false, asList);\n        assertFalse(left.equals(notEqual));\n        assertFalse(right.equals(notEqual));\n      }\n    }\n  }\n\n","sourceOld":"  public void testHashCodeAndEquals() {\n    int num = atLeast(100);\n    final boolean singleField = random().nextBoolean();\n    List<Term> terms = new ArrayList<>();\n    Set<Term> uniqueTerms = new HashSet<>();\n    for (int i = 0; i < num; i++) {\n      String field = \"field\" + (singleField ? \"1\" : random().nextInt(100));\n      String string = TestUtil.randomRealisticUnicodeString(random());\n      terms.add(new Term(field, string));\n      uniqueTerms.add(new Term(field, string));\n      TermsFilter left = termsFilter(singleField ? random().nextBoolean() : false, uniqueTerms);\n      Collections.shuffle(terms, random());\n      TermsFilter right = termsFilter(singleField ? random().nextBoolean() : false, terms);\n      assertEquals(right, left);\n      assertEquals(right.hashCode(), left.hashCode());\n      if (uniqueTerms.size() > 1) {\n        List<Term> asList = new ArrayList<>(uniqueTerms);\n        asList.remove(0);\n        TermsFilter notEqual = termsFilter(singleField ? random().nextBoolean() : false, asList);\n        assertFalse(left.equals(notEqual));\n        assertFalse(right.equals(notEqual));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2aeaa47b6bcd5681cef55dfa7701d9293d6fde01":["4107dd39b127d892359c5c1d67d0f14d92f1a9bf"],"4107dd39b127d892359c5c1d67d0f14d92f1a9bf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"6613659748fe4411a7dcf85266e55db1f95f7315":["2aeaa47b6bcd5681cef55dfa7701d9293d6fde01"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c2042d3e27841c5b60112990fc33559e10ccf6dd":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c2042d3e27841c5b60112990fc33559e10ccf6dd"]},"commit2Childs":{"2aeaa47b6bcd5681cef55dfa7701d9293d6fde01":["6613659748fe4411a7dcf85266e55db1f95f7315"],"4107dd39b127d892359c5c1d67d0f14d92f1a9bf":["2aeaa47b6bcd5681cef55dfa7701d9293d6fde01"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c2042d3e27841c5b60112990fc33559e10ccf6dd"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4107dd39b127d892359c5c1d67d0f14d92f1a9bf"],"c2042d3e27841c5b60112990fc33559e10ccf6dd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}