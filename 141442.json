{"path":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.DocTermsCache#createValue(IndexReader,Entry).mjava","commits":[{"id":"be20f9fed1d3edcb1c84abcc39df87a90fab22df","date":1275590285,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.DocTermsCache#createValue(IndexReader,Entry).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.StringCache#createValue(IndexReader,Entry).mjava","sourceNew":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n\n      String field = StringHelper.intern(entryKey.field);\n      Terms terms = MultiFields.getTerms(reader, field);\n\n      final boolean fasterButMoreRAM = ((Boolean) entryKey.custom).booleanValue();\n\n      // Holds the actual term data, expanded.\n      final PagedBytes bytes = new PagedBytes(15);\n\n      int startBPV;\n\n      if (terms != null) {\n        // Try for coarse estimate for number of bits; this\n        // should be an underestimate most of the time, which\n        // is fine -- GrowableWriter will reallocate as needed\n        long numUniqueTerms = 0;\n        try {\n          numUniqueTerms = terms.getUniqueTermCount();\n        } catch (UnsupportedOperationException uoe) {\n          numUniqueTerms = -1;\n        }\n        if (numUniqueTerms != -1) {\n          startBPV = PackedInts.bitsRequired(numUniqueTerms*4);\n        } else {\n          startBPV = 1;\n        }\n      } else {\n        startBPV = 1;\n      }\n\n      final GrowableWriter docToOffset = new GrowableWriter(startBPV, reader.maxDoc(), fasterButMoreRAM);\n      \n      // pointer==0 means not set\n      bytes.copyUsingLengthPrefix(new BytesRef());\n\n      if (terms != null) {\n        final TermsEnum termsEnum = terms.iterator();\n        final Bits delDocs = MultiFields.getDeletedDocs(reader);\n        DocsEnum docs = null;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final long pointer = bytes.copyUsingLengthPrefix(term);\n          docs = termsEnum.docs(delDocs, docs);\n          while (true) {\n            final int docID = docs.nextDoc();\n            if (docID == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            docToOffset.set(docID, pointer);\n          }\n        }\n      }\n\n      // maybe an int-only impl?\n      return new DocTermsImpl(bytes.freeze(), docToOffset.getMutable());\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern(entryKey.field);\n      final String[] retArray = new String[reader.maxDoc()];\n\n      Terms terms = MultiFields.getTerms(reader, field);\n      if (terms != null) {\n        final TermsEnum termsEnum = terms.iterator();\n        final Bits delDocs = MultiFields.getDeletedDocs(reader);\n        DocsEnum docs = null;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          docs = termsEnum.docs(delDocs, docs);\n          final String termval = term.utf8ToString();\n          while (true) {\n            final int docID = docs.nextDoc();\n            if (docID == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            retArray[docID] = termval;\n          }\n        }\n      }\n      return retArray;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87697f76828e4cfc6dc898262de8898e5010703f","date":1276817002,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.DocTermsCache#createValue(IndexReader,Entry).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.DocTermsCache#createValue(IndexReader,Entry).mjava","sourceNew":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n\n      String field = StringHelper.intern(entryKey.field);\n      Terms terms = MultiFields.getTerms(reader, field);\n\n      final boolean fasterButMoreRAM = ((Boolean) entryKey.custom).booleanValue();\n\n      // Holds the actual term data, expanded.\n      final PagedBytes bytes = new PagedBytes(15);\n\n      int startBPV;\n\n      if (terms != null) {\n        // Try for coarse estimate for number of bits; this\n        // should be an underestimate most of the time, which\n        // is fine -- GrowableWriter will reallocate as needed\n        long numUniqueTerms = 0;\n        try {\n          numUniqueTerms = terms.getUniqueTermCount();\n        } catch (UnsupportedOperationException uoe) {\n          numUniqueTerms = -1;\n        }\n        if (numUniqueTerms != -1) {\n          startBPV = PackedInts.bitsRequired(numUniqueTerms*4);\n        } else {\n          startBPV = 1;\n        }\n      } else {\n        startBPV = 1;\n      }\n\n      final GrowableWriter docToOffset = new GrowableWriter(startBPV, reader.maxDoc(), fasterButMoreRAM);\n      \n      // pointer==0 means not set\n      bytes.copyUsingLengthPrefix(new BytesRef());\n\n      if (terms != null) {\n        final TermsEnum termsEnum = terms.iterator();\n        final Bits delDocs = MultiFields.getDeletedDocs(reader);\n        DocsEnum docs = null;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final long pointer = bytes.copyUsingLengthPrefix(term);\n          docs = termsEnum.docs(delDocs, docs);\n          while (true) {\n            final int docID = docs.nextDoc();\n            if (docID == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            docToOffset.set(docID, pointer);\n          }\n        }\n      }\n\n      // maybe an int-only impl?\n      return new DocTermsImpl(bytes.freeze(true), docToOffset.getMutable());\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n\n      String field = StringHelper.intern(entryKey.field);\n      Terms terms = MultiFields.getTerms(reader, field);\n\n      final boolean fasterButMoreRAM = ((Boolean) entryKey.custom).booleanValue();\n\n      // Holds the actual term data, expanded.\n      final PagedBytes bytes = new PagedBytes(15);\n\n      int startBPV;\n\n      if (terms != null) {\n        // Try for coarse estimate for number of bits; this\n        // should be an underestimate most of the time, which\n        // is fine -- GrowableWriter will reallocate as needed\n        long numUniqueTerms = 0;\n        try {\n          numUniqueTerms = terms.getUniqueTermCount();\n        } catch (UnsupportedOperationException uoe) {\n          numUniqueTerms = -1;\n        }\n        if (numUniqueTerms != -1) {\n          startBPV = PackedInts.bitsRequired(numUniqueTerms*4);\n        } else {\n          startBPV = 1;\n        }\n      } else {\n        startBPV = 1;\n      }\n\n      final GrowableWriter docToOffset = new GrowableWriter(startBPV, reader.maxDoc(), fasterButMoreRAM);\n      \n      // pointer==0 means not set\n      bytes.copyUsingLengthPrefix(new BytesRef());\n\n      if (terms != null) {\n        final TermsEnum termsEnum = terms.iterator();\n        final Bits delDocs = MultiFields.getDeletedDocs(reader);\n        DocsEnum docs = null;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final long pointer = bytes.copyUsingLengthPrefix(term);\n          docs = termsEnum.docs(delDocs, docs);\n          while (true) {\n            final int docID = docs.nextDoc();\n            if (docID == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            docToOffset.set(docID, pointer);\n          }\n        }\n      }\n\n      // maybe an int-only impl?\n      return new DocTermsImpl(bytes.freeze(), docToOffset.getMutable());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"03b0f4eb3bc61d48f2910ae15fd1457a3f907ff7","date":1277380640,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.DocTermsCache#createValue(IndexReader,Entry).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.DocTermsCache#createValue(IndexReader,Entry).mjava","sourceNew":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n\n      String field = StringHelper.intern(entryKey.field);\n      Terms terms = MultiFields.getTerms(reader, field);\n\n      final boolean fasterButMoreRAM = ((Boolean) entryKey.custom).booleanValue();\n\n      final int termCountHardLimit = reader.maxDoc();\n\n      // Holds the actual term data, expanded.\n      final PagedBytes bytes = new PagedBytes(15);\n\n      int startBPV;\n\n      if (terms != null) {\n        // Try for coarse estimate for number of bits; this\n        // should be an underestimate most of the time, which\n        // is fine -- GrowableWriter will reallocate as needed\n        long numUniqueTerms = 0;\n        try {\n          numUniqueTerms = terms.getUniqueTermCount();\n        } catch (UnsupportedOperationException uoe) {\n          numUniqueTerms = -1;\n        }\n        if (numUniqueTerms != -1) {\n          if (numUniqueTerms > termCountHardLimit) {\n            numUniqueTerms = termCountHardLimit;\n          }\n          startBPV = PackedInts.bitsRequired(numUniqueTerms*4);\n        } else {\n          startBPV = 1;\n        }\n      } else {\n        startBPV = 1;\n      }\n\n      final GrowableWriter docToOffset = new GrowableWriter(startBPV, reader.maxDoc(), fasterButMoreRAM);\n      \n      // pointer==0 means not set\n      bytes.copyUsingLengthPrefix(new BytesRef());\n\n      if (terms != null) {\n        int termCount = 0;\n        final TermsEnum termsEnum = terms.iterator();\n        final Bits delDocs = MultiFields.getDeletedDocs(reader);\n        DocsEnum docs = null;\n        while(true) {\n          if (termCount++ == termCountHardLimit) {\n            // app is misusing the API (there is more than\n            // one term per doc); in this case we make best\n            // effort to load what we can (see LUCENE-2142)\n            break;\n          }\n\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final long pointer = bytes.copyUsingLengthPrefix(term);\n          docs = termsEnum.docs(delDocs, docs);\n          while (true) {\n            final int docID = docs.nextDoc();\n            if (docID == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            docToOffset.set(docID, pointer);\n          }\n        }\n      }\n\n      // maybe an int-only impl?\n      return new DocTermsImpl(bytes.freeze(true), docToOffset.getMutable());\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n\n      String field = StringHelper.intern(entryKey.field);\n      Terms terms = MultiFields.getTerms(reader, field);\n\n      final boolean fasterButMoreRAM = ((Boolean) entryKey.custom).booleanValue();\n\n      // Holds the actual term data, expanded.\n      final PagedBytes bytes = new PagedBytes(15);\n\n      int startBPV;\n\n      if (terms != null) {\n        // Try for coarse estimate for number of bits; this\n        // should be an underestimate most of the time, which\n        // is fine -- GrowableWriter will reallocate as needed\n        long numUniqueTerms = 0;\n        try {\n          numUniqueTerms = terms.getUniqueTermCount();\n        } catch (UnsupportedOperationException uoe) {\n          numUniqueTerms = -1;\n        }\n        if (numUniqueTerms != -1) {\n          startBPV = PackedInts.bitsRequired(numUniqueTerms*4);\n        } else {\n          startBPV = 1;\n        }\n      } else {\n        startBPV = 1;\n      }\n\n      final GrowableWriter docToOffset = new GrowableWriter(startBPV, reader.maxDoc(), fasterButMoreRAM);\n      \n      // pointer==0 means not set\n      bytes.copyUsingLengthPrefix(new BytesRef());\n\n      if (terms != null) {\n        final TermsEnum termsEnum = terms.iterator();\n        final Bits delDocs = MultiFields.getDeletedDocs(reader);\n        DocsEnum docs = null;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final long pointer = bytes.copyUsingLengthPrefix(term);\n          docs = termsEnum.docs(delDocs, docs);\n          while (true) {\n            final int docID = docs.nextDoc();\n            if (docID == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            docToOffset.set(docID, pointer);\n          }\n        }\n      }\n\n      // maybe an int-only impl?\n      return new DocTermsImpl(bytes.freeze(true), docToOffset.getMutable());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.DocTermsCache#createValue(IndexReader,Entry).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.DocTermsCache#createValue(IndexReader,Entry).mjava","sourceNew":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n\n      String field = StringHelper.intern(entryKey.field);\n      Terms terms = MultiFields.getTerms(reader, field);\n\n      final boolean fasterButMoreRAM = ((Boolean) entryKey.custom).booleanValue();\n\n      final int termCountHardLimit = reader.maxDoc();\n\n      // Holds the actual term data, expanded.\n      final PagedBytes bytes = new PagedBytes(15);\n\n      int startBPV;\n\n      if (terms != null) {\n        // Try for coarse estimate for number of bits; this\n        // should be an underestimate most of the time, which\n        // is fine -- GrowableWriter will reallocate as needed\n        long numUniqueTerms = 0;\n        try {\n          numUniqueTerms = terms.getUniqueTermCount();\n        } catch (UnsupportedOperationException uoe) {\n          numUniqueTerms = -1;\n        }\n        if (numUniqueTerms != -1) {\n          if (numUniqueTerms > termCountHardLimit) {\n            numUniqueTerms = termCountHardLimit;\n          }\n          startBPV = PackedInts.bitsRequired(numUniqueTerms*4);\n        } else {\n          startBPV = 1;\n        }\n      } else {\n        startBPV = 1;\n      }\n\n      final GrowableWriter docToOffset = new GrowableWriter(startBPV, reader.maxDoc(), fasterButMoreRAM);\n      \n      // pointer==0 means not set\n      bytes.copyUsingLengthPrefix(new BytesRef());\n\n      if (terms != null) {\n        int termCount = 0;\n        final TermsEnum termsEnum = terms.iterator();\n        final Bits delDocs = MultiFields.getDeletedDocs(reader);\n        DocsEnum docs = null;\n        while(true) {\n          if (termCount++ == termCountHardLimit) {\n            // app is misusing the API (there is more than\n            // one term per doc); in this case we make best\n            // effort to load what we can (see LUCENE-2142)\n            break;\n          }\n\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final long pointer = bytes.copyUsingLengthPrefix(term);\n          docs = termsEnum.docs(delDocs, docs);\n          while (true) {\n            final int docID = docs.nextDoc();\n            if (docID == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            docToOffset.set(docID, pointer);\n          }\n        }\n      }\n\n      // maybe an int-only impl?\n      return new DocTermsImpl(bytes.freeze(true), docToOffset.getMutable());\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n\n      String field = StringHelper.intern(entryKey.field);\n      Terms terms = MultiFields.getTerms(reader, field);\n\n      final boolean fasterButMoreRAM = ((Boolean) entryKey.custom).booleanValue();\n\n      // Holds the actual term data, expanded.\n      final PagedBytes bytes = new PagedBytes(15);\n\n      int startBPV;\n\n      if (terms != null) {\n        // Try for coarse estimate for number of bits; this\n        // should be an underestimate most of the time, which\n        // is fine -- GrowableWriter will reallocate as needed\n        long numUniqueTerms = 0;\n        try {\n          numUniqueTerms = terms.getUniqueTermCount();\n        } catch (UnsupportedOperationException uoe) {\n          numUniqueTerms = -1;\n        }\n        if (numUniqueTerms != -1) {\n          startBPV = PackedInts.bitsRequired(numUniqueTerms*4);\n        } else {\n          startBPV = 1;\n        }\n      } else {\n        startBPV = 1;\n      }\n\n      final GrowableWriter docToOffset = new GrowableWriter(startBPV, reader.maxDoc(), fasterButMoreRAM);\n      \n      // pointer==0 means not set\n      bytes.copyUsingLengthPrefix(new BytesRef());\n\n      if (terms != null) {\n        final TermsEnum termsEnum = terms.iterator();\n        final Bits delDocs = MultiFields.getDeletedDocs(reader);\n        DocsEnum docs = null;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final long pointer = bytes.copyUsingLengthPrefix(term);\n          docs = termsEnum.docs(delDocs, docs);\n          while (true) {\n            final int docID = docs.nextDoc();\n            if (docID == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            docToOffset.set(docID, pointer);\n          }\n        }\n      }\n\n      // maybe an int-only impl?\n      return new DocTermsImpl(bytes.freeze(), docToOffset.getMutable());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eee9156bf08d7eaae5e8d8ab5f855ba61012e257","date":1285443157,"type":4,"author":"Ryan McKinley","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.DocTermsCache#createValue(IndexReader,Entry).mjava","sourceNew":null,"sourceOld":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n\n      String field = StringHelper.intern(entryKey.field);\n      Terms terms = MultiFields.getTerms(reader, field);\n\n      final boolean fasterButMoreRAM = ((Boolean) entryKey.custom).booleanValue();\n\n      final int termCountHardLimit = reader.maxDoc();\n\n      // Holds the actual term data, expanded.\n      final PagedBytes bytes = new PagedBytes(15);\n\n      int startBPV;\n\n      if (terms != null) {\n        // Try for coarse estimate for number of bits; this\n        // should be an underestimate most of the time, which\n        // is fine -- GrowableWriter will reallocate as needed\n        long numUniqueTerms = 0;\n        try {\n          numUniqueTerms = terms.getUniqueTermCount();\n        } catch (UnsupportedOperationException uoe) {\n          numUniqueTerms = -1;\n        }\n        if (numUniqueTerms != -1) {\n          if (numUniqueTerms > termCountHardLimit) {\n            numUniqueTerms = termCountHardLimit;\n          }\n          startBPV = PackedInts.bitsRequired(numUniqueTerms*4);\n        } else {\n          startBPV = 1;\n        }\n      } else {\n        startBPV = 1;\n      }\n\n      final GrowableWriter docToOffset = new GrowableWriter(startBPV, reader.maxDoc(), fasterButMoreRAM);\n      \n      // pointer==0 means not set\n      bytes.copyUsingLengthPrefix(new BytesRef());\n\n      if (terms != null) {\n        int termCount = 0;\n        final TermsEnum termsEnum = terms.iterator();\n        final Bits delDocs = MultiFields.getDeletedDocs(reader);\n        DocsEnum docs = null;\n        while(true) {\n          if (termCount++ == termCountHardLimit) {\n            // app is misusing the API (there is more than\n            // one term per doc); in this case we make best\n            // effort to load what we can (see LUCENE-2142)\n            break;\n          }\n\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final long pointer = bytes.copyUsingLengthPrefix(term);\n          docs = termsEnum.docs(delDocs, docs);\n          while (true) {\n            final int docID = docs.nextDoc();\n            if (docID == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            docToOffset.set(docID, pointer);\n          }\n        }\n      }\n\n      // maybe an int-only impl?\n      return new DocTermsImpl(bytes.freeze(true), docToOffset.getMutable());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":4,"author":"Michael Busch","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.DocTermsCache#createValue(IndexReader,Entry).mjava","sourceNew":null,"sourceOld":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n\n      String field = StringHelper.intern(entryKey.field);\n      Terms terms = MultiFields.getTerms(reader, field);\n\n      final boolean fasterButMoreRAM = ((Boolean) entryKey.custom).booleanValue();\n\n      final int termCountHardLimit = reader.maxDoc();\n\n      // Holds the actual term data, expanded.\n      final PagedBytes bytes = new PagedBytes(15);\n\n      int startBPV;\n\n      if (terms != null) {\n        // Try for coarse estimate for number of bits; this\n        // should be an underestimate most of the time, which\n        // is fine -- GrowableWriter will reallocate as needed\n        long numUniqueTerms = 0;\n        try {\n          numUniqueTerms = terms.getUniqueTermCount();\n        } catch (UnsupportedOperationException uoe) {\n          numUniqueTerms = -1;\n        }\n        if (numUniqueTerms != -1) {\n          if (numUniqueTerms > termCountHardLimit) {\n            numUniqueTerms = termCountHardLimit;\n          }\n          startBPV = PackedInts.bitsRequired(numUniqueTerms*4);\n        } else {\n          startBPV = 1;\n        }\n      } else {\n        startBPV = 1;\n      }\n\n      final GrowableWriter docToOffset = new GrowableWriter(startBPV, reader.maxDoc(), fasterButMoreRAM);\n      \n      // pointer==0 means not set\n      bytes.copyUsingLengthPrefix(new BytesRef());\n\n      if (terms != null) {\n        int termCount = 0;\n        final TermsEnum termsEnum = terms.iterator();\n        final Bits delDocs = MultiFields.getDeletedDocs(reader);\n        DocsEnum docs = null;\n        while(true) {\n          if (termCount++ == termCountHardLimit) {\n            // app is misusing the API (there is more than\n            // one term per doc); in this case we make best\n            // effort to load what we can (see LUCENE-2142)\n            break;\n          }\n\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final long pointer = bytes.copyUsingLengthPrefix(term);\n          docs = termsEnum.docs(delDocs, docs);\n          while (true) {\n            final int docID = docs.nextDoc();\n            if (docID == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            docToOffset.set(docID, pointer);\n          }\n        }\n      }\n\n      // maybe an int-only impl?\n      return new DocTermsImpl(bytes.freeze(true), docToOffset.getMutable());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"eee9156bf08d7eaae5e8d8ab5f855ba61012e257":["03b0f4eb3bc61d48f2910ae15fd1457a3f907ff7"],"87697f76828e4cfc6dc898262de8898e5010703f":["be20f9fed1d3edcb1c84abcc39df87a90fab22df"],"be20f9fed1d3edcb1c84abcc39df87a90fab22df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5f4e87790277826a2aea119328600dfb07761f32":["be20f9fed1d3edcb1c84abcc39df87a90fab22df","03b0f4eb3bc61d48f2910ae15fd1457a3f907ff7"],"03b0f4eb3bc61d48f2910ae15fd1457a3f907ff7":["87697f76828e4cfc6dc898262de8898e5010703f"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","eee9156bf08d7eaae5e8d8ab5f855ba61012e257"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["eee9156bf08d7eaae5e8d8ab5f855ba61012e257"]},"commit2Childs":{"eee9156bf08d7eaae5e8d8ab5f855ba61012e257":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"87697f76828e4cfc6dc898262de8898e5010703f":["03b0f4eb3bc61d48f2910ae15fd1457a3f907ff7"],"be20f9fed1d3edcb1c84abcc39df87a90fab22df":["87697f76828e4cfc6dc898262de8898e5010703f","5f4e87790277826a2aea119328600dfb07761f32"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["be20f9fed1d3edcb1c84abcc39df87a90fab22df"],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"03b0f4eb3bc61d48f2910ae15fd1457a3f907ff7":["eee9156bf08d7eaae5e8d8ab5f855ba61012e257","5f4e87790277826a2aea119328600dfb07761f32"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}