{"path":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doContinue().mjava","commits":[{"id":"163fe85a71d778fd2b7747f65ca27b54829e2e57","date":1279898785,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doContinue().mjava","pathOld":"/dev/null","sourceNew":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copy(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b103252dee6afa1b6d7a622c773d178788eb85a","date":1280180143,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doContinue().mjava","pathOld":"/dev/null","sourceNew":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copy(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3242a09f703274d3b9283f2064a1a33064b53a1b","date":1280263474,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doContinue().mjava","pathOld":"/dev/null","sourceNew":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copy(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"825bcb488bc228d1fb6a19c1f441a2181f7d766d","date":1285691504,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doContinue().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doContinue().mjava","sourceNew":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copy(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","sourceOld":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copy(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doContinue().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doContinue().mjava","sourceNew":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copy(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","sourceOld":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copy(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doContinue().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doContinue().mjava","sourceNew":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copy(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","sourceOld":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copy(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["825bcb488bc228d1fb6a19c1f441a2181f7d766d"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4b103252dee6afa1b6d7a622c773d178788eb85a"],"4b103252dee6afa1b6d7a622c773d178788eb85a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","163fe85a71d778fd2b7747f65ca27b54829e2e57"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"825bcb488bc228d1fb6a19c1f441a2181f7d766d":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["3242a09f703274d3b9283f2064a1a33064b53a1b","825bcb488bc228d1fb6a19c1f441a2181f7d766d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b91922b55d15444d554721b352861d028eb8278"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"4b103252dee6afa1b6d7a622c773d178788eb85a":["3242a09f703274d3b9283f2064a1a33064b53a1b","825bcb488bc228d1fb6a19c1f441a2181f7d766d"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"825bcb488bc228d1fb6a19c1f441a2181f7d766d":["7b91922b55d15444d554721b352861d028eb8278","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3242a09f703274d3b9283f2064a1a33064b53a1b","4b103252dee6afa1b6d7a622c773d178788eb85a","163fe85a71d778fd2b7747f65ca27b54829e2e57"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}