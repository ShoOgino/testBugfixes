{"path":"lucene/src/test/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"src/test/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,EXPLAIN_SCORE_TOLERANCE_DELTA);\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, no matter what the description says, \n        // just verify contained expl has same score\n        verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase();\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,EXPLAIN_SCORE_TOLERANCE_DELTA);\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,EXPLAIN_SCORE_TOLERANCE_DELTA);\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, no matter what the description says, \n        // just verify contained expl has same score\n        verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase();\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,EXPLAIN_SCORE_TOLERANCE_DELTA);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce","date":1297021734,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,EXPLAIN_SCORE_TOLERANCE_DELTA);\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, no matter what the description says, \n        // just verify contained expl has same score\n        verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase();\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,EXPLAIN_SCORE_TOLERANCE_DELTA);\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,EXPLAIN_SCORE_TOLERANCE_DELTA);\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, no matter what the description says, \n        // just verify contained expl has same score\n        verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase();\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,EXPLAIN_SCORE_TOLERANCE_DELTA);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,EXPLAIN_SCORE_TOLERANCE_DELTA);\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, no matter what the description says, \n        // just verify contained expl has same score\n        verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase();\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,EXPLAIN_SCORE_TOLERANCE_DELTA);\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,EXPLAIN_SCORE_TOLERANCE_DELTA);\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, no matter what the description says, \n        // just verify contained expl has same score\n        verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase();\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,EXPLAIN_SCORE_TOLERANCE_DELTA);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":5,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,EXPLAIN_SCORE_TOLERANCE_DELTA);\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, no matter what the description says, \n        // just verify contained expl has same score\n        verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase();\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,EXPLAIN_SCORE_TOLERANCE_DELTA);\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,EXPLAIN_SCORE_TOLERANCE_DELTA);\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, no matter what the description says, \n        // just verify contained expl has same score\n        verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase();\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,EXPLAIN_SCORE_TOLERANCE_DELTA);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"29ef99d61cda9641b6250bf9567329a6e65f901d":["9454a6510e2db155fb01faa5c049b06ece95fab9","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["9454a6510e2db155fb01faa5c049b06ece95fab9","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}