{"path":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac34f0c5bb9274821fb0cb18075234e02002e9bf","date":1402508126,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    final int numTransitions = lightAutomaton.getNumTransitions(state);\n    lightAutomaton.initTransition(state, transition);\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < numTransitions; i++) {\n      lightAutomaton.getNextTransition(transition);\n      if (transition.max >= c) {\n        int nextChar = Math.max(c, transition.min);\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.dest;\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          lightAutomaton.initTransition(state, transition);\n          lightAutomaton.getNextTransition(transition);\n          state = transition.dest;\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.min;\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    final int numTransitions = automaton.getNumTransitions(state);\n    automaton.initTransition(state, transition);\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < numTransitions; i++) {\n      automaton.getNextTransition(transition);\n      if (transition.max >= c) {\n        int nextChar = Math.max(c, transition.min);\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.dest;\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          automaton.initTransition(state, transition);\n          automaton.getNextTransition(transition);\n          state = transition.dest;\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.min;\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    final int numTransitions = lightAutomaton.getNumTransitions(state);\n    lightAutomaton.initTransition(state, transition);\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < numTransitions; i++) {\n      lightAutomaton.getNextTransition(transition);\n      if (transition.max >= c) {\n        int nextChar = Math.max(c, transition.min);\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.dest;\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          lightAutomaton.initTransition(state, transition);\n          lightAutomaton.getNextTransition(transition);\n          state = transition.dest;\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.min;\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    final int numTransitions = automaton.getNumTransitions(state);\n    automaton.initTransition(state, transition);\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < numTransitions; i++) {\n      automaton.getNextTransition(transition);\n      if (transition.max >= c) {\n        int nextChar = Math.max(c, transition.min);\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.dest;\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          automaton.initTransition(state, transition);\n          automaton.getNextTransition(transition);\n          state = transition.dest;\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.min;\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length()) {\n      c = seekBytesRef.byteAt(position) & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.setLength(position);\n    visited[state] = curGen;\n\n    final int numTransitions = automaton.getNumTransitions(state);\n    automaton.initTransition(state, transition);\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < numTransitions; i++) {\n      automaton.getNextTransition(transition);\n      if (transition.max >= c) {\n        int nextChar = Math.max(c, transition.min);\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length() + 1);\n        seekBytesRef.append((byte) nextChar);\n        state = transition.dest;\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          automaton.initTransition(state, transition);\n          automaton.getNextTransition(transition);\n          state = transition.dest;\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length() + 1);\n          seekBytesRef.append((byte) transition.min);\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length()-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    final int numTransitions = automaton.getNumTransitions(state);\n    automaton.initTransition(state, transition);\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < numTransitions; i++) {\n      automaton.getNextTransition(transition);\n      if (transition.max >= c) {\n        int nextChar = Math.max(c, transition.min);\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.dest;\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          automaton.initTransition(state, transition);\n          automaton.getNextTransition(transition);\n          state = transition.dest;\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.min;\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":["ac34f0c5bb9274821fb0cb18075234e02002e9bf","bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7","5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"20a5c56c8be07b6993c34c9f1a02fe0ff4cc6f14","date":1582882926,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length()) {\n      c = seekBytesRef.byteAt(position) & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.setLength(position);\n    setVisited(state);\n\n    final int numTransitions = automaton.getNumTransitions(state);\n    automaton.initTransition(state, transition);\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < numTransitions; i++) {\n      automaton.getNextTransition(transition);\n      if (transition.max >= c) {\n        int nextChar = Math.max(c, transition.min);\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length() + 1);\n        seekBytesRef.append((byte) nextChar);\n        state = transition.dest;\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (!isVisited(state) && !runAutomaton.isAccept(state)) {\n          setVisited(state);\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          automaton.initTransition(state, transition);\n          automaton.getNextTransition(transition);\n          state = transition.dest;\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length() + 1);\n          seekBytesRef.append((byte) transition.min);\n          \n          // we found a loop, record it for faster enumeration\n          if (!linear && isVisited(state)) {\n            setLinear(seekBytesRef.length()-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length()) {\n      c = seekBytesRef.byteAt(position) & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.setLength(position);\n    visited[state] = curGen;\n\n    final int numTransitions = automaton.getNumTransitions(state);\n    automaton.initTransition(state, transition);\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < numTransitions; i++) {\n      automaton.getNextTransition(transition);\n      if (transition.max >= c) {\n        int nextChar = Math.max(c, transition.min);\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length() + 1);\n        seekBytesRef.append((byte) nextChar);\n        state = transition.dest;\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          automaton.initTransition(state, transition);\n          automaton.getNextTransition(transition);\n          state = transition.dest;\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length() + 1);\n          seekBytesRef.append((byte) transition.min);\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length()-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["5c84485629d80d203608e8975a1139de9933cc38"],"20a5c56c8be07b6993c34c9f1a02fe0ff4cc6f14":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"5c84485629d80d203608e8975a1139de9933cc38":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["20a5c56c8be07b6993c34c9f1a02fe0ff4cc6f14"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5c84485629d80d203608e8975a1139de9933cc38","ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["5c84485629d80d203608e8975a1139de9933cc38"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["20a5c56c8be07b6993c34c9f1a02fe0ff4cc6f14"],"5c84485629d80d203608e8975a1139de9933cc38":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"20a5c56c8be07b6993c34c9f1a02fe0ff4cc6f14":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}