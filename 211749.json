{"path":"lucene/sandbox/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testGlobalVersions().mjava","commits":[{"id":"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e","date":1400786907,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testGlobalVersions().mjava","pathOld":"lucene/codecs/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testGlobalVersions().mjava","sourceNew":"  // Simulates optimistic concurrency in a distributed indexing app and confirms the latest version always wins:\n  public void testGlobalVersions() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    IDSource idsSource = getRandomIDs();\n    int numIDs = atLeast(100);\n    System.out.println(\"ids=\" + numIDs);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numIDs + \" ids\");\n    }\n    Set<String> idsSeen = new HashSet<String>();\n    while (idsSeen.size() < numIDs) {\n      idsSeen.add(idsSource.next());\n    }\n    final String[] ids = idsSeen.toArray(new String[numIDs]);\n\n    final Object[] locks = new Object[ids.length];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    final AtomicLong nextVersion = new AtomicLong();\n\n    final SearcherManager mgr = new SearcherManager(w.w, true, new SearcherFactory());\n\n    final Long missingValue = -1L;\n\n    final LiveFieldValues<IndexSearcher,Long> versionValues = new LiveFieldValues<IndexSearcher,Long>(mgr, missingValue) {\n      @Override\n      protected Long lookupFromSearcher(IndexSearcher s, String id) {\n        // TODO: would be cleaner if we could do our PerThreadLookup here instead of \"up above\":\n        // We always return missing: the caller then does a lookup against the current reader\n        return missingValue;\n      }\n    };\n\n    // Maps to the version the id was lasted indexed with:\n    final Map<String,Long> truth = new ConcurrentHashMap<>();\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 7)];\n\n    final int versionType = random().nextInt(3);\n\n    if (VERBOSE) {\n      if (versionType == 0) {\n        System.out.println(\"TEST: use random versions\");\n      } else if (versionType == 1) {\n        System.out.println(\"TEST: use monotonic versions\");\n      } else {\n        System.out.println(\"TEST: use nanotime versions\");\n      }\n    }\n\n    // Run for 3 sec in normal tests, else 60 seconds for nightly:\n    final long stopTime = System.currentTimeMillis() + (TEST_NIGHTLY ? 60000 : 3000);\n\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              runForReal();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void runForReal() throws IOException, InterruptedException {\n            startingGun.await();\n            PerThreadVersionPKLookup lookup = null;\n            IndexReader lookupReader = null;\n            while (System.currentTimeMillis() < stopTime) {\n\n              // Intentionally pull version first, and then sleep/yield, to provoke version conflicts:\n              long newVersion;\n              if (versionType == 0) {\n                // Random:\n                newVersion = random().nextLong() & 0x7fffffffffffffffL;\n              } else if (versionType == 1) {\n                // Monotonic\n                newVersion = nextVersion.getAndIncrement();\n              } else {\n                newVersion = System.nanoTime();\n              }\n\n              if (versionType != 0) {\n                if (random().nextBoolean()) {\n                  Thread.yield();\n                } else {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 4));\n                }\n              }\n\n              int x = random().nextInt(ids.length);\n\n              // TODO: we could relax this, if e.g. we assign indexer thread based on ID.  This would ensure a given ID cannot be indexed at\n              // the same time in multiple threads:\n\n              // Only one thread can update an ID at once:\n              synchronized (locks[x]) {\n\n                String id = ids[x];\n\n                // We will attempt to index id with newVersion, but only do so if id wasn't yet indexed, or it was indexed with an older\n                // version (< newVersion):\n\n                // Must lookup the RT value before pulling from the index, in case a reopen happens just after we lookup:\n                Long currentVersion = versionValues.get(id);\n\n                IndexSearcher s = mgr.acquire();\n                try {\n                  if (VERBOSE) System.out.println(\"\\n\" + Thread.currentThread().getName() + \": update id=\" + id + \" newVersion=\" + newVersion);\n\n                  if (lookup == null || lookupReader != s.getIndexReader()) {\n                    // TODO: sort of messy; we could add reopen to PerThreadVersionPKLookup?\n                    // TODO: this is thin ice .... that we don't incRef/decRef this reader we are implicitly holding onto:\n                    lookupReader = s.getIndexReader();\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \": open new PK lookup reader=\" + lookupReader);\n                    lookup = new PerThreadVersionPKLookup(lookupReader, \"id\");\n                  }\n\n                  Long truthVersion = truth.get(id);\n                  if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   truthVersion=\" + truthVersion);\n\n                  boolean doIndex;\n                  if (currentVersion == missingValue) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in RT cache\");\n                    int otherDocID = lookup.lookup(new BytesRef(id), newVersion+1);\n                    if (otherDocID == -1) {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in index, or version is <= newVersion; will index\");\n                      doIndex = true;\n                    } else {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in index with version=\" + lookup.getVersion() + \"; will not index\");\n                      doIndex = false;\n                      if (truthVersion.longValue() !=lookup.getVersion()) {\n                        System.out.println(Thread.currentThread() + \": now fail0!\");\n                      }\n                      assertEquals(truthVersion.longValue(), lookup.getVersion());\n                    }\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in RT cache: currentVersion=\" + currentVersion);\n                    doIndex = newVersion > currentVersion;\n                  }\n\n                  if (doIndex) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   now index\");\n                    boolean passes = truthVersion == null || truthVersion.longValue() <= newVersion;\n                    if (passes == false) {\n                      System.out.println(Thread.currentThread() + \": now fail!\");\n                    }\n                    assertTrue(passes);\n                    Document doc = new Document();\n                    doc.add(makeIDField(id, newVersion));\n                    w.updateDocument(new Term(\"id\", id), doc);\n                    truth.put(id, newVersion);\n                    versionValues.add(id, newVersion);\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   skip index\");\n                    assertNotNull(truthVersion);\n                    assertTrue(truthVersion.longValue() >= newVersion);\n                  }\n                } finally {\n                  mgr.release(s);\n                }\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n\n    // Keep reopening the NRT reader until all indexing threads are done:\n    refreshLoop:\n    while (true) {\n      Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n      mgr.maybeRefresh();\n      for (Thread thread : threads) {\n        if (thread.isAlive()) {\n          continue refreshLoop;\n        }\n      }\n\n      break;\n    }\n\n    // Verify final index against truth:\n    for(int i=0;i<2;i++) {\n      mgr.maybeRefresh();\n      IndexSearcher s = mgr.acquire();\n      try {\n        IndexReader r = s.getIndexReader();\n        // cannot assert this: maybe not all IDs were indexed\n        /*\n        assertEquals(numIDs, r.numDocs());\n        if (i == 1) {\n          // After forceMerge no deleted docs:\n          assertEquals(numIDs, r.maxDoc());\n        }\n        */\n        PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n        for(Map.Entry<String,Long> ent : truth.entrySet()) {\n          assertTrue(lookup.lookup(new BytesRef(ent.getKey()), -1L) != -1);\n          assertEquals(ent.getValue().longValue(), lookup.getVersion());\n        }\n      } finally {\n        mgr.release(s);\n      }\n\n      if (i == 1) {\n        break;\n      }\n\n      // forceMerge and verify again\n      w.forceMerge(1);\n    }\n\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Simulates optimistic concurrency in a distributed indexing app and confirms the latest version always wins:\n  public void testGlobalVersions() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    IDSource idsSource = getRandomIDs();\n    int numIDs = atLeast(100);\n    System.out.println(\"ids=\" + numIDs);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numIDs + \" ids\");\n    }\n    Set<String> idsSeen = new HashSet<String>();\n    while (idsSeen.size() < numIDs) {\n      idsSeen.add(idsSource.next());\n    }\n    final String[] ids = idsSeen.toArray(new String[numIDs]);\n\n    final Object[] locks = new Object[ids.length];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    final AtomicLong nextVersion = new AtomicLong();\n\n    final SearcherManager mgr = new SearcherManager(w.w, true, new SearcherFactory());\n\n    final Long missingValue = -1L;\n\n    final LiveFieldValues<IndexSearcher,Long> versionValues = new LiveFieldValues<IndexSearcher,Long>(mgr, missingValue) {\n      @Override\n      protected Long lookupFromSearcher(IndexSearcher s, String id) {\n        // TODO: would be cleaner if we could do our PerThreadLookup here instead of \"up above\":\n        // We always return missing: the caller then does a lookup against the current reader\n        return missingValue;\n      }\n    };\n\n    // Maps to the version the id was lasted indexed with:\n    final Map<String,Long> truth = new ConcurrentHashMap<>();\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 7)];\n\n    final int versionType = random().nextInt(3);\n\n    if (VERBOSE) {\n      if (versionType == 0) {\n        System.out.println(\"TEST: use random versions\");\n      } else if (versionType == 1) {\n        System.out.println(\"TEST: use monotonic versions\");\n      } else {\n        System.out.println(\"TEST: use nanotime versions\");\n      }\n    }\n\n    // Run for 3 sec in normal tests, else 60 seconds for nightly:\n    final long stopTime = System.currentTimeMillis() + (TEST_NIGHTLY ? 60000 : 3000);\n\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              runForReal();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void runForReal() throws IOException, InterruptedException {\n            startingGun.await();\n            PerThreadVersionPKLookup lookup = null;\n            IndexReader lookupReader = null;\n            while (System.currentTimeMillis() < stopTime) {\n\n              // Intentionally pull version first, and then sleep/yield, to provoke version conflicts:\n              long newVersion;\n              if (versionType == 0) {\n                // Random:\n                newVersion = random().nextLong() & 0x7fffffffffffffffL;\n              } else if (versionType == 1) {\n                // Monotonic\n                newVersion = nextVersion.getAndIncrement();\n              } else {\n                newVersion = System.nanoTime();\n              }\n\n              if (versionType != 0) {\n                if (random().nextBoolean()) {\n                  Thread.yield();\n                } else {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 4));\n                }\n              }\n\n              int x = random().nextInt(ids.length);\n\n              // TODO: we could relax this, if e.g. we assign indexer thread based on ID.  This would ensure a given ID cannot be indexed at\n              // the same time in multiple threads:\n\n              // Only one thread can update an ID at once:\n              synchronized (locks[x]) {\n\n                String id = ids[x];\n\n                // We will attempt to index id with newVersion, but only do so if id wasn't yet indexed, or it was indexed with an older\n                // version (< newVersion):\n\n                // Must lookup the RT value before pulling from the index, in case a reopen happens just after we lookup:\n                Long currentVersion = versionValues.get(id);\n\n                IndexSearcher s = mgr.acquire();\n                try {\n                  if (VERBOSE) System.out.println(\"\\n\" + Thread.currentThread().getName() + \": update id=\" + id + \" newVersion=\" + newVersion);\n\n                  if (lookup == null || lookupReader != s.getIndexReader()) {\n                    // TODO: sort of messy; we could add reopen to PerThreadVersionPKLookup?\n                    // TODO: this is thin ice .... that we don't incRef/decRef this reader we are implicitly holding onto:\n                    lookupReader = s.getIndexReader();\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \": open new PK lookup reader=\" + lookupReader);\n                    lookup = new PerThreadVersionPKLookup(lookupReader, \"id\");\n                  }\n\n                  Long truthVersion = truth.get(id);\n                  if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   truthVersion=\" + truthVersion);\n\n                  boolean doIndex;\n                  if (currentVersion == missingValue) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in RT cache\");\n                    int otherDocID = lookup.lookup(new BytesRef(id), newVersion+1);\n                    if (otherDocID == -1) {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in index, or version is <= newVersion; will index\");\n                      doIndex = true;\n                    } else {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in index with version=\" + lookup.getVersion() + \"; will not index\");\n                      doIndex = false;\n                      if (truthVersion.longValue() !=lookup.getVersion()) {\n                        System.out.println(Thread.currentThread() + \": now fail0!\");\n                      }\n                      assertEquals(truthVersion.longValue(), lookup.getVersion());\n                    }\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in RT cache: currentVersion=\" + currentVersion);\n                    doIndex = newVersion > currentVersion;\n                  }\n\n                  if (doIndex) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   now index\");\n                    boolean passes = truthVersion == null || truthVersion.longValue() <= newVersion;\n                    if (passes == false) {\n                      System.out.println(Thread.currentThread() + \": now fail!\");\n                    }\n                    assertTrue(passes);\n                    Document doc = new Document();\n                    doc.add(makeIDField(id, newVersion));\n                    w.updateDocument(new Term(\"id\", id), doc);\n                    truth.put(id, newVersion);\n                    versionValues.add(id, newVersion);\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   skip index\");\n                    assertNotNull(truthVersion);\n                    assertTrue(truthVersion.longValue() >= newVersion);\n                  }\n                } finally {\n                  mgr.release(s);\n                }\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n\n    // Keep reopening the NRT reader until all indexing threads are done:\n    refreshLoop:\n    while (true) {\n      Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n      mgr.maybeRefresh();\n      for (Thread thread : threads) {\n        if (thread.isAlive()) {\n          continue refreshLoop;\n        }\n      }\n\n      break;\n    }\n\n    // Verify final index against truth:\n    for(int i=0;i<2;i++) {\n      mgr.maybeRefresh();\n      IndexSearcher s = mgr.acquire();\n      try {\n        IndexReader r = s.getIndexReader();\n        // cannot assert this: maybe not all IDs were indexed\n        /*\n        assertEquals(numIDs, r.numDocs());\n        if (i == 1) {\n          // After forceMerge no deleted docs:\n          assertEquals(numIDs, r.maxDoc());\n        }\n        */\n        PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n        for(Map.Entry<String,Long> ent : truth.entrySet()) {\n          assertTrue(lookup.lookup(new BytesRef(ent.getKey()), -1L) != -1);\n          assertEquals(ent.getValue().longValue(), lookup.getVersion());\n        }\n      } finally {\n        mgr.release(s);\n      }\n\n      if (i == 1) {\n        break;\n      }\n\n      // forceMerge and verify again\n      w.forceMerge(1);\n    }\n\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9017ec91c7e47796f2938c5f5705089cb048c4ae","date":1400795272,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testGlobalVersions().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testGlobalVersions().mjava","sourceNew":"  // Simulates optimistic concurrency in a distributed indexing app and confirms the latest version always wins:\n  public void testGlobalVersions() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    IDSource idsSource = getRandomIDs();\n    int numIDs = atLeast(100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numIDs + \" ids\");\n    }\n    Set<String> idsSeen = new HashSet<String>();\n    while (idsSeen.size() < numIDs) {\n      idsSeen.add(idsSource.next());\n    }\n    final String[] ids = idsSeen.toArray(new String[numIDs]);\n\n    final Object[] locks = new Object[ids.length];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    final AtomicLong nextVersion = new AtomicLong();\n\n    final SearcherManager mgr = new SearcherManager(w.w, true, new SearcherFactory());\n\n    final Long missingValue = -1L;\n\n    final LiveFieldValues<IndexSearcher,Long> versionValues = new LiveFieldValues<IndexSearcher,Long>(mgr, missingValue) {\n      @Override\n      protected Long lookupFromSearcher(IndexSearcher s, String id) {\n        // TODO: would be cleaner if we could do our PerThreadLookup here instead of \"up above\":\n        // We always return missing: the caller then does a lookup against the current reader\n        return missingValue;\n      }\n    };\n\n    // Maps to the version the id was lasted indexed with:\n    final Map<String,Long> truth = new ConcurrentHashMap<>();\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 7)];\n\n    final int versionType = random().nextInt(3);\n\n    if (VERBOSE) {\n      if (versionType == 0) {\n        System.out.println(\"TEST: use random versions\");\n      } else if (versionType == 1) {\n        System.out.println(\"TEST: use monotonic versions\");\n      } else {\n        System.out.println(\"TEST: use nanotime versions\");\n      }\n    }\n\n    // Run for 3 sec in normal tests, else 60 seconds for nightly:\n    final long stopTime = System.currentTimeMillis() + (TEST_NIGHTLY ? 60000 : 3000);\n\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              runForReal();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void runForReal() throws IOException, InterruptedException {\n            startingGun.await();\n            PerThreadVersionPKLookup lookup = null;\n            IndexReader lookupReader = null;\n            while (System.currentTimeMillis() < stopTime) {\n\n              // Intentionally pull version first, and then sleep/yield, to provoke version conflicts:\n              long newVersion;\n              if (versionType == 0) {\n                // Random:\n                newVersion = random().nextLong() & 0x3fffffffffffffffL;\n              } else if (versionType == 1) {\n                // Monotonic\n                newVersion = nextVersion.getAndIncrement();\n              } else {\n                newVersion = System.nanoTime();\n              }\n\n              if (versionType != 0) {\n                if (random().nextBoolean()) {\n                  Thread.yield();\n                } else {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 4));\n                }\n              }\n\n              int x = random().nextInt(ids.length);\n\n              // TODO: we could relax this, if e.g. we assign indexer thread based on ID.  This would ensure a given ID cannot be indexed at\n              // the same time in multiple threads:\n\n              // Only one thread can update an ID at once:\n              synchronized (locks[x]) {\n\n                String id = ids[x];\n\n                // We will attempt to index id with newVersion, but only do so if id wasn't yet indexed, or it was indexed with an older\n                // version (< newVersion):\n\n                // Must lookup the RT value before pulling from the index, in case a reopen happens just after we lookup:\n                Long currentVersion = versionValues.get(id);\n\n                IndexSearcher s = mgr.acquire();\n                try {\n                  if (VERBOSE) System.out.println(\"\\n\" + Thread.currentThread().getName() + \": update id=\" + id + \" newVersion=\" + newVersion);\n\n                  if (lookup == null || lookupReader != s.getIndexReader()) {\n                    // TODO: sort of messy; we could add reopen to PerThreadVersionPKLookup?\n                    // TODO: this is thin ice .... that we don't incRef/decRef this reader we are implicitly holding onto:\n                    lookupReader = s.getIndexReader();\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \": open new PK lookup reader=\" + lookupReader);\n                    lookup = new PerThreadVersionPKLookup(lookupReader, \"id\");\n                  }\n\n                  Long truthVersion = truth.get(id);\n                  if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   truthVersion=\" + truthVersion);\n\n                  boolean doIndex;\n                  if (currentVersion == missingValue) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in RT cache\");\n                    int otherDocID = lookup.lookup(new BytesRef(id), newVersion+1);\n                    if (otherDocID == -1) {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in index, or version is <= newVersion; will index\");\n                      doIndex = true;\n                    } else {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in index with version=\" + lookup.getVersion() + \"; will not index\");\n                      doIndex = false;\n                      if (truthVersion.longValue() !=lookup.getVersion()) {\n                        System.out.println(Thread.currentThread() + \": now fail0!\");\n                      }\n                      assertEquals(truthVersion.longValue(), lookup.getVersion());\n                    }\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in RT cache: currentVersion=\" + currentVersion);\n                    doIndex = newVersion > currentVersion;\n                  }\n\n                  if (doIndex) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   now index\");\n                    boolean passes = truthVersion == null || truthVersion.longValue() <= newVersion;\n                    if (passes == false) {\n                      System.out.println(Thread.currentThread() + \": now fail!\");\n                    }\n                    assertTrue(passes);\n                    Document doc = new Document();\n                    doc.add(makeIDField(id, newVersion));\n                    w.updateDocument(new Term(\"id\", id), doc);\n                    truth.put(id, newVersion);\n                    versionValues.add(id, newVersion);\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   skip index\");\n                    assertNotNull(truthVersion);\n                    assertTrue(truthVersion.longValue() >= newVersion);\n                  }\n                } finally {\n                  mgr.release(s);\n                }\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n\n    // Keep reopening the NRT reader until all indexing threads are done:\n    refreshLoop:\n    while (true) {\n      Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n      mgr.maybeRefresh();\n      for (Thread thread : threads) {\n        if (thread.isAlive()) {\n          continue refreshLoop;\n        }\n      }\n\n      break;\n    }\n\n    // Verify final index against truth:\n    for(int i=0;i<2;i++) {\n      mgr.maybeRefresh();\n      IndexSearcher s = mgr.acquire();\n      try {\n        IndexReader r = s.getIndexReader();\n        // cannot assert this: maybe not all IDs were indexed\n        /*\n        assertEquals(numIDs, r.numDocs());\n        if (i == 1) {\n          // After forceMerge no deleted docs:\n          assertEquals(numIDs, r.maxDoc());\n        }\n        */\n        PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n        for(Map.Entry<String,Long> ent : truth.entrySet()) {\n          assertTrue(lookup.lookup(new BytesRef(ent.getKey()), -1L) != -1);\n          assertEquals(ent.getValue().longValue(), lookup.getVersion());\n        }\n      } finally {\n        mgr.release(s);\n      }\n\n      if (i == 1) {\n        break;\n      }\n\n      // forceMerge and verify again\n      w.forceMerge(1);\n    }\n\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Simulates optimistic concurrency in a distributed indexing app and confirms the latest version always wins:\n  public void testGlobalVersions() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    IDSource idsSource = getRandomIDs();\n    int numIDs = atLeast(100);\n    System.out.println(\"ids=\" + numIDs);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numIDs + \" ids\");\n    }\n    Set<String> idsSeen = new HashSet<String>();\n    while (idsSeen.size() < numIDs) {\n      idsSeen.add(idsSource.next());\n    }\n    final String[] ids = idsSeen.toArray(new String[numIDs]);\n\n    final Object[] locks = new Object[ids.length];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    final AtomicLong nextVersion = new AtomicLong();\n\n    final SearcherManager mgr = new SearcherManager(w.w, true, new SearcherFactory());\n\n    final Long missingValue = -1L;\n\n    final LiveFieldValues<IndexSearcher,Long> versionValues = new LiveFieldValues<IndexSearcher,Long>(mgr, missingValue) {\n      @Override\n      protected Long lookupFromSearcher(IndexSearcher s, String id) {\n        // TODO: would be cleaner if we could do our PerThreadLookup here instead of \"up above\":\n        // We always return missing: the caller then does a lookup against the current reader\n        return missingValue;\n      }\n    };\n\n    // Maps to the version the id was lasted indexed with:\n    final Map<String,Long> truth = new ConcurrentHashMap<>();\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 7)];\n\n    final int versionType = random().nextInt(3);\n\n    if (VERBOSE) {\n      if (versionType == 0) {\n        System.out.println(\"TEST: use random versions\");\n      } else if (versionType == 1) {\n        System.out.println(\"TEST: use monotonic versions\");\n      } else {\n        System.out.println(\"TEST: use nanotime versions\");\n      }\n    }\n\n    // Run for 3 sec in normal tests, else 60 seconds for nightly:\n    final long stopTime = System.currentTimeMillis() + (TEST_NIGHTLY ? 60000 : 3000);\n\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              runForReal();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void runForReal() throws IOException, InterruptedException {\n            startingGun.await();\n            PerThreadVersionPKLookup lookup = null;\n            IndexReader lookupReader = null;\n            while (System.currentTimeMillis() < stopTime) {\n\n              // Intentionally pull version first, and then sleep/yield, to provoke version conflicts:\n              long newVersion;\n              if (versionType == 0) {\n                // Random:\n                newVersion = random().nextLong() & 0x7fffffffffffffffL;\n              } else if (versionType == 1) {\n                // Monotonic\n                newVersion = nextVersion.getAndIncrement();\n              } else {\n                newVersion = System.nanoTime();\n              }\n\n              if (versionType != 0) {\n                if (random().nextBoolean()) {\n                  Thread.yield();\n                } else {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 4));\n                }\n              }\n\n              int x = random().nextInt(ids.length);\n\n              // TODO: we could relax this, if e.g. we assign indexer thread based on ID.  This would ensure a given ID cannot be indexed at\n              // the same time in multiple threads:\n\n              // Only one thread can update an ID at once:\n              synchronized (locks[x]) {\n\n                String id = ids[x];\n\n                // We will attempt to index id with newVersion, but only do so if id wasn't yet indexed, or it was indexed with an older\n                // version (< newVersion):\n\n                // Must lookup the RT value before pulling from the index, in case a reopen happens just after we lookup:\n                Long currentVersion = versionValues.get(id);\n\n                IndexSearcher s = mgr.acquire();\n                try {\n                  if (VERBOSE) System.out.println(\"\\n\" + Thread.currentThread().getName() + \": update id=\" + id + \" newVersion=\" + newVersion);\n\n                  if (lookup == null || lookupReader != s.getIndexReader()) {\n                    // TODO: sort of messy; we could add reopen to PerThreadVersionPKLookup?\n                    // TODO: this is thin ice .... that we don't incRef/decRef this reader we are implicitly holding onto:\n                    lookupReader = s.getIndexReader();\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \": open new PK lookup reader=\" + lookupReader);\n                    lookup = new PerThreadVersionPKLookup(lookupReader, \"id\");\n                  }\n\n                  Long truthVersion = truth.get(id);\n                  if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   truthVersion=\" + truthVersion);\n\n                  boolean doIndex;\n                  if (currentVersion == missingValue) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in RT cache\");\n                    int otherDocID = lookup.lookup(new BytesRef(id), newVersion+1);\n                    if (otherDocID == -1) {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in index, or version is <= newVersion; will index\");\n                      doIndex = true;\n                    } else {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in index with version=\" + lookup.getVersion() + \"; will not index\");\n                      doIndex = false;\n                      if (truthVersion.longValue() !=lookup.getVersion()) {\n                        System.out.println(Thread.currentThread() + \": now fail0!\");\n                      }\n                      assertEquals(truthVersion.longValue(), lookup.getVersion());\n                    }\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in RT cache: currentVersion=\" + currentVersion);\n                    doIndex = newVersion > currentVersion;\n                  }\n\n                  if (doIndex) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   now index\");\n                    boolean passes = truthVersion == null || truthVersion.longValue() <= newVersion;\n                    if (passes == false) {\n                      System.out.println(Thread.currentThread() + \": now fail!\");\n                    }\n                    assertTrue(passes);\n                    Document doc = new Document();\n                    doc.add(makeIDField(id, newVersion));\n                    w.updateDocument(new Term(\"id\", id), doc);\n                    truth.put(id, newVersion);\n                    versionValues.add(id, newVersion);\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   skip index\");\n                    assertNotNull(truthVersion);\n                    assertTrue(truthVersion.longValue() >= newVersion);\n                  }\n                } finally {\n                  mgr.release(s);\n                }\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n\n    // Keep reopening the NRT reader until all indexing threads are done:\n    refreshLoop:\n    while (true) {\n      Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n      mgr.maybeRefresh();\n      for (Thread thread : threads) {\n        if (thread.isAlive()) {\n          continue refreshLoop;\n        }\n      }\n\n      break;\n    }\n\n    // Verify final index against truth:\n    for(int i=0;i<2;i++) {\n      mgr.maybeRefresh();\n      IndexSearcher s = mgr.acquire();\n      try {\n        IndexReader r = s.getIndexReader();\n        // cannot assert this: maybe not all IDs were indexed\n        /*\n        assertEquals(numIDs, r.numDocs());\n        if (i == 1) {\n          // After forceMerge no deleted docs:\n          assertEquals(numIDs, r.maxDoc());\n        }\n        */\n        PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n        for(Map.Entry<String,Long> ent : truth.entrySet()) {\n          assertTrue(lookup.lookup(new BytesRef(ent.getKey()), -1L) != -1);\n          assertEquals(ent.getValue().longValue(), lookup.getVersion());\n        }\n      } finally {\n        mgr.release(s);\n      }\n\n      if (i == 1) {\n        break;\n      }\n\n      // forceMerge and verify again\n      w.forceMerge(1);\n    }\n\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d637064d608752565d4f9f41b2497dfdfdde50e","date":1400798123,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testGlobalVersions().mjava","pathOld":"/dev/null","sourceNew":"  // Simulates optimistic concurrency in a distributed indexing app and confirms the latest version always wins:\n  public void testGlobalVersions() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    IDSource idsSource = getRandomIDs();\n    int numIDs = atLeast(100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numIDs + \" ids\");\n    }\n    Set<String> idsSeen = new HashSet<String>();\n    while (idsSeen.size() < numIDs) {\n      idsSeen.add(idsSource.next());\n    }\n    final String[] ids = idsSeen.toArray(new String[numIDs]);\n\n    final Object[] locks = new Object[ids.length];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    final AtomicLong nextVersion = new AtomicLong();\n\n    final SearcherManager mgr = new SearcherManager(w.w, true, new SearcherFactory());\n\n    final Long missingValue = -1L;\n\n    final LiveFieldValues<IndexSearcher,Long> versionValues = new LiveFieldValues<IndexSearcher,Long>(mgr, missingValue) {\n      @Override\n      protected Long lookupFromSearcher(IndexSearcher s, String id) {\n        // TODO: would be cleaner if we could do our PerThreadLookup here instead of \"up above\":\n        // We always return missing: the caller then does a lookup against the current reader\n        return missingValue;\n      }\n    };\n\n    // Maps to the version the id was lasted indexed with:\n    final Map<String,Long> truth = new ConcurrentHashMap<>();\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 7)];\n\n    final int versionType = random().nextInt(3);\n\n    if (VERBOSE) {\n      if (versionType == 0) {\n        System.out.println(\"TEST: use random versions\");\n      } else if (versionType == 1) {\n        System.out.println(\"TEST: use monotonic versions\");\n      } else {\n        System.out.println(\"TEST: use nanotime versions\");\n      }\n    }\n\n    // Run for 3 sec in normal tests, else 60 seconds for nightly:\n    final long stopTime = System.currentTimeMillis() + (TEST_NIGHTLY ? 60000 : 3000);\n\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              runForReal();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void runForReal() throws IOException, InterruptedException {\n            startingGun.await();\n            PerThreadVersionPKLookup lookup = null;\n            IndexReader lookupReader = null;\n            while (System.currentTimeMillis() < stopTime) {\n\n              // Intentionally pull version first, and then sleep/yield, to provoke version conflicts:\n              long newVersion;\n              if (versionType == 0) {\n                // Random:\n                newVersion = random().nextLong() & 0x3fffffffffffffffL;\n              } else if (versionType == 1) {\n                // Monotonic\n                newVersion = nextVersion.getAndIncrement();\n              } else {\n                newVersion = System.nanoTime();\n              }\n\n              if (versionType != 0) {\n                if (random().nextBoolean()) {\n                  Thread.yield();\n                } else {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 4));\n                }\n              }\n\n              int x = random().nextInt(ids.length);\n\n              // TODO: we could relax this, if e.g. we assign indexer thread based on ID.  This would ensure a given ID cannot be indexed at\n              // the same time in multiple threads:\n\n              // Only one thread can update an ID at once:\n              synchronized (locks[x]) {\n\n                String id = ids[x];\n\n                // We will attempt to index id with newVersion, but only do so if id wasn't yet indexed, or it was indexed with an older\n                // version (< newVersion):\n\n                // Must lookup the RT value before pulling from the index, in case a reopen happens just after we lookup:\n                Long currentVersion = versionValues.get(id);\n\n                IndexSearcher s = mgr.acquire();\n                try {\n                  if (VERBOSE) System.out.println(\"\\n\" + Thread.currentThread().getName() + \": update id=\" + id + \" newVersion=\" + newVersion);\n\n                  if (lookup == null || lookupReader != s.getIndexReader()) {\n                    // TODO: sort of messy; we could add reopen to PerThreadVersionPKLookup?\n                    // TODO: this is thin ice .... that we don't incRef/decRef this reader we are implicitly holding onto:\n                    lookupReader = s.getIndexReader();\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \": open new PK lookup reader=\" + lookupReader);\n                    lookup = new PerThreadVersionPKLookup(lookupReader, \"id\");\n                  }\n\n                  Long truthVersion = truth.get(id);\n                  if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   truthVersion=\" + truthVersion);\n\n                  boolean doIndex;\n                  if (currentVersion == missingValue) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in RT cache\");\n                    int otherDocID = lookup.lookup(new BytesRef(id), newVersion+1);\n                    if (otherDocID == -1) {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in index, or version is <= newVersion; will index\");\n                      doIndex = true;\n                    } else {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in index with version=\" + lookup.getVersion() + \"; will not index\");\n                      doIndex = false;\n                      if (truthVersion.longValue() !=lookup.getVersion()) {\n                        System.out.println(Thread.currentThread() + \": now fail0!\");\n                      }\n                      assertEquals(truthVersion.longValue(), lookup.getVersion());\n                    }\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in RT cache: currentVersion=\" + currentVersion);\n                    doIndex = newVersion > currentVersion;\n                  }\n\n                  if (doIndex) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   now index\");\n                    boolean passes = truthVersion == null || truthVersion.longValue() <= newVersion;\n                    if (passes == false) {\n                      System.out.println(Thread.currentThread() + \": now fail!\");\n                    }\n                    assertTrue(passes);\n                    Document doc = new Document();\n                    doc.add(makeIDField(id, newVersion));\n                    w.updateDocument(new Term(\"id\", id), doc);\n                    truth.put(id, newVersion);\n                    versionValues.add(id, newVersion);\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   skip index\");\n                    assertNotNull(truthVersion);\n                    assertTrue(truthVersion.longValue() >= newVersion);\n                  }\n                } finally {\n                  mgr.release(s);\n                }\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n\n    // Keep reopening the NRT reader until all indexing threads are done:\n    refreshLoop:\n    while (true) {\n      Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n      mgr.maybeRefresh();\n      for (Thread thread : threads) {\n        if (thread.isAlive()) {\n          continue refreshLoop;\n        }\n      }\n\n      break;\n    }\n\n    // Verify final index against truth:\n    for(int i=0;i<2;i++) {\n      mgr.maybeRefresh();\n      IndexSearcher s = mgr.acquire();\n      try {\n        IndexReader r = s.getIndexReader();\n        // cannot assert this: maybe not all IDs were indexed\n        /*\n        assertEquals(numIDs, r.numDocs());\n        if (i == 1) {\n          // After forceMerge no deleted docs:\n          assertEquals(numIDs, r.maxDoc());\n        }\n        */\n        PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n        for(Map.Entry<String,Long> ent : truth.entrySet()) {\n          assertTrue(lookup.lookup(new BytesRef(ent.getKey()), -1L) != -1);\n          assertEquals(ent.getValue().longValue(), lookup.getVersion());\n        }\n      } finally {\n        mgr.release(s);\n      }\n\n      if (i == 1) {\n        break;\n      }\n\n      // forceMerge and verify again\n      w.forceMerge(1);\n    }\n\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testGlobalVersions().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testGlobalVersions().mjava","sourceNew":"  // Simulates optimistic concurrency in a distributed indexing app and confirms the latest version always wins:\n  public void testGlobalVersions() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    IDSource idsSource = getRandomIDs();\n    int numIDs = atLeast(100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numIDs + \" ids\");\n    }\n    Set<String> idsSeen = new HashSet<String>();\n    while (idsSeen.size() < numIDs) {\n      idsSeen.add(idsSource.next());\n    }\n    final String[] ids = idsSeen.toArray(new String[numIDs]);\n\n    final Object[] locks = new Object[ids.length];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    final AtomicLong nextVersion = new AtomicLong();\n\n    final SearcherManager mgr = new SearcherManager(w.w, true, new SearcherFactory());\n\n    final Long missingValue = -1L;\n\n    final LiveFieldValues<IndexSearcher,Long> versionValues = new LiveFieldValues<IndexSearcher,Long>(mgr, missingValue) {\n      @Override\n      protected Long lookupFromSearcher(IndexSearcher s, String id) {\n        // TODO: would be cleaner if we could do our PerThreadLookup here instead of \"up above\":\n        // We always return missing: the caller then does a lookup against the current reader\n        return missingValue;\n      }\n    };\n\n    // Maps to the version the id was lasted indexed with:\n    final Map<String,Long> truth = new ConcurrentHashMap<>();\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 7)];\n\n    final int versionType = random().nextInt(3);\n\n    if (VERBOSE) {\n      if (versionType == 0) {\n        System.out.println(\"TEST: use random versions\");\n      } else if (versionType == 1) {\n        System.out.println(\"TEST: use monotonic versions\");\n      } else {\n        System.out.println(\"TEST: use nanotime versions\");\n      }\n    }\n\n    // Run for 3 sec in normal tests, else 60 seconds for nightly:\n    final long stopTime = System.currentTimeMillis() + (TEST_NIGHTLY ? 60000 : 3000);\n\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              runForReal();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void runForReal() throws IOException, InterruptedException {\n            startingGun.await();\n            PerThreadVersionPKLookup lookup = null;\n            IndexReader lookupReader = null;\n            while (System.currentTimeMillis() < stopTime) {\n\n              // Intentionally pull version first, and then sleep/yield, to provoke version conflicts:\n              long newVersion;\n              if (versionType == 0) {\n                // Random:\n                newVersion = random().nextLong() & 0x3fffffffffffffffL;\n              } else if (versionType == 1) {\n                // Monotonic\n                newVersion = nextVersion.getAndIncrement();\n              } else {\n                newVersion = System.nanoTime();\n              }\n\n              if (versionType != 0) {\n                if (random().nextBoolean()) {\n                  Thread.yield();\n                } else {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 4));\n                }\n              }\n\n              int x = random().nextInt(ids.length);\n\n              // TODO: we could relax this, if e.g. we assign indexer thread based on ID.  This would ensure a given ID cannot be indexed at\n              // the same time in multiple threads:\n\n              // Only one thread can update an ID at once:\n              synchronized (locks[x]) {\n\n                String id = ids[x];\n\n                // We will attempt to index id with newVersion, but only do so if id wasn't yet indexed, or it was indexed with an older\n                // version (< newVersion):\n\n                // Must lookup the RT value before pulling from the index, in case a reopen happens just after we lookup:\n                Long currentVersion = versionValues.get(id);\n\n                IndexSearcher s = mgr.acquire();\n                try {\n                  if (VERBOSE) System.out.println(\"\\n\" + Thread.currentThread().getName() + \": update id=\" + id + \" newVersion=\" + newVersion);\n\n                  if (lookup == null || lookupReader != s.getIndexReader()) {\n                    // TODO: sort of messy; we could add reopen to PerThreadVersionPKLookup?\n                    // TODO: this is thin ice .... that we don't incRef/decRef this reader we are implicitly holding onto:\n                    lookupReader = s.getIndexReader();\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \": open new PK lookup reader=\" + lookupReader);\n                    lookup = new PerThreadVersionPKLookup(lookupReader, \"id\");\n                  }\n\n                  Long truthVersion = truth.get(id);\n                  if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   truthVersion=\" + truthVersion);\n\n                  boolean doIndex;\n                  if (currentVersion == missingValue) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in RT cache\");\n                    int otherDocID = lookup.lookup(new BytesRef(id), newVersion+1);\n                    if (otherDocID == -1) {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in index, or version is <= newVersion; will index\");\n                      doIndex = true;\n                    } else {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in index with version=\" + lookup.getVersion() + \"; will not index\");\n                      doIndex = false;\n                      if (truthVersion.longValue() !=lookup.getVersion()) {\n                        System.out.println(Thread.currentThread() + \": now fail0!\");\n                      }\n                      assertEquals(truthVersion.longValue(), lookup.getVersion());\n                    }\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in RT cache: currentVersion=\" + currentVersion);\n                    doIndex = newVersion > currentVersion;\n                  }\n\n                  if (doIndex) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   now index\");\n                    boolean passes = truthVersion == null || truthVersion.longValue() <= newVersion;\n                    if (passes == false) {\n                      System.out.println(Thread.currentThread() + \": now fail!\");\n                    }\n                    assertTrue(passes);\n                    Document doc = new Document();\n                    doc.add(makeIDField(id, newVersion));\n                    w.updateDocument(new Term(\"id\", id), doc);\n                    truth.put(id, newVersion);\n                    versionValues.add(id, newVersion);\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   skip index\");\n                    assertNotNull(truthVersion);\n                    assertTrue(truthVersion.longValue() >= newVersion);\n                  }\n                } finally {\n                  mgr.release(s);\n                }\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n\n    // Keep reopening the NRT reader until all indexing threads are done:\n    refreshLoop:\n    while (true) {\n      Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n      mgr.maybeRefresh();\n      for (Thread thread : threads) {\n        if (thread.isAlive()) {\n          continue refreshLoop;\n        }\n      }\n\n      break;\n    }\n\n    // Verify final index against truth:\n    for(int i=0;i<2;i++) {\n      mgr.maybeRefresh();\n      IndexSearcher s = mgr.acquire();\n      try {\n        IndexReader r = s.getIndexReader();\n        // cannot assert this: maybe not all IDs were indexed\n        /*\n        assertEquals(numIDs, r.numDocs());\n        if (i == 1) {\n          // After forceMerge no deleted docs:\n          assertEquals(numIDs, r.maxDoc());\n        }\n        */\n        PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n        for(Map.Entry<String,Long> ent : truth.entrySet()) {\n          assertTrue(lookup.lookup(new BytesRef(ent.getKey()), -1L) != -1);\n          assertEquals(ent.getValue().longValue(), lookup.getVersion());\n        }\n      } finally {\n        mgr.release(s);\n      }\n\n      if (i == 1) {\n        break;\n      }\n\n      // forceMerge and verify again\n      w.forceMerge(1);\n    }\n\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Simulates optimistic concurrency in a distributed indexing app and confirms the latest version always wins:\n  public void testGlobalVersions() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    IDSource idsSource = getRandomIDs();\n    int numIDs = atLeast(100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numIDs + \" ids\");\n    }\n    Set<String> idsSeen = new HashSet<String>();\n    while (idsSeen.size() < numIDs) {\n      idsSeen.add(idsSource.next());\n    }\n    final String[] ids = idsSeen.toArray(new String[numIDs]);\n\n    final Object[] locks = new Object[ids.length];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    final AtomicLong nextVersion = new AtomicLong();\n\n    final SearcherManager mgr = new SearcherManager(w.w, true, new SearcherFactory());\n\n    final Long missingValue = -1L;\n\n    final LiveFieldValues<IndexSearcher,Long> versionValues = new LiveFieldValues<IndexSearcher,Long>(mgr, missingValue) {\n      @Override\n      protected Long lookupFromSearcher(IndexSearcher s, String id) {\n        // TODO: would be cleaner if we could do our PerThreadLookup here instead of \"up above\":\n        // We always return missing: the caller then does a lookup against the current reader\n        return missingValue;\n      }\n    };\n\n    // Maps to the version the id was lasted indexed with:\n    final Map<String,Long> truth = new ConcurrentHashMap<>();\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 7)];\n\n    final int versionType = random().nextInt(3);\n\n    if (VERBOSE) {\n      if (versionType == 0) {\n        System.out.println(\"TEST: use random versions\");\n      } else if (versionType == 1) {\n        System.out.println(\"TEST: use monotonic versions\");\n      } else {\n        System.out.println(\"TEST: use nanotime versions\");\n      }\n    }\n\n    // Run for 3 sec in normal tests, else 60 seconds for nightly:\n    final long stopTime = System.currentTimeMillis() + (TEST_NIGHTLY ? 60000 : 3000);\n\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              runForReal();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void runForReal() throws IOException, InterruptedException {\n            startingGun.await();\n            PerThreadVersionPKLookup lookup = null;\n            IndexReader lookupReader = null;\n            while (System.currentTimeMillis() < stopTime) {\n\n              // Intentionally pull version first, and then sleep/yield, to provoke version conflicts:\n              long newVersion;\n              if (versionType == 0) {\n                // Random:\n                newVersion = random().nextLong() & 0x3fffffffffffffffL;\n              } else if (versionType == 1) {\n                // Monotonic\n                newVersion = nextVersion.getAndIncrement();\n              } else {\n                newVersion = System.nanoTime();\n              }\n\n              if (versionType != 0) {\n                if (random().nextBoolean()) {\n                  Thread.yield();\n                } else {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 4));\n                }\n              }\n\n              int x = random().nextInt(ids.length);\n\n              // TODO: we could relax this, if e.g. we assign indexer thread based on ID.  This would ensure a given ID cannot be indexed at\n              // the same time in multiple threads:\n\n              // Only one thread can update an ID at once:\n              synchronized (locks[x]) {\n\n                String id = ids[x];\n\n                // We will attempt to index id with newVersion, but only do so if id wasn't yet indexed, or it was indexed with an older\n                // version (< newVersion):\n\n                // Must lookup the RT value before pulling from the index, in case a reopen happens just after we lookup:\n                Long currentVersion = versionValues.get(id);\n\n                IndexSearcher s = mgr.acquire();\n                try {\n                  if (VERBOSE) System.out.println(\"\\n\" + Thread.currentThread().getName() + \": update id=\" + id + \" newVersion=\" + newVersion);\n\n                  if (lookup == null || lookupReader != s.getIndexReader()) {\n                    // TODO: sort of messy; we could add reopen to PerThreadVersionPKLookup?\n                    // TODO: this is thin ice .... that we don't incRef/decRef this reader we are implicitly holding onto:\n                    lookupReader = s.getIndexReader();\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \": open new PK lookup reader=\" + lookupReader);\n                    lookup = new PerThreadVersionPKLookup(lookupReader, \"id\");\n                  }\n\n                  Long truthVersion = truth.get(id);\n                  if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   truthVersion=\" + truthVersion);\n\n                  boolean doIndex;\n                  if (currentVersion == missingValue) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in RT cache\");\n                    int otherDocID = lookup.lookup(new BytesRef(id), newVersion+1);\n                    if (otherDocID == -1) {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in index, or version is <= newVersion; will index\");\n                      doIndex = true;\n                    } else {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in index with version=\" + lookup.getVersion() + \"; will not index\");\n                      doIndex = false;\n                      if (truthVersion.longValue() !=lookup.getVersion()) {\n                        System.out.println(Thread.currentThread() + \": now fail0!\");\n                      }\n                      assertEquals(truthVersion.longValue(), lookup.getVersion());\n                    }\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in RT cache: currentVersion=\" + currentVersion);\n                    doIndex = newVersion > currentVersion;\n                  }\n\n                  if (doIndex) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   now index\");\n                    boolean passes = truthVersion == null || truthVersion.longValue() <= newVersion;\n                    if (passes == false) {\n                      System.out.println(Thread.currentThread() + \": now fail!\");\n                    }\n                    assertTrue(passes);\n                    Document doc = new Document();\n                    doc.add(makeIDField(id, newVersion));\n                    w.updateDocument(new Term(\"id\", id), doc);\n                    truth.put(id, newVersion);\n                    versionValues.add(id, newVersion);\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   skip index\");\n                    assertNotNull(truthVersion);\n                    assertTrue(truthVersion.longValue() >= newVersion);\n                  }\n                } finally {\n                  mgr.release(s);\n                }\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n\n    // Keep reopening the NRT reader until all indexing threads are done:\n    refreshLoop:\n    while (true) {\n      Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n      mgr.maybeRefresh();\n      for (Thread thread : threads) {\n        if (thread.isAlive()) {\n          continue refreshLoop;\n        }\n      }\n\n      break;\n    }\n\n    // Verify final index against truth:\n    for(int i=0;i<2;i++) {\n      mgr.maybeRefresh();\n      IndexSearcher s = mgr.acquire();\n      try {\n        IndexReader r = s.getIndexReader();\n        // cannot assert this: maybe not all IDs were indexed\n        /*\n        assertEquals(numIDs, r.numDocs());\n        if (i == 1) {\n          // After forceMerge no deleted docs:\n          assertEquals(numIDs, r.maxDoc());\n        }\n        */\n        PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n        for(Map.Entry<String,Long> ent : truth.entrySet()) {\n          assertTrue(lookup.lookup(new BytesRef(ent.getKey()), -1L) != -1);\n          assertEquals(ent.getValue().longValue(), lookup.getVersion());\n        }\n      } finally {\n        mgr.release(s);\n      }\n\n      if (i == 1) {\n        break;\n      }\n\n      // forceMerge and verify again\n      w.forceMerge(1);\n    }\n\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b516a692d03225c8f0e81a13ceed2dc32bb457d","date":1453411951,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testGlobalVersions().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testGlobalVersions().mjava","sourceNew":"  // Simulates optimistic concurrency in a distributed indexing app and confirms the latest version always wins:\n  public void testGlobalVersions() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    IDSource idsSource = getRandomIDs();\n    int numIDs = atLeast(100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numIDs + \" ids\");\n    }\n    Set<String> idsSeen = new HashSet<String>();\n    while (idsSeen.size() < numIDs) {\n      idsSeen.add(idsSource.next());\n    }\n    final String[] ids = idsSeen.toArray(new String[numIDs]);\n\n    final Object[] locks = new Object[ids.length];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    final AtomicLong nextVersion = new AtomicLong();\n\n    final SearcherManager mgr = new SearcherManager(w.w, new SearcherFactory());\n\n    final Long missingValue = -1L;\n\n    final LiveFieldValues<IndexSearcher,Long> versionValues = new LiveFieldValues<IndexSearcher,Long>(mgr, missingValue) {\n      @Override\n      protected Long lookupFromSearcher(IndexSearcher s, String id) {\n        // TODO: would be cleaner if we could do our PerThreadLookup here instead of \"up above\":\n        // We always return missing: the caller then does a lookup against the current reader\n        return missingValue;\n      }\n    };\n\n    // Maps to the version the id was lasted indexed with:\n    final Map<String,Long> truth = new ConcurrentHashMap<>();\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 7)];\n\n    final int versionType = random().nextInt(3);\n\n    if (VERBOSE) {\n      if (versionType == 0) {\n        System.out.println(\"TEST: use random versions\");\n      } else if (versionType == 1) {\n        System.out.println(\"TEST: use monotonic versions\");\n      } else {\n        System.out.println(\"TEST: use nanotime versions\");\n      }\n    }\n\n    // Run for 3 sec in normal tests, else 60 seconds for nightly:\n    final long stopTime = System.currentTimeMillis() + (TEST_NIGHTLY ? 60000 : 3000);\n\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              runForReal();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void runForReal() throws IOException, InterruptedException {\n            startingGun.await();\n            PerThreadVersionPKLookup lookup = null;\n            IndexReader lookupReader = null;\n            while (System.currentTimeMillis() < stopTime) {\n\n              // Intentionally pull version first, and then sleep/yield, to provoke version conflicts:\n              long newVersion;\n              if (versionType == 0) {\n                // Random:\n                newVersion = random().nextLong() & 0x3fffffffffffffffL;\n              } else if (versionType == 1) {\n                // Monotonic\n                newVersion = nextVersion.getAndIncrement();\n              } else {\n                newVersion = System.nanoTime();\n              }\n\n              if (versionType != 0) {\n                if (random().nextBoolean()) {\n                  Thread.yield();\n                } else {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 4));\n                }\n              }\n\n              int x = random().nextInt(ids.length);\n\n              // TODO: we could relax this, if e.g. we assign indexer thread based on ID.  This would ensure a given ID cannot be indexed at\n              // the same time in multiple threads:\n\n              // Only one thread can update an ID at once:\n              synchronized (locks[x]) {\n\n                String id = ids[x];\n\n                // We will attempt to index id with newVersion, but only do so if id wasn't yet indexed, or it was indexed with an older\n                // version (< newVersion):\n\n                // Must lookup the RT value before pulling from the index, in case a reopen happens just after we lookup:\n                Long currentVersion = versionValues.get(id);\n\n                IndexSearcher s = mgr.acquire();\n                try {\n                  if (VERBOSE) System.out.println(\"\\n\" + Thread.currentThread().getName() + \": update id=\" + id + \" newVersion=\" + newVersion);\n\n                  if (lookup == null || lookupReader != s.getIndexReader()) {\n                    // TODO: sort of messy; we could add reopen to PerThreadVersionPKLookup?\n                    // TODO: this is thin ice .... that we don't incRef/decRef this reader we are implicitly holding onto:\n                    lookupReader = s.getIndexReader();\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \": open new PK lookup reader=\" + lookupReader);\n                    lookup = new PerThreadVersionPKLookup(lookupReader, \"id\");\n                  }\n\n                  Long truthVersion = truth.get(id);\n                  if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   truthVersion=\" + truthVersion);\n\n                  boolean doIndex;\n                  if (currentVersion == missingValue) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in RT cache\");\n                    int otherDocID = lookup.lookup(new BytesRef(id), newVersion+1);\n                    if (otherDocID == -1) {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in index, or version is <= newVersion; will index\");\n                      doIndex = true;\n                    } else {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in index with version=\" + lookup.getVersion() + \"; will not index\");\n                      doIndex = false;\n                      if (truthVersion.longValue() !=lookup.getVersion()) {\n                        System.out.println(Thread.currentThread() + \": now fail0!\");\n                      }\n                      assertEquals(truthVersion.longValue(), lookup.getVersion());\n                    }\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in RT cache: currentVersion=\" + currentVersion);\n                    doIndex = newVersion > currentVersion;\n                  }\n\n                  if (doIndex) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   now index\");\n                    boolean passes = truthVersion == null || truthVersion.longValue() <= newVersion;\n                    if (passes == false) {\n                      System.out.println(Thread.currentThread() + \": now fail!\");\n                    }\n                    assertTrue(passes);\n                    Document doc = new Document();\n                    doc.add(makeIDField(id, newVersion));\n                    w.updateDocument(new Term(\"id\", id), doc);\n                    truth.put(id, newVersion);\n                    versionValues.add(id, newVersion);\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   skip index\");\n                    assertNotNull(truthVersion);\n                    assertTrue(truthVersion.longValue() >= newVersion);\n                  }\n                } finally {\n                  mgr.release(s);\n                }\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n\n    // Keep reopening the NRT reader until all indexing threads are done:\n    refreshLoop:\n    while (true) {\n      Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n      mgr.maybeRefresh();\n      for (Thread thread : threads) {\n        if (thread.isAlive()) {\n          continue refreshLoop;\n        }\n      }\n\n      break;\n    }\n\n    // Verify final index against truth:\n    for(int i=0;i<2;i++) {\n      mgr.maybeRefresh();\n      IndexSearcher s = mgr.acquire();\n      try {\n        IndexReader r = s.getIndexReader();\n        // cannot assert this: maybe not all IDs were indexed\n        /*\n        assertEquals(numIDs, r.numDocs());\n        if (i == 1) {\n          // After forceMerge no deleted docs:\n          assertEquals(numIDs, r.maxDoc());\n        }\n        */\n        PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n        for(Map.Entry<String,Long> ent : truth.entrySet()) {\n          assertTrue(lookup.lookup(new BytesRef(ent.getKey()), -1L) != -1);\n          assertEquals(ent.getValue().longValue(), lookup.getVersion());\n        }\n      } finally {\n        mgr.release(s);\n      }\n\n      if (i == 1) {\n        break;\n      }\n\n      // forceMerge and verify again\n      w.forceMerge(1);\n    }\n\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Simulates optimistic concurrency in a distributed indexing app and confirms the latest version always wins:\n  public void testGlobalVersions() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    IDSource idsSource = getRandomIDs();\n    int numIDs = atLeast(100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numIDs + \" ids\");\n    }\n    Set<String> idsSeen = new HashSet<String>();\n    while (idsSeen.size() < numIDs) {\n      idsSeen.add(idsSource.next());\n    }\n    final String[] ids = idsSeen.toArray(new String[numIDs]);\n\n    final Object[] locks = new Object[ids.length];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    final AtomicLong nextVersion = new AtomicLong();\n\n    final SearcherManager mgr = new SearcherManager(w.w, true, new SearcherFactory());\n\n    final Long missingValue = -1L;\n\n    final LiveFieldValues<IndexSearcher,Long> versionValues = new LiveFieldValues<IndexSearcher,Long>(mgr, missingValue) {\n      @Override\n      protected Long lookupFromSearcher(IndexSearcher s, String id) {\n        // TODO: would be cleaner if we could do our PerThreadLookup here instead of \"up above\":\n        // We always return missing: the caller then does a lookup against the current reader\n        return missingValue;\n      }\n    };\n\n    // Maps to the version the id was lasted indexed with:\n    final Map<String,Long> truth = new ConcurrentHashMap<>();\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 7)];\n\n    final int versionType = random().nextInt(3);\n\n    if (VERBOSE) {\n      if (versionType == 0) {\n        System.out.println(\"TEST: use random versions\");\n      } else if (versionType == 1) {\n        System.out.println(\"TEST: use monotonic versions\");\n      } else {\n        System.out.println(\"TEST: use nanotime versions\");\n      }\n    }\n\n    // Run for 3 sec in normal tests, else 60 seconds for nightly:\n    final long stopTime = System.currentTimeMillis() + (TEST_NIGHTLY ? 60000 : 3000);\n\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              runForReal();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void runForReal() throws IOException, InterruptedException {\n            startingGun.await();\n            PerThreadVersionPKLookup lookup = null;\n            IndexReader lookupReader = null;\n            while (System.currentTimeMillis() < stopTime) {\n\n              // Intentionally pull version first, and then sleep/yield, to provoke version conflicts:\n              long newVersion;\n              if (versionType == 0) {\n                // Random:\n                newVersion = random().nextLong() & 0x3fffffffffffffffL;\n              } else if (versionType == 1) {\n                // Monotonic\n                newVersion = nextVersion.getAndIncrement();\n              } else {\n                newVersion = System.nanoTime();\n              }\n\n              if (versionType != 0) {\n                if (random().nextBoolean()) {\n                  Thread.yield();\n                } else {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 4));\n                }\n              }\n\n              int x = random().nextInt(ids.length);\n\n              // TODO: we could relax this, if e.g. we assign indexer thread based on ID.  This would ensure a given ID cannot be indexed at\n              // the same time in multiple threads:\n\n              // Only one thread can update an ID at once:\n              synchronized (locks[x]) {\n\n                String id = ids[x];\n\n                // We will attempt to index id with newVersion, but only do so if id wasn't yet indexed, or it was indexed with an older\n                // version (< newVersion):\n\n                // Must lookup the RT value before pulling from the index, in case a reopen happens just after we lookup:\n                Long currentVersion = versionValues.get(id);\n\n                IndexSearcher s = mgr.acquire();\n                try {\n                  if (VERBOSE) System.out.println(\"\\n\" + Thread.currentThread().getName() + \": update id=\" + id + \" newVersion=\" + newVersion);\n\n                  if (lookup == null || lookupReader != s.getIndexReader()) {\n                    // TODO: sort of messy; we could add reopen to PerThreadVersionPKLookup?\n                    // TODO: this is thin ice .... that we don't incRef/decRef this reader we are implicitly holding onto:\n                    lookupReader = s.getIndexReader();\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \": open new PK lookup reader=\" + lookupReader);\n                    lookup = new PerThreadVersionPKLookup(lookupReader, \"id\");\n                  }\n\n                  Long truthVersion = truth.get(id);\n                  if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   truthVersion=\" + truthVersion);\n\n                  boolean doIndex;\n                  if (currentVersion == missingValue) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in RT cache\");\n                    int otherDocID = lookup.lookup(new BytesRef(id), newVersion+1);\n                    if (otherDocID == -1) {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in index, or version is <= newVersion; will index\");\n                      doIndex = true;\n                    } else {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in index with version=\" + lookup.getVersion() + \"; will not index\");\n                      doIndex = false;\n                      if (truthVersion.longValue() !=lookup.getVersion()) {\n                        System.out.println(Thread.currentThread() + \": now fail0!\");\n                      }\n                      assertEquals(truthVersion.longValue(), lookup.getVersion());\n                    }\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in RT cache: currentVersion=\" + currentVersion);\n                    doIndex = newVersion > currentVersion;\n                  }\n\n                  if (doIndex) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   now index\");\n                    boolean passes = truthVersion == null || truthVersion.longValue() <= newVersion;\n                    if (passes == false) {\n                      System.out.println(Thread.currentThread() + \": now fail!\");\n                    }\n                    assertTrue(passes);\n                    Document doc = new Document();\n                    doc.add(makeIDField(id, newVersion));\n                    w.updateDocument(new Term(\"id\", id), doc);\n                    truth.put(id, newVersion);\n                    versionValues.add(id, newVersion);\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   skip index\");\n                    assertNotNull(truthVersion);\n                    assertTrue(truthVersion.longValue() >= newVersion);\n                  }\n                } finally {\n                  mgr.release(s);\n                }\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n\n    // Keep reopening the NRT reader until all indexing threads are done:\n    refreshLoop:\n    while (true) {\n      Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n      mgr.maybeRefresh();\n      for (Thread thread : threads) {\n        if (thread.isAlive()) {\n          continue refreshLoop;\n        }\n      }\n\n      break;\n    }\n\n    // Verify final index against truth:\n    for(int i=0;i<2;i++) {\n      mgr.maybeRefresh();\n      IndexSearcher s = mgr.acquire();\n      try {\n        IndexReader r = s.getIndexReader();\n        // cannot assert this: maybe not all IDs were indexed\n        /*\n        assertEquals(numIDs, r.numDocs());\n        if (i == 1) {\n          // After forceMerge no deleted docs:\n          assertEquals(numIDs, r.maxDoc());\n        }\n        */\n        PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n        for(Map.Entry<String,Long> ent : truth.entrySet()) {\n          assertTrue(lookup.lookup(new BytesRef(ent.getKey()), -1L) != -1);\n          assertEquals(ent.getValue().longValue(), lookup.getVersion());\n        }\n      } finally {\n        mgr.release(s);\n      }\n\n      if (i == 1) {\n        break;\n      }\n\n      // forceMerge and verify again\n      w.forceMerge(1);\n    }\n\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ee0394b8176abd7c90a4be8c05465be1879db79","date":1522842314,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testGlobalVersions().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testGlobalVersions().mjava","sourceNew":"  // Simulates optimistic concurrency in a distributed indexing app and confirms the latest version always wins:\n  public void testGlobalVersions() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc, false);\n\n    IDSource idsSource = getRandomIDs();\n    int numIDs = atLeast(100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numIDs + \" ids\");\n    }\n    Set<String> idsSeen = new HashSet<String>();\n    while (idsSeen.size() < numIDs) {\n      idsSeen.add(idsSource.next());\n    }\n    final String[] ids = idsSeen.toArray(new String[numIDs]);\n\n    final Object[] locks = new Object[ids.length];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    final AtomicLong nextVersion = new AtomicLong();\n\n    final SearcherManager mgr = new SearcherManager(w.w, new SearcherFactory());\n\n    final Long missingValue = -1L;\n\n    final LiveFieldValues<IndexSearcher,Long> versionValues = new LiveFieldValues<IndexSearcher,Long>(mgr, missingValue) {\n      @Override\n      protected Long lookupFromSearcher(IndexSearcher s, String id) {\n        // TODO: would be cleaner if we could do our PerThreadLookup here instead of \"up above\":\n        // We always return missing: the caller then does a lookup against the current reader\n        return missingValue;\n      }\n    };\n\n    // Maps to the version the id was lasted indexed with:\n    final Map<String,Long> truth = new ConcurrentHashMap<>();\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 7)];\n\n    final int versionType = random().nextInt(3);\n\n    if (VERBOSE) {\n      if (versionType == 0) {\n        System.out.println(\"TEST: use random versions\");\n      } else if (versionType == 1) {\n        System.out.println(\"TEST: use monotonic versions\");\n      } else {\n        System.out.println(\"TEST: use nanotime versions\");\n      }\n    }\n\n    // Run for 3 sec in normal tests, else 60 seconds for nightly:\n    final long stopTime = System.currentTimeMillis() + (TEST_NIGHTLY ? 60000 : 3000);\n\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              runForReal();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void runForReal() throws IOException, InterruptedException {\n            startingGun.await();\n            PerThreadVersionPKLookup lookup = null;\n            IndexReader lookupReader = null;\n            while (System.currentTimeMillis() < stopTime) {\n\n              // Intentionally pull version first, and then sleep/yield, to provoke version conflicts:\n              long newVersion;\n              if (versionType == 0) {\n                // Random:\n                newVersion = random().nextLong() & 0x3fffffffffffffffL;\n              } else if (versionType == 1) {\n                // Monotonic\n                newVersion = nextVersion.getAndIncrement();\n              } else {\n                newVersion = System.nanoTime();\n              }\n\n              if (versionType != 0) {\n                if (random().nextBoolean()) {\n                  Thread.yield();\n                } else {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 4));\n                }\n              }\n\n              int x = random().nextInt(ids.length);\n\n              // TODO: we could relax this, if e.g. we assign indexer thread based on ID.  This would ensure a given ID cannot be indexed at\n              // the same time in multiple threads:\n\n              // Only one thread can update an ID at once:\n              synchronized (locks[x]) {\n\n                String id = ids[x];\n\n                // We will attempt to index id with newVersion, but only do so if id wasn't yet indexed, or it was indexed with an older\n                // version (< newVersion):\n\n                // Must lookup the RT value before pulling from the index, in case a reopen happens just after we lookup:\n                Long currentVersion = versionValues.get(id);\n\n                IndexSearcher s = mgr.acquire();\n                try {\n                  if (VERBOSE) System.out.println(\"\\n\" + Thread.currentThread().getName() + \": update id=\" + id + \" newVersion=\" + newVersion);\n\n                  if (lookup == null || lookupReader != s.getIndexReader()) {\n                    // TODO: sort of messy; we could add reopen to PerThreadVersionPKLookup?\n                    // TODO: this is thin ice .... that we don't incRef/decRef this reader we are implicitly holding onto:\n                    lookupReader = s.getIndexReader();\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \": open new PK lookup reader=\" + lookupReader);\n                    lookup = new PerThreadVersionPKLookup(lookupReader, \"id\");\n                  }\n\n                  Long truthVersion = truth.get(id);\n                  if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   truthVersion=\" + truthVersion);\n\n                  boolean doIndex;\n                  if (currentVersion == missingValue) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in RT cache\");\n                    int otherDocID = lookup.lookup(new BytesRef(id), newVersion+1);\n                    if (otherDocID == -1) {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in index, or version is <= newVersion; will index\");\n                      doIndex = true;\n                    } else {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in index with version=\" + lookup.getVersion() + \"; will not index\");\n                      doIndex = false;\n                      if (truthVersion.longValue() !=lookup.getVersion()) {\n                        System.out.println(Thread.currentThread() + \": now fail0!\");\n                      }\n                      assertEquals(truthVersion.longValue(), lookup.getVersion());\n                    }\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in RT cache: currentVersion=\" + currentVersion);\n                    doIndex = newVersion > currentVersion;\n                  }\n\n                  if (doIndex) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   now index\");\n                    boolean passes = truthVersion == null || truthVersion.longValue() <= newVersion;\n                    if (passes == false) {\n                      System.out.println(Thread.currentThread() + \": now fail!\");\n                    }\n                    assertTrue(passes);\n                    Document doc = new Document();\n                    doc.add(makeIDField(id, newVersion));\n                    w.updateDocument(new Term(\"id\", id), doc);\n                    truth.put(id, newVersion);\n                    versionValues.add(id, newVersion);\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   skip index\");\n                    assertNotNull(truthVersion);\n                    assertTrue(truthVersion.longValue() >= newVersion);\n                  }\n                } finally {\n                  mgr.release(s);\n                }\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n\n    // Keep reopening the NRT reader until all indexing threads are done:\n    refreshLoop:\n    while (true) {\n      Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n      mgr.maybeRefresh();\n      for (Thread thread : threads) {\n        if (thread.isAlive()) {\n          continue refreshLoop;\n        }\n      }\n\n      break;\n    }\n\n    // Verify final index against truth:\n    for(int i=0;i<2;i++) {\n      mgr.maybeRefresh();\n      IndexSearcher s = mgr.acquire();\n      try {\n        IndexReader r = s.getIndexReader();\n        // cannot assert this: maybe not all IDs were indexed\n        /*\n        assertEquals(numIDs, r.numDocs());\n        if (i == 1) {\n          // After forceMerge no deleted docs:\n          assertEquals(numIDs, r.maxDoc());\n        }\n        */\n        PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n        for(Map.Entry<String,Long> ent : truth.entrySet()) {\n          assertTrue(lookup.lookup(new BytesRef(ent.getKey()), -1L) != -1);\n          assertEquals(ent.getValue().longValue(), lookup.getVersion());\n        }\n      } finally {\n        mgr.release(s);\n      }\n\n      if (i == 1) {\n        break;\n      }\n\n      // forceMerge and verify again\n      w.forceMerge(1);\n    }\n\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Simulates optimistic concurrency in a distributed indexing app and confirms the latest version always wins:\n  public void testGlobalVersions() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    IDSource idsSource = getRandomIDs();\n    int numIDs = atLeast(100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numIDs + \" ids\");\n    }\n    Set<String> idsSeen = new HashSet<String>();\n    while (idsSeen.size() < numIDs) {\n      idsSeen.add(idsSource.next());\n    }\n    final String[] ids = idsSeen.toArray(new String[numIDs]);\n\n    final Object[] locks = new Object[ids.length];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    final AtomicLong nextVersion = new AtomicLong();\n\n    final SearcherManager mgr = new SearcherManager(w.w, new SearcherFactory());\n\n    final Long missingValue = -1L;\n\n    final LiveFieldValues<IndexSearcher,Long> versionValues = new LiveFieldValues<IndexSearcher,Long>(mgr, missingValue) {\n      @Override\n      protected Long lookupFromSearcher(IndexSearcher s, String id) {\n        // TODO: would be cleaner if we could do our PerThreadLookup here instead of \"up above\":\n        // We always return missing: the caller then does a lookup against the current reader\n        return missingValue;\n      }\n    };\n\n    // Maps to the version the id was lasted indexed with:\n    final Map<String,Long> truth = new ConcurrentHashMap<>();\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 7)];\n\n    final int versionType = random().nextInt(3);\n\n    if (VERBOSE) {\n      if (versionType == 0) {\n        System.out.println(\"TEST: use random versions\");\n      } else if (versionType == 1) {\n        System.out.println(\"TEST: use monotonic versions\");\n      } else {\n        System.out.println(\"TEST: use nanotime versions\");\n      }\n    }\n\n    // Run for 3 sec in normal tests, else 60 seconds for nightly:\n    final long stopTime = System.currentTimeMillis() + (TEST_NIGHTLY ? 60000 : 3000);\n\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              runForReal();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void runForReal() throws IOException, InterruptedException {\n            startingGun.await();\n            PerThreadVersionPKLookup lookup = null;\n            IndexReader lookupReader = null;\n            while (System.currentTimeMillis() < stopTime) {\n\n              // Intentionally pull version first, and then sleep/yield, to provoke version conflicts:\n              long newVersion;\n              if (versionType == 0) {\n                // Random:\n                newVersion = random().nextLong() & 0x3fffffffffffffffL;\n              } else if (versionType == 1) {\n                // Monotonic\n                newVersion = nextVersion.getAndIncrement();\n              } else {\n                newVersion = System.nanoTime();\n              }\n\n              if (versionType != 0) {\n                if (random().nextBoolean()) {\n                  Thread.yield();\n                } else {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 4));\n                }\n              }\n\n              int x = random().nextInt(ids.length);\n\n              // TODO: we could relax this, if e.g. we assign indexer thread based on ID.  This would ensure a given ID cannot be indexed at\n              // the same time in multiple threads:\n\n              // Only one thread can update an ID at once:\n              synchronized (locks[x]) {\n\n                String id = ids[x];\n\n                // We will attempt to index id with newVersion, but only do so if id wasn't yet indexed, or it was indexed with an older\n                // version (< newVersion):\n\n                // Must lookup the RT value before pulling from the index, in case a reopen happens just after we lookup:\n                Long currentVersion = versionValues.get(id);\n\n                IndexSearcher s = mgr.acquire();\n                try {\n                  if (VERBOSE) System.out.println(\"\\n\" + Thread.currentThread().getName() + \": update id=\" + id + \" newVersion=\" + newVersion);\n\n                  if (lookup == null || lookupReader != s.getIndexReader()) {\n                    // TODO: sort of messy; we could add reopen to PerThreadVersionPKLookup?\n                    // TODO: this is thin ice .... that we don't incRef/decRef this reader we are implicitly holding onto:\n                    lookupReader = s.getIndexReader();\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \": open new PK lookup reader=\" + lookupReader);\n                    lookup = new PerThreadVersionPKLookup(lookupReader, \"id\");\n                  }\n\n                  Long truthVersion = truth.get(id);\n                  if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   truthVersion=\" + truthVersion);\n\n                  boolean doIndex;\n                  if (currentVersion == missingValue) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in RT cache\");\n                    int otherDocID = lookup.lookup(new BytesRef(id), newVersion+1);\n                    if (otherDocID == -1) {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in index, or version is <= newVersion; will index\");\n                      doIndex = true;\n                    } else {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in index with version=\" + lookup.getVersion() + \"; will not index\");\n                      doIndex = false;\n                      if (truthVersion.longValue() !=lookup.getVersion()) {\n                        System.out.println(Thread.currentThread() + \": now fail0!\");\n                      }\n                      assertEquals(truthVersion.longValue(), lookup.getVersion());\n                    }\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in RT cache: currentVersion=\" + currentVersion);\n                    doIndex = newVersion > currentVersion;\n                  }\n\n                  if (doIndex) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   now index\");\n                    boolean passes = truthVersion == null || truthVersion.longValue() <= newVersion;\n                    if (passes == false) {\n                      System.out.println(Thread.currentThread() + \": now fail!\");\n                    }\n                    assertTrue(passes);\n                    Document doc = new Document();\n                    doc.add(makeIDField(id, newVersion));\n                    w.updateDocument(new Term(\"id\", id), doc);\n                    truth.put(id, newVersion);\n                    versionValues.add(id, newVersion);\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   skip index\");\n                    assertNotNull(truthVersion);\n                    assertTrue(truthVersion.longValue() >= newVersion);\n                  }\n                } finally {\n                  mgr.release(s);\n                }\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n\n    // Keep reopening the NRT reader until all indexing threads are done:\n    refreshLoop:\n    while (true) {\n      Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n      mgr.maybeRefresh();\n      for (Thread thread : threads) {\n        if (thread.isAlive()) {\n          continue refreshLoop;\n        }\n      }\n\n      break;\n    }\n\n    // Verify final index against truth:\n    for(int i=0;i<2;i++) {\n      mgr.maybeRefresh();\n      IndexSearcher s = mgr.acquire();\n      try {\n        IndexReader r = s.getIndexReader();\n        // cannot assert this: maybe not all IDs were indexed\n        /*\n        assertEquals(numIDs, r.numDocs());\n        if (i == 1) {\n          // After forceMerge no deleted docs:\n          assertEquals(numIDs, r.maxDoc());\n        }\n        */\n        PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n        for(Map.Entry<String,Long> ent : truth.entrySet()) {\n          assertTrue(lookup.lookup(new BytesRef(ent.getKey()), -1L) != -1);\n          assertEquals(ent.getValue().longValue(), lookup.getVersion());\n        }\n      } finally {\n        mgr.release(s);\n      }\n\n      if (i == 1) {\n        break;\n      }\n\n      // forceMerge and verify again\n      w.forceMerge(1);\n    }\n\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71da933d30aea361ccc224d6544c451cbf49916d","date":1579874339,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testGlobalVersions().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testGlobalVersions().mjava","sourceNew":"  // Simulates optimistic concurrency in a distributed indexing app and confirms the latest version always wins:\n  public void testGlobalVersions() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc, false);\n\n    IDSource idsSource = getRandomIDs();\n    int numIDs = atLeast(100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numIDs + \" ids\");\n    }\n    Set<String> idsSeen = new HashSet<String>();\n    while (idsSeen.size() < numIDs) {\n      idsSeen.add(idsSource.next());\n    }\n    final String[] ids = idsSeen.toArray(new String[numIDs]);\n\n    final Object[] locks = new Object[ids.length];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    final AtomicLong nextVersion = new AtomicLong();\n\n    final SearcherManager mgr = new SearcherManager(w.w, new SearcherFactory());\n\n    final Long missingValue = -1L;\n\n    final LiveFieldValues<IndexSearcher,Long> versionValues = new LiveFieldValues<IndexSearcher,Long>(mgr, missingValue) {\n      @Override\n      protected Long lookupFromSearcher(IndexSearcher s, String id) {\n        // TODO: would be cleaner if we could do our PerThreadLookup here instead of \"up above\":\n        // We always return missing: the caller then does a lookup against the current reader\n        return missingValue;\n      }\n    };\n\n    // Maps to the version the id was lasted indexed with:\n    final Map<String,Long> truth = new ConcurrentHashMap<>();\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 7)];\n\n    final int versionType = random().nextInt(3);\n\n    if (VERBOSE) {\n      if (versionType == 0) {\n        System.out.println(\"TEST: use random versions\");\n      } else if (versionType == 1) {\n        System.out.println(\"TEST: use monotonic versions\");\n      } else {\n        System.out.println(\"TEST: use nanotime versions\");\n      }\n    }\n\n    // Run for .5 sec in normal tests, else 60 seconds for nightly:\n    final long stopTime = System.currentTimeMillis() + (TEST_NIGHTLY ? 60000 : 500);\n\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              runForReal();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void runForReal() throws IOException, InterruptedException {\n            startingGun.await();\n            PerThreadVersionPKLookup lookup = null;\n            IndexReader lookupReader = null;\n            while (System.currentTimeMillis() < stopTime) {\n\n              // Intentionally pull version first, and then sleep/yield, to provoke version conflicts:\n              long newVersion;\n              if (versionType == 0) {\n                // Random:\n                newVersion = random().nextLong() & 0x3fffffffffffffffL;\n              } else if (versionType == 1) {\n                // Monotonic\n                newVersion = nextVersion.getAndIncrement();\n              } else {\n                newVersion = System.nanoTime();\n              }\n\n              if (versionType != 0) {\n                if (random().nextBoolean()) {\n                  Thread.yield();\n                } else {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 4));\n                }\n              }\n\n              int x = random().nextInt(ids.length);\n\n              // TODO: we could relax this, if e.g. we assign indexer thread based on ID.  This would ensure a given ID cannot be indexed at\n              // the same time in multiple threads:\n\n              // Only one thread can update an ID at once:\n              synchronized (locks[x]) {\n\n                String id = ids[x];\n\n                // We will attempt to index id with newVersion, but only do so if id wasn't yet indexed, or it was indexed with an older\n                // version (< newVersion):\n\n                // Must lookup the RT value before pulling from the index, in case a reopen happens just after we lookup:\n                Long currentVersion = versionValues.get(id);\n\n                IndexSearcher s = mgr.acquire();\n                try {\n                  if (VERBOSE) System.out.println(\"\\n\" + Thread.currentThread().getName() + \": update id=\" + id + \" newVersion=\" + newVersion);\n\n                  if (lookup == null || lookupReader != s.getIndexReader()) {\n                    // TODO: sort of messy; we could add reopen to PerThreadVersionPKLookup?\n                    // TODO: this is thin ice .... that we don't incRef/decRef this reader we are implicitly holding onto:\n                    lookupReader = s.getIndexReader();\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \": open new PK lookup reader=\" + lookupReader);\n                    lookup = new PerThreadVersionPKLookup(lookupReader, \"id\");\n                  }\n\n                  Long truthVersion = truth.get(id);\n                  if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   truthVersion=\" + truthVersion);\n\n                  boolean doIndex;\n                  if (currentVersion == missingValue) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in RT cache\");\n                    int otherDocID = lookup.lookup(new BytesRef(id), newVersion+1);\n                    if (otherDocID == -1) {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in index, or version is <= newVersion; will index\");\n                      doIndex = true;\n                    } else {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in index with version=\" + lookup.getVersion() + \"; will not index\");\n                      doIndex = false;\n                      if (truthVersion.longValue() !=lookup.getVersion()) {\n                        System.out.println(Thread.currentThread() + \": now fail0!\");\n                      }\n                      assertEquals(truthVersion.longValue(), lookup.getVersion());\n                    }\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in RT cache: currentVersion=\" + currentVersion);\n                    doIndex = newVersion > currentVersion;\n                  }\n\n                  if (doIndex) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   now index\");\n                    boolean passes = truthVersion == null || truthVersion.longValue() <= newVersion;\n                    if (passes == false) {\n                      System.out.println(Thread.currentThread() + \": now fail!\");\n                    }\n                    assertTrue(passes);\n                    Document doc = new Document();\n                    doc.add(makeIDField(id, newVersion));\n                    w.updateDocument(new Term(\"id\", id), doc);\n                    truth.put(id, newVersion);\n                    versionValues.add(id, newVersion);\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   skip index\");\n                    assertNotNull(truthVersion);\n                    assertTrue(truthVersion.longValue() >= newVersion);\n                  }\n                } finally {\n                  mgr.release(s);\n                }\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n\n    // Keep reopening the NRT reader until all indexing threads are done:\n    refreshLoop:\n    while (true) {\n      Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n      mgr.maybeRefresh();\n      for (Thread thread : threads) {\n        if (thread.isAlive()) {\n          continue refreshLoop;\n        }\n      }\n\n      break;\n    }\n\n    // Verify final index against truth:\n    for(int i=0;i<2;i++) {\n      mgr.maybeRefresh();\n      IndexSearcher s = mgr.acquire();\n      try {\n        IndexReader r = s.getIndexReader();\n        // cannot assert this: maybe not all IDs were indexed\n        /*\n        assertEquals(numIDs, r.numDocs());\n        if (i == 1) {\n          // After forceMerge no deleted docs:\n          assertEquals(numIDs, r.maxDoc());\n        }\n        */\n        PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n        for(Map.Entry<String,Long> ent : truth.entrySet()) {\n          assertTrue(lookup.lookup(new BytesRef(ent.getKey()), -1L) != -1);\n          assertEquals(ent.getValue().longValue(), lookup.getVersion());\n        }\n      } finally {\n        mgr.release(s);\n      }\n\n      if (i == 1) {\n        break;\n      }\n\n      // forceMerge and verify again\n      w.forceMerge(1);\n    }\n\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Simulates optimistic concurrency in a distributed indexing app and confirms the latest version always wins:\n  public void testGlobalVersions() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc, false);\n\n    IDSource idsSource = getRandomIDs();\n    int numIDs = atLeast(100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numIDs + \" ids\");\n    }\n    Set<String> idsSeen = new HashSet<String>();\n    while (idsSeen.size() < numIDs) {\n      idsSeen.add(idsSource.next());\n    }\n    final String[] ids = idsSeen.toArray(new String[numIDs]);\n\n    final Object[] locks = new Object[ids.length];\n    for(int i=0;i<locks.length;i++) {\n      locks[i] = new Object();\n    }\n\n    final AtomicLong nextVersion = new AtomicLong();\n\n    final SearcherManager mgr = new SearcherManager(w.w, new SearcherFactory());\n\n    final Long missingValue = -1L;\n\n    final LiveFieldValues<IndexSearcher,Long> versionValues = new LiveFieldValues<IndexSearcher,Long>(mgr, missingValue) {\n      @Override\n      protected Long lookupFromSearcher(IndexSearcher s, String id) {\n        // TODO: would be cleaner if we could do our PerThreadLookup here instead of \"up above\":\n        // We always return missing: the caller then does a lookup against the current reader\n        return missingValue;\n      }\n    };\n\n    // Maps to the version the id was lasted indexed with:\n    final Map<String,Long> truth = new ConcurrentHashMap<>();\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 7)];\n\n    final int versionType = random().nextInt(3);\n\n    if (VERBOSE) {\n      if (versionType == 0) {\n        System.out.println(\"TEST: use random versions\");\n      } else if (versionType == 1) {\n        System.out.println(\"TEST: use monotonic versions\");\n      } else {\n        System.out.println(\"TEST: use nanotime versions\");\n      }\n    }\n\n    // Run for 3 sec in normal tests, else 60 seconds for nightly:\n    final long stopTime = System.currentTimeMillis() + (TEST_NIGHTLY ? 60000 : 3000);\n\n    for(int i=0;i<threads.length;i++) {\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              runForReal();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void runForReal() throws IOException, InterruptedException {\n            startingGun.await();\n            PerThreadVersionPKLookup lookup = null;\n            IndexReader lookupReader = null;\n            while (System.currentTimeMillis() < stopTime) {\n\n              // Intentionally pull version first, and then sleep/yield, to provoke version conflicts:\n              long newVersion;\n              if (versionType == 0) {\n                // Random:\n                newVersion = random().nextLong() & 0x3fffffffffffffffL;\n              } else if (versionType == 1) {\n                // Monotonic\n                newVersion = nextVersion.getAndIncrement();\n              } else {\n                newVersion = System.nanoTime();\n              }\n\n              if (versionType != 0) {\n                if (random().nextBoolean()) {\n                  Thread.yield();\n                } else {\n                  Thread.sleep(TestUtil.nextInt(random(), 1, 4));\n                }\n              }\n\n              int x = random().nextInt(ids.length);\n\n              // TODO: we could relax this, if e.g. we assign indexer thread based on ID.  This would ensure a given ID cannot be indexed at\n              // the same time in multiple threads:\n\n              // Only one thread can update an ID at once:\n              synchronized (locks[x]) {\n\n                String id = ids[x];\n\n                // We will attempt to index id with newVersion, but only do so if id wasn't yet indexed, or it was indexed with an older\n                // version (< newVersion):\n\n                // Must lookup the RT value before pulling from the index, in case a reopen happens just after we lookup:\n                Long currentVersion = versionValues.get(id);\n\n                IndexSearcher s = mgr.acquire();\n                try {\n                  if (VERBOSE) System.out.println(\"\\n\" + Thread.currentThread().getName() + \": update id=\" + id + \" newVersion=\" + newVersion);\n\n                  if (lookup == null || lookupReader != s.getIndexReader()) {\n                    // TODO: sort of messy; we could add reopen to PerThreadVersionPKLookup?\n                    // TODO: this is thin ice .... that we don't incRef/decRef this reader we are implicitly holding onto:\n                    lookupReader = s.getIndexReader();\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \": open new PK lookup reader=\" + lookupReader);\n                    lookup = new PerThreadVersionPKLookup(lookupReader, \"id\");\n                  }\n\n                  Long truthVersion = truth.get(id);\n                  if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   truthVersion=\" + truthVersion);\n\n                  boolean doIndex;\n                  if (currentVersion == missingValue) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in RT cache\");\n                    int otherDocID = lookup.lookup(new BytesRef(id), newVersion+1);\n                    if (otherDocID == -1) {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id not in index, or version is <= newVersion; will index\");\n                      doIndex = true;\n                    } else {\n                      if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in index with version=\" + lookup.getVersion() + \"; will not index\");\n                      doIndex = false;\n                      if (truthVersion.longValue() !=lookup.getVersion()) {\n                        System.out.println(Thread.currentThread() + \": now fail0!\");\n                      }\n                      assertEquals(truthVersion.longValue(), lookup.getVersion());\n                    }\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   id is in RT cache: currentVersion=\" + currentVersion);\n                    doIndex = newVersion > currentVersion;\n                  }\n\n                  if (doIndex) {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   now index\");\n                    boolean passes = truthVersion == null || truthVersion.longValue() <= newVersion;\n                    if (passes == false) {\n                      System.out.println(Thread.currentThread() + \": now fail!\");\n                    }\n                    assertTrue(passes);\n                    Document doc = new Document();\n                    doc.add(makeIDField(id, newVersion));\n                    w.updateDocument(new Term(\"id\", id), doc);\n                    truth.put(id, newVersion);\n                    versionValues.add(id, newVersion);\n                  } else {\n                    if (VERBOSE) System.out.println(Thread.currentThread().getName() + \":   skip index\");\n                    assertNotNull(truthVersion);\n                    assertTrue(truthVersion.longValue() >= newVersion);\n                  }\n                } finally {\n                  mgr.release(s);\n                }\n              }\n            }\n          }\n        };\n      threads[i].start();\n    }\n\n    startingGun.countDown();\n\n    // Keep reopening the NRT reader until all indexing threads are done:\n    refreshLoop:\n    while (true) {\n      Thread.sleep(TestUtil.nextInt(random(), 1, 10));\n      mgr.maybeRefresh();\n      for (Thread thread : threads) {\n        if (thread.isAlive()) {\n          continue refreshLoop;\n        }\n      }\n\n      break;\n    }\n\n    // Verify final index against truth:\n    for(int i=0;i<2;i++) {\n      mgr.maybeRefresh();\n      IndexSearcher s = mgr.acquire();\n      try {\n        IndexReader r = s.getIndexReader();\n        // cannot assert this: maybe not all IDs were indexed\n        /*\n        assertEquals(numIDs, r.numDocs());\n        if (i == 1) {\n          // After forceMerge no deleted docs:\n          assertEquals(numIDs, r.maxDoc());\n        }\n        */\n        PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n        for(Map.Entry<String,Long> ent : truth.entrySet()) {\n          assertTrue(lookup.lookup(new BytesRef(ent.getKey()), -1L) != -1);\n          assertEquals(ent.getValue().longValue(), lookup.getVersion());\n        }\n      } finally {\n        mgr.release(s);\n      }\n\n      if (i == 1) {\n        break;\n      }\n\n      // forceMerge and verify again\n      w.forceMerge(1);\n    }\n\n    mgr.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":["ca044bd4a0bea8391cbebb44a34aba53a9b50541"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9017ec91c7e47796f2938c5f5705089cb048c4ae"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"9017ec91c7e47796f2938c5f5705089cb048c4ae":["3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["7b516a692d03225c8f0e81a13ceed2dc32bb457d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7b516a692d03225c8f0e81a13ceed2dc32bb457d":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["71da933d30aea361ccc224d6544c451cbf49916d"],"71da933d30aea361ccc224d6544c451cbf49916d":["5ee0394b8176abd7c90a4be8c05465be1879db79"]},"commit2Childs":{"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e":["9017ec91c7e47796f2938c5f5705089cb048c4ae"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["7b516a692d03225c8f0e81a13ceed2dc32bb457d"],"9017ec91c7e47796f2938c5f5705089cb048c4ae":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e","4d637064d608752565d4f9f41b2497dfdfdde50e"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["71da933d30aea361ccc224d6544c451cbf49916d"],"7b516a692d03225c8f0e81a13ceed2dc32bb457d":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"71da933d30aea361ccc224d6544c451cbf49916d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}