{"path":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#mapValueClassesToFieldType(List[SolrInputField]).mjava","commits":[{"id":"c5e2610b40339a9229fd44387a4a33aa04f86a69","date":1434399249,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#mapValueClassesToFieldType(List[SolrInputField]).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Maps all given field values' classes to a field type using the configured type mapping rules.\n     * \n     * @param fields one or more (same-named) field values from one or more documents\n     */\n    private String mapValueClassesToFieldType(List<SolrInputField> fields) {\n      NEXT_TYPE_MAPPING: for (TypeMapping typeMapping : typeMappings) {\n        for (SolrInputField field : fields) {\n          NEXT_FIELD_VALUE: for (Object fieldValue : field.getValues()) {\n            for (Class<?> valueClass : typeMapping.valueClasses) {\n              if (valueClass.isInstance(fieldValue)) {\n                continue NEXT_FIELD_VALUE;\n              }\n            }\n            // This fieldValue is not an instance of any of the mapped valueClass-s,\n            // so mapping fails - go try the next type mapping.\n            continue NEXT_TYPE_MAPPING;\n          }\n        }\n        // Success! Each of this field's values is an instance of a mapped valueClass\n        return typeMapping.fieldTypeName;\n      }\n      // At least one of this field's values is not an instance of any of the mapped valueClass-s\n      return defaultFieldType;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["514f9b38602488e6f0a93fae3437b1d69f42b085"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b377fd91b7578d0c02b259b5112d667e4d5f8e6","date":1499349411,"type":3,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#mapValueClassesToFieldType(List[SolrInputField]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#mapValueClassesToFieldType(List[SolrInputField]).mjava","sourceNew":"    /**\n     * Maps all given field values' classes to a typeMapping object\n     * \n     * @param fields one or more (same-named) field values from one or more documents\n     */\n    private TypeMapping mapValueClassesToFieldType(List<SolrInputField> fields) {\n      NEXT_TYPE_MAPPING: for (TypeMapping typeMapping : typeMappings) {\n        for (SolrInputField field : fields) {\n          NEXT_FIELD_VALUE: for (Object fieldValue : field.getValues()) {\n            for (Class<?> valueClass : typeMapping.valueClasses) {\n              if (valueClass.isInstance(fieldValue)) {\n                continue NEXT_FIELD_VALUE;\n              }\n            }\n            // This fieldValue is not an instance of any of the mapped valueClass-s,\n            // so mapping fails - go try the next type mapping.\n            continue NEXT_TYPE_MAPPING;\n          }\n        }\n        // Success! Each of this field's values is an instance of a mapped valueClass\n        return typeMapping;\n      }\n      // At least one of this field's values is not an instance of any of the mapped valueClass-s\n      // Return the typeMapping marked as default, if we have one, else return null to use fallback type \n      List<TypeMapping> defaultMappings = typeMappings.stream().filter(TypeMapping::isDefault).collect(Collectors.toList());\n      if (defaultMappings.size() > 1) {\n        throw new SolrException(SERVER_ERROR, \"Only one typeMapping can be default\");\n      } else if (defaultMappings.size() == 1) {\n        return defaultMappings.get(0);\n      } else {\n        return null;\n      }\n    }\n\n","sourceOld":"    /**\n     * Maps all given field values' classes to a field type using the configured type mapping rules.\n     * \n     * @param fields one or more (same-named) field values from one or more documents\n     */\n    private String mapValueClassesToFieldType(List<SolrInputField> fields) {\n      NEXT_TYPE_MAPPING: for (TypeMapping typeMapping : typeMappings) {\n        for (SolrInputField field : fields) {\n          NEXT_FIELD_VALUE: for (Object fieldValue : field.getValues()) {\n            for (Class<?> valueClass : typeMapping.valueClasses) {\n              if (valueClass.isInstance(fieldValue)) {\n                continue NEXT_FIELD_VALUE;\n              }\n            }\n            // This fieldValue is not an instance of any of the mapped valueClass-s,\n            // so mapping fails - go try the next type mapping.\n            continue NEXT_TYPE_MAPPING;\n          }\n        }\n        // Success! Each of this field's values is an instance of a mapped valueClass\n        return typeMapping.fieldTypeName;\n      }\n      // At least one of this field's values is not an instance of any of the mapped valueClass-s\n      return defaultFieldType;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e73d8d559120669b47658108d818b637df5456ea","date":1499401413,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#mapValueClassesToFieldType(List[SolrInputField]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#mapValueClassesToFieldType(List[SolrInputField]).mjava","sourceNew":"    /**\n     * Maps all given field values' classes to a typeMapping object\n     * \n     * @param fields one or more (same-named) field values from one or more documents\n     */\n    private TypeMapping mapValueClassesToFieldType(List<SolrInputField> fields) {\n      NEXT_TYPE_MAPPING: for (TypeMapping typeMapping : typeMappings) {\n        for (SolrInputField field : fields) {\n          NEXT_FIELD_VALUE: for (Object fieldValue : field.getValues()) {\n            for (Class<?> valueClass : typeMapping.valueClasses) {\n              if (valueClass.isInstance(fieldValue)) {\n                continue NEXT_FIELD_VALUE;\n              }\n            }\n            // This fieldValue is not an instance of any of the mapped valueClass-s,\n            // so mapping fails - go try the next type mapping.\n            continue NEXT_TYPE_MAPPING;\n          }\n        }\n        // Success! Each of this field's values is an instance of a mapped valueClass\n        return typeMapping;\n      }\n      // At least one of this field's values is not an instance of any of the mapped valueClass-s\n      // Return the typeMapping marked as default, if we have one, else return null to use fallback type \n      List<TypeMapping> defaultMappings = typeMappings.stream().filter(TypeMapping::isDefault).collect(Collectors.toList());\n      if (defaultMappings.size() > 1) {\n        throw new SolrException(SERVER_ERROR, \"Only one typeMapping can be default\");\n      } else if (defaultMappings.size() == 1) {\n        return defaultMappings.get(0);\n      } else {\n        return null;\n      }\n    }\n\n","sourceOld":"    /**\n     * Maps all given field values' classes to a field type using the configured type mapping rules.\n     * \n     * @param fields one or more (same-named) field values from one or more documents\n     */\n    private String mapValueClassesToFieldType(List<SolrInputField> fields) {\n      NEXT_TYPE_MAPPING: for (TypeMapping typeMapping : typeMappings) {\n        for (SolrInputField field : fields) {\n          NEXT_FIELD_VALUE: for (Object fieldValue : field.getValues()) {\n            for (Class<?> valueClass : typeMapping.valueClasses) {\n              if (valueClass.isInstance(fieldValue)) {\n                continue NEXT_FIELD_VALUE;\n              }\n            }\n            // This fieldValue is not an instance of any of the mapped valueClass-s,\n            // so mapping fails - go try the next type mapping.\n            continue NEXT_TYPE_MAPPING;\n          }\n        }\n        // Success! Each of this field's values is an instance of a mapped valueClass\n        return typeMapping.fieldTypeName;\n      }\n      // At least one of this field's values is not an instance of any of the mapped valueClass-s\n      return defaultFieldType;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"514f9b38602488e6f0a93fae3437b1d69f42b085","date":1535781210,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#mapValueClassesToFieldType(List[SolrInputField]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AddSchemaFieldsUpdateProcessorFactory.AddSchemaFieldsUpdateProcessor#mapValueClassesToFieldType(List[SolrInputField]).mjava","sourceNew":"    /**\n     * Maps all given field values' classes to a typeMapping object\n     * \n     * @param fields one or more (same-named) field values from one or more documents\n     */\n    private TypeMapping mapValueClassesToFieldType(List<SolrInputField> fields) {\n      NEXT_TYPE_MAPPING: for (TypeMapping typeMapping : typeMappings) {\n        for (SolrInputField field : fields) {\n          //We do a assert and a null check because even after SOLR-12710 is addressed\n          //older SolrJ versions can send null values causing an NPE\n          assert field.getValues() != null;\n          if (field.getValues() != null) {\n            NEXT_FIELD_VALUE: for (Object fieldValue : field.getValues()) {\n              for (Class<?> valueClass : typeMapping.valueClasses) {\n                if (valueClass.isInstance(fieldValue)) {\n                  continue NEXT_FIELD_VALUE;\n                }\n              }\n              // This fieldValue is not an instance of any of the mapped valueClass-s,\n              // so mapping fails - go try the next type mapping.\n              continue NEXT_TYPE_MAPPING;\n            }\n          }\n        }\n        // Success! Each of this field's values is an instance of a mapped valueClass\n        return typeMapping;\n      }\n      // At least one of this field's values is not an instance of any of the mapped valueClass-s\n      // Return the typeMapping marked as default, if we have one, else return null to use fallback type \n      List<TypeMapping> defaultMappings = typeMappings.stream().filter(TypeMapping::isDefault).collect(Collectors.toList());\n      if (defaultMappings.size() > 1) {\n        throw new SolrException(SERVER_ERROR, \"Only one typeMapping can be default\");\n      } else if (defaultMappings.size() == 1) {\n        return defaultMappings.get(0);\n      } else {\n        return null;\n      }\n    }\n\n","sourceOld":"    /**\n     * Maps all given field values' classes to a typeMapping object\n     * \n     * @param fields one or more (same-named) field values from one or more documents\n     */\n    private TypeMapping mapValueClassesToFieldType(List<SolrInputField> fields) {\n      NEXT_TYPE_MAPPING: for (TypeMapping typeMapping : typeMappings) {\n        for (SolrInputField field : fields) {\n          NEXT_FIELD_VALUE: for (Object fieldValue : field.getValues()) {\n            for (Class<?> valueClass : typeMapping.valueClasses) {\n              if (valueClass.isInstance(fieldValue)) {\n                continue NEXT_FIELD_VALUE;\n              }\n            }\n            // This fieldValue is not an instance of any of the mapped valueClass-s,\n            // so mapping fails - go try the next type mapping.\n            continue NEXT_TYPE_MAPPING;\n          }\n        }\n        // Success! Each of this field's values is an instance of a mapped valueClass\n        return typeMapping;\n      }\n      // At least one of this field's values is not an instance of any of the mapped valueClass-s\n      // Return the typeMapping marked as default, if we have one, else return null to use fallback type \n      List<TypeMapping> defaultMappings = typeMappings.stream().filter(TypeMapping::isDefault).collect(Collectors.toList());\n      if (defaultMappings.size() > 1) {\n        throw new SolrException(SERVER_ERROR, \"Only one typeMapping can be default\");\n      } else if (defaultMappings.size() == 1) {\n        return defaultMappings.get(0);\n      } else {\n        return null;\n      }\n    }\n\n","bugFix":["c5e2610b40339a9229fd44387a4a33aa04f86a69"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4b377fd91b7578d0c02b259b5112d667e4d5f8e6":["c5e2610b40339a9229fd44387a4a33aa04f86a69"],"514f9b38602488e6f0a93fae3437b1d69f42b085":["4b377fd91b7578d0c02b259b5112d667e4d5f8e6"],"c5e2610b40339a9229fd44387a4a33aa04f86a69":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e73d8d559120669b47658108d818b637df5456ea":["c5e2610b40339a9229fd44387a4a33aa04f86a69","4b377fd91b7578d0c02b259b5112d667e4d5f8e6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["514f9b38602488e6f0a93fae3437b1d69f42b085"]},"commit2Childs":{"4b377fd91b7578d0c02b259b5112d667e4d5f8e6":["514f9b38602488e6f0a93fae3437b1d69f42b085","e73d8d559120669b47658108d818b637df5456ea"],"c5e2610b40339a9229fd44387a4a33aa04f86a69":["4b377fd91b7578d0c02b259b5112d667e4d5f8e6","e73d8d559120669b47658108d818b637df5456ea"],"514f9b38602488e6f0a93fae3437b1d69f42b085":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c5e2610b40339a9229fd44387a4a33aa04f86a69"],"e73d8d559120669b47658108d818b637df5456ea":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e73d8d559120669b47658108d818b637df5456ea","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}