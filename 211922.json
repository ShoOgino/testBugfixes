{"path":"src/java/org/apache/solr/update/DirectUpdateHandler#commit(CommitUpdateCommand).mjava","commits":[{"id":"0c3e228bf650e96f3002a8fb73dd0c13d55af077","date":1138253849,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler#commit(CommitUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  /**************** old hit collector... new one is in base class\n  // final DeleteHitCollector deleter = new DeleteHitCollector();\n  class DeleteHitCollector extends HitCollector {\n    public int deleted=0;\n    public void collect(int doc, float score) {\n      try {\n        searcher.getReader().delete(doc);\n        deleted++;\n      } catch (IOException e) {\n        try { closeSearcher(); } catch (Exception ee) { SolrException.log(SolrCore.log,ee); }\n        SolrException.log(SolrCore.log,e);\n        throw new SolrException(500,\"Error deleting doc# \"+doc,e);\n      }\n    }\n  }\n  ***************************/\n\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    synchronized (this) {\n      pset.clear();\n      closeSearcher();  // flush any deletes\n      if (cmd.optimize) {\n        openWriter();  // writer needs to be open to optimize\n        writer.optimize();\n      }\n      closeWriter();\n\n      callPostCommitCallbacks();\n\n      core.getSearcher(true,false,waitSearcher);\n    }\n\n    if (waitSearcher[0] != null) {\n      try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91b8465fcccc31866b472215d79574deeb023eb6","date":1143840320,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler#commit(CommitUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler#commit(CommitUpdateCommand).mjava","sourceNew":"  /**************** old hit collector... new one is in base class\n  // final DeleteHitCollector deleter = new DeleteHitCollector();\n  class DeleteHitCollector extends HitCollector {\n    public int deleted=0;\n    public void collect(int doc, float score) {\n      try {\n        searcher.getReader().delete(doc);\n        deleted++;\n      } catch (IOException e) {\n        try { closeSearcher(); } catch (Exception ee) { SolrException.log(SolrCore.log,ee); }\n        SolrException.log(SolrCore.log,e);\n        throw new SolrException(500,\"Error deleting doc# \"+doc,e);\n      }\n    }\n  }\n  ***************************/\n\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    synchronized (this) {\n      pset.clear();\n      closeSearcher();  // flush any deletes\n      if (cmd.optimize) {\n        openWriter();  // writer needs to be open to optimize\n        writer.optimize();\n      }\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      core.getSearcher(true,false,waitSearcher);\n    }\n\n    if (waitSearcher[0] != null) {\n      try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","sourceOld":"  /**************** old hit collector... new one is in base class\n  // final DeleteHitCollector deleter = new DeleteHitCollector();\n  class DeleteHitCollector extends HitCollector {\n    public int deleted=0;\n    public void collect(int doc, float score) {\n      try {\n        searcher.getReader().delete(doc);\n        deleted++;\n      } catch (IOException e) {\n        try { closeSearcher(); } catch (Exception ee) { SolrException.log(SolrCore.log,ee); }\n        SolrException.log(SolrCore.log,e);\n        throw new SolrException(500,\"Error deleting doc# \"+doc,e);\n      }\n    }\n  }\n  ***************************/\n\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    synchronized (this) {\n      pset.clear();\n      closeSearcher();  // flush any deletes\n      if (cmd.optimize) {\n        openWriter();  // writer needs to be open to optimize\n        writer.optimize();\n      }\n      closeWriter();\n\n      callPostCommitCallbacks();\n\n      core.getSearcher(true,false,waitSearcher);\n    }\n\n    if (waitSearcher[0] != null) {\n      try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"395779b0be3b8194a7aba235ce8edf5921d02c15","date":1166548860,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler#commit(CommitUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler#commit(CommitUpdateCommand).mjava","sourceNew":"  /**************** old hit collector... new one is in base class\n  // final DeleteHitCollector deleter = new DeleteHitCollector();\n  class DeleteHitCollector extends HitCollector {\n    public int deleted=0;\n    public void collect(int doc, float score) {\n      try {\n        searcher.getReader().delete(doc);\n        deleted++;\n      } catch (IOException e) {\n        try { closeSearcher(); } catch (Exception ee) { SolrException.log(SolrCore.log,ee); }\n        SolrException.log(SolrCore.log,e);\n        throw new SolrException(500,\"Error deleting doc# \"+doc,e);\n      }\n    }\n  }\n  ***************************/\n\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    synchronized (this) {\n      pset.clear();\n      closeSearcher();  // flush any deletes\n      if (cmd.optimize) {\n        openWriter();  // writer needs to be open to optimize\n        writer.optimize();\n      }\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      core.getSearcher(true,false,waitSearcher);\n    }\n\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n      try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","sourceOld":"  /**************** old hit collector... new one is in base class\n  // final DeleteHitCollector deleter = new DeleteHitCollector();\n  class DeleteHitCollector extends HitCollector {\n    public int deleted=0;\n    public void collect(int doc, float score) {\n      try {\n        searcher.getReader().delete(doc);\n        deleted++;\n      } catch (IOException e) {\n        try { closeSearcher(); } catch (Exception ee) { SolrException.log(SolrCore.log,ee); }\n        SolrException.log(SolrCore.log,e);\n        throw new SolrException(500,\"Error deleting doc# \"+doc,e);\n      }\n    }\n  }\n  ***************************/\n\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    synchronized (this) {\n      pset.clear();\n      closeSearcher();  // flush any deletes\n      if (cmd.optimize) {\n        openWriter();  // writer needs to be open to optimize\n        writer.optimize();\n      }\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      core.getSearcher(true,false,waitSearcher);\n    }\n\n    if (waitSearcher[0] != null) {\n      try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996","date":1180477701,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler#commit(CommitUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler#commit(CommitUpdateCommand).mjava","sourceNew":"  /**************** old hit collector... new one is in base class\n  // final DeleteHitCollector deleter = new DeleteHitCollector();\n  class DeleteHitCollector extends HitCollector {\n    public int deleted=0;\n    public void collect(int doc, float score) {\n      try {\n        searcher.getReader().delete(doc);\n        deleted++;\n      } catch (IOException e) {\n        try { closeSearcher(); } catch (Exception ee) { SolrException.log(SolrCore.log,ee); }\n        SolrException.log(SolrCore.log,e);\n        throw new SolrException( SolrException.StatusCode.SERVER_ERROR,\"Error deleting doc# \"+doc,e);\n      }\n    }\n  }\n  ***************************/\n\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    synchronized (this) {\n      pset.clear();\n      closeSearcher();  // flush any deletes\n      if (cmd.optimize) {\n        openWriter();  // writer needs to be open to optimize\n        writer.optimize();\n      }\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      core.getSearcher(true,false,waitSearcher);\n    }\n\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n      try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","sourceOld":"  /**************** old hit collector... new one is in base class\n  // final DeleteHitCollector deleter = new DeleteHitCollector();\n  class DeleteHitCollector extends HitCollector {\n    public int deleted=0;\n    public void collect(int doc, float score) {\n      try {\n        searcher.getReader().delete(doc);\n        deleted++;\n      } catch (IOException e) {\n        try { closeSearcher(); } catch (Exception ee) { SolrException.log(SolrCore.log,ee); }\n        SolrException.log(SolrCore.log,e);\n        throw new SolrException(500,\"Error deleting doc# \"+doc,e);\n      }\n    }\n  }\n  ***************************/\n\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    synchronized (this) {\n      pset.clear();\n      closeSearcher();  // flush any deletes\n      if (cmd.optimize) {\n        openWriter();  // writer needs to be open to optimize\n        writer.optimize();\n      }\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      core.getSearcher(true,false,waitSearcher);\n    }\n\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n      try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61af939f4c10286fd8beaa0124064437b7ac44c5","date":1214514846,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler#commit(CommitUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler#commit(CommitUpdateCommand).mjava","sourceNew":"  /**************** old hit collector... new one is in base class\n  // final DeleteHitCollector deleter = new DeleteHitCollector();\n  class DeleteHitCollector extends HitCollector {\n    public int deleted=0;\n    public void collect(int doc, float score) {\n      try {\n        searcher.getReader().delete(doc);\n        deleted++;\n      } catch (IOException e) {\n        try { closeSearcher(); } catch (Exception ee) { SolrException.log(SolrCore.log,ee); }\n        SolrException.log(SolrCore.log,e);\n        throw new SolrException( SolrException.StatusCode.SERVER_ERROR,\"Error deleting doc# \"+doc,e);\n      }\n    }\n  }\n  ***************************/\n\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    synchronized (this) {\n      pset.clear();\n      closeSearcher();  // flush any deletes\n      if (cmd.optimize) {\n        openWriter();  // writer needs to be open to optimize\n        writer.optimize(cmd.maxOptimizeSegments);\n      }\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      core.getSearcher(true,false,waitSearcher);\n    }\n\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n      try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","sourceOld":"  /**************** old hit collector... new one is in base class\n  // final DeleteHitCollector deleter = new DeleteHitCollector();\n  class DeleteHitCollector extends HitCollector {\n    public int deleted=0;\n    public void collect(int doc, float score) {\n      try {\n        searcher.getReader().delete(doc);\n        deleted++;\n      } catch (IOException e) {\n        try { closeSearcher(); } catch (Exception ee) { SolrException.log(SolrCore.log,ee); }\n        SolrException.log(SolrCore.log,e);\n        throw new SolrException( SolrException.StatusCode.SERVER_ERROR,\"Error deleting doc# \"+doc,e);\n      }\n    }\n  }\n  ***************************/\n\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    synchronized (this) {\n      pset.clear();\n      closeSearcher();  // flush any deletes\n      if (cmd.optimize) {\n        openWriter();  // writer needs to be open to optimize\n        writer.optimize();\n      }\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      core.getSearcher(true,false,waitSearcher);\n    }\n\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n      try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61da3ca2ecb2710b1cc3080ea9d08114b9365cca","date":1243484201,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler#commit(CommitUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler#commit(CommitUpdateCommand).mjava","sourceNew":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    synchronized (this) {\n      pset.clear();\n      closeSearcher();  // flush any deletes\n      if (cmd.optimize) {\n        openWriter();  // writer needs to be open to optimize\n        writer.optimize(cmd.maxOptimizeSegments);\n      }\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      core.getSearcher(true,false,waitSearcher);\n    }\n\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n      try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","sourceOld":"  /**************** old hit collector... new one is in base class\n  // final DeleteHitCollector deleter = new DeleteHitCollector();\n  class DeleteHitCollector extends HitCollector {\n    public int deleted=0;\n    public void collect(int doc, float score) {\n      try {\n        searcher.getReader().delete(doc);\n        deleted++;\n      } catch (IOException e) {\n        try { closeSearcher(); } catch (Exception ee) { SolrException.log(SolrCore.log,ee); }\n        SolrException.log(SolrCore.log,e);\n        throw new SolrException( SolrException.StatusCode.SERVER_ERROR,\"Error deleting doc# \"+doc,e);\n      }\n    }\n  }\n  ***************************/\n\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    synchronized (this) {\n      pset.clear();\n      closeSearcher();  // flush any deletes\n      if (cmd.optimize) {\n        openWriter();  // writer needs to be open to optimize\n        writer.optimize(cmd.maxOptimizeSegments);\n      }\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      core.getSearcher(true,false,waitSearcher);\n    }\n\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n      try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"366ee8589b0d5578d8944e35470687383abbcd94","date":1250684482,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DirectUpdateHandler#commit(CommitUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler#commit(CommitUpdateCommand).mjava","sourceNew":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    synchronized (this) {\n      pset.clear();\n      closeSearcher();  // flush any deletes\n      if (cmd.optimize || cmd.expungeDeletes) {\n        openWriter();  // writer needs to be open to optimize\n        if(cmd.optimize) writer.optimize(cmd.maxOptimizeSegments);\n        if(cmd.expungeDeletes) writer.expungeDeletes(cmd.expungeDeletes);\n      }\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      core.getSearcher(true,false,waitSearcher);\n    }\n\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n      try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","sourceOld":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    synchronized (this) {\n      pset.clear();\n      closeSearcher();  // flush any deletes\n      if (cmd.optimize) {\n        openWriter();  // writer needs to be open to optimize\n        writer.optimize(cmd.maxOptimizeSegments);\n      }\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      core.getSearcher(true,false,waitSearcher);\n    }\n\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n      try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler#commit(CommitUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler#commit(CommitUpdateCommand).mjava","sourceNew":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    synchronized (this) {\n      pset.clear();\n      closeSearcher();  // flush any deletes\n      if (cmd.optimize || cmd.expungeDeletes) {\n        openWriter();  // writer needs to be open to optimize\n        if(cmd.optimize) writer.optimize(cmd.maxOptimizeSegments);\n        if(cmd.expungeDeletes) writer.expungeDeletes(cmd.expungeDeletes);\n      }\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      core.getSearcher(true,false,waitSearcher);\n    }\n\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n      try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","sourceOld":"  public void commit(CommitUpdateCommand cmd) throws IOException {\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    synchronized (this) {\n      pset.clear();\n      closeSearcher();  // flush any deletes\n      if (cmd.optimize || cmd.expungeDeletes) {\n        openWriter();  // writer needs to be open to optimize\n        if(cmd.optimize) writer.optimize(cmd.maxOptimizeSegments);\n        if(cmd.expungeDeletes) writer.expungeDeletes(cmd.expungeDeletes);\n      }\n      closeWriter();\n\n      callPostCommitCallbacks();\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      core.getSearcher(true,false,waitSearcher);\n    }\n\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n      try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n\n    return;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"91b8465fcccc31866b472215d79574deeb023eb6":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"366ee8589b0d5578d8944e35470687383abbcd94":["61da3ca2ecb2710b1cc3080ea9d08114b9365cca"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"395779b0be3b8194a7aba235ce8edf5921d02c15":["91b8465fcccc31866b472215d79574deeb023eb6"],"61da3ca2ecb2710b1cc3080ea9d08114b9365cca":["61af939f4c10286fd8beaa0124064437b7ac44c5"],"ad94625fb8d088209f46650c8097196fec67f00c":["366ee8589b0d5578d8944e35470687383abbcd94"],"61af939f4c10286fd8beaa0124064437b7ac44c5":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996":["395779b0be3b8194a7aba235ce8edf5921d02c15"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"91b8465fcccc31866b472215d79574deeb023eb6":["395779b0be3b8194a7aba235ce8edf5921d02c15"],"366ee8589b0d5578d8944e35470687383abbcd94":["ad94625fb8d088209f46650c8097196fec67f00c"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["91b8465fcccc31866b472215d79574deeb023eb6"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"395779b0be3b8194a7aba235ce8edf5921d02c15":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"61da3ca2ecb2710b1cc3080ea9d08114b9365cca":["366ee8589b0d5578d8944e35470687383abbcd94"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"61af939f4c10286fd8beaa0124064437b7ac44c5":["61da3ca2ecb2710b1cc3080ea9d08114b9365cca"],"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996":["61af939f4c10286fd8beaa0124064437b7ac44c5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}