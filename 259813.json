{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[GeoPoint]).mjava","commits":[{"id":"4d85423d45b4f1c56d97b657faad35d1a3100d50","date":1460895224,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[GeoPoint]).mjava","pathOld":"/dev/null","sourceNew":"  /** Filter duplicate points and coplanar points.\n   */\n  static List<GeoPoint> filterPoints(final List<GeoPoint> input) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      throw new IllegalArgumentException(\"polygon is degenerate: all points are identical\");\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      throw new IllegalArgumentException(\"polygon has fewer than three non-identical points\");\n    }\n    \n    // Next step: remove coplanar points and backtracks.  For this, we use a strategy that is similar but we assess whether the points\n    // are on the same plane, taking the first and last points on the same plane only.\n    \n    final List<GeoPoint> nonCoplanarPoints = new ArrayList<>(noIdenticalPoints.size());\n    \n    int startPlaneIndex = -1;\n    final Plane comparePlane = new Plane(noIdenticalPoints.get(0), noIdenticalPoints.get(1));\n    for (int i = 0; i < noIdenticalPoints.size()-1; i++) {\n      final GeoPoint thePoint = noIdenticalPoints.get(getLegalIndex(- i - 1, noIdenticalPoints.size()));\n      if (!comparePlane.evaluateIsZero(thePoint)) {\n        startPlaneIndex = getLegalIndex(-i, noIdenticalPoints.size());\n        break;\n      }\n    }\n    if (startPlaneIndex == -1) {\n      throw new IllegalArgumentException(\"polygon is degenerate: all points are coplanar\");\n    }\n\n    // Now we can start the process of walking around, removing duplicate points.\n    int currentPlaneIndex = startPlaneIndex;\n    while (true) {\n      final GeoPoint currentPoint = noIdenticalPoints.get(currentPlaneIndex);\n      nonCoplanarPoints.add(currentPoint);\n      int nextPlaneIndex = getLegalIndex(currentPlaneIndex + 1, noIdenticalPoints.size());\n      if (nextPlaneIndex == startPlaneIndex) {\n        break;\n      }\n      final Plane testPlane = new Plane(currentPoint, noIdenticalPoints.get(nextPlaneIndex));\n      while (true) {\n        currentPlaneIndex = nextPlaneIndex;\n        if (currentPlaneIndex == startPlaneIndex) {\n          break;\n        }\n        // Check if the next point is off plane\n        nextPlaneIndex = getLegalIndex(currentPlaneIndex + 1, noIdenticalPoints.size());\n        final GeoPoint nextNonCoplanarPoint = noIdenticalPoints.get(nextPlaneIndex);\n        if (!testPlane.evaluateIsZero(nextNonCoplanarPoint)) {\n          // We will want to add the point at currentPlaneIndex to the list (last on of the series)\n          break;\n        }\n      }\n      if (currentPlaneIndex == startPlaneIndex) {\n        break;\n      }\n    }\n    \n    return nonCoplanarPoints;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"536a864ce38bf14fb3f072a3129a389e95200e20","date":1461068886,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[GeoPoint]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[GeoPoint]).mjava","sourceNew":"  /** Filter duplicate points and coplanar points.\n   * @param start with input list of points\n   * @return the filtered list, or null if we can't get a legit polygon from the input.\n   */\n  static List<GeoPoint> filterPoints(final List<GeoPoint> input) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      return null;\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      return null;\n    }\n    \n    // Now, do the depth-first search needed to find a path that has no coplanarities in it.\n    // This is, unfortunately, not easy, because coplanarity is not transitive as you walk around the polygon.\n    // If point C is not coplanar with edge A-B, there is no guarantee that A is not coplanar with B-C.\n    // But we have to produce a polygon that is safe no matter which way it is looked at.\n    // The approach I'm taking therefore is to do a depth-first search until we find a valid polygon.\n    // This algorithmically awful in the worst case, but luckily we can presume that real-life data\n    // does not require more than a couple of iterations.\n    \n    for  (int i = 0; i < noIdenticalPoints.size(); i++) {\n      final SafePath startPath = new SafePath(null, noIdenticalPoints.get(i), i, null);\n      // Search, with this as the start path.\n      final SafePath resultPath = findSafePath(startPath, noIdenticalPoints, getLegalIndex(i+1, noIdenticalPoints.size()), i);\n      if (resultPath != null && resultPath.previous != null) {\n        // Read out result, maintaining ordering\n        final List<GeoPoint> rval = new ArrayList<>(noIdenticalPoints.size());\n        resultPath.fillInList(rval);\n        return rval;\n      }\n    }\n    // No path found.  This means that everything was coplanar.\n    return null;\n  }\n\n","sourceOld":"  /** Filter duplicate points and coplanar points.\n   */\n  static List<GeoPoint> filterPoints(final List<GeoPoint> input) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      throw new IllegalArgumentException(\"polygon is degenerate: all points are identical\");\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      throw new IllegalArgumentException(\"polygon has fewer than three non-identical points\");\n    }\n    \n    // Next step: remove coplanar points and backtracks.  For this, we use a strategy that is similar but we assess whether the points\n    // are on the same plane, taking the first and last points on the same plane only.\n    \n    final List<GeoPoint> nonCoplanarPoints = new ArrayList<>(noIdenticalPoints.size());\n    \n    int startPlaneIndex = -1;\n    final Plane comparePlane = new Plane(noIdenticalPoints.get(0), noIdenticalPoints.get(1));\n    for (int i = 0; i < noIdenticalPoints.size()-1; i++) {\n      final GeoPoint thePoint = noIdenticalPoints.get(getLegalIndex(- i - 1, noIdenticalPoints.size()));\n      if (!comparePlane.evaluateIsZero(thePoint)) {\n        startPlaneIndex = getLegalIndex(-i, noIdenticalPoints.size());\n        break;\n      }\n    }\n    if (startPlaneIndex == -1) {\n      throw new IllegalArgumentException(\"polygon is degenerate: all points are coplanar\");\n    }\n\n    // Now we can start the process of walking around, removing duplicate points.\n    int currentPlaneIndex = startPlaneIndex;\n    while (true) {\n      final GeoPoint currentPoint = noIdenticalPoints.get(currentPlaneIndex);\n      nonCoplanarPoints.add(currentPoint);\n      int nextPlaneIndex = getLegalIndex(currentPlaneIndex + 1, noIdenticalPoints.size());\n      if (nextPlaneIndex == startPlaneIndex) {\n        break;\n      }\n      final Plane testPlane = new Plane(currentPoint, noIdenticalPoints.get(nextPlaneIndex));\n      while (true) {\n        currentPlaneIndex = nextPlaneIndex;\n        if (currentPlaneIndex == startPlaneIndex) {\n          break;\n        }\n        // Check if the next point is off plane\n        nextPlaneIndex = getLegalIndex(currentPlaneIndex + 1, noIdenticalPoints.size());\n        final GeoPoint nextNonCoplanarPoint = noIdenticalPoints.get(nextPlaneIndex);\n        if (!testPlane.evaluateIsZero(nextNonCoplanarPoint)) {\n          // We will want to add the point at currentPlaneIndex to the list (last on of the series)\n          break;\n        }\n      }\n      if (currentPlaneIndex == startPlaneIndex) {\n        break;\n      }\n    }\n    \n    return nonCoplanarPoints;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"682a83d892315f255e96edb6e48d59527c9cac9e","date":1461087846,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[GeoPoint]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[GeoPoint]).mjava","sourceNew":"  /** Filter duplicate points and coplanar points.\n   * @param input with input list of points\n   * @return the filtered list, or null if we can't get a legit polygon from the input.\n   */\n  static List<GeoPoint> filterPoints(final List<GeoPoint> input) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      return null;\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      return null;\n    }\n    \n    // Now, do the depth-first search needed to find a path that has no coplanarities in it.\n    // This is, unfortunately, not easy, because coplanarity is not transitive as you walk around the polygon.\n    // If point C is not coplanar with edge A-B, there is no guarantee that A is not coplanar with B-C.\n    // But we have to produce a polygon that is safe no matter which way it is looked at.\n    // The approach I'm taking therefore is to do a depth-first search until we find a valid polygon.\n    // This algorithmically awful in the worst case, but luckily we can presume that real-life data\n    // does not require more than a couple of iterations.\n    \n    for  (int i = 0; i < noIdenticalPoints.size(); i++) {\n      final SafePath startPath = new SafePath(null, noIdenticalPoints.get(i), i, null);\n      // Search, with this as the start path.\n      final SafePath resultPath = findSafePath(startPath, noIdenticalPoints, getLegalIndex(i+1, noIdenticalPoints.size()), i);\n      if (resultPath != null && resultPath.previous != null) {\n        // Read out result, maintaining ordering\n        final List<GeoPoint> rval = new ArrayList<>(noIdenticalPoints.size());\n        resultPath.fillInList(rval);\n        return rval;\n      }\n    }\n    // No path found.  This means that everything was coplanar.\n    return null;\n  }\n\n","sourceOld":"  /** Filter duplicate points and coplanar points.\n   * @param start with input list of points\n   * @return the filtered list, or null if we can't get a legit polygon from the input.\n   */\n  static List<GeoPoint> filterPoints(final List<GeoPoint> input) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      return null;\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      return null;\n    }\n    \n    // Now, do the depth-first search needed to find a path that has no coplanarities in it.\n    // This is, unfortunately, not easy, because coplanarity is not transitive as you walk around the polygon.\n    // If point C is not coplanar with edge A-B, there is no guarantee that A is not coplanar with B-C.\n    // But we have to produce a polygon that is safe no matter which way it is looked at.\n    // The approach I'm taking therefore is to do a depth-first search until we find a valid polygon.\n    // This algorithmically awful in the worst case, but luckily we can presume that real-life data\n    // does not require more than a couple of iterations.\n    \n    for  (int i = 0; i < noIdenticalPoints.size(); i++) {\n      final SafePath startPath = new SafePath(null, noIdenticalPoints.get(i), i, null);\n      // Search, with this as the start path.\n      final SafePath resultPath = findSafePath(startPath, noIdenticalPoints, getLegalIndex(i+1, noIdenticalPoints.size()), i);\n      if (resultPath != null && resultPath.previous != null) {\n        // Read out result, maintaining ordering\n        final List<GeoPoint> rval = new ArrayList<>(noIdenticalPoints.size());\n        resultPath.fillInList(rval);\n        return rval;\n      }\n    }\n    // No path found.  This means that everything was coplanar.\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99b0a9e4d18bb364d2546e5230cc61abcd2d366b","date":1461241852,"type":5,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[GeoPoint],double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[GeoPoint]).mjava","sourceNew":"  /** Filter duplicate points and coplanar points.\n   * @param input with input list of points\n   * @param leniencyValue is the allowed distance of a point from the plane for cleanup of overly detailed polygons\n   * @return the filtered list, or null if we can't get a legit polygon from the input.\n   */\n  static List<GeoPoint> filterPoints(final List<GeoPoint> input, final double leniencyValue) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      return null;\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      return null;\n    }\n    \n    // Now, do the depth-first search needed to find a path that has no coplanarities in it.\n    // This is, unfortunately, not easy, because coplanarity is not transitive as you walk around the polygon.\n    // If point C is not coplanar with edge A-B, there is no guarantee that A is not coplanar with B-C.\n    // But we have to produce a polygon that is safe no matter which way it is looked at.\n    // The approach I'm taking therefore is to do a depth-first search until we find a valid polygon.\n    // This algorithmically awful in the worst case, but luckily we can presume that real-life data\n    // does not require more than a couple of iterations.\n    \n    for  (int i = 0; i < noIdenticalPoints.size(); i++) {\n      final SafePath startPath = new SafePath(null, noIdenticalPoints.get(i), i, null);\n      // Search, with this as the start path.\n      final SafePath resultPath = findSafePath(startPath, noIdenticalPoints, getLegalIndex(i+1, noIdenticalPoints.size()), i, leniencyValue);\n      if (resultPath != null && resultPath.previous != null) {\n        // Read out result, maintaining ordering\n        final List<GeoPoint> rval = new ArrayList<>(noIdenticalPoints.size());\n        resultPath.fillInList(rval);\n        return rval;\n      }\n    }\n    // No path found.  This means that everything was coplanar.\n    return null;\n  }\n\n","sourceOld":"  /** Filter duplicate points and coplanar points.\n   * @param input with input list of points\n   * @return the filtered list, or null if we can't get a legit polygon from the input.\n   */\n  static List<GeoPoint> filterPoints(final List<GeoPoint> input) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      return null;\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      return null;\n    }\n    \n    // Now, do the depth-first search needed to find a path that has no coplanarities in it.\n    // This is, unfortunately, not easy, because coplanarity is not transitive as you walk around the polygon.\n    // If point C is not coplanar with edge A-B, there is no guarantee that A is not coplanar with B-C.\n    // But we have to produce a polygon that is safe no matter which way it is looked at.\n    // The approach I'm taking therefore is to do a depth-first search until we find a valid polygon.\n    // This algorithmically awful in the worst case, but luckily we can presume that real-life data\n    // does not require more than a couple of iterations.\n    \n    for  (int i = 0; i < noIdenticalPoints.size(); i++) {\n      final SafePath startPath = new SafePath(null, noIdenticalPoints.get(i), i, null);\n      // Search, with this as the start path.\n      final SafePath resultPath = findSafePath(startPath, noIdenticalPoints, getLegalIndex(i+1, noIdenticalPoints.size()), i);\n      if (resultPath != null && resultPath.previous != null) {\n        // Read out result, maintaining ordering\n        final List<GeoPoint> rval = new ArrayList<>(noIdenticalPoints.size());\n        resultPath.fillInList(rval);\n        return rval;\n      }\n    }\n    // No path found.  This means that everything was coplanar.\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba1a26cce088d68dd4a3c599994fbc52c06e37b4","date":1461672182,"type":2,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[GeoPoint]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[GeoPoint],double).mjava","sourceNew":"  /** Filter duplicate points.\n   * @param input with input list of points\n   * @return the filtered list, or null if we can't get a legit polygon from the input.\n   */\n  static List<GeoPoint> filterPoints(final List<GeoPoint> input) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      return null;\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      return null;\n    }\n    \n    return noIdenticalPoints;\n  }\n\n","sourceOld":"  /** Filter duplicate points and coplanar points.\n   * @param input with input list of points\n   * @param leniencyValue is the allowed distance of a point from the plane for cleanup of overly detailed polygons\n   * @return the filtered list, or null if we can't get a legit polygon from the input.\n   */\n  static List<GeoPoint> filterPoints(final List<GeoPoint> input, final double leniencyValue) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      return null;\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      return null;\n    }\n    \n    // Now, do the depth-first search needed to find a path that has no coplanarities in it.\n    // This is, unfortunately, not easy, because coplanarity is not transitive as you walk around the polygon.\n    // If point C is not coplanar with edge A-B, there is no guarantee that A is not coplanar with B-C.\n    // But we have to produce a polygon that is safe no matter which way it is looked at.\n    // The approach I'm taking therefore is to do a depth-first search until we find a valid polygon.\n    // This algorithmically awful in the worst case, but luckily we can presume that real-life data\n    // does not require more than a couple of iterations.\n    \n    for  (int i = 0; i < noIdenticalPoints.size(); i++) {\n      final SafePath startPath = new SafePath(null, noIdenticalPoints.get(i), i, null);\n      // Search, with this as the start path.\n      final SafePath resultPath = findSafePath(startPath, noIdenticalPoints, getLegalIndex(i+1, noIdenticalPoints.size()), i, leniencyValue);\n      if (resultPath != null && resultPath.previous != null) {\n        // Read out result, maintaining ordering\n        final List<GeoPoint> rval = new ArrayList<>(noIdenticalPoints.size());\n        resultPath.fillInList(rval);\n        return rval;\n      }\n    }\n    // No path found.  This means that everything was coplanar.\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06729f5a814f91b46fa06d668ae86a5d257ba644","date":1461675413,"type":5,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[#-extends-GeoPoint]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[GeoPoint]).mjava","sourceNew":"  /** Filter duplicate points.\n   * @param input with input list of points\n   * @return the filtered list, or null if we can't get a legit polygon from the input.\n   */\n  static List<GeoPoint> filterPoints(final List<? extends GeoPoint> input) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      return null;\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      return null;\n    }\n    \n    return noIdenticalPoints;\n  }\n\n","sourceOld":"  /** Filter duplicate points.\n   * @param input with input list of points\n   * @return the filtered list, or null if we can't get a legit polygon from the input.\n   */\n  static List<GeoPoint> filterPoints(final List<GeoPoint> input) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      return null;\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      return null;\n    }\n    \n    return noIdenticalPoints;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4d85423d45b4f1c56d97b657faad35d1a3100d50":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"06729f5a814f91b46fa06d668ae86a5d257ba644":["ba1a26cce088d68dd4a3c599994fbc52c06e37b4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"682a83d892315f255e96edb6e48d59527c9cac9e":["536a864ce38bf14fb3f072a3129a389e95200e20"],"ba1a26cce088d68dd4a3c599994fbc52c06e37b4":["99b0a9e4d18bb364d2546e5230cc61abcd2d366b"],"99b0a9e4d18bb364d2546e5230cc61abcd2d366b":["682a83d892315f255e96edb6e48d59527c9cac9e"],"536a864ce38bf14fb3f072a3129a389e95200e20":["4d85423d45b4f1c56d97b657faad35d1a3100d50"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["99b0a9e4d18bb364d2546e5230cc61abcd2d366b"]},"commit2Childs":{"4d85423d45b4f1c56d97b657faad35d1a3100d50":["536a864ce38bf14fb3f072a3129a389e95200e20"],"06729f5a814f91b46fa06d668ae86a5d257ba644":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4d85423d45b4f1c56d97b657faad35d1a3100d50"],"682a83d892315f255e96edb6e48d59527c9cac9e":["99b0a9e4d18bb364d2546e5230cc61abcd2d366b"],"ba1a26cce088d68dd4a3c599994fbc52c06e37b4":["06729f5a814f91b46fa06d668ae86a5d257ba644"],"536a864ce38bf14fb3f072a3129a389e95200e20":["682a83d892315f255e96edb6e48d59527c9cac9e"],"99b0a9e4d18bb364d2546e5230cc61abcd2d366b":["ba1a26cce088d68dd4a3c599994fbc52c06e37b4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["06729f5a814f91b46fa06d668ae86a5d257ba644","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}