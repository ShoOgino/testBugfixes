{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map[String,String]).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map[String,String]).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    // TODO: as of LUCENE-2095, we can simplify this method,\n    // since only 1 thread can be in here at once\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes();\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n          \n          readerPool.commit();\n          \n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Collection<String> files = toSync.files(directory, false);\n          for(final String fileName: files) {\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection<String> pending = new ArrayList<String>();\n\n          Iterator<String> it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    // TODO: as of LUCENE-2095, we can simplify this method,\n    // since only 1 thread can be in here at once\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes();\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n          \n          readerPool.commit();\n          \n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Collection<String> files = toSync.files(directory, false);\n          for(final String fileName: files) {\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection<String> pending = new ArrayList<String>();\n\n          Iterator<String> it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e4b4e97a5e8ab5b96cc56c561131d720c756756b","date":1269362401,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    // TODO: as of LUCENE-2095, we can simplify this method,\n    // since only 1 thread can be in here at once\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes();\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n          \n          readerPool.commit();\n          \n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Collection<String> files = toSync.files(directory, false);\n          for(final String fileName: files) {\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    // TODO: as of LUCENE-2095, we can simplify this method,\n    // since only 1 thread can be in here at once\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes();\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n          \n          readerPool.commit();\n          \n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Collection<String> files = toSync.files(directory, false);\n          for(final String fileName: files) {\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection<String> pending = new ArrayList<String>();\n\n          Iterator<String> it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb10b6bcde550b87d8f10e5f010bd8f3021023b6","date":1274974592,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    // TODO: as of LUCENE-2095, we can simplify this method,\n    // since only 1 thread can be in here at once\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.  Multiple\n        // threads can be doing this at once, if say a large\n        // merge and a small merge finish at the same time:\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n        \n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        deleter.incRef(toSync, false);\n        myChangeCount = changeCount;\n        \n        Collection<String> files = toSync.files(directory, false);\n        for(final String fileName: files) {\n          assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    // TODO: as of LUCENE-2095, we can simplify this method,\n    // since only 1 thread can be in here at once\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes();\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n          \n          readerPool.commit();\n          \n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Collection<String> files = toSync.files(directory, false);\n          for(final String fileName: files) {\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":["d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1085ea837da8f1e96697e17cf73e1d08e7329261","date":1281469548,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    // TODO: as of LUCENE-2095, we can simplify this method,\n    // since only 1 thread can be in here at once\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.  Multiple\n        // threads can be doing this at once, if say a large\n        // merge and a small merge finish at the same time:\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n        \n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        deleter.incRef(toSync, false);\n        myChangeCount = changeCount;\n        \n        Collection<String> files = toSync.files(directory, false);\n        for(final String fileName: files) {\n          assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n\n          // If this trips it means we are missing a call to\n          // .checkpoint somewhere, because by the time we\n          // are called, deleter should know about every\n          // file referenced by the current head\n          // segmentInfos:\n          assert deleter.exists(fileName);\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    // TODO: as of LUCENE-2095, we can simplify this method,\n    // since only 1 thread can be in here at once\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.  Multiple\n        // threads can be doing this at once, if say a large\n        // merge and a small merge finish at the same time:\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n        \n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        deleter.incRef(toSync, false);\n        myChangeCount = changeCount;\n        \n        Collection<String> files = toSync.files(directory, false);\n        for(final String fileName: files) {\n          assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"975460c64e0309e8a78d230321879ec18e65dc0a","date":1281550753,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n        myChangeCount = changeCount;\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    // TODO: as of LUCENE-2095, we can simplify this method,\n    // since only 1 thread can be in here at once\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.  Multiple\n        // threads can be doing this at once, if say a large\n        // merge and a small merge finish at the same time:\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n        \n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        deleter.incRef(toSync, false);\n        myChangeCount = changeCount;\n        \n        Collection<String> files = toSync.files(directory, false);\n        for(final String fileName: files) {\n          assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n\n          // If this trips it means we are missing a call to\n          // .checkpoint somewhere, because by the time we\n          // are called, deleter should know about every\n          // file referenced by the current head\n          // segmentInfos:\n          assert deleter.exists(fileName);\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":["850aca8525380ccb7df9626d7caa89678005dd31"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8ebf8c7f71c978cb9cdc8f49ff9f14751927f8a7","date":1290867534,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n        myChangeCount = changeCount;\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n        myChangeCount = changeCount;\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map[String,String]).mjava","sourceNew":null,"sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n        myChangeCount = changeCount;\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":4,"author":"Michael Busch","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map[String,String]).mjava","sourceNew":null,"sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    // TODO: as of LUCENE-2095, we can simplify this method,\n    // since only 1 thread can be in here at once\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.  Multiple\n        // threads can be doing this at once, if say a large\n        // merge and a small merge finish at the same time:\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n        \n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        deleter.incRef(toSync, false);\n        myChangeCount = changeCount;\n        \n        Collection<String> files = toSync.files(directory, false);\n        for(final String fileName: files) {\n          assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8ebf8c7f71c978cb9cdc8f49ff9f14751927f8a7":["975460c64e0309e8a78d230321879ec18e65dc0a"],"975460c64e0309e8a78d230321879ec18e65dc0a":["1085ea837da8f1e96697e17cf73e1d08e7329261"],"1085ea837da8f1e96697e17cf73e1d08e7329261":["fb10b6bcde550b87d8f10e5f010bd8f3021023b6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["fb10b6bcde550b87d8f10e5f010bd8f3021023b6","8ebf8c7f71c978cb9cdc8f49ff9f14751927f8a7"],"3bb13258feba31ab676502787ab2e1779f129b7a":["975460c64e0309e8a78d230321879ec18e65dc0a","8ebf8c7f71c978cb9cdc8f49ff9f14751927f8a7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8ebf8c7f71c978cb9cdc8f49ff9f14751927f8a7"],"fb10b6bcde550b87d8f10e5f010bd8f3021023b6":["e4b4e97a5e8ab5b96cc56c561131d720c756756b"],"e4b4e97a5e8ab5b96cc56c561131d720c756756b":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"8ebf8c7f71c978cb9cdc8f49ff9f14751927f8a7":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","3bb13258feba31ab676502787ab2e1779f129b7a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"975460c64e0309e8a78d230321879ec18e65dc0a":["8ebf8c7f71c978cb9cdc8f49ff9f14751927f8a7","3bb13258feba31ab676502787ab2e1779f129b7a"],"1085ea837da8f1e96697e17cf73e1d08e7329261":["975460c64e0309e8a78d230321879ec18e65dc0a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"3bb13258feba31ab676502787ab2e1779f129b7a":[],"fb10b6bcde550b87d8f10e5f010bd8f3021023b6":["1085ea837da8f1e96697e17cf73e1d08e7329261","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e4b4e97a5e8ab5b96cc56c561131d720c756756b":["fb10b6bcde550b87d8f10e5f010bd8f3021023b6"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["e4b4e97a5e8ab5b96cc56c561131d720c756756b"]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","3bb13258feba31ab676502787ab2e1779f129b7a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}