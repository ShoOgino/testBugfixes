{"path":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /**\n   * Save this segment's info.\n   */\n  void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    output.writeByte((byte) (hasSingleNormFile ? 1:0));\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for(int j = 0; j < normGen.length; j++) {\n        output.writeLong(normGen[j]);\n      }\n    }\n    output.writeByte(isCompoundFile);\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    output.writeStringStringMap(diagnostics);\n  }\n\n","sourceOld":"  /**\n   * Save this segment's info.\n   */\n  void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    output.writeByte((byte) (hasSingleNormFile ? 1:0));\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for(int j = 0; j < normGen.length; j++) {\n        output.writeLong(normGen[j]);\n      }\n    }\n    output.writeByte(isCompoundFile);\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    output.writeStringStringMap(diagnostics);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /**\n   * Save this segment's info.\n   */\n  void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    output.writeByte((byte) (hasSingleNormFile ? 1:0));\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for(int j = 0; j < normGen.length; j++) {\n        output.writeLong(normGen[j]);\n      }\n    }\n    output.writeByte(isCompoundFile);\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    output.writeString(codec.name);\n    output.writeStringStringMap(diagnostics);\n  }\n\n","sourceOld":"  /**\n   * Save this segment's info.\n   */\n  void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    output.writeByte((byte) (hasSingleNormFile ? 1:0));\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for(int j = 0; j < normGen.length; j++) {\n        output.writeLong(normGen[j]);\n      }\n    }\n    output.writeByte(isCompoundFile);\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    output.writeStringStringMap(diagnostics);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6267e1ce56c2eec111425690cd04e251b6f14952","date":1275222352,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    output.writeString(codec.name);\n    output.writeStringStringMap(diagnostics);\n  }\n\n","sourceOld":"  /**\n   * Save this segment's info.\n   */\n  void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    output.writeByte((byte) (hasSingleNormFile ? 1:0));\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for(int j = 0; j < normGen.length; j++) {\n        output.writeLong(normGen[j]);\n      }\n    }\n    output.writeByte(isCompoundFile);\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    output.writeString(codec.name);\n    output.writeStringStringMap(diagnostics);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6066dbe072ec5334ff5824f474e9d3abd1620fb7","date":1278709584,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    output.writeString(codec.name);\n    output.writeStringStringMap(diagnostics);\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    output.writeString(codec.name);\n    output.writeStringStringMap(diagnostics);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    output.writeString(codec.name);\n    output.writeStringStringMap(diagnostics);\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    output.writeString(codec.name);\n    output.writeStringStringMap(diagnostics);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"833a7987bc1c94455fde83e3311f72bddedcfb93","date":1279951470,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    output.writeString(codec.name);\n    output.writeStringStringMap(diagnostics);\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    output.writeString(codec.name);\n    output.writeStringStringMap(diagnostics);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a493e6d0c3ad86bd55c0a1360d110142e948f2bd","date":1289406991,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    output.writeString(codec.name);\n    output.writeStringStringMap(diagnostics);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85a883878c0af761245ab048babc63d099f835f3","date":1289553330,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    output.writeString(codec.name);\n    output.writeStringStringMap(diagnostics);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e1cbd7e289dc1243c7a59e1a83d078163a147fe","date":1292268032,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte(hasVectors);\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5dd55ef4d8a74ff17963e786d91a8ddc54806cfa","date":1292347838,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte(hasVectors);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    output.writeString(codec.name);\n    output.writeStringStringMap(diagnostics);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9dc373b96fc96e6300e2f5af947f6998e6aa6a6","date":1295759448,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9b72f7c3d7827c64dd4ec580ded81778da361d","date":1295897920,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0c7a8f7304b75b1528814c5820fa23a96816c27","date":1298314239,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) hasProx);\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) hasVectors);\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) hasProx);\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) hasVectors);\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14ec33385f6fbb6ce172882d14605790418a5d31","date":1298910796,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) hasProx);\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) hasVectors);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1224a4027481acce15495b03bce9b48b93b42722","date":1300792329,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.length);\n      for (long fieldNormGen : normGen) {\n        output.writeLong(fieldNormGen);\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) hasProx);\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) hasVectors);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f411c79281946a184efeab34a673deffc25edcb","date":1303995312,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9df1ed091b5966e1234a7c4233d866955c0460a7","date":1304068770,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fe2fc74577855eadfb5eae3153c2fffdaaf791","date":1305237079,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c700f8d0842d3e52bb2bdfbfdc046a137e836edb","date":1305285499,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n    \n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx ? 1:0));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors ? 1 : 0));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx));\n    output.writeString(codec.getName());\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors));\n  }\n\n","sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx));\n    segmentCodecs.write(output);\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfo#write(IndexOutput).mjava","sourceNew":null,"sourceOld":"  /** Save this segment's info. */\n  public void write(IndexOutput output)\n    throws IOException {\n    assert delCount <= docCount: \"delCount=\" + delCount + \" docCount=\" + docCount + \" segment=\" + name;\n    // Write the Lucene version that created this segment, since 3.1\n    output.writeString(version);\n    output.writeString(name);\n    output.writeInt(docCount);\n    output.writeLong(delGen);\n\n    output.writeInt(docStoreOffset);\n    if (docStoreOffset != -1) {\n      output.writeString(docStoreSegment);\n      output.writeByte((byte) (docStoreIsCompoundFile ? 1:0));\n    }\n\n\n    if (normGen == null) {\n      output.writeInt(NO);\n    } else {\n      output.writeInt(normGen.size());\n      for (Entry<Integer,Long> entry : normGen.entrySet()) {\n        output.writeInt(entry.getKey());\n        output.writeLong(entry.getValue());\n      }\n    }\n\n    output.writeByte((byte) (isCompoundFile ? YES : NO));\n    output.writeInt(delCount);\n    output.writeByte((byte) (hasProx));\n    output.writeString(codec.getName());\n    output.writeStringStringMap(diagnostics);\n    output.writeByte((byte) (hasVectors));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fe2fc74577855eadfb5eae3153c2fffdaaf791":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"a493e6d0c3ad86bd55c0a1360d110142e948f2bd":["6066dbe072ec5334ff5824f474e9d3abd1620fb7"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["833a7987bc1c94455fde83e3311f72bddedcfb93","5dd55ef4d8a74ff17963e786d91a8ddc54806cfa"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","b9dc373b96fc96e6300e2f5af947f6998e6aa6a6"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["bde51b089eb7f86171eb3406e38a274743f9b7ac","1224a4027481acce15495b03bce9b48b93b42722"],"14ec33385f6fbb6ce172882d14605790418a5d31":["b0c7a8f7304b75b1528814c5820fa23a96816c27"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","b9dc373b96fc96e6300e2f5af947f6998e6aa6a6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["135621f3a0670a9394eb563224a3b76cc4dddc0f","d3fe2fc74577855eadfb5eae3153c2fffdaaf791"],"7e1cbd7e289dc1243c7a59e1a83d078163a147fe":["a493e6d0c3ad86bd55c0a1360d110142e948f2bd"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["bb9b72f7c3d7827c64dd4ec580ded81778da361d","b0c7a8f7304b75b1528814c5820fa23a96816c27"],"1224a4027481acce15495b03bce9b48b93b42722":["14ec33385f6fbb6ce172882d14605790418a5d31"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"833a7987bc1c94455fde83e3311f72bddedcfb93":["5f4e87790277826a2aea119328600dfb07761f32"],"b9dc373b96fc96e6300e2f5af947f6998e6aa6a6":["5dd55ef4d8a74ff17963e786d91a8ddc54806cfa"],"5f411c79281946a184efeab34a673deffc25edcb":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"85a883878c0af761245ab048babc63d099f835f3":["6066dbe072ec5334ff5824f474e9d3abd1620fb7","a493e6d0c3ad86bd55c0a1360d110142e948f2bd"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["d619839baa8ce5503e496b94a9e42ad6f079293f","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"3cc749c053615f5871f3b95715fe292f34e70a53":["7b91922b55d15444d554721b352861d028eb8278"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["1224a4027481acce15495b03bce9b48b93b42722","9df1ed091b5966e1234a7c4233d866955c0460a7"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["85a883878c0af761245ab048babc63d099f835f3","5dd55ef4d8a74ff17963e786d91a8ddc54806cfa"],"5f4e87790277826a2aea119328600dfb07761f32":["6267e1ce56c2eec111425690cd04e251b6f14952","6066dbe072ec5334ff5824f474e9d3abd1620fb7"],"7b91922b55d15444d554721b352861d028eb8278":["d3fe2fc74577855eadfb5eae3153c2fffdaaf791"],"6267e1ce56c2eec111425690cd04e251b6f14952":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"9df1ed091b5966e1234a7c4233d866955c0460a7":["5f411c79281946a184efeab34a673deffc25edcb"],"6066dbe072ec5334ff5824f474e9d3abd1620fb7":["6267e1ce56c2eec111425690cd04e251b6f14952"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["29ef99d61cda9641b6250bf9567329a6e65f901d","1224a4027481acce15495b03bce9b48b93b42722"],"b0c7a8f7304b75b1528814c5820fa23a96816c27":["b9dc373b96fc96e6300e2f5af947f6998e6aa6a6"],"a3776dccca01c11e7046323cfad46a3b4a471233":["1224a4027481acce15495b03bce9b48b93b42722","d3fe2fc74577855eadfb5eae3153c2fffdaaf791"],"5dd55ef4d8a74ff17963e786d91a8ddc54806cfa":["7e1cbd7e289dc1243c7a59e1a83d078163a147fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc749c053615f5871f3b95715fe292f34e70a53"]},"commit2Childs":{"d3fe2fc74577855eadfb5eae3153c2fffdaaf791":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb","7b91922b55d15444d554721b352861d028eb8278","a3776dccca01c11e7046323cfad46a3b4a471233"],"a493e6d0c3ad86bd55c0a1360d110142e948f2bd":["7e1cbd7e289dc1243c7a59e1a83d078163a147fe","85a883878c0af761245ab048babc63d099f835f3"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["6267e1ce56c2eec111425690cd04e251b6f14952"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bb9b72f7c3d7827c64dd4ec580ded81778da361d"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["5f411c79281946a184efeab34a673deffc25edcb"],"14ec33385f6fbb6ce172882d14605790418a5d31":["1224a4027481acce15495b03bce9b48b93b42722"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":[],"7e1cbd7e289dc1243c7a59e1a83d078163a147fe":["5dd55ef4d8a74ff17963e786d91a8ddc54806cfa"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"833a7987bc1c94455fde83e3311f72bddedcfb93":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"1224a4027481acce15495b03bce9b48b93b42722":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","b3e06be49006ecac364d39d12b9c9f74882f9b9f","d619839baa8ce5503e496b94a9e42ad6f079293f","a3776dccca01c11e7046323cfad46a3b4a471233"],"b9dc373b96fc96e6300e2f5af947f6998e6aa6a6":["bb9b72f7c3d7827c64dd4ec580ded81778da361d","29ef99d61cda9641b6250bf9567329a6e65f901d","b0c7a8f7304b75b1528814c5820fa23a96816c27"],"5f411c79281946a184efeab34a673deffc25edcb":["9df1ed091b5966e1234a7c4233d866955c0460a7"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"85a883878c0af761245ab048babc63d099f835f3":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["d3fe2fc74577855eadfb5eae3153c2fffdaaf791","135621f3a0670a9394eb563224a3b76cc4dddc0f"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"3cc749c053615f5871f3b95715fe292f34e70a53":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5f4e87790277826a2aea119328600dfb07761f32":["833a7987bc1c94455fde83e3311f72bddedcfb93"],"7b91922b55d15444d554721b352861d028eb8278":["3cc749c053615f5871f3b95715fe292f34e70a53"],"9df1ed091b5966e1234a7c4233d866955c0460a7":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"6267e1ce56c2eec111425690cd04e251b6f14952":["5f4e87790277826a2aea119328600dfb07761f32","6066dbe072ec5334ff5824f474e9d3abd1620fb7"],"6066dbe072ec5334ff5824f474e9d3abd1620fb7":["a493e6d0c3ad86bd55c0a1360d110142e948f2bd","85a883878c0af761245ab048babc63d099f835f3","5f4e87790277826a2aea119328600dfb07761f32"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"b0c7a8f7304b75b1528814c5820fa23a96816c27":["14ec33385f6fbb6ce172882d14605790418a5d31","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"5dd55ef4d8a74ff17963e786d91a8ddc54806cfa":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","b9dc373b96fc96e6300e2f5af947f6998e6aa6a6","ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb","a3776dccca01c11e7046323cfad46a3b4a471233","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}