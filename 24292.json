{"path":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","commits":[{"id":"404d1ab7f6f396235047017c88d545fec15dafb7","date":1511975378,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestEarlyTerminatingSortingCollector#testEarlyTermination().mjava","sourceNew":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (trackMaxScore == false && paging == false && maxSegmentSize >= numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  public void testEarlyTermination() throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        final Sort sort = new Sort(new SortField(\"ndv1\", SortField.Type.LONG, false));\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, new EarlyTerminatingSortingCollector(collector2, sort, numHits));\n        assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());\n        assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb2ca551506eb8f7577cee251cd2a0cf55b0f020","date":1511981526,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","sourceNew":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().maxDoc() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (trackMaxScore == false && paging == false && maxSegmentSize >= numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (trackMaxScore == false && paging == false && maxSegmentSize >= numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestEarlyTerminatingSortingCollector#testEarlyTermination().mjava","sourceNew":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().maxDoc() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (trackMaxScore == false && paging == false && maxSegmentSize >= numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  public void testEarlyTermination() throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        final Sort sort = new Sort(new SortField(\"ndv1\", SortField.Type.LONG, false));\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, new EarlyTerminatingSortingCollector(collector2, sort, numHits));\n        assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());\n        assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90fd44f6cbe87f857a94381a51d1b32d629d090c","date":1512547281,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","sourceNew":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().maxDoc() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (trackMaxScore == false && paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().maxDoc() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (trackMaxScore == false && paging == false && maxSegmentSize >= numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":["404d1ab7f6f396235047017c88d545fec15dafb7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f8a23446329cc7f1063e9f995ba8d32a45e82f8","date":1512658048,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","sourceNew":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (trackMaxScore == false && paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().maxDoc() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (trackMaxScore == false && paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","sourceNew":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (trackMaxScore == false && paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().maxDoc() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (trackMaxScore == false && paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","sourceNew":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (trackMaxScore == false && paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","sourceNew":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final boolean trackMaxScore = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (trackMaxScore == false && paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04c370507e5521b2eb998530736f1c19b851ed5a","date":1531911305,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","sourceNew":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean trackDocScores = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, trackDocScores, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, trackDocScores, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean fillFields = random().nextBoolean();\n        final boolean trackDocScores = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d3f7ab1a502671bbdb03bcced21e764d2483221","date":1532329609,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","sourceNew":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final boolean trackDocScores = random().nextBoolean();\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, trackDocScores, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, trackDocScores, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","sourceNew":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits.value >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits.value <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits.value, td1.totalHits.value);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits, td1.totalHits);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe3c6364bed04a73ad0884b05401d80ce96027a9","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","sourceNew":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, Integer.MAX_VALUE);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, 1);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits.value >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits.value <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits.value, td1.totalHits.value);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, true);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, false);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits.value >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits.value <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits.value, td1.totalHits.value);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0726aad62c56adb2afd66930b9cc49f0c1e00ffe","date":1564077580,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","sourceNew":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, Integer.MAX_VALUE);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, 1);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits.value >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits.value <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits.value, td1.totalHits.value);\n        }\n        CheckHits.checkEqual(query, td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, Integer.MAX_VALUE);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, 1);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits.value >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits.value <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits.value, td1.totalHits.value);\n        }\n        assertTopDocsEquals(td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f","date":1579652839,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination#doTestEarlyTermination(boolean).mjava","sourceNew":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(1);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, Integer.MAX_VALUE);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, 1);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits.value >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits.value <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits.value, td1.totalHits.value);\n        }\n        CheckHits.checkEqual(query, td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","sourceOld":"  private void doTestEarlyTermination(boolean paging) throws IOException {\n    final int iters = atLeast(8);\n    for (int i = 0; i < iters; ++i) {\n      createRandomIndex(false);\n      int maxSegmentSize = 0;\n      for (LeafReaderContext ctx : reader.leaves()) {\n        maxSegmentSize = Math.max(ctx.reader().numDocs(), maxSegmentSize);\n      }\n      for (int j = 0; j < iters; ++j) {\n        final IndexSearcher searcher = newSearcher(reader);\n        final int numHits = TestUtil.nextInt(random(), 1, numDocs);\n        FieldDoc after;\n        if (paging) {\n          assert searcher.getIndexReader().numDocs() > 0;\n          TopFieldDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);\n          after = (FieldDoc) td.scoreDocs[td.scoreDocs.length - 1];\n        } else {\n          after = null;\n        }\n        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, Integer.MAX_VALUE);\n        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, 1);\n\n        final Query query;\n        if (random().nextBoolean()) {\n          query = new TermQuery(new Term(\"s\", RandomPicks.randomFrom(random(), terms)));\n        } else {\n          query = new MatchAllDocsQuery();\n        }\n        searcher.search(query, collector1);\n        searcher.search(query, collector2);\n        TopDocs td1 = collector1.topDocs();\n        TopDocs td2 = collector2.topDocs();\n\n        assertFalse(collector1.isEarlyTerminated());\n        if (paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {\n          // Make sure that we sometimes early terminate\n          assertTrue(collector2.isEarlyTerminated());\n        }\n        if (collector2.isEarlyTerminated()) {\n          assertTrue(td2.totalHits.value >= td1.scoreDocs.length);\n          assertTrue(td2.totalHits.value <= reader.maxDoc());\n        } else {\n          assertEquals(td2.totalHits.value, td1.totalHits.value);\n        }\n        CheckHits.checkEqual(query, td1.scoreDocs, td2.scoreDocs);\n      }\n      closeIndex();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["0726aad62c56adb2afd66930b9cc49f0c1e00ffe"],"404d1ab7f6f396235047017c88d545fec15dafb7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"04c370507e5521b2eb998530736f1c19b851ed5a":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"bb2ca551506eb8f7577cee251cd2a0cf55b0f020":["404d1ab7f6f396235047017c88d545fec15dafb7"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["04c370507e5521b2eb998530736f1c19b851ed5a"],"417142ff08fda9cf0b72d5133e63097a166c6458":["90fd44f6cbe87f857a94381a51d1b32d629d090c","7f8a23446329cc7f1063e9f995ba8d32a45e82f8"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bb2ca551506eb8f7577cee251cd2a0cf55b0f020"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["417142ff08fda9cf0b72d5133e63097a166c6458","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"90fd44f6cbe87f857a94381a51d1b32d629d090c":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"7f8a23446329cc7f1063e9f995ba8d32a45e82f8":["90fd44f6cbe87f857a94381a51d1b32d629d090c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"83788ad129a5154d5c6562c4e8ce3db48793aada":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["417142ff08fda9cf0b72d5133e63097a166c6458"],"0726aad62c56adb2afd66930b9cc49f0c1e00ffe":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["83788ad129a5154d5c6562c4e8ce3db48793aada"]},"commit2Childs":{"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"404d1ab7f6f396235047017c88d545fec15dafb7":["bb2ca551506eb8f7577cee251cd2a0cf55b0f020"],"04c370507e5521b2eb998530736f1c19b851ed5a":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"bb2ca551506eb8f7577cee251cd2a0cf55b0f020":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"417142ff08fda9cf0b72d5133e63097a166c6458":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["90fd44f6cbe87f857a94381a51d1b32d629d090c"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"90fd44f6cbe87f857a94381a51d1b32d629d090c":["417142ff08fda9cf0b72d5133e63097a166c6458","7f8a23446329cc7f1063e9f995ba8d32a45e82f8"],"7f8a23446329cc7f1063e9f995ba8d32a45e82f8":["417142ff08fda9cf0b72d5133e63097a166c6458"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["404d1ab7f6f396235047017c88d545fec15dafb7","1aad05eeff7818b0833c02ac6b743aa72054963b"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["04c370507e5521b2eb998530736f1c19b851ed5a","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"0726aad62c56adb2afd66930b9cc49f0c1e00ffe":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["0726aad62c56adb2afd66930b9cc49f0c1e00ffe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}