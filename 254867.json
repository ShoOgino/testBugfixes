{"path":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonTree#createTree(double[],double[]).mjava","commits":[{"id":"034996547ca41c5004216fdd0178acbf06438da2","date":1461284133,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonTree#createTree(double[],double[]).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Creates an edge interval tree from a set of polygon vertices.\n   * @return root node of the tree.\n   */\n  private static Edge createTree(double polyLats[], double polyLons[]) {\n    // edge order is deterministic and reproducible based on the double values.\n    // TODO: make a real balanced tree instead :)\n    List<Integer> list = new ArrayList<Integer>(polyLats.length - 1);\n    for (int i = 1; i < polyLats.length; i++) {\n      list.add(i);\n    }\n    Collections.shuffle(list, new Random(Arrays.hashCode(polyLats) ^ Arrays.hashCode(polyLons)));\n    Edge root = null;\n    for (int i : list) {\n      double lat1 = polyLats[i-1];\n      double lon1 = polyLons[i-1];\n      double lat2 = polyLats[i];\n      double lon2 = polyLons[i];\n      Edge newNode = new Edge(lat1, lon1, lat2, lon2, Math.min(lat1, lat2), Math.max(lat1, lat2));\n      if (root == null) {\n        // add first node\n        root = newNode;\n      } else {\n        // traverse tree to find home for new node, along the path updating all parent's max value along the way.\n        Edge node = root;\n        while (true) {\n          node.max = Math.max(node.max, newNode.max);\n          if (newNode.low < node.low) {\n            if (node.left == null) {\n              node.left = newNode;\n              break;\n            }\n            node = node.left;\n          } else {\n            if (node.right == null) {\n              node.right = newNode;\n              break;\n            }\n            node = node.right;\n          }\n        }\n      }\n    }\n    return root;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["2502e456720c9236c8bd4bd1ebc882d04e3a7080"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca","date":1461308643,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonTree#createTree(double[],double[]).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Creates an edge interval tree from a set of polygon vertices.\n   * @return root node of the tree.\n   */\n  private static Edge createTree(double polyLats[], double polyLons[]) {\n    // edge order is deterministic and reproducible based on the double values.\n    // TODO: make a real balanced tree instead :)\n    List<Integer> list = new ArrayList<Integer>(polyLats.length - 1);\n    for (int i = 1; i < polyLats.length; i++) {\n      list.add(i);\n    }\n    Collections.shuffle(list, new Random(Arrays.hashCode(polyLats) ^ Arrays.hashCode(polyLons)));\n    Edge root = null;\n    for (int i : list) {\n      double lat1 = polyLats[i-1];\n      double lon1 = polyLons[i-1];\n      double lat2 = polyLats[i];\n      double lon2 = polyLons[i];\n      Edge newNode = new Edge(lat1, lon1, lat2, lon2, Math.min(lat1, lat2), Math.max(lat1, lat2));\n      if (root == null) {\n        // add first node\n        root = newNode;\n      } else {\n        // traverse tree to find home for new node, along the path updating all parent's max value along the way.\n        Edge node = root;\n        while (true) {\n          node.max = Math.max(node.max, newNode.max);\n          if (newNode.low < node.low) {\n            if (node.left == null) {\n              node.left = newNode;\n              break;\n            }\n            node = node.left;\n          } else {\n            if (node.right == null) {\n              node.right = newNode;\n              break;\n            }\n            node = node.right;\n          }\n        }\n      }\n    }\n    return root;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2502e456720c9236c8bd4bd1ebc882d04e3a7080","date":1461341355,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonTree#createTree(double[],double[]).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonTree#createTree(double[],double[]).mjava","sourceNew":"  /** \n   * Creates an edge interval tree from a set of polygon vertices.\n   * @return root node of the tree.\n   */\n  private static Edge createTree(double polyLats[], double polyLons[]) {\n    Edge edges[] = new Edge[polyLats.length - 1];\n    for (int i = 1; i < polyLats.length; i++) {\n      double lat1 = polyLats[i-1];\n      double lon1 = polyLons[i-1];\n      double lat2 = polyLats[i];\n      double lon2 = polyLons[i];\n      edges[i - 1] = new Edge(lat1, lon1, lat2, lon2, Math.min(lat1, lat2), Math.max(lat1, lat2));\n    }\n    // sort the edges then build a balanced tree from them\n    Arrays.sort(edges, (left, right) -> {\n      int ret = Double.compare(left.low, right.low);\n      if (ret == 0) {\n        ret = Double.compare(left.max, right.max);\n      }\n      return ret;\n    });\n    return createTree(edges, 0, edges.length - 1);\n  }\n\n","sourceOld":"  /** \n   * Creates an edge interval tree from a set of polygon vertices.\n   * @return root node of the tree.\n   */\n  private static Edge createTree(double polyLats[], double polyLons[]) {\n    // edge order is deterministic and reproducible based on the double values.\n    // TODO: make a real balanced tree instead :)\n    List<Integer> list = new ArrayList<Integer>(polyLats.length - 1);\n    for (int i = 1; i < polyLats.length; i++) {\n      list.add(i);\n    }\n    Collections.shuffle(list, new Random(Arrays.hashCode(polyLats) ^ Arrays.hashCode(polyLons)));\n    Edge root = null;\n    for (int i : list) {\n      double lat1 = polyLats[i-1];\n      double lon1 = polyLons[i-1];\n      double lat2 = polyLats[i];\n      double lon2 = polyLons[i];\n      Edge newNode = new Edge(lat1, lon1, lat2, lon2, Math.min(lat1, lat2), Math.max(lat1, lat2));\n      if (root == null) {\n        // add first node\n        root = newNode;\n      } else {\n        // traverse tree to find home for new node, along the path updating all parent's max value along the way.\n        Edge node = root;\n        while (true) {\n          node.max = Math.max(node.max, newNode.max);\n          if (newNode.low < node.low) {\n            if (node.left == null) {\n              node.left = newNode;\n              break;\n            }\n            node = node.left;\n          } else {\n            if (node.right == null) {\n              node.right = newNode;\n              break;\n            }\n            node = node.right;\n          }\n        }\n      }\n    }\n    return root;\n  }\n\n","bugFix":["034996547ca41c5004216fdd0178acbf06438da2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"925fce43f3bac029d912b9b7de03c789e258a333","date":1461612714,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/Polygon2D#createTree(double[],double[]).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonTree#createTree(double[],double[]).mjava","sourceNew":"  /** \n   * Creates an edge interval tree from a set of polygon vertices.\n   * @return root node of the tree.\n   */\n  private static Edge createTree(double polyLats[], double polyLons[]) {\n    Edge edges[] = new Edge[polyLats.length - 1];\n    for (int i = 1; i < polyLats.length; i++) {\n      double lat1 = polyLats[i-1];\n      double lon1 = polyLons[i-1];\n      double lat2 = polyLats[i];\n      double lon2 = polyLons[i];\n      edges[i - 1] = new Edge(lat1, lon1, lat2, lon2, Math.min(lat1, lat2), Math.max(lat1, lat2));\n    }\n    // sort the edges then build a balanced tree from them\n    Arrays.sort(edges, (left, right) -> {\n      int ret = Double.compare(left.low, right.low);\n      if (ret == 0) {\n        ret = Double.compare(left.max, right.max);\n      }\n      return ret;\n    });\n    return createTree(edges, 0, edges.length - 1);\n  }\n\n","sourceOld":"  /** \n   * Creates an edge interval tree from a set of polygon vertices.\n   * @return root node of the tree.\n   */\n  private static Edge createTree(double polyLats[], double polyLons[]) {\n    Edge edges[] = new Edge[polyLats.length - 1];\n    for (int i = 1; i < polyLats.length; i++) {\n      double lat1 = polyLats[i-1];\n      double lon1 = polyLons[i-1];\n      double lat2 = polyLats[i];\n      double lon2 = polyLons[i];\n      edges[i - 1] = new Edge(lat1, lon1, lat2, lon2, Math.min(lat1, lat2), Math.max(lat1, lat2));\n    }\n    // sort the edges then build a balanced tree from them\n    Arrays.sort(edges, (left, right) -> {\n      int ret = Double.compare(left.low, right.low);\n      if (ret == 0) {\n        ret = Double.compare(left.max, right.max);\n      }\n      return ret;\n    });\n    return createTree(edges, 0, edges.length - 1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonTree#createTree(double[],double[]).mjava","sourceNew":null,"sourceOld":"  /** \n   * Creates an edge interval tree from a set of polygon vertices.\n   * @return root node of the tree.\n   */\n  private static Edge createTree(double polyLats[], double polyLons[]) {\n    // edge order is deterministic and reproducible based on the double values.\n    // TODO: make a real balanced tree instead :)\n    List<Integer> list = new ArrayList<Integer>(polyLats.length - 1);\n    for (int i = 1; i < polyLats.length; i++) {\n      list.add(i);\n    }\n    Collections.shuffle(list, new Random(Arrays.hashCode(polyLats) ^ Arrays.hashCode(polyLons)));\n    Edge root = null;\n    for (int i : list) {\n      double lat1 = polyLats[i-1];\n      double lon1 = polyLons[i-1];\n      double lat2 = polyLats[i];\n      double lon2 = polyLons[i];\n      Edge newNode = new Edge(lat1, lon1, lat2, lon2, Math.min(lat1, lat2), Math.max(lat1, lat2));\n      if (root == null) {\n        // add first node\n        root = newNode;\n      } else {\n        // traverse tree to find home for new node, along the path updating all parent's max value along the way.\n        Edge node = root;\n        while (true) {\n          node.max = Math.max(node.max, newNode.max);\n          if (newNode.low < node.low) {\n            if (node.left == null) {\n              node.left = newNode;\n              break;\n            }\n            node = node.left;\n          } else {\n            if (node.right == null) {\n              node.right = newNode;\n              break;\n            }\n            node = node.right;\n          }\n        }\n      }\n    }\n    return root;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","034996547ca41c5004216fdd0178acbf06438da2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca","925fce43f3bac029d912b9b7de03c789e258a333"],"2502e456720c9236c8bd4bd1ebc882d04e3a7080":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca"],"034996547ca41c5004216fdd0178acbf06438da2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"925fce43f3bac029d912b9b7de03c789e258a333":["2502e456720c9236c8bd4bd1ebc882d04e3a7080"]},"commit2Childs":{"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","2502e456720c9236c8bd4bd1ebc882d04e3a7080"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca","034996547ca41c5004216fdd0178acbf06438da2"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2502e456720c9236c8bd4bd1ebc882d04e3a7080":["925fce43f3bac029d912b9b7de03c789e258a333"],"034996547ca41c5004216fdd0178acbf06438da2":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca"],"925fce43f3bac029d912b9b7de03c789e258a333":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}