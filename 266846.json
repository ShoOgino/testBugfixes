{"path":"lucene/src/test/org/apache/lucene/index/TestCompoundFile#testManySubFiles().mjava","commits":[{"id":"c244b48864165a90cc6a3456949611d87454cda2","date":1314123519,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCompoundFile#testManySubFiles().mjava","pathOld":"/dev/null","sourceNew":"  // Make sure we don't somehow use more than 1 descriptor\n  // when reading a CFS with many subs:\n  public void testManySubFiles() throws IOException {\n\n    final Directory d = newFSDirectory(_TestUtil.getTempDir(\"CFSManySubFiles\"));\n    final int FILE_COUNT = 10000;\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      IndexOutput out = d.createOutput(\"file.\" + fileIdx, newIOContext(random));\n      out.writeByte((byte) fileIdx);\n      out.close();\n    }\n    \n    final CompoundFileDirectory cfd = d.createCompoundOutput(\"c.cfs\", newIOContext(random));\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      final String fileName = \"file.\" + fileIdx;\n      d.copy(cfd, fileName, fileName, newIOContext(random));\n    }\n    cfd.close();\n\n    final IndexInput[] ins = new IndexInput[FILE_COUNT];\n    final CompoundFileDirectory cfr = d.openCompoundInput(\"c.cfs\", newIOContext(random));\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      ins[fileIdx] = cfr.openInput(\"file.\" + fileIdx, newIOContext(random));\n    }\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      assertEquals((byte) fileIdx, ins[fileIdx].readByte());\n    }\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      ins[fileIdx].close();\n    }\n    cfr.close();\n    d.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"67aadace85f701c87a4e0721eedcda25d8415a70","date":1314201925,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCompoundFile#testManySubFiles().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCompoundFile#testManySubFiles().mjava","sourceNew":"  // Make sure we don't somehow use more than 1 descriptor\n  // when reading a CFS with many subs:\n  public void testManySubFiles() throws IOException {\n\n    final Directory d = newFSDirectory(_TestUtil.getTempDir(\"CFSManySubFiles\"));\n    final int FILE_COUNT = 10000;\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      IndexOutput out = d.createOutput(\"file.\" + fileIdx, newIOContext(random));\n      out.writeByte((byte) fileIdx);\n      out.close();\n    }\n    \n    final CompoundFileDirectory cfd = new CompoundFileDirectory(d, \"c.cfs\", newIOContext(random), true);\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      final String fileName = \"file.\" + fileIdx;\n      d.copy(cfd, fileName, fileName, newIOContext(random));\n    }\n    cfd.close();\n\n    final IndexInput[] ins = new IndexInput[FILE_COUNT];\n    final CompoundFileDirectory cfr = new CompoundFileDirectory(d, \"c.cfs\", newIOContext(random), false);\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      ins[fileIdx] = cfr.openInput(\"file.\" + fileIdx, newIOContext(random));\n    }\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      assertEquals((byte) fileIdx, ins[fileIdx].readByte());\n    }\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      ins[fileIdx].close();\n    }\n    cfr.close();\n    d.close();\n  }\n\n","sourceOld":"  // Make sure we don't somehow use more than 1 descriptor\n  // when reading a CFS with many subs:\n  public void testManySubFiles() throws IOException {\n\n    final Directory d = newFSDirectory(_TestUtil.getTempDir(\"CFSManySubFiles\"));\n    final int FILE_COUNT = 10000;\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      IndexOutput out = d.createOutput(\"file.\" + fileIdx, newIOContext(random));\n      out.writeByte((byte) fileIdx);\n      out.close();\n    }\n    \n    final CompoundFileDirectory cfd = d.createCompoundOutput(\"c.cfs\", newIOContext(random));\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      final String fileName = \"file.\" + fileIdx;\n      d.copy(cfd, fileName, fileName, newIOContext(random));\n    }\n    cfd.close();\n\n    final IndexInput[] ins = new IndexInput[FILE_COUNT];\n    final CompoundFileDirectory cfr = d.openCompoundInput(\"c.cfs\", newIOContext(random));\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      ins[fileIdx] = cfr.openInput(\"file.\" + fileIdx, newIOContext(random));\n    }\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      assertEquals((byte) fileIdx, ins[fileIdx].readByte());\n    }\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      ins[fileIdx].close();\n    }\n    cfr.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8be580b58bcc650d428f3f22de81cadcf51d650a","date":1325279655,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCompoundFile#testManySubFiles().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCompoundFile#testManySubFiles().mjava","sourceNew":"  // Make sure we don't somehow use more than 1 descriptor\n  // when reading a CFS with many subs:\n  public void testManySubFiles() throws IOException {\n\n    final Directory d = newFSDirectory(_TestUtil.getTempDir(\"CFSManySubFiles\"));\n    final int FILE_COUNT = atLeast(500);\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      IndexOutput out = d.createOutput(\"file.\" + fileIdx, newIOContext(random));\n      out.writeByte((byte) fileIdx);\n      out.close();\n    }\n    \n    final CompoundFileDirectory cfd = new CompoundFileDirectory(d, \"c.cfs\", newIOContext(random), true);\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      final String fileName = \"file.\" + fileIdx;\n      d.copy(cfd, fileName, fileName, newIOContext(random));\n    }\n    cfd.close();\n\n    final IndexInput[] ins = new IndexInput[FILE_COUNT];\n    final CompoundFileDirectory cfr = new CompoundFileDirectory(d, \"c.cfs\", newIOContext(random), false);\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      ins[fileIdx] = cfr.openInput(\"file.\" + fileIdx, newIOContext(random));\n    }\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      assertEquals((byte) fileIdx, ins[fileIdx].readByte());\n    }\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      ins[fileIdx].close();\n    }\n    cfr.close();\n    d.close();\n  }\n\n","sourceOld":"  // Make sure we don't somehow use more than 1 descriptor\n  // when reading a CFS with many subs:\n  public void testManySubFiles() throws IOException {\n\n    final Directory d = newFSDirectory(_TestUtil.getTempDir(\"CFSManySubFiles\"));\n    final int FILE_COUNT = 10000;\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      IndexOutput out = d.createOutput(\"file.\" + fileIdx, newIOContext(random));\n      out.writeByte((byte) fileIdx);\n      out.close();\n    }\n    \n    final CompoundFileDirectory cfd = new CompoundFileDirectory(d, \"c.cfs\", newIOContext(random), true);\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      final String fileName = \"file.\" + fileIdx;\n      d.copy(cfd, fileName, fileName, newIOContext(random));\n    }\n    cfd.close();\n\n    final IndexInput[] ins = new IndexInput[FILE_COUNT];\n    final CompoundFileDirectory cfr = new CompoundFileDirectory(d, \"c.cfs\", newIOContext(random), false);\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      ins[fileIdx] = cfr.openInput(\"file.\" + fileIdx, newIOContext(random));\n    }\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      assertEquals((byte) fileIdx, ins[fileIdx].readByte());\n    }\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      ins[fileIdx].close();\n    }\n    cfr.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCompoundFile#testManySubFiles().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCompoundFile#testManySubFiles().mjava","sourceNew":"  // Make sure we don't somehow use more than 1 descriptor\n  // when reading a CFS with many subs:\n  public void testManySubFiles() throws IOException {\n\n    final Directory d = newFSDirectory(_TestUtil.getTempDir(\"CFSManySubFiles\"));\n    final int FILE_COUNT = atLeast(500);\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      IndexOutput out = d.createOutput(\"file.\" + fileIdx, newIOContext(random));\n      out.writeByte((byte) fileIdx);\n      out.close();\n    }\n    \n    final CompoundFileDirectory cfd = new CompoundFileDirectory(d, \"c.cfs\", newIOContext(random), true);\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      final String fileName = \"file.\" + fileIdx;\n      d.copy(cfd, fileName, fileName, newIOContext(random));\n    }\n    cfd.close();\n\n    final IndexInput[] ins = new IndexInput[FILE_COUNT];\n    final CompoundFileDirectory cfr = new CompoundFileDirectory(d, \"c.cfs\", newIOContext(random), false);\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      ins[fileIdx] = cfr.openInput(\"file.\" + fileIdx, newIOContext(random));\n    }\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      assertEquals((byte) fileIdx, ins[fileIdx].readByte());\n    }\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      ins[fileIdx].close();\n    }\n    cfr.close();\n    d.close();\n  }\n\n","sourceOld":"  // Make sure we don't somehow use more than 1 descriptor\n  // when reading a CFS with many subs:\n  public void testManySubFiles() throws IOException {\n\n    final Directory d = newFSDirectory(_TestUtil.getTempDir(\"CFSManySubFiles\"));\n    final int FILE_COUNT = atLeast(500);\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      IndexOutput out = d.createOutput(\"file.\" + fileIdx, newIOContext(random));\n      out.writeByte((byte) fileIdx);\n      out.close();\n    }\n    \n    final CompoundFileDirectory cfd = new CompoundFileDirectory(d, \"c.cfs\", newIOContext(random), true);\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      final String fileName = \"file.\" + fileIdx;\n      d.copy(cfd, fileName, fileName, newIOContext(random));\n    }\n    cfd.close();\n\n    final IndexInput[] ins = new IndexInput[FILE_COUNT];\n    final CompoundFileDirectory cfr = new CompoundFileDirectory(d, \"c.cfs\", newIOContext(random), false);\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      ins[fileIdx] = cfr.openInput(\"file.\" + fileIdx, newIOContext(random));\n    }\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      assertEquals((byte) fileIdx, ins[fileIdx].readByte());\n    }\n\n    for(int fileIdx=0;fileIdx<FILE_COUNT;fileIdx++) {\n      ins[fileIdx].close();\n    }\n    cfr.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"67aadace85f701c87a4e0721eedcda25d8415a70":["c244b48864165a90cc6a3456949611d87454cda2"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["8be580b58bcc650d428f3f22de81cadcf51d650a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8be580b58bcc650d428f3f22de81cadcf51d650a":["67aadace85f701c87a4e0721eedcda25d8415a70"],"c244b48864165a90cc6a3456949611d87454cda2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"67aadace85f701c87a4e0721eedcda25d8415a70":["8be580b58bcc650d428f3f22de81cadcf51d650a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c244b48864165a90cc6a3456949611d87454cda2"],"8be580b58bcc650d428f3f22de81cadcf51d650a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"c244b48864165a90cc6a3456949611d87454cda2":["67aadace85f701c87a4e0721eedcda25d8415a70"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}