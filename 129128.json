{"path":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","commits":[{"id":"6864413dbc0c12104c978c05456f3da1d45adb03","date":1186770873,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the next token in the stream, or null at EOS.\n   *  When possible, the input Token should be used as the\n   *  returned Token (this gives fastest tokenization\n   *  performance), but this is not required and a new Token\n   *  may be returned.  Callers may re-use a single Token\n   *  instance for successive calls to this method and must\n   *  therefore fully consume the previously returned Token\n   *  before calling this method again.\n   *  @param result a Token that may or may not be used to\n   *   return\n   *  @return next token in the stream or null if\n   *   end-of-stream was hit*/\n  public Token next(Token result) throws IOException {\n    return next();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["fee44d0bd0b9443ff6068d0ba8458fd103dff4aa"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fee44d0bd0b9443ff6068d0ba8458fd103dff4aa","date":1199000070,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","sourceNew":"  /** Returns the next token in the stream, or null at EOS.\n   *  When possible, the input Token should be used as the\n   *  returned Token (this gives fastest tokenization\n   *  performance), but this is not required and a new Token\n   *  may be returned. Callers may re-use a single Token\n   *  instance for successive calls to this method.\n   *  <p>\n   *  This implicitly defines a \"contract\" between \n   *  consumers (callers of this method) and \n   *  producers (implementations of this method \n   *  that are the source for tokens):\n   *  <ul>\n   *   <li>A consumer must fully consume the previously \n   *       returned Token before calling this method again.</li>\n   *   <li>A producer must call {@link Token#clear()}\n   *       before setting the fields in it & returning it</li>\n   *  </ul>\n   *  Note that a {@link TokenFilter} is considered a consumer.\n   *  @param result a Token that may or may not be used to return\n   *  @return next token in the stream or null if end-of-stream was hit\n   */\n  public Token next(Token result) throws IOException {\n    return next();\n  }\n\n","sourceOld":"  /** Returns the next token in the stream, or null at EOS.\n   *  When possible, the input Token should be used as the\n   *  returned Token (this gives fastest tokenization\n   *  performance), but this is not required and a new Token\n   *  may be returned.  Callers may re-use a single Token\n   *  instance for successive calls to this method and must\n   *  therefore fully consume the previously returned Token\n   *  before calling this method again.\n   *  @param result a Token that may or may not be used to\n   *   return\n   *  @return next token in the stream or null if\n   *   end-of-stream was hit*/\n  public Token next(Token result) throws IOException {\n    return next();\n  }\n\n","bugFix":["6864413dbc0c12104c978c05456f3da1d45adb03"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e2cb543b41c145f33390f460ee743d6693c9c6c","date":1219243087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","sourceNew":"  /** Returns the next token in the stream, or null at EOS.\n   *  When possible, the input Token should be used as the\n   *  returned Token (this gives fastest tokenization\n   *  performance), but this is not required and a new Token\n   *  may be returned. Callers may re-use a single Token\n   *  instance for successive calls to this method.\n   *  <p>\n   *  This implicitly defines a \"contract\" between \n   *  consumers (callers of this method) and \n   *  producers (implementations of this method \n   *  that are the source for tokens):\n   *  <ul>\n   *   <li>A consumer must fully consume the previously \n   *       returned Token before calling this method again.</li>\n   *   <li>A producer must call {@link Token#clear()}\n   *       before setting the fields in it & returning it</li>\n   *  </ul>\n   *  Also, the producer must make no assumptions about a\n   *  Token after it has been returned: the caller may\n   *  arbitrarily change it.  If the producer needs to hold\n   *  onto the token for subsequent calls, it must clone()\n   *  it before storing it.\n   *  Note that a {@link TokenFilter} is considered a consumer.\n   *  @param reusableToken a Token that may or may not be used to\n   *  return; this parameter should never be null (the callee\n   *  is not required to check for null before using it, but it is a\n   *  good idea to assert that it is not null.)\n   *  @return next token in the stream or null if end-of-stream was hit\n   */\n  public Token next(final Token reusableToken) throws IOException {\n    // We don't actually use inputToken, but still add this assert\n    assert reusableToken != null;\n    return next();\n  }\n\n","sourceOld":"  /** Returns the next token in the stream, or null at EOS.\n   *  When possible, the input Token should be used as the\n   *  returned Token (this gives fastest tokenization\n   *  performance), but this is not required and a new Token\n   *  may be returned. Callers may re-use a single Token\n   *  instance for successive calls to this method.\n   *  <p>\n   *  This implicitly defines a \"contract\" between \n   *  consumers (callers of this method) and \n   *  producers (implementations of this method \n   *  that are the source for tokens):\n   *  <ul>\n   *   <li>A consumer must fully consume the previously \n   *       returned Token before calling this method again.</li>\n   *   <li>A producer must call {@link Token#clear()}\n   *       before setting the fields in it & returning it</li>\n   *  </ul>\n   *  Note that a {@link TokenFilter} is considered a consumer.\n   *  @param result a Token that may or may not be used to return\n   *  @return next token in the stream or null if end-of-stream was hit\n   */\n  public Token next(Token result) throws IOException {\n    return next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74a5e7f20b4a444da9df3b2c0f331fa7a1f64223","date":1227051709,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","sourceNew":"  /** Returns the next token in the stream, or null at EOS.\n   *  When possible, the input Token should be used as the\n   *  returned Token (this gives fastest tokenization\n   *  performance), but this is not required and a new Token\n   *  may be returned. Callers may re-use a single Token\n   *  instance for successive calls to this method.\n   *  <p>\n   *  This implicitly defines a \"contract\" between \n   *  consumers (callers of this method) and \n   *  producers (implementations of this method \n   *  that are the source for tokens):\n   *  <ul>\n   *   <li>A consumer must fully consume the previously \n   *       returned Token before calling this method again.</li>\n   *   <li>A producer must call {@link Token#clear()}\n   *       before setting the fields in it & returning it</li>\n   *  </ul>\n   *  Also, the producer must make no assumptions about a\n   *  Token after it has been returned: the caller may\n   *  arbitrarily change it.  If the producer needs to hold\n   *  onto the token for subsequent calls, it must clone()\n   *  it before storing it.\n   *  Note that a {@link TokenFilter} is considered a consumer.\n   *  @param reusableToken a Token that may or may not be used to\n   *  return; this parameter should never be null (the callee\n   *  is not required to check for null before using it, but it is a\n   *  good idea to assert that it is not null.)\n   *  @return next token in the stream or null if end-of-stream was hit\n   *  @deprecated The new {@link #incrementToken()} and {@link AttributeSource}\n   *  APIs should be used instead. See also {@link #useNewAPI()}.\n   */\n  public Token next(final Token reusableToken) throws IOException {\n    // We don't actually use inputToken, but still add this assert\n    assert reusableToken != null;\n    return next();\n  }\n\n","sourceOld":"  /** Returns the next token in the stream, or null at EOS.\n   *  When possible, the input Token should be used as the\n   *  returned Token (this gives fastest tokenization\n   *  performance), but this is not required and a new Token\n   *  may be returned. Callers may re-use a single Token\n   *  instance for successive calls to this method.\n   *  <p>\n   *  This implicitly defines a \"contract\" between \n   *  consumers (callers of this method) and \n   *  producers (implementations of this method \n   *  that are the source for tokens):\n   *  <ul>\n   *   <li>A consumer must fully consume the previously \n   *       returned Token before calling this method again.</li>\n   *   <li>A producer must call {@link Token#clear()}\n   *       before setting the fields in it & returning it</li>\n   *  </ul>\n   *  Also, the producer must make no assumptions about a\n   *  Token after it has been returned: the caller may\n   *  arbitrarily change it.  If the producer needs to hold\n   *  onto the token for subsequent calls, it must clone()\n   *  it before storing it.\n   *  Note that a {@link TokenFilter} is considered a consumer.\n   *  @param reusableToken a Token that may or may not be used to\n   *  return; this parameter should never be null (the callee\n   *  is not required to check for null before using it, but it is a\n   *  good idea to assert that it is not null.)\n   *  @return next token in the stream or null if end-of-stream was hit\n   */\n  public Token next(final Token reusableToken) throws IOException {\n    // We don't actually use inputToken, but still add this assert\n    assert reusableToken != null;\n    return next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec8b5a20a12931b8d7e616c79c5248ae06cc5568","date":1248471948,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","sourceNew":"  /** Returns the next token in the stream, or null at EOS.\n   *  When possible, the input Token should be used as the\n   *  returned Token (this gives fastest tokenization\n   *  performance), but this is not required and a new Token\n   *  may be returned. Callers may re-use a single Token\n   *  instance for successive calls to this method.\n   *  <p>\n   *  This implicitly defines a \"contract\" between \n   *  consumers (callers of this method) and \n   *  producers (implementations of this method \n   *  that are the source for tokens):\n   *  <ul>\n   *   <li>A consumer must fully consume the previously \n   *       returned Token before calling this method again.</li>\n   *   <li>A producer must call {@link Token#clear()}\n   *       before setting the fields in it & returning it</li>\n   *  </ul>\n   *  Also, the producer must make no assumptions about a\n   *  Token after it has been returned: the caller may\n   *  arbitrarily change it.  If the producer needs to hold\n   *  onto the token for subsequent calls, it must clone()\n   *  it before storing it.\n   *  Note that a {@link TokenFilter} is considered a consumer.\n   *  @param reusableToken a Token that may or may not be used to\n   *  return; this parameter should never be null (the callee\n   *  is not required to check for null before using it, but it is a\n   *  good idea to assert that it is not null.)\n   *  @return next token in the stream or null if end-of-stream was hit\n   *  @deprecated The new {@link #incrementToken()} and {@link AttributeSource}\n   *  APIs should be used instead.\n   */\n  public Token next(final Token reusableToken) throws IOException {\n    assert reusableToken != null;\n    \n    if (onlyUseNewAPI)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (hasIncrementToken) {\n      tokenWrapper.delegate = reusableToken;\n      return incrementToken() ? tokenWrapper.delegate : null;\n    } else {\n      assert hasNext;\n      final Token token = next();\n      if (token == null) return null;\n      tokenWrapper.delegate = token;\n      return token;\n    }\n  }\n\n","sourceOld":"  /** Returns the next token in the stream, or null at EOS.\n   *  When possible, the input Token should be used as the\n   *  returned Token (this gives fastest tokenization\n   *  performance), but this is not required and a new Token\n   *  may be returned. Callers may re-use a single Token\n   *  instance for successive calls to this method.\n   *  <p>\n   *  This implicitly defines a \"contract\" between \n   *  consumers (callers of this method) and \n   *  producers (implementations of this method \n   *  that are the source for tokens):\n   *  <ul>\n   *   <li>A consumer must fully consume the previously \n   *       returned Token before calling this method again.</li>\n   *   <li>A producer must call {@link Token#clear()}\n   *       before setting the fields in it & returning it</li>\n   *  </ul>\n   *  Also, the producer must make no assumptions about a\n   *  Token after it has been returned: the caller may\n   *  arbitrarily change it.  If the producer needs to hold\n   *  onto the token for subsequent calls, it must clone()\n   *  it before storing it.\n   *  Note that a {@link TokenFilter} is considered a consumer.\n   *  @param reusableToken a Token that may or may not be used to\n   *  return; this parameter should never be null (the callee\n   *  is not required to check for null before using it, but it is a\n   *  good idea to assert that it is not null.)\n   *  @return next token in the stream or null if end-of-stream was hit\n   *  @deprecated The new {@link #incrementToken()} and {@link AttributeSource}\n   *  APIs should be used instead. See also {@link #useNewAPI()}.\n   */\n  public Token next(final Token reusableToken) throws IOException {\n    // We don't actually use inputToken, but still add this assert\n    assert reusableToken != null;\n    return next();\n  }\n\n","bugFix":null,"bugIntro":["93995eb4992a09cc5a4b13b04225eca0bca45d57"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0833fee1ce16a2b8e10f21cbccd2e93f3d8ccf31","date":1249940086,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","sourceNew":"  /** Returns the next token in the stream, or null at EOS.\n   *  When possible, the input Token should be used as the\n   *  returned Token (this gives fastest tokenization\n   *  performance), but this is not required and a new Token\n   *  may be returned. Callers may re-use a single Token\n   *  instance for successive calls to this method.\n   *  <p>\n   *  This implicitly defines a \"contract\" between \n   *  consumers (callers of this method) and \n   *  producers (implementations of this method \n   *  that are the source for tokens):\n   *  <ul>\n   *   <li>A consumer must fully consume the previously \n   *       returned Token before calling this method again.</li>\n   *   <li>A producer must call {@link Token#clear()}\n   *       before setting the fields in it & returning it</li>\n   *  </ul>\n   *  Also, the producer must make no assumptions about a\n   *  Token after it has been returned: the caller may\n   *  arbitrarily change it.  If the producer needs to hold\n   *  onto the token for subsequent calls, it must clone()\n   *  it before storing it.\n   *  Note that a {@link TokenFilter} is considered a consumer.\n   *  @param reusableToken a Token that may or may not be used to\n   *  return; this parameter should never be null (the callee\n   *  is not required to check for null before using it, but it is a\n   *  good idea to assert that it is not null.)\n   *  @return next token in the stream or null if end-of-stream was hit\n   *  @deprecated The new {@link #incrementToken()} and {@link AttributeSource}\n   *  APIs should be used instead.\n   */\n  public Token next(final Token reusableToken) throws IOException {\n    assert reusableToken != null;\n    \n    if (onlyUseNewAPI)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (supportedMethods.hasIncrementToken) {\n      tokenWrapper.delegate = reusableToken;\n      return incrementToken() ? tokenWrapper.delegate : null;\n    } else {\n      assert supportedMethods.hasNext;\n      final Token token = next();\n      if (token == null) return null;\n      tokenWrapper.delegate = token;\n      return token;\n    }\n  }\n\n","sourceOld":"  /** Returns the next token in the stream, or null at EOS.\n   *  When possible, the input Token should be used as the\n   *  returned Token (this gives fastest tokenization\n   *  performance), but this is not required and a new Token\n   *  may be returned. Callers may re-use a single Token\n   *  instance for successive calls to this method.\n   *  <p>\n   *  This implicitly defines a \"contract\" between \n   *  consumers (callers of this method) and \n   *  producers (implementations of this method \n   *  that are the source for tokens):\n   *  <ul>\n   *   <li>A consumer must fully consume the previously \n   *       returned Token before calling this method again.</li>\n   *   <li>A producer must call {@link Token#clear()}\n   *       before setting the fields in it & returning it</li>\n   *  </ul>\n   *  Also, the producer must make no assumptions about a\n   *  Token after it has been returned: the caller may\n   *  arbitrarily change it.  If the producer needs to hold\n   *  onto the token for subsequent calls, it must clone()\n   *  it before storing it.\n   *  Note that a {@link TokenFilter} is considered a consumer.\n   *  @param reusableToken a Token that may or may not be used to\n   *  return; this parameter should never be null (the callee\n   *  is not required to check for null before using it, but it is a\n   *  good idea to assert that it is not null.)\n   *  @return next token in the stream or null if end-of-stream was hit\n   *  @deprecated The new {@link #incrementToken()} and {@link AttributeSource}\n   *  APIs should be used instead.\n   */\n  public Token next(final Token reusableToken) throws IOException {\n    assert reusableToken != null;\n    \n    if (onlyUseNewAPI)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (hasIncrementToken) {\n      tokenWrapper.delegate = reusableToken;\n      return incrementToken() ? tokenWrapper.delegate : null;\n    } else {\n      assert hasNext;\n      final Token token = next();\n      if (token == null) return null;\n      tokenWrapper.delegate = token;\n      return token;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"39c72a0a1f317a4165b759c7842b5d73d7858d1d","date":1251209760,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","sourceNew":"  /**\n   * Returns the next token in the stream, or null at EOS. When possible, the\n   * input Token should be used as the returned Token (this gives fastest\n   * tokenization performance), but this is not required and a new Token may be\n   * returned. Callers may re-use a single Token instance for successive calls\n   * to this method.\n   * <p>\n   * This implicitly defines a \"contract\" between consumers (callers of this\n   * method) and producers (implementations of this method that are the source\n   * for tokens):\n   * <ul>\n   * <li>A consumer must fully consume the previously returned {@link Token}\n   * before calling this method again.</li>\n   * <li>A producer must call {@link Token#clear()} before setting the fields in\n   * it and returning it</li>\n   * </ul>\n   * Also, the producer must make no assumptions about a {@link Token} after it\n   * has been returned: the caller may arbitrarily change it. If the producer\n   * needs to hold onto the {@link Token} for subsequent calls, it must clone()\n   * it before storing it. Note that a {@link TokenFilter} is considered a\n   * consumer.\n   * \n   * @param reusableToken a {@link Token} that may or may not be used to return;\n   *        this parameter should never be null (the callee is not required to\n   *        check for null before using it, but it is a good idea to assert that\n   *        it is not null.)\n   * @return next {@link Token} in the stream or null if end-of-stream was hit\n   * @deprecated The new {@link #incrementToken()} and {@link AttributeSource}\n   *             APIs should be used instead.\n   */\n  public Token next(final Token reusableToken) throws IOException {\n    assert reusableToken != null;\n    \n    if (onlyUseNewAPI)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (supportedMethods.hasIncrementToken) {\n      tokenWrapper.delegate = reusableToken;\n      return incrementToken() ? tokenWrapper.delegate : null;\n    } else {\n      assert supportedMethods.hasNext;\n      final Token token = next();\n      if (token == null) return null;\n      tokenWrapper.delegate = token;\n      return token;\n    }\n  }\n\n","sourceOld":"  /** Returns the next token in the stream, or null at EOS.\n   *  When possible, the input Token should be used as the\n   *  returned Token (this gives fastest tokenization\n   *  performance), but this is not required and a new Token\n   *  may be returned. Callers may re-use a single Token\n   *  instance for successive calls to this method.\n   *  <p>\n   *  This implicitly defines a \"contract\" between \n   *  consumers (callers of this method) and \n   *  producers (implementations of this method \n   *  that are the source for tokens):\n   *  <ul>\n   *   <li>A consumer must fully consume the previously \n   *       returned Token before calling this method again.</li>\n   *   <li>A producer must call {@link Token#clear()}\n   *       before setting the fields in it & returning it</li>\n   *  </ul>\n   *  Also, the producer must make no assumptions about a\n   *  Token after it has been returned: the caller may\n   *  arbitrarily change it.  If the producer needs to hold\n   *  onto the token for subsequent calls, it must clone()\n   *  it before storing it.\n   *  Note that a {@link TokenFilter} is considered a consumer.\n   *  @param reusableToken a Token that may or may not be used to\n   *  return; this parameter should never be null (the callee\n   *  is not required to check for null before using it, but it is a\n   *  good idea to assert that it is not null.)\n   *  @return next token in the stream or null if end-of-stream was hit\n   *  @deprecated The new {@link #incrementToken()} and {@link AttributeSource}\n   *  APIs should be used instead.\n   */\n  public Token next(final Token reusableToken) throws IOException {\n    assert reusableToken != null;\n    \n    if (onlyUseNewAPI)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (supportedMethods.hasIncrementToken) {\n      tokenWrapper.delegate = reusableToken;\n      return incrementToken() ? tokenWrapper.delegate : null;\n    } else {\n      assert supportedMethods.hasNext;\n      final Token token = next();\n      if (token == null) return null;\n      tokenWrapper.delegate = token;\n      return token;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4821e344090113a4e6d4d31265a0166ab07930d","date":1251215880,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","sourceNew":"  /**\n   * Returns the next token in the stream, or null at EOS. When possible, the\n   * input Token should be used as the returned Token (this gives fastest\n   * tokenization performance), but this is not required and a new Token may be\n   * returned. Callers may re-use a single Token instance for successive calls\n   * to this method.\n   * <p>\n   * This implicitly defines a \"contract\" between consumers (callers of this\n   * method) and producers (implementations of this method that are the source\n   * for tokens):\n   * <ul>\n   * <li>A consumer must fully consume the previously returned {@link Token}\n   * before calling this method again.</li>\n   * <li>A producer must call {@link Token#clear()} before setting the fields in\n   * it and returning it</li>\n   * </ul>\n   * Also, the producer must make no assumptions about a {@link Token} after it\n   * has been returned: the caller may arbitrarily change it. If the producer\n   * needs to hold onto the {@link Token} for subsequent calls, it must clone()\n   * it before storing it. Note that a {@link TokenFilter} is considered a\n   * consumer.\n   * \n   * @param reusableToken a {@link Token} that may or may not be used to return;\n   *        this parameter should never be null (the callee is not required to\n   *        check for null before using it, but it is a good idea to assert that\n   *        it is not null.)\n   * @return next {@link Token} in the stream or null if end-of-stream was hit\n   * @deprecated The new {@link #incrementToken()} and {@link AttributeSource}\n   *             APIs should be used instead.\n   */\n  public Token next(final Token reusableToken) throws IOException {\n    assert reusableToken != null;\n    \n    if (tokenWrapper == null)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (supportedMethods.hasIncrementToken) {\n      tokenWrapper.delegate = reusableToken;\n      return incrementToken() ? tokenWrapper.delegate : null;\n    } else {\n      assert supportedMethods.hasNext;\n      final Token token = next();\n      if (token == null) return null;\n      tokenWrapper.delegate = token;\n      return token;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns the next token in the stream, or null at EOS. When possible, the\n   * input Token should be used as the returned Token (this gives fastest\n   * tokenization performance), but this is not required and a new Token may be\n   * returned. Callers may re-use a single Token instance for successive calls\n   * to this method.\n   * <p>\n   * This implicitly defines a \"contract\" between consumers (callers of this\n   * method) and producers (implementations of this method that are the source\n   * for tokens):\n   * <ul>\n   * <li>A consumer must fully consume the previously returned {@link Token}\n   * before calling this method again.</li>\n   * <li>A producer must call {@link Token#clear()} before setting the fields in\n   * it and returning it</li>\n   * </ul>\n   * Also, the producer must make no assumptions about a {@link Token} after it\n   * has been returned: the caller may arbitrarily change it. If the producer\n   * needs to hold onto the {@link Token} for subsequent calls, it must clone()\n   * it before storing it. Note that a {@link TokenFilter} is considered a\n   * consumer.\n   * \n   * @param reusableToken a {@link Token} that may or may not be used to return;\n   *        this parameter should never be null (the callee is not required to\n   *        check for null before using it, but it is a good idea to assert that\n   *        it is not null.)\n   * @return next {@link Token} in the stream or null if end-of-stream was hit\n   * @deprecated The new {@link #incrementToken()} and {@link AttributeSource}\n   *             APIs should be used instead.\n   */\n  public Token next(final Token reusableToken) throws IOException {\n    assert reusableToken != null;\n    \n    if (onlyUseNewAPI)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (supportedMethods.hasIncrementToken) {\n      tokenWrapper.delegate = reusableToken;\n      return incrementToken() ? tokenWrapper.delegate : null;\n    } else {\n      assert supportedMethods.hasNext;\n      final Token token = next();\n      if (token == null) return null;\n      tokenWrapper.delegate = token;\n      return token;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93995eb4992a09cc5a4b13b04225eca0bca45d57","date":1253288184,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","sourceNew":"  /**\n   * Returns the next token in the stream, or null at EOS. When possible, the\n   * input Token should be used as the returned Token (this gives fastest\n   * tokenization performance), but this is not required and a new Token may be\n   * returned. Callers may re-use a single Token instance for successive calls\n   * to this method.\n   * <p>\n   * This implicitly defines a \"contract\" between consumers (callers of this\n   * method) and producers (implementations of this method that are the source\n   * for tokens):\n   * <ul>\n   * <li>A consumer must fully consume the previously returned {@link Token}\n   * before calling this method again.</li>\n   * <li>A producer must call {@link Token#clear()} before setting the fields in\n   * it and returning it</li>\n   * </ul>\n   * Also, the producer must make no assumptions about a {@link Token} after it\n   * has been returned: the caller may arbitrarily change it. If the producer\n   * needs to hold onto the {@link Token} for subsequent calls, it must clone()\n   * it before storing it. Note that a {@link TokenFilter} is considered a\n   * consumer.\n   * \n   * @param reusableToken a {@link Token} that may or may not be used to return;\n   *        this parameter should never be null (the callee is not required to\n   *        check for null before using it, but it is a good idea to assert that\n   *        it is not null.)\n   * @return next {@link Token} in the stream or null if end-of-stream was hit\n   * @deprecated The new {@link #incrementToken()} and {@link AttributeSource}\n   *             APIs should be used instead.\n   */\n  public Token next(final Token reusableToken) throws IOException {\n    assert reusableToken != null;\n    \n    if (tokenWrapper == null)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (supportedMethods.hasIncrementToken) {\n      tokenWrapper.delegate = reusableToken;\n      return incrementToken() ? tokenWrapper.delegate : null;\n    } else {\n      assert supportedMethods.hasNext;\n      return next();\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns the next token in the stream, or null at EOS. When possible, the\n   * input Token should be used as the returned Token (this gives fastest\n   * tokenization performance), but this is not required and a new Token may be\n   * returned. Callers may re-use a single Token instance for successive calls\n   * to this method.\n   * <p>\n   * This implicitly defines a \"contract\" between consumers (callers of this\n   * method) and producers (implementations of this method that are the source\n   * for tokens):\n   * <ul>\n   * <li>A consumer must fully consume the previously returned {@link Token}\n   * before calling this method again.</li>\n   * <li>A producer must call {@link Token#clear()} before setting the fields in\n   * it and returning it</li>\n   * </ul>\n   * Also, the producer must make no assumptions about a {@link Token} after it\n   * has been returned: the caller may arbitrarily change it. If the producer\n   * needs to hold onto the {@link Token} for subsequent calls, it must clone()\n   * it before storing it. Note that a {@link TokenFilter} is considered a\n   * consumer.\n   * \n   * @param reusableToken a {@link Token} that may or may not be used to return;\n   *        this parameter should never be null (the callee is not required to\n   *        check for null before using it, but it is a good idea to assert that\n   *        it is not null.)\n   * @return next {@link Token} in the stream or null if end-of-stream was hit\n   * @deprecated The new {@link #incrementToken()} and {@link AttributeSource}\n   *             APIs should be used instead.\n   */\n  public Token next(final Token reusableToken) throws IOException {\n    assert reusableToken != null;\n    \n    if (tokenWrapper == null)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (supportedMethods.hasIncrementToken) {\n      tokenWrapper.delegate = reusableToken;\n      return incrementToken() ? tokenWrapper.delegate : null;\n    } else {\n      assert supportedMethods.hasNext;\n      final Token token = next();\n      if (token == null) return null;\n      tokenWrapper.delegate = token;\n      return token;\n    }\n  }\n\n","bugFix":["ec8b5a20a12931b8d7e616c79c5248ae06cc5568"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439b0fe2f799d1c722151e88e32bdefad8d34ebe","date":1255282509,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#next(Token).mjava","sourceNew":null,"sourceOld":"  /**\n   * Returns the next token in the stream, or null at EOS. When possible, the\n   * input Token should be used as the returned Token (this gives fastest\n   * tokenization performance), but this is not required and a new Token may be\n   * returned. Callers may re-use a single Token instance for successive calls\n   * to this method.\n   * <p>\n   * This implicitly defines a \"contract\" between consumers (callers of this\n   * method) and producers (implementations of this method that are the source\n   * for tokens):\n   * <ul>\n   * <li>A consumer must fully consume the previously returned {@link Token}\n   * before calling this method again.</li>\n   * <li>A producer must call {@link Token#clear()} before setting the fields in\n   * it and returning it</li>\n   * </ul>\n   * Also, the producer must make no assumptions about a {@link Token} after it\n   * has been returned: the caller may arbitrarily change it. If the producer\n   * needs to hold onto the {@link Token} for subsequent calls, it must clone()\n   * it before storing it. Note that a {@link TokenFilter} is considered a\n   * consumer.\n   * \n   * @param reusableToken a {@link Token} that may or may not be used to return;\n   *        this parameter should never be null (the callee is not required to\n   *        check for null before using it, but it is a good idea to assert that\n   *        it is not null.)\n   * @return next {@link Token} in the stream or null if end-of-stream was hit\n   * @deprecated The new {@link #incrementToken()} and {@link AttributeSource}\n   *             APIs should be used instead.\n   */\n  public Token next(final Token reusableToken) throws IOException {\n    assert reusableToken != null;\n    \n    if (tokenWrapper == null)\n      throw new UnsupportedOperationException(\"This TokenStream only supports the new Attributes API.\");\n    \n    if (supportedMethods.hasIncrementToken) {\n      tokenWrapper.delegate = reusableToken;\n      return incrementToken() ? tokenWrapper.delegate : null;\n    } else {\n      assert supportedMethods.hasNext;\n      return next();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7e2cb543b41c145f33390f460ee743d6693c9c6c":["fee44d0bd0b9443ff6068d0ba8458fd103dff4aa"],"6864413dbc0c12104c978c05456f3da1d45adb03":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"74a5e7f20b4a444da9df3b2c0f331fa7a1f64223":["7e2cb543b41c145f33390f460ee743d6693c9c6c"],"fee44d0bd0b9443ff6068d0ba8458fd103dff4aa":["6864413dbc0c12104c978c05456f3da1d45adb03"],"93995eb4992a09cc5a4b13b04225eca0bca45d57":["f4821e344090113a4e6d4d31265a0166ab07930d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"439b0fe2f799d1c722151e88e32bdefad8d34ebe":["93995eb4992a09cc5a4b13b04225eca0bca45d57"],"f4821e344090113a4e6d4d31265a0166ab07930d":["39c72a0a1f317a4165b759c7842b5d73d7858d1d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["439b0fe2f799d1c722151e88e32bdefad8d34ebe"],"39c72a0a1f317a4165b759c7842b5d73d7858d1d":["0833fee1ce16a2b8e10f21cbccd2e93f3d8ccf31"],"0833fee1ce16a2b8e10f21cbccd2e93f3d8ccf31":["ec8b5a20a12931b8d7e616c79c5248ae06cc5568"],"ec8b5a20a12931b8d7e616c79c5248ae06cc5568":["74a5e7f20b4a444da9df3b2c0f331fa7a1f64223"]},"commit2Childs":{"7e2cb543b41c145f33390f460ee743d6693c9c6c":["74a5e7f20b4a444da9df3b2c0f331fa7a1f64223"],"6864413dbc0c12104c978c05456f3da1d45adb03":["fee44d0bd0b9443ff6068d0ba8458fd103dff4aa"],"fee44d0bd0b9443ff6068d0ba8458fd103dff4aa":["7e2cb543b41c145f33390f460ee743d6693c9c6c"],"74a5e7f20b4a444da9df3b2c0f331fa7a1f64223":["ec8b5a20a12931b8d7e616c79c5248ae06cc5568"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6864413dbc0c12104c978c05456f3da1d45adb03"],"93995eb4992a09cc5a4b13b04225eca0bca45d57":["439b0fe2f799d1c722151e88e32bdefad8d34ebe"],"439b0fe2f799d1c722151e88e32bdefad8d34ebe":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f4821e344090113a4e6d4d31265a0166ab07930d":["93995eb4992a09cc5a4b13b04225eca0bca45d57"],"39c72a0a1f317a4165b759c7842b5d73d7858d1d":["f4821e344090113a4e6d4d31265a0166ab07930d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"0833fee1ce16a2b8e10f21cbccd2e93f3d8ccf31":["39c72a0a1f317a4165b759c7842b5d73d7858d1d"],"ec8b5a20a12931b8d7e616c79c5248ae06cc5568":["0833fee1ce16a2b8e10f21cbccd2e93f3d8ccf31"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}