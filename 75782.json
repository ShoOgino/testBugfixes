{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/OfflinePointReader#split(long,LongBitSet,PointWriter,PointWriter,boolean).mjava","commits":[{"id":"9fd704a49b365ee23de059c76ac9050beb643d0c","date":1457873731,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/OfflinePointReader#split(long,LongBitSet,PointWriter,PointWriter,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public long split(long count, LongBitSet rightTree, PointWriter left, PointWriter right, boolean doClearBits) throws IOException {\n\n    if (left instanceof OfflinePointWriter == false ||\n        right instanceof OfflinePointWriter == false) {\n      return super.split(count, rightTree, left, right, doClearBits);\n    }\n\n    // We specialize the offline -> offline split since the default impl\n    // is somewhat wasteful otherwise (e.g. decoding docID when we don't\n    // need to)\n\n    int packedBytesLength = packedValue.length;\n\n    int bytesPerDoc = packedBytesLength + Integer.BYTES;\n    if (longOrds) {\n      bytesPerDoc += Long.BYTES;\n    } else {\n      bytesPerDoc += Integer.BYTES;\n    }\n\n    long rightCount = 0;\n\n    IndexOutput rightOut = ((OfflinePointWriter) right).out;\n    IndexOutput leftOut = ((OfflinePointWriter) left).out;\n\n    ((OfflinePointWriter) right).count = count;\n    ((OfflinePointWriter) left).count = count;\n\n    assert count <= countLeft: \"count=\" + count + \" countLeft=\" + countLeft;\n\n    countLeft -= count;\n\n    byte[] buffer = new byte[bytesPerDoc];\n    while (count > 0) {\n      in.readBytes(buffer, 0, buffer.length);\n      long ord;\n      if (longOrds) {\n        ord = readLong(buffer, packedBytesLength);\n      } else {\n        ord = readInt(buffer, packedBytesLength);\n      }\n      if (rightTree.get(ord)) {\n        rightOut.writeBytes(buffer, 0, bytesPerDoc);\n        if (doClearBits) {\n          rightTree.clear(ord);\n        }\n        rightCount++;\n      } else {\n        leftOut.writeBytes(buffer, 0, bytesPerDoc);\n      }\n\n      count--;\n    }\n\n    return rightCount;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1e52a98a3809d9d747b7694f15f80b7018403ef5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"950b7a6881d14da782b60444c11295e3ec50d41a","date":1458379095,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/OfflinePointReader#split(long,LongBitSet,PointWriter,PointWriter,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/OfflinePointReader#split(long,LongBitSet,PointWriter,PointWriter,boolean).mjava","sourceNew":"  @Override\n  public long split(long count, LongBitSet rightTree, PointWriter left, PointWriter right, boolean doClearBits) throws IOException {\n\n    if (left instanceof OfflinePointWriter == false ||\n        right instanceof OfflinePointWriter == false) {\n      return super.split(count, rightTree, left, right, doClearBits);\n    }\n\n    // We specialize the offline -> offline split since the default impl\n    // is somewhat wasteful otherwise (e.g. decoding docID when we don't\n    // need to)\n\n    int packedBytesLength = packedValue.length;\n\n    int bytesPerDoc = packedBytesLength + Integer.BYTES;\n    if (longOrds) {\n      bytesPerDoc += Long.BYTES;\n    } else {\n      bytesPerDoc += Integer.BYTES;\n    }\n\n    long rightCount = 0;\n\n    IndexOutput rightOut = ((OfflinePointWriter) right).out;\n    IndexOutput leftOut = ((OfflinePointWriter) left).out;\n\n    assert count <= countLeft: \"count=\" + count + \" countLeft=\" + countLeft;\n\n    countLeft -= count;\n\n    long countStart = count;\n\n    byte[] buffer = new byte[bytesPerDoc];\n    while (count > 0) {\n      in.readBytes(buffer, 0, buffer.length);\n      long ord;\n      if (longOrds) {\n        ord = readLong(buffer, packedBytesLength);\n      } else {\n        ord = readInt(buffer, packedBytesLength);\n      }\n      if (rightTree.get(ord)) {\n        rightOut.writeBytes(buffer, 0, bytesPerDoc);\n        if (doClearBits) {\n          rightTree.clear(ord);\n        }\n        rightCount++;\n      } else {\n        leftOut.writeBytes(buffer, 0, bytesPerDoc);\n      }\n\n      count--;\n    }\n\n    ((OfflinePointWriter) right).count = rightCount;\n    ((OfflinePointWriter) left).count = countStart-rightCount;\n\n    return rightCount;\n  }\n\n","sourceOld":"  @Override\n  public long split(long count, LongBitSet rightTree, PointWriter left, PointWriter right, boolean doClearBits) throws IOException {\n\n    if (left instanceof OfflinePointWriter == false ||\n        right instanceof OfflinePointWriter == false) {\n      return super.split(count, rightTree, left, right, doClearBits);\n    }\n\n    // We specialize the offline -> offline split since the default impl\n    // is somewhat wasteful otherwise (e.g. decoding docID when we don't\n    // need to)\n\n    int packedBytesLength = packedValue.length;\n\n    int bytesPerDoc = packedBytesLength + Integer.BYTES;\n    if (longOrds) {\n      bytesPerDoc += Long.BYTES;\n    } else {\n      bytesPerDoc += Integer.BYTES;\n    }\n\n    long rightCount = 0;\n\n    IndexOutput rightOut = ((OfflinePointWriter) right).out;\n    IndexOutput leftOut = ((OfflinePointWriter) left).out;\n\n    ((OfflinePointWriter) right).count = count;\n    ((OfflinePointWriter) left).count = count;\n\n    assert count <= countLeft: \"count=\" + count + \" countLeft=\" + countLeft;\n\n    countLeft -= count;\n\n    byte[] buffer = new byte[bytesPerDoc];\n    while (count > 0) {\n      in.readBytes(buffer, 0, buffer.length);\n      long ord;\n      if (longOrds) {\n        ord = readLong(buffer, packedBytesLength);\n      } else {\n        ord = readInt(buffer, packedBytesLength);\n      }\n      if (rightTree.get(ord)) {\n        rightOut.writeBytes(buffer, 0, bytesPerDoc);\n        if (doClearBits) {\n          rightTree.clear(ord);\n        }\n        rightCount++;\n      } else {\n        leftOut.writeBytes(buffer, 0, bytesPerDoc);\n      }\n\n      count--;\n    }\n\n    return rightCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"416f9e28900210be57b69bc12e2954fb98ed7ebe","date":1458479803,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/OfflinePointReader#split(long,LongBitSet,PointWriter,PointWriter,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/OfflinePointReader#split(long,LongBitSet,PointWriter,PointWriter,boolean).mjava","sourceNew":"  @Override\n  public long split(long count, LongBitSet rightTree, PointWriter left, PointWriter right, boolean doClearBits) throws IOException {\n\n    if (left instanceof OfflinePointWriter == false ||\n        right instanceof OfflinePointWriter == false) {\n      return super.split(count, rightTree, left, right, doClearBits);\n    }\n\n    // We specialize the offline -> offline split since the default impl\n    // is somewhat wasteful otherwise (e.g. decoding docID when we don't\n    // need to)\n\n    int packedBytesLength = packedValue.length;\n\n    int bytesPerDoc = packedBytesLength + Integer.BYTES;\n    if (singleValuePerDoc == false) {\n      if (longOrds) {\n        bytesPerDoc += Long.BYTES;\n      } else {\n        bytesPerDoc += Integer.BYTES;\n      }\n    }\n\n    long rightCount = 0;\n\n    IndexOutput rightOut = ((OfflinePointWriter) right).out;\n    IndexOutput leftOut = ((OfflinePointWriter) left).out;\n\n    assert count <= countLeft: \"count=\" + count + \" countLeft=\" + countLeft;\n\n    countLeft -= count;\n\n    long countStart = count;\n\n    byte[] buffer = new byte[bytesPerDoc];\n    while (count > 0) {\n      in.readBytes(buffer, 0, buffer.length);\n      long ord;\n      if (longOrds) {\n        ord = readLong(buffer, packedBytesLength);\n      } else {\n        // This is either ord (multi-valued case) or docID (which we use as ord in the single valued case):\n        ord = readInt(buffer, packedBytesLength);\n      }\n\n      if (rightTree.get(ord)) {\n        rightOut.writeBytes(buffer, 0, bytesPerDoc);\n        if (doClearBits) {\n          rightTree.clear(ord);\n        }\n        rightCount++;\n      } else {\n        leftOut.writeBytes(buffer, 0, bytesPerDoc);\n      }\n\n      count--;\n    }\n\n    ((OfflinePointWriter) right).count = rightCount;\n    ((OfflinePointWriter) left).count = countStart-rightCount;\n\n    return rightCount;\n  }\n\n","sourceOld":"  @Override\n  public long split(long count, LongBitSet rightTree, PointWriter left, PointWriter right, boolean doClearBits) throws IOException {\n\n    if (left instanceof OfflinePointWriter == false ||\n        right instanceof OfflinePointWriter == false) {\n      return super.split(count, rightTree, left, right, doClearBits);\n    }\n\n    // We specialize the offline -> offline split since the default impl\n    // is somewhat wasteful otherwise (e.g. decoding docID when we don't\n    // need to)\n\n    int packedBytesLength = packedValue.length;\n\n    int bytesPerDoc = packedBytesLength + Integer.BYTES;\n    if (longOrds) {\n      bytesPerDoc += Long.BYTES;\n    } else {\n      bytesPerDoc += Integer.BYTES;\n    }\n\n    long rightCount = 0;\n\n    IndexOutput rightOut = ((OfflinePointWriter) right).out;\n    IndexOutput leftOut = ((OfflinePointWriter) left).out;\n\n    assert count <= countLeft: \"count=\" + count + \" countLeft=\" + countLeft;\n\n    countLeft -= count;\n\n    long countStart = count;\n\n    byte[] buffer = new byte[bytesPerDoc];\n    while (count > 0) {\n      in.readBytes(buffer, 0, buffer.length);\n      long ord;\n      if (longOrds) {\n        ord = readLong(buffer, packedBytesLength);\n      } else {\n        ord = readInt(buffer, packedBytesLength);\n      }\n      if (rightTree.get(ord)) {\n        rightOut.writeBytes(buffer, 0, bytesPerDoc);\n        if (doClearBits) {\n          rightTree.clear(ord);\n        }\n        rightCount++;\n      } else {\n        leftOut.writeBytes(buffer, 0, bytesPerDoc);\n      }\n\n      count--;\n    }\n\n    ((OfflinePointWriter) right).count = rightCount;\n    ((OfflinePointWriter) left).count = countStart-rightCount;\n\n    return rightCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3c42f66b070ce19a713a1d4b571c280a2ef4fbb9","date":1458832923,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/OfflinePointReader#split(long,LongBitSet,PointWriter,PointWriter,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/OfflinePointReader#split(long,LongBitSet,PointWriter,PointWriter,boolean).mjava","sourceNew":"  @Override\n  public long split(long count, LongBitSet rightTree, PointWriter left, PointWriter right, boolean doClearBits) throws IOException {\n\n    if (left instanceof OfflinePointWriter == false ||\n        right instanceof OfflinePointWriter == false) {\n      return super.split(count, rightTree, left, right, doClearBits);\n    }\n\n    // We specialize the offline -> offline split since the default impl\n    // is somewhat wasteful otherwise (e.g. decoding docID when we don't\n    // need to)\n\n    int packedBytesLength = packedValue.length;\n\n    int bytesPerDoc = packedBytesLength + Integer.BYTES;\n    if (singleValuePerDoc == false) {\n      if (longOrds) {\n        bytesPerDoc += Long.BYTES;\n      } else {\n        bytesPerDoc += Integer.BYTES;\n      }\n    }\n\n    long rightCount = 0;\n\n    IndexOutput rightOut = ((OfflinePointWriter) right).out;\n    IndexOutput leftOut = ((OfflinePointWriter) left).out;\n\n    assert count <= countLeft: \"count=\" + count + \" countLeft=\" + countLeft;\n\n    countLeft -= count;\n\n    long countStart = count;\n\n    byte[] buffer = new byte[bytesPerDoc];\n    while (count > 0) {\n      in.readBytes(buffer, 0, buffer.length);\n\n      long ord;\n      if (singleValuePerDoc == false) {\n        ord = readInt(buffer, packedBytesLength+Integer.BYTES);\n      } else if (longOrds) {\n        ord = readLong(buffer, packedBytesLength+Integer.BYTES);\n      } else {\n        ord = readInt(buffer, packedBytesLength);\n      }\n\n      if (rightTree.get(ord)) {\n        rightOut.writeBytes(buffer, 0, bytesPerDoc);\n        if (doClearBits) {\n          rightTree.clear(ord);\n        }\n        rightCount++;\n      } else {\n        leftOut.writeBytes(buffer, 0, bytesPerDoc);\n      }\n\n      count--;\n    }\n\n    ((OfflinePointWriter) right).count = rightCount;\n    ((OfflinePointWriter) left).count = countStart-rightCount;\n\n    return rightCount;\n  }\n\n","sourceOld":"  @Override\n  public long split(long count, LongBitSet rightTree, PointWriter left, PointWriter right, boolean doClearBits) throws IOException {\n\n    if (left instanceof OfflinePointWriter == false ||\n        right instanceof OfflinePointWriter == false) {\n      return super.split(count, rightTree, left, right, doClearBits);\n    }\n\n    // We specialize the offline -> offline split since the default impl\n    // is somewhat wasteful otherwise (e.g. decoding docID when we don't\n    // need to)\n\n    int packedBytesLength = packedValue.length;\n\n    int bytesPerDoc = packedBytesLength + Integer.BYTES;\n    if (singleValuePerDoc == false) {\n      if (longOrds) {\n        bytesPerDoc += Long.BYTES;\n      } else {\n        bytesPerDoc += Integer.BYTES;\n      }\n    }\n\n    long rightCount = 0;\n\n    IndexOutput rightOut = ((OfflinePointWriter) right).out;\n    IndexOutput leftOut = ((OfflinePointWriter) left).out;\n\n    assert count <= countLeft: \"count=\" + count + \" countLeft=\" + countLeft;\n\n    countLeft -= count;\n\n    long countStart = count;\n\n    byte[] buffer = new byte[bytesPerDoc];\n    while (count > 0) {\n      in.readBytes(buffer, 0, buffer.length);\n      long ord;\n      if (longOrds) {\n        ord = readLong(buffer, packedBytesLength);\n      } else {\n        // This is either ord (multi-valued case) or docID (which we use as ord in the single valued case):\n        ord = readInt(buffer, packedBytesLength);\n      }\n\n      if (rightTree.get(ord)) {\n        rightOut.writeBytes(buffer, 0, bytesPerDoc);\n        if (doClearBits) {\n          rightTree.clear(ord);\n        }\n        rightCount++;\n      } else {\n        leftOut.writeBytes(buffer, 0, bytesPerDoc);\n      }\n\n      count--;\n    }\n\n    ((OfflinePointWriter) right).count = rightCount;\n    ((OfflinePointWriter) left).count = countStart-rightCount;\n\n    return rightCount;\n  }\n\n","bugFix":null,"bugIntro":["1e52a98a3809d9d747b7694f15f80b7018403ef5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e52a98a3809d9d747b7694f15f80b7018403ef5","date":1459072349,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/OfflinePointReader#split(long,LongBitSet,PointWriter,PointWriter,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/OfflinePointReader#split(long,LongBitSet,PointWriter,PointWriter,boolean).mjava","sourceNew":"  @Override\n  public long split(long count, LongBitSet rightTree, PointWriter left, PointWriter right, boolean doClearBits) throws IOException {\n\n    if (left instanceof OfflinePointWriter == false ||\n        right instanceof OfflinePointWriter == false) {\n      return super.split(count, rightTree, left, right, doClearBits);\n    }\n\n    // We specialize the offline -> offline split since the default impl\n    // is somewhat wasteful otherwise (e.g. decoding docID when we don't\n    // need to)\n\n    int packedBytesLength = packedValue.length;\n\n    int bytesPerDoc = packedBytesLength + Integer.BYTES;\n    if (singleValuePerDoc == false) {\n      if (longOrds) {\n        bytesPerDoc += Long.BYTES;\n      } else {\n        bytesPerDoc += Integer.BYTES;\n      }\n    }\n\n    long rightCount = 0;\n\n    IndexOutput rightOut = ((OfflinePointWriter) right).out;\n    IndexOutput leftOut = ((OfflinePointWriter) left).out;\n\n    assert count <= countLeft: \"count=\" + count + \" countLeft=\" + countLeft;\n\n    countLeft -= count;\n\n    long countStart = count;\n\n    byte[] buffer = new byte[bytesPerDoc];\n    while (count > 0) {\n      in.readBytes(buffer, 0, buffer.length);\n\n      long ord;\n      if (longOrds) {\n        // A long ord, after the docID:\n        ord = readLong(buffer, packedBytesLength+Integer.BYTES);\n      } else if (singleValuePerDoc) {\n        // docID is the ord:\n        ord = readInt(buffer, packedBytesLength);\n      } else {\n        // An int ord, after the docID:\n        ord = readInt(buffer, packedBytesLength+Integer.BYTES);\n      }\n\n      if (rightTree.get(ord)) {\n        rightOut.writeBytes(buffer, 0, bytesPerDoc);\n        if (doClearBits) {\n          rightTree.clear(ord);\n        }\n        rightCount++;\n      } else {\n        leftOut.writeBytes(buffer, 0, bytesPerDoc);\n      }\n\n      count--;\n    }\n\n    ((OfflinePointWriter) right).count = rightCount;\n    ((OfflinePointWriter) left).count = countStart-rightCount;\n\n    return rightCount;\n  }\n\n","sourceOld":"  @Override\n  public long split(long count, LongBitSet rightTree, PointWriter left, PointWriter right, boolean doClearBits) throws IOException {\n\n    if (left instanceof OfflinePointWriter == false ||\n        right instanceof OfflinePointWriter == false) {\n      return super.split(count, rightTree, left, right, doClearBits);\n    }\n\n    // We specialize the offline -> offline split since the default impl\n    // is somewhat wasteful otherwise (e.g. decoding docID when we don't\n    // need to)\n\n    int packedBytesLength = packedValue.length;\n\n    int bytesPerDoc = packedBytesLength + Integer.BYTES;\n    if (singleValuePerDoc == false) {\n      if (longOrds) {\n        bytesPerDoc += Long.BYTES;\n      } else {\n        bytesPerDoc += Integer.BYTES;\n      }\n    }\n\n    long rightCount = 0;\n\n    IndexOutput rightOut = ((OfflinePointWriter) right).out;\n    IndexOutput leftOut = ((OfflinePointWriter) left).out;\n\n    assert count <= countLeft: \"count=\" + count + \" countLeft=\" + countLeft;\n\n    countLeft -= count;\n\n    long countStart = count;\n\n    byte[] buffer = new byte[bytesPerDoc];\n    while (count > 0) {\n      in.readBytes(buffer, 0, buffer.length);\n\n      long ord;\n      if (singleValuePerDoc == false) {\n        ord = readInt(buffer, packedBytesLength+Integer.BYTES);\n      } else if (longOrds) {\n        ord = readLong(buffer, packedBytesLength+Integer.BYTES);\n      } else {\n        ord = readInt(buffer, packedBytesLength);\n      }\n\n      if (rightTree.get(ord)) {\n        rightOut.writeBytes(buffer, 0, bytesPerDoc);\n        if (doClearBits) {\n          rightTree.clear(ord);\n        }\n        rightCount++;\n      } else {\n        leftOut.writeBytes(buffer, 0, bytesPerDoc);\n      }\n\n      count--;\n    }\n\n    ((OfflinePointWriter) right).count = rightCount;\n    ((OfflinePointWriter) left).count = countStart-rightCount;\n\n    return rightCount;\n  }\n\n","bugFix":["9fd704a49b365ee23de059c76ac9050beb643d0c","3c42f66b070ce19a713a1d4b571c280a2ef4fbb9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78bdc7d6906146edb12a1a6c1f765ba680ed5124","date":1549523533,"type":4,"author":"iverase","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/OfflinePointReader#split(long,LongBitSet,PointWriter,PointWriter,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  public long split(long count, LongBitSet rightTree, PointWriter left, PointWriter right, boolean doClearBits) throws IOException {\n\n    if (left instanceof OfflinePointWriter == false ||\n        right instanceof OfflinePointWriter == false) {\n      return super.split(count, rightTree, left, right, doClearBits);\n    }\n\n    // We specialize the offline -> offline split since the default impl\n    // is somewhat wasteful otherwise (e.g. decoding docID when we don't\n    // need to)\n\n    int packedBytesLength = packedValue.length;\n\n    int bytesPerDoc = packedBytesLength + Integer.BYTES;\n    if (singleValuePerDoc == false) {\n      if (longOrds) {\n        bytesPerDoc += Long.BYTES;\n      } else {\n        bytesPerDoc += Integer.BYTES;\n      }\n    }\n\n    long rightCount = 0;\n\n    IndexOutput rightOut = ((OfflinePointWriter) right).out;\n    IndexOutput leftOut = ((OfflinePointWriter) left).out;\n\n    assert count <= countLeft: \"count=\" + count + \" countLeft=\" + countLeft;\n\n    countLeft -= count;\n\n    long countStart = count;\n\n    byte[] buffer = new byte[bytesPerDoc];\n    while (count > 0) {\n      in.readBytes(buffer, 0, buffer.length);\n\n      long ord;\n      if (longOrds) {\n        // A long ord, after the docID:\n        ord = readLong(buffer, packedBytesLength+Integer.BYTES);\n      } else if (singleValuePerDoc) {\n        // docID is the ord:\n        ord = readInt(buffer, packedBytesLength);\n      } else {\n        // An int ord, after the docID:\n        ord = readInt(buffer, packedBytesLength+Integer.BYTES);\n      }\n\n      if (rightTree.get(ord)) {\n        rightOut.writeBytes(buffer, 0, bytesPerDoc);\n        if (doClearBits) {\n          rightTree.clear(ord);\n        }\n        rightCount++;\n      } else {\n        leftOut.writeBytes(buffer, 0, bytesPerDoc);\n      }\n\n      count--;\n    }\n\n    ((OfflinePointWriter) right).count = rightCount;\n    ((OfflinePointWriter) left).count = countStart-rightCount;\n\n    return rightCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3c42f66b070ce19a713a1d4b571c280a2ef4fbb9":["416f9e28900210be57b69bc12e2954fb98ed7ebe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["1e52a98a3809d9d747b7694f15f80b7018403ef5"],"1e52a98a3809d9d747b7694f15f80b7018403ef5":["3c42f66b070ce19a713a1d4b571c280a2ef4fbb9"],"416f9e28900210be57b69bc12e2954fb98ed7ebe":["950b7a6881d14da782b60444c11295e3ec50d41a"],"950b7a6881d14da782b60444c11295e3ec50d41a":["9fd704a49b365ee23de059c76ac9050beb643d0c"],"9fd704a49b365ee23de059c76ac9050beb643d0c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"]},"commit2Childs":{"3c42f66b070ce19a713a1d4b571c280a2ef4fbb9":["1e52a98a3809d9d747b7694f15f80b7018403ef5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9fd704a49b365ee23de059c76ac9050beb643d0c"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"416f9e28900210be57b69bc12e2954fb98ed7ebe":["3c42f66b070ce19a713a1d4b571c280a2ef4fbb9"],"1e52a98a3809d9d747b7694f15f80b7018403ef5":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"950b7a6881d14da782b60444c11295e3ec50d41a":["416f9e28900210be57b69bc12e2954fb98ed7ebe"],"9fd704a49b365ee23de059c76ac9050beb643d0c":["950b7a6881d14da782b60444c11295e3ec50d41a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}