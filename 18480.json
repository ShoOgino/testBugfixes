{"path":"src/java/org/apache/lucene/search/FieldSortedHitQueue#lessThan(Object,Object).mjava","commits":[{"id":"6decf4a21b049e524a98231b4df27f61c84f7b65","date":1075479753,"type":0,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#lessThan(Object,Object).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Compares documents based on the value of the term in the field\n     * being sorted by.  Documents which should appear at the top of the\n     * list should have low values in the term; documents which should\n     * appear at the end should have high values.\n     *\n     * <p>In the context of this method, \"less than\" means \"less relevant\",\n     * so documents at the top of the list are \"greatest\" and documents at\n     * the bottom are \"least\".\n     *\n     * <p>Document A is considered less than Document B\n     * if A.field.term > B.field.term or A.doc > B.doc.\n     *\n     * @param a  ScoreDoc object for document a.\n     * @param b  ScoreDoc object for document b.\n     * @return true if document a is less than document b.\n     * @see ScoreDoc\n     */\n    protected final boolean lessThan (Object a, Object b) {\n        ScoreDoc hitA = (ScoreDoc) a;\n        ScoreDoc hitB = (ScoreDoc) b;\n        int scoreA = fieldOrder[hitA.doc];\n        int scoreB = fieldOrder[hitB.doc];\n        if (scoreA == scoreB)\n            return hitA.doc > hitB.doc;\n        else\n            return scoreA > scoreB;   // bigger is really less - the ones at the top should be the lowest\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6691cb6747f9e850337c706c06b92e9ddf816e1","date":1077044431,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#lessThan(Object,Object).mjava","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal ScoreDoc docA = (ScoreDoc) a;\n\t\tfinal ScoreDoc docB = (ScoreDoc) b;\n\t\tfinal int n = comparators.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tc = comparators[i].compare (docA, docB);\n\t\t}\n\t\treturn c > 0;\n\t}\n\n","sourceOld":"    /**\n     * Compares documents based on the value of the term in the field\n     * being sorted by.  Documents which should appear at the top of the\n     * list should have low values in the term; documents which should\n     * appear at the end should have high values.\n     *\n     * <p>In the context of this method, \"less than\" means \"less relevant\",\n     * so documents at the top of the list are \"greatest\" and documents at\n     * the bottom are \"least\".\n     *\n     * <p>Document A is considered less than Document B\n     * if A.field.term > B.field.term or A.doc > B.doc.\n     *\n     * @param a  ScoreDoc object for document a.\n     * @param b  ScoreDoc object for document b.\n     * @return true if document a is less than document b.\n     * @see ScoreDoc\n     */\n    protected final boolean lessThan (Object a, Object b) {\n        ScoreDoc hitA = (ScoreDoc) a;\n        ScoreDoc hitB = (ScoreDoc) b;\n        int scoreA = fieldOrder[hitA.doc];\n        int scoreB = fieldOrder[hitB.doc];\n        if (scoreA == scoreB)\n            return hitA.doc > hitB.doc;\n        else\n            return scoreA > scoreB;   // bigger is really less - the ones at the top should be the lowest\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99ee715b9c02dd47d9e69a18607a5192c1ebd82b","date":1085007927,"type":3,"author":"Tim Jones","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#lessThan(Object,Object).mjava","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":"  /**\n   * Returns whether <code>a</code> is less relevant than <code>b</code>.\n   * @param a ScoreDoc\n   * @param b ScoreDoc\n   * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n   */\n  protected final boolean lessThan (final Object a, final Object b) {\n    final ScoreDoc docA = (ScoreDoc) a;\n    final ScoreDoc docB = (ScoreDoc) b;\n\n    // keep track of maximum score\n    if (docA.score > maxscore) maxscore = docA.score;\n    if (docB.score > maxscore) maxscore = docB.score;\n\n    // run comparators\n    final int n = comparators.length;\n    int c = 0;\n    for (int i=0; i<n && c==0; ++i) {\n      c = (fields[i].reverse) ? comparators[i].compare (docB, docA)\n                              : comparators[i].compare (docA, docB);\n    }\n    return c > 0;\n  }\n\n","sourceOld":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal ScoreDoc docA = (ScoreDoc) a;\n\t\tfinal ScoreDoc docB = (ScoreDoc) b;\n\t\tfinal int n = comparators.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tc = comparators[i].compare (docA, docB);\n\t\t}\n\t\treturn c > 0;\n\t}\n\n","bugFix":null,"bugIntro":["812085e8a70bb6d650fded5fa0db7c49a746e918"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b8301bda6c89483f2968ce59c7b1c1e9b93ecfb7","date":1095531677,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#lessThan(Object,Object).mjava","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":"  /**\n   * Returns whether <code>a</code> is less relevant than <code>b</code>.\n   * @param a ScoreDoc\n   * @param b ScoreDoc\n   * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n   */\n  protected final boolean lessThan (final Object a, final Object b) {\n    final ScoreDoc docA = (ScoreDoc) a;\n    final ScoreDoc docB = (ScoreDoc) b;\n\n    // keep track of maximum score\n    if (docA.score > maxscore) maxscore = docA.score;\n    if (docB.score > maxscore) maxscore = docB.score;\n\n    // run comparators\n    final int n = comparators.length;\n    int c = 0;\n    for (int i=0; i<n && c==0; ++i) {\n      c = (fields[i].reverse) ? comparators[i].compare (docB, docA)\n                              : comparators[i].compare (docA, docB);\n    }\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n    return c > 0;\n  }\n\n","sourceOld":"  /**\n   * Returns whether <code>a</code> is less relevant than <code>b</code>.\n   * @param a ScoreDoc\n   * @param b ScoreDoc\n   * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n   */\n  protected final boolean lessThan (final Object a, final Object b) {\n    final ScoreDoc docA = (ScoreDoc) a;\n    final ScoreDoc docB = (ScoreDoc) b;\n\n    // keep track of maximum score\n    if (docA.score > maxscore) maxscore = docA.score;\n    if (docB.score > maxscore) maxscore = docB.score;\n\n    // run comparators\n    final int n = comparators.length;\n    int c = 0;\n    for (int i=0; i<n && c==0; ++i) {\n      c = (fields[i].reverse) ? comparators[i].compare (docB, docA)\n                              : comparators[i].compare (docA, docB);\n    }\n    return c > 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2bd4be73b5ce7c1b99bb92cedce8d72f0ba18105","date":1111514529,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#lessThan(Object,Object).mjava","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":"  /**\n   * Returns whether <code>a</code> is less relevant than <code>b</code>.\n   * @param a ScoreDoc\n   * @param b ScoreDoc\n   * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n   */\n  protected boolean lessThan (final Object a, final Object b) {\n    final ScoreDoc docA = (ScoreDoc) a;\n    final ScoreDoc docB = (ScoreDoc) b;\n\n    // keep track of maximum score\n    if (docA.score > maxscore) maxscore = docA.score;\n    if (docB.score > maxscore) maxscore = docB.score;\n\n    // run comparators\n    final int n = comparators.length;\n    int c = 0;\n    for (int i=0; i<n && c==0; ++i) {\n      c = (fields[i].reverse) ? comparators[i].compare (docB, docA)\n                              : comparators[i].compare (docA, docB);\n    }\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n    return c > 0;\n  }\n\n","sourceOld":"  /**\n   * Returns whether <code>a</code> is less relevant than <code>b</code>.\n   * @param a ScoreDoc\n   * @param b ScoreDoc\n   * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n   */\n  protected final boolean lessThan (final Object a, final Object b) {\n    final ScoreDoc docA = (ScoreDoc) a;\n    final ScoreDoc docB = (ScoreDoc) b;\n\n    // keep track of maximum score\n    if (docA.score > maxscore) maxscore = docA.score;\n    if (docB.score > maxscore) maxscore = docB.score;\n\n    // run comparators\n    final int n = comparators.length;\n    int c = 0;\n    for (int i=0; i<n && c==0; ++i) {\n      c = (fields[i].reverse) ? comparators[i].compare (docB, docA)\n                              : comparators[i].compare (docA, docB);\n    }\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n    return c > 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"812085e8a70bb6d650fded5fa0db7c49a746e918","date":1131743942,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#lessThan(Object,Object).mjava","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":"  /**\n   * Returns whether <code>a</code> is less relevant than <code>b</code>.\n   * @param a ScoreDoc\n   * @param b ScoreDoc\n   * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n   */\n  protected boolean lessThan (final Object a, final Object b) {\n    final ScoreDoc docA = (ScoreDoc) a;\n    final ScoreDoc docB = (ScoreDoc) b;\n\n    // run comparators\n    final int n = comparators.length;\n    int c = 0;\n    for (int i=0; i<n && c==0; ++i) {\n      c = (fields[i].reverse) ? comparators[i].compare (docB, docA)\n                              : comparators[i].compare (docA, docB);\n    }\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n    return c > 0;\n  }\n\n","sourceOld":"  /**\n   * Returns whether <code>a</code> is less relevant than <code>b</code>.\n   * @param a ScoreDoc\n   * @param b ScoreDoc\n   * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n   */\n  protected boolean lessThan (final Object a, final Object b) {\n    final ScoreDoc docA = (ScoreDoc) a;\n    final ScoreDoc docB = (ScoreDoc) b;\n\n    // keep track of maximum score\n    if (docA.score > maxscore) maxscore = docA.score;\n    if (docB.score > maxscore) maxscore = docB.score;\n\n    // run comparators\n    final int n = comparators.length;\n    int c = 0;\n    for (int i=0; i<n && c==0; ++i) {\n      c = (fields[i].reverse) ? comparators[i].compare (docB, docA)\n                              : comparators[i].compare (docA, docB);\n    }\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n    return c > 0;\n  }\n\n","bugFix":["99ee715b9c02dd47d9e69a18607a5192c1ebd82b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ded38b25fe842ef1efc6715745bb8d8ed8e2fc99","date":1255432705,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":null,"sourceOld":"  /**\n   * Returns whether <code>a</code> is less relevant than <code>b</code>.\n   * @param a ScoreDoc\n   * @param b ScoreDoc\n   * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n   */\n  protected boolean lessThan (final Object a, final Object b) {\n    final ScoreDoc docA = (ScoreDoc) a;\n    final ScoreDoc docB = (ScoreDoc) b;\n\n    // run comparators\n    final int n = comparators.length;\n    int c = 0;\n    for (int i=0; i<n && c==0; ++i) {\n      c = (fields[i].reverse) ? comparators[i].compare (docB, docA)\n                              : comparators[i].compare (docA, docB);\n    }\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n    return c > 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"812085e8a70bb6d650fded5fa0db7c49a746e918":["2bd4be73b5ce7c1b99bb92cedce8d72f0ba18105"],"c6691cb6747f9e850337c706c06b92e9ddf816e1":["6decf4a21b049e524a98231b4df27f61c84f7b65"],"99ee715b9c02dd47d9e69a18607a5192c1ebd82b":["c6691cb6747f9e850337c706c06b92e9ddf816e1"],"b8301bda6c89483f2968ce59c7b1c1e9b93ecfb7":["99ee715b9c02dd47d9e69a18607a5192c1ebd82b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ded38b25fe842ef1efc6715745bb8d8ed8e2fc99":["812085e8a70bb6d650fded5fa0db7c49a746e918"],"6decf4a21b049e524a98231b4df27f61c84f7b65":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2bd4be73b5ce7c1b99bb92cedce8d72f0ba18105":["b8301bda6c89483f2968ce59c7b1c1e9b93ecfb7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ded38b25fe842ef1efc6715745bb8d8ed8e2fc99"]},"commit2Childs":{"812085e8a70bb6d650fded5fa0db7c49a746e918":["ded38b25fe842ef1efc6715745bb8d8ed8e2fc99"],"c6691cb6747f9e850337c706c06b92e9ddf816e1":["99ee715b9c02dd47d9e69a18607a5192c1ebd82b"],"99ee715b9c02dd47d9e69a18607a5192c1ebd82b":["b8301bda6c89483f2968ce59c7b1c1e9b93ecfb7"],"b8301bda6c89483f2968ce59c7b1c1e9b93ecfb7":["2bd4be73b5ce7c1b99bb92cedce8d72f0ba18105"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6decf4a21b049e524a98231b4df27f61c84f7b65"],"6decf4a21b049e524a98231b4df27f61c84f7b65":["c6691cb6747f9e850337c706c06b92e9ddf816e1"],"ded38b25fe842ef1efc6715745bb8d8ed8e2fc99":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2bd4be73b5ce7c1b99bb92cedce8d72f0ba18105":["812085e8a70bb6d650fded5fa0db7c49a746e918"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}