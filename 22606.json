{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/MaintainTimeRoutedAliasCmd#deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias,ZkStateReader.AliasesManager,Instant).mjava","commits":[{"id":"b627755385655c7cd3fb296f17593658805cf4d5","date":1552455143,"type":1,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MaintainTimeRoutedAliasCmd#deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias,ZkStateReader.AliasesManager,Instant).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MaintainRoutedAliasCmd#deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias,ZkStateReader.AliasesManager,Instant).mjava","sourceNew":"  /**\n   * Deletes some of the oldest collection(s) based on {@link TimeRoutedAlias#getAutoDeleteAgeMath()}. If not present\n   * then does nothing.  Returns non-null results if something was deleted (or if we tried to).\n   * {@code now} is the date from which the math is relative to.\n   */\n  NamedList deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias timeRoutedAlias,\n                                                  ZkStateReader.AliasesManager aliasesManager,\n                                                  Instant now) throws Exception {\n    final String autoDeleteAgeMathStr = timeRoutedAlias.getAutoDeleteAgeMath();\n    if (autoDeleteAgeMathStr == null) {\n      return null;\n    }\n    final Instant delBefore;\n    try {\n      delBefore = new DateMathParser(Date.from(now), timeRoutedAlias.getTimeZone()).parseMath(autoDeleteAgeMathStr).toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e); // note: should not happen by this point\n    }\n\n    String aliasName = timeRoutedAlias.getAliasName();\n\n    Collection<String> collectionsToDelete = new LinkedHashSet<>();\n\n    // First update the alias    (there may be no change to make!)\n    aliasesManager.applyModificationAndExportToZk(curAliases -> {\n      // note: we could re-parse the TimeRoutedAlias object from curAliases but I don't think there's a point to it.\n\n      final List<Map.Entry<Instant, String>> parsedCollections =\n          timeRoutedAlias.parseCollections(curAliases);\n\n      //iterating from newest to oldest, find the first collection that has a time <= \"before\".  We keep this collection\n      // (and all newer to left) but we delete older collections, which are the ones that follow.\n      // This logic will always keep the first collection, which we can't delete.\n      int numToKeep = 0;\n      for (Map.Entry<Instant, String> parsedCollection : parsedCollections) {\n        numToKeep++;\n        final Instant colInstant = parsedCollection.getKey();\n        if (colInstant.isBefore(delBefore) || colInstant.equals(delBefore)) {\n          break;\n        }\n      }\n      if (numToKeep == parsedCollections.size()) {\n        log.debug(\"No old time routed collections to delete.\");\n        return curAliases;\n      }\n\n      final List<String> targetList = curAliases.getCollectionAliasListMap().get(aliasName);\n      // remember to delete these... (oldest to newest)\n      for (int i = targetList.size() - 1; i >= numToKeep; i--) {\n        collectionsToDelete.add(targetList.get(i));\n      }\n      // new alias list has only \"numToKeep\" first items\n      final List<String> collectionsToKeep = targetList.subList(0, numToKeep);\n      final String collectionsToKeepStr = StrUtils.join(collectionsToKeep, ',');\n      return curAliases.cloneWithCollectionAlias(aliasName, collectionsToKeepStr);\n    });\n\n    if (collectionsToDelete.isEmpty()) {\n      return null;\n    }\n\n    log.info(\"Removing old time routed collections: {}\", collectionsToDelete);\n    // Should this be done asynchronously?  If we got \"ASYNC\" then probably.\n    //   It would shorten the time the Overseer holds a lock on the alias name\n    //   (deleting the collections will be done later and not use that lock).\n    //   Don't bother about parallel; it's unusual to have more than 1.\n    // Note we don't throw an exception here under most cases; instead the response will have information about\n    //   how each delete request went, possibly including a failure message.\n    final CollectionsHandler collHandler = ocmh.overseer.getCoreContainer().getCollectionsHandler();\n    NamedList results = new NamedList();\n    for (String collection : collectionsToDelete) {\n      final SolrParams reqParams = CollectionAdminRequest.deleteCollection(collection).getParams();\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      collHandler.handleRequestBody(new LocalSolrQueryRequest(null, reqParams), rsp);\n      results.add(collection, rsp.getValues());\n    }\n    return results;\n  }\n\n","sourceOld":"  /**\n   * Deletes some of the oldest collection(s) based on {@link TimeRoutedAlias#getAutoDeleteAgeMath()}. If not present\n   * then does nothing.  Returns non-null results if something was deleted (or if we tried to).\n   * {@code now} is the date from which the math is relative to.\n   */\n  NamedList deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias timeRoutedAlias,\n                                                  ZkStateReader.AliasesManager aliasesManager,\n                                                  Instant now) throws Exception {\n    final String autoDeleteAgeMathStr = timeRoutedAlias.getAutoDeleteAgeMath();\n    if (autoDeleteAgeMathStr == null) {\n      return null;\n    }\n    final Instant delBefore;\n    try {\n      delBefore = new DateMathParser(Date.from(now), timeRoutedAlias.getTimeZone()).parseMath(autoDeleteAgeMathStr).toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e); // note: should not happen by this point\n    }\n\n    String aliasName = timeRoutedAlias.getAliasName();\n\n    Collection<String> collectionsToDelete = new LinkedHashSet<>();\n\n    // First update the alias    (there may be no change to make!)\n    aliasesManager.applyModificationAndExportToZk(curAliases -> {\n      // note: we could re-parse the TimeRoutedAlias object from curAliases but I don't think there's a point to it.\n\n      final List<Map.Entry<Instant, String>> parsedCollections =\n          timeRoutedAlias.parseCollections(curAliases, () -> newAliasMustExistException(aliasName));\n\n      //iterating from newest to oldest, find the first collection that has a time <= \"before\".  We keep this collection\n      // (and all newer to left) but we delete older collections, which are the ones that follow.\n      // This logic will always keep the first collection, which we can't delete.\n      int numToKeep = 0;\n      for (Map.Entry<Instant, String> parsedCollection : parsedCollections) {\n        numToKeep++;\n        final Instant colInstant = parsedCollection.getKey();\n        if (colInstant.isBefore(delBefore) || colInstant.equals(delBefore)) {\n          break;\n        }\n      }\n      if (numToKeep == parsedCollections.size()) {\n        log.debug(\"No old time routed collections to delete.\");\n        return curAliases;\n      }\n\n      final List<String> targetList = curAliases.getCollectionAliasListMap().get(aliasName);\n      // remember to delete these... (oldest to newest)\n      for (int i = targetList.size() - 1; i >= numToKeep; i--) {\n        collectionsToDelete.add(targetList.get(i));\n      }\n      // new alias list has only \"numToKeep\" first items\n      final List<String> collectionsToKeep = targetList.subList(0, numToKeep);\n      final String collectionsToKeepStr = StrUtils.join(collectionsToKeep, ',');\n      return curAliases.cloneWithCollectionAlias(aliasName, collectionsToKeepStr);\n    });\n\n    if (collectionsToDelete.isEmpty()) {\n      return null;\n    }\n\n    log.info(\"Removing old time routed collections: {}\", collectionsToDelete);\n    // Should this be done asynchronously?  If we got \"ASYNC\" then probably.\n    //   It would shorten the time the Overseer holds a lock on the alias name\n    //   (deleting the collections will be done later and not use that lock).\n    //   Don't bother about parallel; it's unusual to have more than 1.\n    // Note we don't throw an exception here under most cases; instead the response will have information about\n    //   how each delete request went, possibly including a failure message.\n    final CollectionsHandler collHandler = ocmh.overseer.getCoreContainer().getCollectionsHandler();\n    NamedList results = new NamedList();\n    for (String collection : collectionsToDelete) {\n      final SolrParams reqParams = CollectionAdminRequest.deleteCollection(collection).getParams();\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      collHandler.handleRequestBody(new LocalSolrQueryRequest(null, reqParams), rsp);\n      results.add(collection, rsp.getValues());\n    }\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"105e345cf3c0abed3cb6c109274a379cb2655adc","date":1561038472,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MaintainTimeRoutedAliasCmd#deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias,ZkStateReader.AliasesManager,Instant).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MaintainTimeRoutedAliasCmd#deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias,ZkStateReader.AliasesManager,Instant).mjava","sourceNew":"  /**\n   * Deletes some of the oldest collection(s) based on {@link TimeRoutedAlias#getAutoDeleteAgeMath()}. If not present\n   * then does nothing.  Returns non-null results if something was deleted (or if we tried to).\n   * {@code now} is the date from which the math is relative to.\n   */\n  NamedList deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias timeRoutedAlias,\n                                                  ZkStateReader.AliasesManager aliasesManager,\n                                                  Instant now) throws Exception {\n    final String autoDeleteAgeMathStr = timeRoutedAlias.getAutoDeleteAgeMath();\n    if (autoDeleteAgeMathStr == null) {\n      return null;\n    }\n    final Instant delBefore;\n    try {\n      delBefore = new DateMathParser(Date.from(now), timeRoutedAlias.getTimeZone()).parseMath(autoDeleteAgeMathStr).toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e); // note: should not happen by this point\n    }\n\n    String aliasName = timeRoutedAlias.getAliasName();\n\n    Collection<String> collectionsToDelete = new LinkedHashSet<>();\n\n    // First update the alias    (there may be no change to make!)\n    aliasesManager.applyModificationAndExportToZk(curAliases -> {\n      // note: we could re-parse the TimeRoutedAlias object from curAliases but I don't think there's a point to it.\n\n      final List<Map.Entry<Instant, String>> parsedCollections =\n          timeRoutedAlias.parseCollections(curAliases);\n\n      //iterating from newest to oldest, find the first collection that has a time <= \"before\".  We keep this collection\n      // (and all newer to left) but we delete older collections, which are the ones that follow.\n      // This logic will always keep the first collection, which we can't delete.\n      int numToKeep = 0;\n      DateTimeFormatter dtf = null;\n      if (log.isDebugEnabled()) {\n        dtf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.n\", Locale.ROOT);\n        dtf = dtf.withZone(ZoneId.of(\"UTC\"));\n      }\n      for (Map.Entry<Instant, String> parsedCollection : parsedCollections) {\n        numToKeep++;\n        final Instant colInstant = parsedCollection.getKey();\n        if (colInstant.isBefore(delBefore) || colInstant.equals(delBefore)) {\n          if (log.isDebugEnabled()) { // don't perform formatting unless debugging\n            log.debug(\"{} is equal to or before {} deletions may be required\", dtf.format(colInstant),dtf.format(delBefore));\n          }\n          break;\n        } else {\n          if (log.isDebugEnabled()) { // don't perform formatting unless debugging\n            log.debug(\"{} is not before {} and will be retained\", dtf.format(colInstant),dtf.format(delBefore));\n          }\n        }\n      }\n      if (numToKeep == parsedCollections.size()) {\n        log.debug(\"No old time routed collections to delete... parsed collections={}\", parsedCollections);\n        return curAliases;\n      }\n      log.debug(\"Collections will be deleted... parsed collections={}\", parsedCollections);\n      Map<String, List<String>> collectionAliasListMap = curAliases.getCollectionAliasListMap();\n      final List<String> targetList = collectionAliasListMap.get(aliasName);\n      // remember to delete these... (oldest to newest)\n      log.debug(\"Iterating backwards on collection list to find deletions: {}\", targetList);\n      for (int i = targetList.size() - 1; i >= numToKeep; i--) {\n        String toDelete = targetList.get(i);\n        log.debug(\"Adding to TRA delete list:{}\",toDelete);\n        collectionsToDelete.add(toDelete);\n      }\n      // new alias list has only \"numToKeep\" first items\n      final List<String> collectionsToKeep = targetList.subList(0, numToKeep);\n      final String collectionsToKeepStr = StrUtils.join(collectionsToKeep, ',');\n      return curAliases.cloneWithCollectionAlias(aliasName, collectionsToKeepStr);\n    });\n\n    if (collectionsToDelete.isEmpty()) {\n      return null;\n    }\n\n    log.info(\"Removing old time routed collections: {}\", collectionsToDelete);\n    // Should this be done asynchronously?  If we got \"ASYNC\" then probably.\n    //   It would shorten the time the Overseer holds a lock on the alias name\n    //   (deleting the collections will be done later and not use that lock).\n    //   Don't bother about parallel; it's unusual to have more than 1.\n    // Note we don't throw an exception here under most cases; instead the response will have information about\n    //   how each delete request went, possibly including a failure message.\n    final CollectionsHandler collHandler = ocmh.overseer.getCoreContainer().getCollectionsHandler();\n    NamedList results = new NamedList();\n    for (String collection : collectionsToDelete) {\n      final SolrParams reqParams = CollectionAdminRequest.deleteCollection(collection).getParams();\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      collHandler.handleRequestBody(new LocalSolrQueryRequest(null, reqParams), rsp);\n      results.add(collection, rsp.getValues());\n    }\n    return results;\n  }\n\n","sourceOld":"  /**\n   * Deletes some of the oldest collection(s) based on {@link TimeRoutedAlias#getAutoDeleteAgeMath()}. If not present\n   * then does nothing.  Returns non-null results if something was deleted (or if we tried to).\n   * {@code now} is the date from which the math is relative to.\n   */\n  NamedList deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias timeRoutedAlias,\n                                                  ZkStateReader.AliasesManager aliasesManager,\n                                                  Instant now) throws Exception {\n    final String autoDeleteAgeMathStr = timeRoutedAlias.getAutoDeleteAgeMath();\n    if (autoDeleteAgeMathStr == null) {\n      return null;\n    }\n    final Instant delBefore;\n    try {\n      delBefore = new DateMathParser(Date.from(now), timeRoutedAlias.getTimeZone()).parseMath(autoDeleteAgeMathStr).toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e); // note: should not happen by this point\n    }\n\n    String aliasName = timeRoutedAlias.getAliasName();\n\n    Collection<String> collectionsToDelete = new LinkedHashSet<>();\n\n    // First update the alias    (there may be no change to make!)\n    aliasesManager.applyModificationAndExportToZk(curAliases -> {\n      // note: we could re-parse the TimeRoutedAlias object from curAliases but I don't think there's a point to it.\n\n      final List<Map.Entry<Instant, String>> parsedCollections =\n          timeRoutedAlias.parseCollections(curAliases);\n\n      //iterating from newest to oldest, find the first collection that has a time <= \"before\".  We keep this collection\n      // (and all newer to left) but we delete older collections, which are the ones that follow.\n      // This logic will always keep the first collection, which we can't delete.\n      int numToKeep = 0;\n      for (Map.Entry<Instant, String> parsedCollection : parsedCollections) {\n        numToKeep++;\n        final Instant colInstant = parsedCollection.getKey();\n        if (colInstant.isBefore(delBefore) || colInstant.equals(delBefore)) {\n          break;\n        }\n      }\n      if (numToKeep == parsedCollections.size()) {\n        log.debug(\"No old time routed collections to delete.\");\n        return curAliases;\n      }\n\n      final List<String> targetList = curAliases.getCollectionAliasListMap().get(aliasName);\n      // remember to delete these... (oldest to newest)\n      for (int i = targetList.size() - 1; i >= numToKeep; i--) {\n        collectionsToDelete.add(targetList.get(i));\n      }\n      // new alias list has only \"numToKeep\" first items\n      final List<String> collectionsToKeep = targetList.subList(0, numToKeep);\n      final String collectionsToKeepStr = StrUtils.join(collectionsToKeep, ',');\n      return curAliases.cloneWithCollectionAlias(aliasName, collectionsToKeepStr);\n    });\n\n    if (collectionsToDelete.isEmpty()) {\n      return null;\n    }\n\n    log.info(\"Removing old time routed collections: {}\", collectionsToDelete);\n    // Should this be done asynchronously?  If we got \"ASYNC\" then probably.\n    //   It would shorten the time the Overseer holds a lock on the alias name\n    //   (deleting the collections will be done later and not use that lock).\n    //   Don't bother about parallel; it's unusual to have more than 1.\n    // Note we don't throw an exception here under most cases; instead the response will have information about\n    //   how each delete request went, possibly including a failure message.\n    final CollectionsHandler collHandler = ocmh.overseer.getCoreContainer().getCollectionsHandler();\n    NamedList results = new NamedList();\n    for (String collection : collectionsToDelete) {\n      final SolrParams reqParams = CollectionAdminRequest.deleteCollection(collection).getParams();\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      collHandler.handleRequestBody(new LocalSolrQueryRequest(null, reqParams), rsp);\n      results.add(collection, rsp.getValues());\n    }\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eebf1b080530bdd7572c4927fb2bb52334b7a86","date":1563199033,"type":4,"author":"Gus Heck","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MaintainTimeRoutedAliasCmd#deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias,ZkStateReader.AliasesManager,Instant).mjava","sourceNew":null,"sourceOld":"  /**\n   * Deletes some of the oldest collection(s) based on {@link TimeRoutedAlias#getAutoDeleteAgeMath()}. If not present\n   * then does nothing.  Returns non-null results if something was deleted (or if we tried to).\n   * {@code now} is the date from which the math is relative to.\n   */\n  NamedList deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias timeRoutedAlias,\n                                                  ZkStateReader.AliasesManager aliasesManager,\n                                                  Instant now) throws Exception {\n    final String autoDeleteAgeMathStr = timeRoutedAlias.getAutoDeleteAgeMath();\n    if (autoDeleteAgeMathStr == null) {\n      return null;\n    }\n    final Instant delBefore;\n    try {\n      delBefore = new DateMathParser(Date.from(now), timeRoutedAlias.getTimeZone()).parseMath(autoDeleteAgeMathStr).toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e); // note: should not happen by this point\n    }\n\n    String aliasName = timeRoutedAlias.getAliasName();\n\n    Collection<String> collectionsToDelete = new LinkedHashSet<>();\n\n    // First update the alias    (there may be no change to make!)\n    aliasesManager.applyModificationAndExportToZk(curAliases -> {\n      // note: we could re-parse the TimeRoutedAlias object from curAliases but I don't think there's a point to it.\n\n      final List<Map.Entry<Instant, String>> parsedCollections =\n          timeRoutedAlias.parseCollections(curAliases);\n\n      //iterating from newest to oldest, find the first collection that has a time <= \"before\".  We keep this collection\n      // (and all newer to left) but we delete older collections, which are the ones that follow.\n      // This logic will always keep the first collection, which we can't delete.\n      int numToKeep = 0;\n      DateTimeFormatter dtf = null;\n      if (log.isDebugEnabled()) {\n        dtf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.n\", Locale.ROOT);\n        dtf = dtf.withZone(ZoneId.of(\"UTC\"));\n      }\n      for (Map.Entry<Instant, String> parsedCollection : parsedCollections) {\n        numToKeep++;\n        final Instant colInstant = parsedCollection.getKey();\n        if (colInstant.isBefore(delBefore) || colInstant.equals(delBefore)) {\n          if (log.isDebugEnabled()) { // don't perform formatting unless debugging\n            log.debug(\"{} is equal to or before {} deletions may be required\", dtf.format(colInstant),dtf.format(delBefore));\n          }\n          break;\n        } else {\n          if (log.isDebugEnabled()) { // don't perform formatting unless debugging\n            log.debug(\"{} is not before {} and will be retained\", dtf.format(colInstant),dtf.format(delBefore));\n          }\n        }\n      }\n      if (numToKeep == parsedCollections.size()) {\n        log.debug(\"No old time routed collections to delete... parsed collections={}\", parsedCollections);\n        return curAliases;\n      }\n      log.debug(\"Collections will be deleted... parsed collections={}\", parsedCollections);\n      Map<String, List<String>> collectionAliasListMap = curAliases.getCollectionAliasListMap();\n      final List<String> targetList = collectionAliasListMap.get(aliasName);\n      // remember to delete these... (oldest to newest)\n      log.debug(\"Iterating backwards on collection list to find deletions: {}\", targetList);\n      for (int i = targetList.size() - 1; i >= numToKeep; i--) {\n        String toDelete = targetList.get(i);\n        log.debug(\"Adding to TRA delete list:{}\",toDelete);\n        collectionsToDelete.add(toDelete);\n      }\n      // new alias list has only \"numToKeep\" first items\n      final List<String> collectionsToKeep = targetList.subList(0, numToKeep);\n      final String collectionsToKeepStr = StrUtils.join(collectionsToKeep, ',');\n      return curAliases.cloneWithCollectionAlias(aliasName, collectionsToKeepStr);\n    });\n\n    if (collectionsToDelete.isEmpty()) {\n      return null;\n    }\n\n    log.info(\"Removing old time routed collections: {}\", collectionsToDelete);\n    // Should this be done asynchronously?  If we got \"ASYNC\" then probably.\n    //   It would shorten the time the Overseer holds a lock on the alias name\n    //   (deleting the collections will be done later and not use that lock).\n    //   Don't bother about parallel; it's unusual to have more than 1.\n    // Note we don't throw an exception here under most cases; instead the response will have information about\n    //   how each delete request went, possibly including a failure message.\n    final CollectionsHandler collHandler = ocmh.overseer.getCoreContainer().getCollectionsHandler();\n    NamedList results = new NamedList();\n    for (String collection : collectionsToDelete) {\n      final SolrParams reqParams = CollectionAdminRequest.deleteCollection(collection).getParams();\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      collHandler.handleRequestBody(new LocalSolrQueryRequest(null, reqParams), rsp);\n      results.add(collection, rsp.getValues());\n    }\n    return results;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"105e345cf3c0abed3cb6c109274a379cb2655adc":["b627755385655c7cd3fb296f17593658805cf4d5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b627755385655c7cd3fb296f17593658805cf4d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["105e345cf3c0abed3cb6c109274a379cb2655adc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"]},"commit2Childs":{"105e345cf3c0abed3cb6c109274a379cb2655adc":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b627755385655c7cd3fb296f17593658805cf4d5"],"b627755385655c7cd3fb296f17593658805cf4d5":["105e345cf3c0abed3cb6c109274a379cb2655adc"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}