{"path":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testHllOptions().mjava","commits":[{"id":"4a4e2c829188fb99886a64558664d79c9ac0fdf1","date":1431021538,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testHllOptions().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * whitebox test that HLL Option parsing does the right thing\n   * @see #testCardinality \n   * @see #testHllOptionsErrors\n   */\n  public void testHllOptions() throws Exception {\n    SolrCore core = h.getCore();\n\n    SchemaField field_l = core.getLatestSchema().getField(\"field_l\");\n    SchemaField field_d = core.getLatestSchema().getField(\"field_d\");\n    SchemaField field_dt = core.getLatestSchema().getField(\"field_dt\");\n    SchemaField field_s = core.getLatestSchema().getField(\"field_s\");\n    SchemaField field_i = core.getLatestSchema().getField(\"field_i\");\n    SchemaField field_f = core.getLatestSchema().getField(\"field_f\");\n    SchemaField field_severity = core.getLatestSchema().getField(\"severity\");\n\n    // simple cases that shouldn't use HLL\n    assertNull(HllOptions.parseHllOptions(params(), field_l));\n    assertNull(HllOptions.parseHllOptions(params(\"cardinality\",\"false\"), field_l));\n\n    // sanity check, future proof againts the HLL library changing stuff on us\n    assertEquals(\"HLL Changed definition min for log2m, \" + \n                 \"need to note in upgrade instructions and maybe adjust accuracy hueristic\",\n                 4, HLL.MINIMUM_LOG2M_PARAM);\n    // NOTE: https://github.com/aggregateknowledge/java-hll/issues/14\n    assertEquals(\"HLL Changed definition max for log2m, \" + \n                 \"need to note in upgrade instructions and maybe adjust accuracy hueristic\",\n                 30, HLL.MAXIMUM_LOG2M_PARAM);\n    assertEquals(\"HLL Changed definition min for regwidth, \" + \n                 \"need to note in upgrade instructions and probably adjust hueristic\",\n                 1, HLL.MINIMUM_REGWIDTH_PARAM);\n    assertEquals(\"HLL Changed definition max for regwidth, \" + \n                 \"need to note in upgrade instructions and probably adjust hueristic\",\n                 8, HLL.MAXIMUM_REGWIDTH_PARAM);\n\n    // all of these should produce equivilent HLLOptions (Long, Double, or String using defaults)\n    SolrParams[] longDefaultParams = new SolrParams[] {\n      // basic usage\n      params(\"cardinality\",\"true\"),\n      params(\"cardinality\",\"0.33\"),\n\n      // expert level options\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\"), \n      params(\"cardinality\",\"true\", \"hllRegwidth\",\"6\"), \n      params(\"cardinality\",\"true\", \"hllPreHash\",\"false\"),\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"6\", \"hllPreHash\", \"false\"),\n\n      // explicit hllLog2M should override numeric arg\n      params(\"cardinality\",\"1.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"6\"),\n      params(\"cardinality\",\"0.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"6\", \"hllPreHash\",\"false\")\n    };\n    for (SchemaField field : new SchemaField[] { field_l, field_d, field_dt, field_s }) {\n      final String f = field.getName();\n      for (SolrParams p : longDefaultParams) {\n        HllOptions opts = HllOptions.parseHllOptions(p, field);\n        assertEquals(f + \" long defaults: \" + p, 13, opts.getLog2m());\n        assertEquals(f + \" long defaults: \" + p, 6, opts.getRegwidth());\n        assertNotNull(f + \" long defaults: \" + p, opts.getHasher());\n      }\n\n      // non defaults: lower/upper accuracy bounds should give min/max log2m & adjusted regwidth\n      HllOptions optsMin = HllOptions.parseHllOptions(params(\"cardinality\",\"0\"), field);\n      assertEquals(f + \" min log2m\", HLL.MINIMUM_LOG2M_PARAM, optsMin.getLog2m());\n      assertEquals(f + \" min regwidth\", 5, optsMin.getRegwidth()); // lowest hueristic for 64bit\n\n      HllOptions optsMax = HllOptions.parseHllOptions(params(\"cardinality\",\"1\"), field);\n      assertEquals(f + \" max log2m\", HLL.MAXIMUM_LOG2M_PARAM, optsMax.getLog2m());\n      assertEquals(f + \" max regwidth\", HLL.MAXIMUM_REGWIDTH_PARAM, optsMax.getRegwidth());\n\n    }\n\n    // all of these should produce equivilent HLLOptions (Int, Float, or ValueSource using defaults)\n    SolrParams[] intDefaultParams = new SolrParams[] {\n      // basic usage\n      params(\"cardinality\",\"true\"),\n      params(\"cardinality\",\"0.33\"),\n\n      // expert level options\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\"), \n      params(\"cardinality\",\"true\", \"hllRegwidth\",\"5\"), \n      params(\"cardinality\",\"true\", \"hllPreHash\",\"false\"),\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"5\", \"hllPreHash\", \"false\"),\n\n      // explicit hllLog2M & hllRegwidth should override hueristic float arg\n      params(\"cardinality\",\"1.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"5\"),\n      params(\"cardinality\",\"0.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"5\", \"hllPreHash\",\"false\")\n    };\n    for (SchemaField field : new SchemaField[] { field_i, field_f, field_severity, null }) {\n      final String f = null == field ? \"(func)\" : field.getName();\n      for (SolrParams p : intDefaultParams) {\n        HllOptions opts = HllOptions.parseHllOptions(p, field);\n        assertEquals(f + \" int defaults: \" + p, 13, opts.getLog2m());\n        assertEquals(f + \" int defaults: \" + p, 5, opts.getRegwidth());\n        assertNotNull(f + \" int defaults: \" + p, opts.getHasher());\n      }\n\n      // non defaults: lower/upper accuracy bounds should give min/max log2m & adjusted regwidth\n      HllOptions optsMin = HllOptions.parseHllOptions(params(\"cardinality\",\"0\"), field);\n      assertEquals(f + \" min log2m\", HLL.MINIMUM_LOG2M_PARAM, optsMin.getLog2m());\n      assertEquals(f + \" min regwidth\", 4, optsMin.getRegwidth()); // lowest hueristic for 32bit\n\n      HllOptions optsMax = HllOptions.parseHllOptions(params(\"cardinality\",\"1\"), field);\n      assertEquals(f + \" max log2m\", HLL.MAXIMUM_LOG2M_PARAM, optsMax.getLog2m());\n      assertEquals(f + \" max regwidth\", HLL.MAXIMUM_REGWIDTH_PARAM, optsMax.getRegwidth());\n\n    }\n\n    // basic pre-hashed arg check specifically for long fields\n    assertNotNull(HllOptions.parseHllOptions(params(\"cardinality\",\"true\"), field_l).getHasher());\n    assertNotNull(HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"false\"), \n                                             field_l).getHasher());\n    assertNull(HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), \n                                          field_l).getHasher());\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9f4251f14d2db68330fc1e6f0495c053a905d560"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9f4251f14d2db68330fc1e6f0495c053a905d560","date":1537116380,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testHllOptions().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testHllOptions().mjava","sourceNew":"  /**\n   * whitebox test that HLL Option parsing does the right thing\n   * @see #testCardinality \n   * @see #testHllOptionsErrors\n   */\n  public void testHllOptions() throws Exception {\n    SolrCore core = h.getCore();\n\n    SchemaField field_l = core.getLatestSchema().getField(\"field_l\");\n    SchemaField field_d = core.getLatestSchema().getField(\"field_d\");\n    SchemaField field_dt = core.getLatestSchema().getField(\"field_dt\");\n    SchemaField field_s = core.getLatestSchema().getField(\"field_s\");\n    SchemaField field_i = core.getLatestSchema().getField(\"field_i\");\n    SchemaField field_f = core.getLatestSchema().getField(\"field_f\");\n    SchemaField field_severity = core.getLatestSchema().getField(\"severity\");\n\n    // simple cases that shouldn't use HLL\n    assertNull(HllOptions.parseHllOptions(params(), field_l));\n    assertNull(HllOptions.parseHllOptions(params(\"cardinality\",\"false\"), field_l));\n\n    // sanity check, future proof againts the HLL library changing stuff on us\n    assertEquals(\"HLL Changed definition min for log2m, \" + \n                 \"need to note in upgrade instructions and maybe adjust accuracy hueristic\",\n                 4, HLL.MINIMUM_LOG2M_PARAM);\n    // NOTE: https://github.com/aggregateknowledge/java-hll/issues/14\n    assertEquals(\"HLL Changed definition max for log2m, \" + \n                 \"need to note in upgrade instructions and maybe adjust accuracy hueristic\",\n                 30, HLL.MAXIMUM_LOG2M_PARAM);\n    assertEquals(\"HLL Changed definition min for regwidth, \" + \n                 \"need to note in upgrade instructions and probably adjust hueristic\",\n                 1, HLL.MINIMUM_REGWIDTH_PARAM);\n    assertEquals(\"HLL Changed definition max for regwidth, \" + \n                 \"need to note in upgrade instructions and probably adjust hueristic\",\n                 8, HLL.MAXIMUM_REGWIDTH_PARAM);\n\n    // all of these should produce equivalent HLLOptions (Long, Double, or String using defaults)\n    SolrParams[] longDefaultParams = new SolrParams[] {\n      // basic usage\n      params(\"cardinality\",\"true\"),\n      params(\"cardinality\",\"0.33\"),\n\n      // expert level options\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\"), \n      params(\"cardinality\",\"true\", \"hllRegwidth\",\"6\"), \n      params(\"cardinality\",\"true\", \"hllPreHash\",\"false\"),\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"6\", \"hllPreHash\", \"false\"),\n\n      // explicit hllLog2M should override numeric arg\n      params(\"cardinality\",\"1.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"6\"),\n      params(\"cardinality\",\"0.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"6\", \"hllPreHash\",\"false\")\n    };\n    for (SchemaField field : new SchemaField[] { field_l, field_d, field_dt, field_s }) {\n      final String f = field.getName();\n      for (SolrParams p : longDefaultParams) {\n        HllOptions opts = HllOptions.parseHllOptions(p, field);\n        assertEquals(f + \" long defaults: \" + p, 13, opts.getLog2m());\n        assertEquals(f + \" long defaults: \" + p, 6, opts.getRegwidth());\n        assertNotNull(f + \" long defaults: \" + p, opts.getHasher());\n      }\n\n      // non defaults: lower/upper accuracy bounds should give min/max log2m & adjusted regwidth\n      HllOptions optsMin = HllOptions.parseHllOptions(params(\"cardinality\",\"0\"), field);\n      assertEquals(f + \" min log2m\", HLL.MINIMUM_LOG2M_PARAM, optsMin.getLog2m());\n      assertEquals(f + \" min regwidth\", 5, optsMin.getRegwidth()); // lowest hueristic for 64bit\n\n      HllOptions optsMax = HllOptions.parseHllOptions(params(\"cardinality\",\"1\"), field);\n      assertEquals(f + \" max log2m\", HLL.MAXIMUM_LOG2M_PARAM, optsMax.getLog2m());\n      assertEquals(f + \" max regwidth\", HLL.MAXIMUM_REGWIDTH_PARAM, optsMax.getRegwidth());\n\n    }\n\n    // all of these should produce equivalent HLLOptions (Int, Float, or ValueSource using defaults)\n    SolrParams[] intDefaultParams = new SolrParams[] {\n      // basic usage\n      params(\"cardinality\",\"true\"),\n      params(\"cardinality\",\"0.33\"),\n\n      // expert level options\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\"), \n      params(\"cardinality\",\"true\", \"hllRegwidth\",\"5\"), \n      params(\"cardinality\",\"true\", \"hllPreHash\",\"false\"),\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"5\", \"hllPreHash\", \"false\"),\n\n      // explicit hllLog2M & hllRegwidth should override hueristic float arg\n      params(\"cardinality\",\"1.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"5\"),\n      params(\"cardinality\",\"0.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"5\", \"hllPreHash\",\"false\")\n    };\n    for (SchemaField field : new SchemaField[] { field_i, field_f, field_severity, null }) {\n      final String f = null == field ? \"(func)\" : field.getName();\n      for (SolrParams p : intDefaultParams) {\n        HllOptions opts = HllOptions.parseHllOptions(p, field);\n        assertEquals(f + \" int defaults: \" + p, 13, opts.getLog2m());\n        assertEquals(f + \" int defaults: \" + p, 5, opts.getRegwidth());\n        assertNotNull(f + \" int defaults: \" + p, opts.getHasher());\n      }\n\n      // non defaults: lower/upper accuracy bounds should give min/max log2m & adjusted regwidth\n      HllOptions optsMin = HllOptions.parseHllOptions(params(\"cardinality\",\"0\"), field);\n      assertEquals(f + \" min log2m\", HLL.MINIMUM_LOG2M_PARAM, optsMin.getLog2m());\n      assertEquals(f + \" min regwidth\", 4, optsMin.getRegwidth()); // lowest hueristic for 32bit\n\n      HllOptions optsMax = HllOptions.parseHllOptions(params(\"cardinality\",\"1\"), field);\n      assertEquals(f + \" max log2m\", HLL.MAXIMUM_LOG2M_PARAM, optsMax.getLog2m());\n      assertEquals(f + \" max regwidth\", HLL.MAXIMUM_REGWIDTH_PARAM, optsMax.getRegwidth());\n\n    }\n\n    // basic pre-hashed arg check specifically for long fields\n    assertNotNull(HllOptions.parseHllOptions(params(\"cardinality\",\"true\"), field_l).getHasher());\n    assertNotNull(HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"false\"), \n                                             field_l).getHasher());\n    assertNull(HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), \n                                          field_l).getHasher());\n\n  }\n\n","sourceOld":"  /**\n   * whitebox test that HLL Option parsing does the right thing\n   * @see #testCardinality \n   * @see #testHllOptionsErrors\n   */\n  public void testHllOptions() throws Exception {\n    SolrCore core = h.getCore();\n\n    SchemaField field_l = core.getLatestSchema().getField(\"field_l\");\n    SchemaField field_d = core.getLatestSchema().getField(\"field_d\");\n    SchemaField field_dt = core.getLatestSchema().getField(\"field_dt\");\n    SchemaField field_s = core.getLatestSchema().getField(\"field_s\");\n    SchemaField field_i = core.getLatestSchema().getField(\"field_i\");\n    SchemaField field_f = core.getLatestSchema().getField(\"field_f\");\n    SchemaField field_severity = core.getLatestSchema().getField(\"severity\");\n\n    // simple cases that shouldn't use HLL\n    assertNull(HllOptions.parseHllOptions(params(), field_l));\n    assertNull(HllOptions.parseHllOptions(params(\"cardinality\",\"false\"), field_l));\n\n    // sanity check, future proof againts the HLL library changing stuff on us\n    assertEquals(\"HLL Changed definition min for log2m, \" + \n                 \"need to note in upgrade instructions and maybe adjust accuracy hueristic\",\n                 4, HLL.MINIMUM_LOG2M_PARAM);\n    // NOTE: https://github.com/aggregateknowledge/java-hll/issues/14\n    assertEquals(\"HLL Changed definition max for log2m, \" + \n                 \"need to note in upgrade instructions and maybe adjust accuracy hueristic\",\n                 30, HLL.MAXIMUM_LOG2M_PARAM);\n    assertEquals(\"HLL Changed definition min for regwidth, \" + \n                 \"need to note in upgrade instructions and probably adjust hueristic\",\n                 1, HLL.MINIMUM_REGWIDTH_PARAM);\n    assertEquals(\"HLL Changed definition max for regwidth, \" + \n                 \"need to note in upgrade instructions and probably adjust hueristic\",\n                 8, HLL.MAXIMUM_REGWIDTH_PARAM);\n\n    // all of these should produce equivilent HLLOptions (Long, Double, or String using defaults)\n    SolrParams[] longDefaultParams = new SolrParams[] {\n      // basic usage\n      params(\"cardinality\",\"true\"),\n      params(\"cardinality\",\"0.33\"),\n\n      // expert level options\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\"), \n      params(\"cardinality\",\"true\", \"hllRegwidth\",\"6\"), \n      params(\"cardinality\",\"true\", \"hllPreHash\",\"false\"),\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"6\", \"hllPreHash\", \"false\"),\n\n      // explicit hllLog2M should override numeric arg\n      params(\"cardinality\",\"1.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"6\"),\n      params(\"cardinality\",\"0.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"6\", \"hllPreHash\",\"false\")\n    };\n    for (SchemaField field : new SchemaField[] { field_l, field_d, field_dt, field_s }) {\n      final String f = field.getName();\n      for (SolrParams p : longDefaultParams) {\n        HllOptions opts = HllOptions.parseHllOptions(p, field);\n        assertEquals(f + \" long defaults: \" + p, 13, opts.getLog2m());\n        assertEquals(f + \" long defaults: \" + p, 6, opts.getRegwidth());\n        assertNotNull(f + \" long defaults: \" + p, opts.getHasher());\n      }\n\n      // non defaults: lower/upper accuracy bounds should give min/max log2m & adjusted regwidth\n      HllOptions optsMin = HllOptions.parseHllOptions(params(\"cardinality\",\"0\"), field);\n      assertEquals(f + \" min log2m\", HLL.MINIMUM_LOG2M_PARAM, optsMin.getLog2m());\n      assertEquals(f + \" min regwidth\", 5, optsMin.getRegwidth()); // lowest hueristic for 64bit\n\n      HllOptions optsMax = HllOptions.parseHllOptions(params(\"cardinality\",\"1\"), field);\n      assertEquals(f + \" max log2m\", HLL.MAXIMUM_LOG2M_PARAM, optsMax.getLog2m());\n      assertEquals(f + \" max regwidth\", HLL.MAXIMUM_REGWIDTH_PARAM, optsMax.getRegwidth());\n\n    }\n\n    // all of these should produce equivilent HLLOptions (Int, Float, or ValueSource using defaults)\n    SolrParams[] intDefaultParams = new SolrParams[] {\n      // basic usage\n      params(\"cardinality\",\"true\"),\n      params(\"cardinality\",\"0.33\"),\n\n      // expert level options\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\"), \n      params(\"cardinality\",\"true\", \"hllRegwidth\",\"5\"), \n      params(\"cardinality\",\"true\", \"hllPreHash\",\"false\"),\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"5\", \"hllPreHash\", \"false\"),\n\n      // explicit hllLog2M & hllRegwidth should override hueristic float arg\n      params(\"cardinality\",\"1.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"5\"),\n      params(\"cardinality\",\"0.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"5\", \"hllPreHash\",\"false\")\n    };\n    for (SchemaField field : new SchemaField[] { field_i, field_f, field_severity, null }) {\n      final String f = null == field ? \"(func)\" : field.getName();\n      for (SolrParams p : intDefaultParams) {\n        HllOptions opts = HllOptions.parseHllOptions(p, field);\n        assertEquals(f + \" int defaults: \" + p, 13, opts.getLog2m());\n        assertEquals(f + \" int defaults: \" + p, 5, opts.getRegwidth());\n        assertNotNull(f + \" int defaults: \" + p, opts.getHasher());\n      }\n\n      // non defaults: lower/upper accuracy bounds should give min/max log2m & adjusted regwidth\n      HllOptions optsMin = HllOptions.parseHllOptions(params(\"cardinality\",\"0\"), field);\n      assertEquals(f + \" min log2m\", HLL.MINIMUM_LOG2M_PARAM, optsMin.getLog2m());\n      assertEquals(f + \" min regwidth\", 4, optsMin.getRegwidth()); // lowest hueristic for 32bit\n\n      HllOptions optsMax = HllOptions.parseHllOptions(params(\"cardinality\",\"1\"), field);\n      assertEquals(f + \" max log2m\", HLL.MAXIMUM_LOG2M_PARAM, optsMax.getLog2m());\n      assertEquals(f + \" max regwidth\", HLL.MAXIMUM_REGWIDTH_PARAM, optsMax.getRegwidth());\n\n    }\n\n    // basic pre-hashed arg check specifically for long fields\n    assertNotNull(HllOptions.parseHllOptions(params(\"cardinality\",\"true\"), field_l).getHasher());\n    assertNotNull(HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"false\"), \n                                             field_l).getHasher());\n    assertNull(HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), \n                                          field_l).getHasher());\n\n  }\n\n","bugFix":["4a4e2c829188fb99886a64558664d79c9ac0fdf1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1bdc96c0ff14d9b1ac3705697b384dd91eae8056","date":1562666209,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testHllOptions().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/StatsComponentTest#testHllOptions().mjava","sourceNew":"  /**\n   * whitebox test that HLL Option parsing does the right thing\n   * @see #testCardinality \n   * @see #testHllOptionsErrors\n   */\n  public void testHllOptions() throws Exception {\n    SolrCore core = h.getCore();\n\n    SchemaField field_l = core.getLatestSchema().getField(\"field_l\");\n    SchemaField field_d = core.getLatestSchema().getField(\"field_d\");\n    SchemaField field_dt = core.getLatestSchema().getField(\"field_dt\");\n    SchemaField field_s = core.getLatestSchema().getField(\"field_s\");\n    SchemaField field_i = core.getLatestSchema().getField(\"field_i\");\n    SchemaField field_f = core.getLatestSchema().getField(\"field_f\");\n    SchemaField field_severity = core.getLatestSchema().getField(\"severity\");\n\n    // simple cases that shouldn't use HLL\n    assertNull(HllOptions.parseHllOptions(params(), field_l));\n    assertNull(HllOptions.parseHllOptions(params(\"cardinality\",\"false\"), field_l));\n\n    // sanity check, future proof against the HLL library changing stuff on us\n    assertEquals(\"HLL Changed definition min for log2m, \" + \n                 \"need to note in upgrade instructions and maybe adjust accuracy hueristic\",\n                 4, HLL.MINIMUM_LOG2M_PARAM);\n    // NOTE: https://github.com/aggregateknowledge/java-hll/issues/14\n    assertEquals(\"HLL Changed definition max for log2m, \" + \n                 \"need to note in upgrade instructions and maybe adjust accuracy hueristic\",\n                 30, HLL.MAXIMUM_LOG2M_PARAM);\n    assertEquals(\"HLL Changed definition min for regwidth, \" + \n                 \"need to note in upgrade instructions and probably adjust hueristic\",\n                 1, HLL.MINIMUM_REGWIDTH_PARAM);\n    assertEquals(\"HLL Changed definition max for regwidth, \" + \n                 \"need to note in upgrade instructions and probably adjust hueristic\",\n                 8, HLL.MAXIMUM_REGWIDTH_PARAM);\n\n    // all of these should produce equivalent HLLOptions (Long, Double, or String using defaults)\n    SolrParams[] longDefaultParams = new SolrParams[] {\n      // basic usage\n      params(\"cardinality\",\"true\"),\n      params(\"cardinality\",\"0.33\"),\n\n      // expert level options\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\"), \n      params(\"cardinality\",\"true\", \"hllRegwidth\",\"6\"), \n      params(\"cardinality\",\"true\", \"hllPreHash\",\"false\"),\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"6\", \"hllPreHash\", \"false\"),\n\n      // explicit hllLog2M should override numeric arg\n      params(\"cardinality\",\"1.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"6\"),\n      params(\"cardinality\",\"0.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"6\", \"hllPreHash\",\"false\")\n    };\n    for (SchemaField field : new SchemaField[] { field_l, field_d, field_dt, field_s }) {\n      final String f = field.getName();\n      for (SolrParams p : longDefaultParams) {\n        HllOptions opts = HllOptions.parseHllOptions(p, field);\n        assertEquals(f + \" long defaults: \" + p, 13, opts.getLog2m());\n        assertEquals(f + \" long defaults: \" + p, 6, opts.getRegwidth());\n        assertNotNull(f + \" long defaults: \" + p, opts.getHasher());\n      }\n\n      // non defaults: lower/upper accuracy bounds should give min/max log2m & adjusted regwidth\n      HllOptions optsMin = HllOptions.parseHllOptions(params(\"cardinality\",\"0\"), field);\n      assertEquals(f + \" min log2m\", HLL.MINIMUM_LOG2M_PARAM, optsMin.getLog2m());\n      assertEquals(f + \" min regwidth\", 5, optsMin.getRegwidth()); // lowest hueristic for 64bit\n\n      HllOptions optsMax = HllOptions.parseHllOptions(params(\"cardinality\",\"1\"), field);\n      assertEquals(f + \" max log2m\", HLL.MAXIMUM_LOG2M_PARAM, optsMax.getLog2m());\n      assertEquals(f + \" max regwidth\", HLL.MAXIMUM_REGWIDTH_PARAM, optsMax.getRegwidth());\n\n    }\n\n    // all of these should produce equivalent HLLOptions (Int, Float, or ValueSource using defaults)\n    SolrParams[] intDefaultParams = new SolrParams[] {\n      // basic usage\n      params(\"cardinality\",\"true\"),\n      params(\"cardinality\",\"0.33\"),\n\n      // expert level options\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\"), \n      params(\"cardinality\",\"true\", \"hllRegwidth\",\"5\"), \n      params(\"cardinality\",\"true\", \"hllPreHash\",\"false\"),\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"5\", \"hllPreHash\", \"false\"),\n\n      // explicit hllLog2M & hllRegwidth should override hueristic float arg\n      params(\"cardinality\",\"1.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"5\"),\n      params(\"cardinality\",\"0.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"5\", \"hllPreHash\",\"false\")\n    };\n    for (SchemaField field : new SchemaField[] { field_i, field_f, field_severity, null }) {\n      final String f = null == field ? \"(func)\" : field.getName();\n      for (SolrParams p : intDefaultParams) {\n        HllOptions opts = HllOptions.parseHllOptions(p, field);\n        assertEquals(f + \" int defaults: \" + p, 13, opts.getLog2m());\n        assertEquals(f + \" int defaults: \" + p, 5, opts.getRegwidth());\n        assertNotNull(f + \" int defaults: \" + p, opts.getHasher());\n      }\n\n      // non defaults: lower/upper accuracy bounds should give min/max log2m & adjusted regwidth\n      HllOptions optsMin = HllOptions.parseHllOptions(params(\"cardinality\",\"0\"), field);\n      assertEquals(f + \" min log2m\", HLL.MINIMUM_LOG2M_PARAM, optsMin.getLog2m());\n      assertEquals(f + \" min regwidth\", 4, optsMin.getRegwidth()); // lowest hueristic for 32bit\n\n      HllOptions optsMax = HllOptions.parseHllOptions(params(\"cardinality\",\"1\"), field);\n      assertEquals(f + \" max log2m\", HLL.MAXIMUM_LOG2M_PARAM, optsMax.getLog2m());\n      assertEquals(f + \" max regwidth\", HLL.MAXIMUM_REGWIDTH_PARAM, optsMax.getRegwidth());\n\n    }\n\n    // basic pre-hashed arg check specifically for long fields\n    assertNotNull(HllOptions.parseHllOptions(params(\"cardinality\",\"true\"), field_l).getHasher());\n    assertNotNull(HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"false\"), \n                                             field_l).getHasher());\n    assertNull(HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), \n                                          field_l).getHasher());\n\n  }\n\n","sourceOld":"  /**\n   * whitebox test that HLL Option parsing does the right thing\n   * @see #testCardinality \n   * @see #testHllOptionsErrors\n   */\n  public void testHllOptions() throws Exception {\n    SolrCore core = h.getCore();\n\n    SchemaField field_l = core.getLatestSchema().getField(\"field_l\");\n    SchemaField field_d = core.getLatestSchema().getField(\"field_d\");\n    SchemaField field_dt = core.getLatestSchema().getField(\"field_dt\");\n    SchemaField field_s = core.getLatestSchema().getField(\"field_s\");\n    SchemaField field_i = core.getLatestSchema().getField(\"field_i\");\n    SchemaField field_f = core.getLatestSchema().getField(\"field_f\");\n    SchemaField field_severity = core.getLatestSchema().getField(\"severity\");\n\n    // simple cases that shouldn't use HLL\n    assertNull(HllOptions.parseHllOptions(params(), field_l));\n    assertNull(HllOptions.parseHllOptions(params(\"cardinality\",\"false\"), field_l));\n\n    // sanity check, future proof againts the HLL library changing stuff on us\n    assertEquals(\"HLL Changed definition min for log2m, \" + \n                 \"need to note in upgrade instructions and maybe adjust accuracy hueristic\",\n                 4, HLL.MINIMUM_LOG2M_PARAM);\n    // NOTE: https://github.com/aggregateknowledge/java-hll/issues/14\n    assertEquals(\"HLL Changed definition max for log2m, \" + \n                 \"need to note in upgrade instructions and maybe adjust accuracy hueristic\",\n                 30, HLL.MAXIMUM_LOG2M_PARAM);\n    assertEquals(\"HLL Changed definition min for regwidth, \" + \n                 \"need to note in upgrade instructions and probably adjust hueristic\",\n                 1, HLL.MINIMUM_REGWIDTH_PARAM);\n    assertEquals(\"HLL Changed definition max for regwidth, \" + \n                 \"need to note in upgrade instructions and probably adjust hueristic\",\n                 8, HLL.MAXIMUM_REGWIDTH_PARAM);\n\n    // all of these should produce equivalent HLLOptions (Long, Double, or String using defaults)\n    SolrParams[] longDefaultParams = new SolrParams[] {\n      // basic usage\n      params(\"cardinality\",\"true\"),\n      params(\"cardinality\",\"0.33\"),\n\n      // expert level options\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\"), \n      params(\"cardinality\",\"true\", \"hllRegwidth\",\"6\"), \n      params(\"cardinality\",\"true\", \"hllPreHash\",\"false\"),\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"6\", \"hllPreHash\", \"false\"),\n\n      // explicit hllLog2M should override numeric arg\n      params(\"cardinality\",\"1.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"6\"),\n      params(\"cardinality\",\"0.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"6\", \"hllPreHash\",\"false\")\n    };\n    for (SchemaField field : new SchemaField[] { field_l, field_d, field_dt, field_s }) {\n      final String f = field.getName();\n      for (SolrParams p : longDefaultParams) {\n        HllOptions opts = HllOptions.parseHllOptions(p, field);\n        assertEquals(f + \" long defaults: \" + p, 13, opts.getLog2m());\n        assertEquals(f + \" long defaults: \" + p, 6, opts.getRegwidth());\n        assertNotNull(f + \" long defaults: \" + p, opts.getHasher());\n      }\n\n      // non defaults: lower/upper accuracy bounds should give min/max log2m & adjusted regwidth\n      HllOptions optsMin = HllOptions.parseHllOptions(params(\"cardinality\",\"0\"), field);\n      assertEquals(f + \" min log2m\", HLL.MINIMUM_LOG2M_PARAM, optsMin.getLog2m());\n      assertEquals(f + \" min regwidth\", 5, optsMin.getRegwidth()); // lowest hueristic for 64bit\n\n      HllOptions optsMax = HllOptions.parseHllOptions(params(\"cardinality\",\"1\"), field);\n      assertEquals(f + \" max log2m\", HLL.MAXIMUM_LOG2M_PARAM, optsMax.getLog2m());\n      assertEquals(f + \" max regwidth\", HLL.MAXIMUM_REGWIDTH_PARAM, optsMax.getRegwidth());\n\n    }\n\n    // all of these should produce equivalent HLLOptions (Int, Float, or ValueSource using defaults)\n    SolrParams[] intDefaultParams = new SolrParams[] {\n      // basic usage\n      params(\"cardinality\",\"true\"),\n      params(\"cardinality\",\"0.33\"),\n\n      // expert level options\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\"), \n      params(\"cardinality\",\"true\", \"hllRegwidth\",\"5\"), \n      params(\"cardinality\",\"true\", \"hllPreHash\",\"false\"),\n      params(\"cardinality\",\"true\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"5\", \"hllPreHash\", \"false\"),\n\n      // explicit hllLog2M & hllRegwidth should override hueristic float arg\n      params(\"cardinality\",\"1.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"5\"),\n      params(\"cardinality\",\"0.0\", \"hllLog2m\",\"13\", \"hllRegwidth\",\"5\", \"hllPreHash\",\"false\")\n    };\n    for (SchemaField field : new SchemaField[] { field_i, field_f, field_severity, null }) {\n      final String f = null == field ? \"(func)\" : field.getName();\n      for (SolrParams p : intDefaultParams) {\n        HllOptions opts = HllOptions.parseHllOptions(p, field);\n        assertEquals(f + \" int defaults: \" + p, 13, opts.getLog2m());\n        assertEquals(f + \" int defaults: \" + p, 5, opts.getRegwidth());\n        assertNotNull(f + \" int defaults: \" + p, opts.getHasher());\n      }\n\n      // non defaults: lower/upper accuracy bounds should give min/max log2m & adjusted regwidth\n      HllOptions optsMin = HllOptions.parseHllOptions(params(\"cardinality\",\"0\"), field);\n      assertEquals(f + \" min log2m\", HLL.MINIMUM_LOG2M_PARAM, optsMin.getLog2m());\n      assertEquals(f + \" min regwidth\", 4, optsMin.getRegwidth()); // lowest hueristic for 32bit\n\n      HllOptions optsMax = HllOptions.parseHllOptions(params(\"cardinality\",\"1\"), field);\n      assertEquals(f + \" max log2m\", HLL.MAXIMUM_LOG2M_PARAM, optsMax.getLog2m());\n      assertEquals(f + \" max regwidth\", HLL.MAXIMUM_REGWIDTH_PARAM, optsMax.getRegwidth());\n\n    }\n\n    // basic pre-hashed arg check specifically for long fields\n    assertNotNull(HllOptions.parseHllOptions(params(\"cardinality\",\"true\"), field_l).getHasher());\n    assertNotNull(HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"false\"), \n                                             field_l).getHasher());\n    assertNull(HllOptions.parseHllOptions(params(\"cardinality\",\"true\", \"hllPreHashed\", \"true\"), \n                                          field_l).getHasher());\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1bdc96c0ff14d9b1ac3705697b384dd91eae8056":["9f4251f14d2db68330fc1e6f0495c053a905d560"],"9f4251f14d2db68330fc1e6f0495c053a905d560":["4a4e2c829188fb99886a64558664d79c9ac0fdf1"],"4a4e2c829188fb99886a64558664d79c9ac0fdf1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1bdc96c0ff14d9b1ac3705697b384dd91eae8056"]},"commit2Childs":{"1bdc96c0ff14d9b1ac3705697b384dd91eae8056":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9f4251f14d2db68330fc1e6f0495c053a905d560":["1bdc96c0ff14d9b1ac3705697b384dd91eae8056"],"4a4e2c829188fb99886a64558664d79c9ac0fdf1":["9f4251f14d2db68330fc1e6f0495c053a905d560"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4a4e2c829188fb99886a64558664d79c9ac0fdf1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}