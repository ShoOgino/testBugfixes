{"path":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","commits":[{"id":"59ce67ef5584d0d65a576a6bbe06322cc84eb9b0","date":1412077943,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Build a {@link DocIdSet} that contains all doc ids that have been added.\n   * This method may return <tt>null</tt> if no documents were addded to this\n   * builder.\n   * NOTE: this is a destructive operation, the builder should not be used\n   * anymore after this method has been called.\n   */\n  public DocIdSet build() {\n    final DocIdSet result = denseSet != null ? denseSet : sparseSet;\n    denseSet = null;\n    sparseSet = null;\n    costUpperBound = 0;\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9a47902d6207303f5ed3e7aaca62ca33433af66","date":1412435312,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Build a {@link DocIdSet} that contains all doc ids that have been added.\n   * This method may return <tt>null</tt> if no documents were addded to this\n   * builder.\n   * NOTE: this is a destructive operation, the builder should not be used\n   * anymore after this method has been called.\n   */\n  public DocIdSet build() {\n    final DocIdSet result = denseSet != null ? denseSet : sparseSet;\n    denseSet = null;\n    sparseSet = null;\n    costUpperBound = 0;\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80c55596a764e2d397e982828e75fcac5ce430a0","date":1413987559,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","sourceNew":"  /**\n   * Build a {@link DocIdSet} that contains all doc ids that have been added.\n   * This method may return <tt>null</tt> if no documents were addded to this\n   * builder.\n   * NOTE: this is a destructive operation, the builder should not be used\n   * anymore after this method has been called.\n   */\n  public DocIdSet build() {\n    final DocIdSet result;\n    if (denseSet != null) {\n      result = new FixedBitDocIdSet(denseSet, denseSet.cardinality());\n    } else if (sparseSet != null) {\n      result = new SparseFixedBitDocIdSet(sparseSet, sparseSet.approximateCardinality());\n    } else {\n      result = null;\n    }\n    denseSet = null;\n    sparseSet = null;\n    costUpperBound = 0;\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Build a {@link DocIdSet} that contains all doc ids that have been added.\n   * This method may return <tt>null</tt> if no documents were addded to this\n   * builder.\n   * NOTE: this is a destructive operation, the builder should not be used\n   * anymore after this method has been called.\n   */\n  public DocIdSet build() {\n    final DocIdSet result = denseSet != null ? denseSet : sparseSet;\n    denseSet = null;\n    sparseSet = null;\n    costUpperBound = 0;\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e","date":1414135939,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","sourceNew":"  /**\n   * Build a {@link DocIdSet} that contains all doc ids that have been added.\n   * This method may return <tt>null</tt> if no documents were addded to this\n   * builder.\n   * NOTE: this is a destructive operation, the builder should not be used\n   * anymore after this method has been called.\n   */\n  public DocIdSet build() {\n    final DocIdSet result;\n    if (denseSet != null) {\n      result = new BitDocIdSet(denseSet);\n    } else if (sparseSet != null) {\n      result = new BitDocIdSet(sparseSet);\n    } else {\n      result = null;\n    }\n    denseSet = null;\n    sparseSet = null;\n    costUpperBound = 0;\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Build a {@link DocIdSet} that contains all doc ids that have been added.\n   * This method may return <tt>null</tt> if no documents were addded to this\n   * builder.\n   * NOTE: this is a destructive operation, the builder should not be used\n   * anymore after this method has been called.\n   */\n  public DocIdSet build() {\n    final DocIdSet result;\n    if (denseSet != null) {\n      result = new FixedBitDocIdSet(denseSet, denseSet.cardinality());\n    } else if (sparseSet != null) {\n      result = new SparseFixedBitDocIdSet(sparseSet, sparseSet.approximateCardinality());\n    } else {\n      result = null;\n    }\n    denseSet = null;\n    sparseSet = null;\n    costUpperBound = 0;\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b012914a8110b2ff1d075ed1ef72aa57084d4897","date":1414685177,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","sourceNew":null,"sourceOld":"  /**\n   * Build a {@link DocIdSet} that contains all doc ids that have been added.\n   * This method may return <tt>null</tt> if no documents were addded to this\n   * builder.\n   * NOTE: this is a destructive operation, the builder should not be used\n   * anymore after this method has been called.\n   */\n  public DocIdSet build() {\n    final DocIdSet result;\n    if (denseSet != null) {\n      result = new BitDocIdSet(denseSet);\n    } else if (sparseSet != null) {\n      result = new BitDocIdSet(sparseSet);\n    } else {\n      result = null;\n    }\n    denseSet = null;\n    sparseSet = null;\n    costUpperBound = 0;\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e91a2d9ed80172872da0f517870da6756289554","date":1436431140,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    return build(-1);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b63007489248c99b5cdc766ce55938891f5d969","date":1456737032,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","sourceNew":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    try {\n      if (bitSet != null) {\n        return new BitDocIdSet(bitSet);\n      } else {\n        LSBRadixSorter sorter = new LSBRadixSorter();\n        sorter.sort(buffer, 0, bufferSize);\n        final int l = dedup(buffer, bufferSize);\n        assert l <= bufferSize;\n        buffer = ArrayUtil.grow(buffer, l + 1);\n        buffer[l] = DocIdSetIterator.NO_MORE_DOCS;\n        return new IntArrayDocIdSet(buffer, l);\n      }\n    } finally {\n      this.buffer = null;\n      this.bufferSize = 0;\n      this.bitSet = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    return build(-1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","sourceNew":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    try {\n      if (bitSet != null) {\n        return new BitDocIdSet(bitSet);\n      } else {\n        LSBRadixSorter sorter = new LSBRadixSorter();\n        sorter.sort(buffer, 0, bufferSize);\n        final int l = dedup(buffer, bufferSize);\n        assert l <= bufferSize;\n        buffer = ArrayUtil.grow(buffer, l + 1);\n        buffer[l] = DocIdSetIterator.NO_MORE_DOCS;\n        return new IntArrayDocIdSet(buffer, l);\n      }\n    } finally {\n      this.buffer = null;\n      this.bufferSize = 0;\n      this.bitSet = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    return build(-1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f8ac9e4a1f2a93ec9acbeb9da9bae9bc5d582c6","date":1461860441,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","sourceNew":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    try {\n      if (bitSet != null) {\n        return new BitDocIdSet(bitSet);\n      } else {\n        LSBRadixSorter sorter = new LSBRadixSorter();\n        sorter.sort(PackedInts.bitsRequired(maxDoc - 1), buffer, bufferSize);\n        final int l = dedup(buffer, bufferSize);\n        assert l <= bufferSize;\n        buffer = ArrayUtil.grow(buffer, l + 1);\n        buffer[l] = DocIdSetIterator.NO_MORE_DOCS;\n        return new IntArrayDocIdSet(buffer, l);\n      }\n    } finally {\n      this.buffer = null;\n      this.bufferSize = 0;\n      this.bitSet = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    try {\n      if (bitSet != null) {\n        return new BitDocIdSet(bitSet);\n      } else {\n        LSBRadixSorter sorter = new LSBRadixSorter();\n        sorter.sort(buffer, 0, bufferSize);\n        final int l = dedup(buffer, bufferSize);\n        assert l <= bufferSize;\n        buffer = ArrayUtil.grow(buffer, l + 1);\n        buffer[l] = DocIdSetIterator.NO_MORE_DOCS;\n        return new IntArrayDocIdSet(buffer, l);\n      }\n    } finally {\n      this.buffer = null;\n      this.bufferSize = 0;\n      this.bitSet = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9ee4c03e3ee986704eeeb45c571d001905a6430","date":1462194267,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","sourceNew":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    try {\n      if (bitSet != null) {\n        assert counter >= 0;\n        final long cost = Math.round(counter / numValuesPerDoc);\n        return new BitDocIdSet(bitSet, cost);\n      } else {\n        LSBRadixSorter sorter = new LSBRadixSorter();\n        sorter.sort(PackedInts.bitsRequired(maxDoc - 1), buffer, bufferSize);\n        final int l;\n        if (multivalued) {\n          l = dedup(buffer, bufferSize);\n        } else {\n          assert noDups(buffer, bufferSize);\n          l = bufferSize;\n        }\n        assert l <= bufferSize;\n        buffer = ArrayUtil.grow(buffer, l + 1);\n        buffer[l] = DocIdSetIterator.NO_MORE_DOCS;\n        return new IntArrayDocIdSet(buffer, l);\n      }\n    } finally {\n      this.buffer = null;\n      this.bufferSize = 0;\n      this.bitSet = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    try {\n      if (bitSet != null) {\n        return new BitDocIdSet(bitSet);\n      } else {\n        LSBRadixSorter sorter = new LSBRadixSorter();\n        sorter.sort(PackedInts.bitsRequired(maxDoc - 1), buffer, bufferSize);\n        final int l = dedup(buffer, bufferSize);\n        assert l <= bufferSize;\n        buffer = ArrayUtil.grow(buffer, l + 1);\n        buffer[l] = DocIdSetIterator.NO_MORE_DOCS;\n        return new IntArrayDocIdSet(buffer, l);\n      }\n    } finally {\n      this.buffer = null;\n      this.bufferSize = 0;\n      this.bitSet = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30540ec27130887a9372c159e8fe971200f37727","date":1462223109,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","sourceNew":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    try {\n      if (bitSet != null) {\n        assert counter >= 0;\n        final long cost = Math.round(counter / numValuesPerDoc);\n        return new BitDocIdSet(bitSet, cost);\n      } else {\n        LSBRadixSorter sorter = new LSBRadixSorter();\n        sorter.sort(PackedInts.bitsRequired(maxDoc - 1), buffer, bufferSize);\n        final int l;\n        if (multivalued) {\n          l = dedup(buffer, bufferSize);\n        } else {\n          assert noDups(buffer, bufferSize);\n          l = bufferSize;\n        }\n        assert l <= bufferSize;\n        buffer = ArrayUtil.grow(buffer, l + 1);\n        buffer[l] = DocIdSetIterator.NO_MORE_DOCS;\n        return new IntArrayDocIdSet(buffer, l);\n      }\n    } finally {\n      this.buffer = null;\n      this.bufferSize = 0;\n      this.bitSet = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    try {\n      if (bitSet != null) {\n        return new BitDocIdSet(bitSet);\n      } else {\n        LSBRadixSorter sorter = new LSBRadixSorter();\n        sorter.sort(PackedInts.bitsRequired(maxDoc - 1), buffer, bufferSize);\n        final int l = dedup(buffer, bufferSize);\n        assert l <= bufferSize;\n        buffer = ArrayUtil.grow(buffer, l + 1);\n        buffer[l] = DocIdSetIterator.NO_MORE_DOCS;\n        return new IntArrayDocIdSet(buffer, l);\n      }\n    } finally {\n      this.buffer = null;\n      this.bufferSize = 0;\n      this.bitSet = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","sourceNew":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    try {\n      if (bitSet != null) {\n        assert counter >= 0;\n        final long cost = Math.round(counter / numValuesPerDoc);\n        return new BitDocIdSet(bitSet, cost);\n      } else {\n        LSBRadixSorter sorter = new LSBRadixSorter();\n        sorter.sort(PackedInts.bitsRequired(maxDoc - 1), buffer, bufferSize);\n        final int l;\n        if (multivalued) {\n          l = dedup(buffer, bufferSize);\n        } else {\n          assert noDups(buffer, bufferSize);\n          l = bufferSize;\n        }\n        assert l <= bufferSize;\n        buffer = ArrayUtil.grow(buffer, l + 1);\n        buffer[l] = DocIdSetIterator.NO_MORE_DOCS;\n        return new IntArrayDocIdSet(buffer, l);\n      }\n    } finally {\n      this.buffer = null;\n      this.bufferSize = 0;\n      this.bitSet = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    try {\n      if (bitSet != null) {\n        return new BitDocIdSet(bitSet);\n      } else {\n        LSBRadixSorter sorter = new LSBRadixSorter();\n        sorter.sort(buffer, 0, bufferSize);\n        final int l = dedup(buffer, bufferSize);\n        assert l <= bufferSize;\n        buffer = ArrayUtil.grow(buffer, l + 1);\n        buffer[l] = DocIdSetIterator.NO_MORE_DOCS;\n        return new IntArrayDocIdSet(buffer, l);\n      }\n    } finally {\n      this.buffer = null;\n      this.bufferSize = 0;\n      this.bitSet = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9cb92b52940b86bd2ad151ecc61b2f5e83af1a5e","date":1463988431,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","sourceNew":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    try {\n      if (bitSet != null) {\n        assert counter >= 0;\n        final long cost = Math.round(counter / numValuesPerDoc);\n        return new BitDocIdSet(bitSet, cost);\n      } else {\n        Buffer concatenated = concat(buffers);\n        LSBRadixSorter sorter = new LSBRadixSorter();\n        sorter.sort(PackedInts.bitsRequired(maxDoc - 1), concatenated.array, concatenated.length);\n        final int l;\n        if (multivalued) {\n          l = dedup(concatenated.array, concatenated.length);\n        } else {\n          assert noDups(concatenated.array, concatenated.length);\n          l = concatenated.length;\n        }\n        assert l <= concatenated.length;\n        concatenated.array[l] = DocIdSetIterator.NO_MORE_DOCS;\n        return new IntArrayDocIdSet(concatenated.array, l);\n      }\n    } finally {\n      this.buffers = null;\n      this.bitSet = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    try {\n      if (bitSet != null) {\n        assert counter >= 0;\n        final long cost = Math.round(counter / numValuesPerDoc);\n        return new BitDocIdSet(bitSet, cost);\n      } else {\n        LSBRadixSorter sorter = new LSBRadixSorter();\n        sorter.sort(PackedInts.bitsRequired(maxDoc - 1), buffer, bufferSize);\n        final int l;\n        if (multivalued) {\n          l = dedup(buffer, bufferSize);\n        } else {\n          assert noDups(buffer, bufferSize);\n          l = bufferSize;\n        }\n        assert l <= bufferSize;\n        buffer = ArrayUtil.grow(buffer, l + 1);\n        buffer[l] = DocIdSetIterator.NO_MORE_DOCS;\n        return new IntArrayDocIdSet(buffer, l);\n      }\n    } finally {\n      this.buffer = null;\n      this.bufferSize = 0;\n      this.bitSet = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e616cfbf284ecbd0f40b4b9e4196daa27e92abd5","date":1464066565,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","sourceNew":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    try {\n      if (bitSet != null) {\n        assert counter >= 0;\n        final long cost = Math.round(counter / numValuesPerDoc);\n        return new BitDocIdSet(bitSet, cost);\n      } else {\n        Buffer concatenated = concat(buffers);\n        LSBRadixSorter sorter = new LSBRadixSorter();\n        sorter.sort(PackedInts.bitsRequired(maxDoc - 1), concatenated.array, concatenated.length);\n        final int l;\n        if (multivalued) {\n          l = dedup(concatenated.array, concatenated.length);\n        } else {\n          assert noDups(concatenated.array, concatenated.length);\n          l = concatenated.length;\n        }\n        assert l <= concatenated.length;\n        concatenated.array[l] = DocIdSetIterator.NO_MORE_DOCS;\n        return new IntArrayDocIdSet(concatenated.array, l);\n      }\n    } finally {\n      this.buffers = null;\n      this.bitSet = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    try {\n      if (bitSet != null) {\n        assert counter >= 0;\n        final long cost = Math.round(counter / numValuesPerDoc);\n        return new BitDocIdSet(bitSet, cost);\n      } else {\n        LSBRadixSorter sorter = new LSBRadixSorter();\n        sorter.sort(PackedInts.bitsRequired(maxDoc - 1), buffer, bufferSize);\n        final int l;\n        if (multivalued) {\n          l = dedup(buffer, bufferSize);\n        } else {\n          assert noDups(buffer, bufferSize);\n          l = bufferSize;\n        }\n        assert l <= bufferSize;\n        buffer = ArrayUtil.grow(buffer, l + 1);\n        buffer[l] = DocIdSetIterator.NO_MORE_DOCS;\n        return new IntArrayDocIdSet(buffer, l);\n      }\n    } finally {\n      this.buffer = null;\n      this.bufferSize = 0;\n      this.bitSet = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder#build().mjava","sourceNew":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    try {\n      if (bitSet != null) {\n        assert counter >= 0;\n        final long cost = Math.round(counter / numValuesPerDoc);\n        return new BitDocIdSet(bitSet, cost);\n      } else {\n        Buffer concatenated = concat(buffers);\n        LSBRadixSorter sorter = new LSBRadixSorter();\n        sorter.sort(PackedInts.bitsRequired(maxDoc - 1), concatenated.array, concatenated.length);\n        final int l;\n        if (multivalued) {\n          l = dedup(concatenated.array, concatenated.length);\n        } else {\n          assert noDups(concatenated.array, concatenated.length);\n          l = concatenated.length;\n        }\n        assert l <= concatenated.length;\n        concatenated.array[l] = DocIdSetIterator.NO_MORE_DOCS;\n        return new IntArrayDocIdSet(concatenated.array, l);\n      }\n    } finally {\n      this.buffers = null;\n      this.bitSet = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Build a {@link DocIdSet} from the accumulated doc IDs.\n   */\n  public DocIdSet build() {\n    try {\n      if (bitSet != null) {\n        assert counter >= 0;\n        final long cost = Math.round(counter / numValuesPerDoc);\n        return new BitDocIdSet(bitSet, cost);\n      } else {\n        LSBRadixSorter sorter = new LSBRadixSorter();\n        sorter.sort(PackedInts.bitsRequired(maxDoc - 1), buffer, bufferSize);\n        final int l;\n        if (multivalued) {\n          l = dedup(buffer, bufferSize);\n        } else {\n          assert noDups(buffer, bufferSize);\n          l = bufferSize;\n        }\n        assert l <= bufferSize;\n        buffer = ArrayUtil.grow(buffer, l + 1);\n        buffer[l] = DocIdSetIterator.NO_MORE_DOCS;\n        return new IntArrayDocIdSet(buffer, l);\n      }\n    } finally {\n      this.buffer = null;\n      this.bufferSize = 0;\n      this.bitSet = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["0e91a2d9ed80172872da0f517870da6756289554","2b63007489248c99b5cdc766ce55938891f5d969"],"9cb92b52940b86bd2ad151ecc61b2f5e83af1a5e":["30540ec27130887a9372c159e8fe971200f37727"],"b012914a8110b2ff1d075ed1ef72aa57084d4897":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"5f8ac9e4a1f2a93ec9acbeb9da9bae9bc5d582c6":["af2638813028b254a88b418ebeafb541afb49653"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","59ce67ef5584d0d65a576a6bbe06322cc84eb9b0"],"30540ec27130887a9372c159e8fe971200f37727":["5f8ac9e4a1f2a93ec9acbeb9da9bae9bc5d582c6","c9ee4c03e3ee986704eeeb45c571d001905a6430"],"59ce67ef5584d0d65a576a6bbe06322cc84eb9b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["55b50463286869f584cf849d1587a0fcd54d1dfa","e616cfbf284ecbd0f40b4b9e4196daa27e92abd5"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["af2638813028b254a88b418ebeafb541afb49653","30540ec27130887a9372c159e8fe971200f37727"],"c9ee4c03e3ee986704eeeb45c571d001905a6430":["5f8ac9e4a1f2a93ec9acbeb9da9bae9bc5d582c6"],"0e91a2d9ed80172872da0f517870da6756289554":["b012914a8110b2ff1d075ed1ef72aa57084d4897"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2b63007489248c99b5cdc766ce55938891f5d969":["0e91a2d9ed80172872da0f517870da6756289554"],"80c55596a764e2d397e982828e75fcac5ce430a0":["59ce67ef5584d0d65a576a6bbe06322cc84eb9b0"],"e616cfbf284ecbd0f40b4b9e4196daa27e92abd5":["30540ec27130887a9372c159e8fe971200f37727","9cb92b52940b86bd2ad151ecc61b2f5e83af1a5e"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["80c55596a764e2d397e982828e75fcac5ce430a0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e616cfbf284ecbd0f40b4b9e4196daa27e92abd5"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["5f8ac9e4a1f2a93ec9acbeb9da9bae9bc5d582c6","55b50463286869f584cf849d1587a0fcd54d1dfa"],"9cb92b52940b86bd2ad151ecc61b2f5e83af1a5e":["e616cfbf284ecbd0f40b4b9e4196daa27e92abd5"],"b012914a8110b2ff1d075ed1ef72aa57084d4897":["0e91a2d9ed80172872da0f517870da6756289554"],"5f8ac9e4a1f2a93ec9acbeb9da9bae9bc5d582c6":["30540ec27130887a9372c159e8fe971200f37727","c9ee4c03e3ee986704eeeb45c571d001905a6430"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":[],"30540ec27130887a9372c159e8fe971200f37727":["9cb92b52940b86bd2ad151ecc61b2f5e83af1a5e","55b50463286869f584cf849d1587a0fcd54d1dfa","e616cfbf284ecbd0f40b4b9e4196daa27e92abd5"],"59ce67ef5584d0d65a576a6bbe06322cc84eb9b0":["d9a47902d6207303f5ed3e7aaca62ca33433af66","80c55596a764e2d397e982828e75fcac5ce430a0"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"c9ee4c03e3ee986704eeeb45c571d001905a6430":["30540ec27130887a9372c159e8fe971200f37727"],"0e91a2d9ed80172872da0f517870da6756289554":["af2638813028b254a88b418ebeafb541afb49653","2b63007489248c99b5cdc766ce55938891f5d969"],"2b63007489248c99b5cdc766ce55938891f5d969":["af2638813028b254a88b418ebeafb541afb49653"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d9a47902d6207303f5ed3e7aaca62ca33433af66","59ce67ef5584d0d65a576a6bbe06322cc84eb9b0"],"80c55596a764e2d397e982828e75fcac5ce430a0":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"e616cfbf284ecbd0f40b4b9e4196daa27e92abd5":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["b012914a8110b2ff1d075ed1ef72aa57084d4897"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d9a47902d6207303f5ed3e7aaca62ca33433af66","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}