{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/CreateAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results)\n      throws Exception {\n    final String aliasName = message.getStr(NAME);\n    final List<String> canonicalCollectionList = parseCollectionsParameter(message.get(\"collections\"));\n    final String canonicalCollectionsString = StrUtils.join(canonicalCollectionList, ',');\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    validateAllCollectionsExistAndNoDups(canonicalCollectionList, zkStateReader);\n\n    zkStateReader.aliasesHolder.applyModificationAndExportToZk(aliases -> aliases.cloneWithCollectionAlias(aliasName, canonicalCollectionsString));\n\n    // Sleep a bit to allow ZooKeeper state propagation.\n    //\n    // THIS IS A KLUDGE.\n    //\n    // Solr's view of the cluster is eventually consistent. *Eventually* all nodes and CloudSolrClients will be aware of\n    // alias changes, but not immediately. If a newly created alias is queried, things should work right away since Solr\n    // will attempt to see if it needs to get the latest aliases when it can't otherwise resolve the name.  However\n    // modifications to an alias will take some time.\n    //\n    // We could levy this requirement on the client but they would probably always add an obligatory sleep, which is\n    // just kicking the can down the road.  Perhaps ideally at this juncture here we could somehow wait until all\n    // Solr nodes in the cluster have the latest aliases?\n    Thread.sleep(100);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results)\n      throws Exception {\n    final String aliasName = message.getStr(NAME);\n    final List<String> canonicalCollectionList = parseCollectionsParameter(message.get(\"collections\"));\n    final String canonicalCollectionsString = StrUtils.join(canonicalCollectionList, ',');\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    validateAllCollectionsExistAndNoDups(canonicalCollectionList, zkStateReader);\n\n    zkStateReader.aliasesHolder.applyModificationAndExportToZk(aliases -> aliases.cloneWithCollectionAlias(aliasName, canonicalCollectionsString));\n\n    // Sleep a bit to allow ZooKeeper state propagation.\n    //\n    // THIS IS A KLUDGE.\n    //\n    // Solr's view of the cluster is eventually consistent. *Eventually* all nodes and CloudSolrClients will be aware of\n    // alias changes, but not immediately. If a newly created alias is queried, things should work right away since Solr\n    // will attempt to see if it needs to get the latest aliases when it can't otherwise resolve the name.  However\n    // modifications to an alias will take some time.\n    //\n    // We could levy this requirement on the client but they would probably always add an obligatory sleep, which is\n    // just kicking the can down the road.  Perhaps ideally at this juncture here we could somehow wait until all\n    // Solr nodes in the cluster have the latest aliases?\n    Thread.sleep(100);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/CreateAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results)\n      throws Exception {\n    final String aliasName = message.getStr(NAME);\n    final List<String> canonicalCollectionList = parseCollectionsParameter(message.get(\"collections\"));\n    final String canonicalCollectionsString = StrUtils.join(canonicalCollectionList, ',');\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    validateAllCollectionsExistAndNoDups(canonicalCollectionList, zkStateReader);\n\n    zkStateReader.aliasesHolder.applyModificationAndExportToZk(aliases -> aliases.cloneWithCollectionAlias(aliasName, canonicalCollectionsString));\n\n    // Sleep a bit to allow ZooKeeper state propagation.\n    //\n    // THIS IS A KLUDGE.\n    //\n    // Solr's view of the cluster is eventually consistent. *Eventually* all nodes and CloudSolrClients will be aware of\n    // alias changes, but not immediately. If a newly created alias is queried, things should work right away since Solr\n    // will attempt to see if it needs to get the latest aliases when it can't otherwise resolve the name.  However\n    // modifications to an alias will take some time.\n    //\n    // We could levy this requirement on the client but they would probably always add an obligatory sleep, which is\n    // just kicking the can down the road.  Perhaps ideally at this juncture here we could somehow wait until all\n    // Solr nodes in the cluster have the latest aliases?\n    Thread.sleep(100);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results)\n      throws Exception {\n    final String aliasName = message.getStr(NAME);\n    final List<String> canonicalCollectionList = parseCollectionsParameter(message.get(\"collections\"));\n    final String canonicalCollectionsString = StrUtils.join(canonicalCollectionList, ',');\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    validateAllCollectionsExistAndNoDups(canonicalCollectionList, zkStateReader);\n\n    zkStateReader.aliasesHolder.applyModificationAndExportToZk(aliases -> aliases.cloneWithCollectionAlias(aliasName, canonicalCollectionsString));\n\n    // Sleep a bit to allow ZooKeeper state propagation.\n    //\n    // THIS IS A KLUDGE.\n    //\n    // Solr's view of the cluster is eventually consistent. *Eventually* all nodes and CloudSolrClients will be aware of\n    // alias changes, but not immediately. If a newly created alias is queried, things should work right away since Solr\n    // will attempt to see if it needs to get the latest aliases when it can't otherwise resolve the name.  However\n    // modifications to an alias will take some time.\n    //\n    // We could levy this requirement on the client but they would probably always add an obligatory sleep, which is\n    // just kicking the can down the road.  Perhaps ideally at this juncture here we could somehow wait until all\n    // Solr nodes in the cluster have the latest aliases?\n    Thread.sleep(100);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6857f8205f8c5b4ff39a54d8aebb4fdfb7cfb691","date":1516909549,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results)\n      throws Exception {\n    final String aliasName = message.getStr(CommonParams.NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ZkStateReader.AliasesManager holder = zkStateReader.aliasesHolder;\n\n    //TODO refactor callCreatePlainAlias\n    if (!anyRoutingParams(message)) {\n\n      final List<String> canonicalCollectionList = parseCollectionsParameter(message.get(\"collections\"));\n      final String canonicalCollectionsString = StrUtils.join(canonicalCollectionList, ',');\n      validateAllCollectionsExistAndNoDups(canonicalCollectionList, zkStateReader);\n      holder.applyModificationAndExportToZk(aliases -> aliases.cloneWithCollectionAlias(aliasName, canonicalCollectionsString));\n\n    } else { //TODO refactor callCreateRoutedAlias\n\n      // Validate we got everything we need\n      if (!message.getProperties().keySet().containsAll(REQUIRED_ROUTER_PARAMS)) {\n        throw new SolrException(BAD_REQUEST, \"A routed alias requires these params: \" + REQUIRED_ROUTER_PARAMS\n        + \" plus some create-collection prefixed ones.\");\n      }\n\n      Map<String, String> aliasMetadata = new LinkedHashMap<>();\n      message.getProperties().entrySet().stream()\n          .filter(entry -> PARAM_IS_METADATA.test(entry.getKey()))\n          .forEach(entry -> aliasMetadata.put(entry.getKey(), (String) entry.getValue()));\n\n      //TODO read these from metadata where appropriate. This leads to consistent logic between initial routed alias\n      //  collection creation, and subsequent collections to be created.\n\n      final String routingType = message.getStr(ROUTER_TYPE);\n      final String tz = message.getStr(TZ);\n      final String start = message.getStr(ROUTER_START);\n      final String increment = message.getStr(ROUTER_INCREMENT);\n      final String maxFutureMs = message.getStr(ROUTER_MAX_FUTURE);\n\n      try {\n        if (maxFutureMs != null && 0 > Long.parseLong(maxFutureMs)) {\n          throw new NumberFormatException(\"Negative value not allowed here\");\n        }\n      } catch (NumberFormatException e) {\n        throw new SolrException(BAD_REQUEST, ROUTER_MAX_FUTURE + \" must be a valid long integer representing a number \" +\n            \"of milliseconds greater than or equal to zero\");\n      }\n\n      if (!\"time\".equals(routingType)) {\n        throw new SolrException(BAD_REQUEST, \"Only time based routing is supported at this time\");\n      }\n\n      // Check for invalid timezone\n      TimeZone zone = TimeZoneUtils.parseTimezone(tz);\n\n      // check that the increment is valid date math\n      try {\n        new DateMathParser(zone).parseMath(increment);\n      } catch (ParseException e) {\n        throw new SolrException(BAD_REQUEST,e.getMessage(),e);\n      }\n\n      Instant startTime = parseStart(start, zone);\n\n      // It's too much work to check the routed field against the schema, there seems to be no good way to get\n      // a copy of the schema aside from loading it directly from zookeeper based on the config name, but that\n      // also requires I load solrconfig.xml to check what the value for managedSchemaResourceName is too, (or\n      // discover that managed schema is not turned on and read schema.xml instead... and check for dynamic\n      // field patterns too. As much as it would be nice to validate all inputs it's not worth the effort.\n\n      String initialCollectionName = TimeRoutedAliasUpdateProcessor\n          .formatCollectionNameFromInstant(aliasName, startTime);\n\n      // Create the collection\n      NamedList createResults = new NamedList();\n      RoutedAliasCreateCollectionCmd.createCollectionAndWait(state, createResults, aliasName, aliasMetadata, initialCollectionName, ocmh);\n      validateAllCollectionsExistAndNoDups(Collections.singletonList(initialCollectionName), zkStateReader);\n\n      // Create/update the alias\n      holder.applyModificationAndExportToZk(aliases -> aliases\n          .cloneWithCollectionAlias(aliasName, initialCollectionName)\n          .cloneWithCollectionAliasMetadata(aliasName, aliasMetadata));\n    }\n\n    // Sleep a bit to allow ZooKeeper state propagation.\n    //\n    // THIS IS A KLUDGE.\n    //\n    // Solr's view of the cluster is eventually consistent. *Eventually* all nodes and CloudSolrClients will be aware of\n    // alias changes, but not immediately. If a newly created alias is queried, things should work right away since Solr\n    // will attempt to see if it needs to get the latest aliases when it can't otherwise resolve the name.  However\n    // modifications to an alias will take some time.\n    //\n    // We could levy this requirement on the client but they would probably always add an obligatory sleep, which is\n    // just kicking the can down the road.  Perhaps ideally at this juncture here we could somehow wait until all\n    // Solr nodes in the cluster have the latest aliases?\n    Thread.sleep(100);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results)\n      throws Exception {\n    final String aliasName = message.getStr(NAME);\n    final List<String> canonicalCollectionList = parseCollectionsParameter(message.get(\"collections\"));\n    final String canonicalCollectionsString = StrUtils.join(canonicalCollectionList, ',');\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    validateAllCollectionsExistAndNoDups(canonicalCollectionList, zkStateReader);\n\n    zkStateReader.aliasesHolder.applyModificationAndExportToZk(aliases -> aliases.cloneWithCollectionAlias(aliasName, canonicalCollectionsString));\n\n    // Sleep a bit to allow ZooKeeper state propagation.\n    //\n    // THIS IS A KLUDGE.\n    //\n    // Solr's view of the cluster is eventually consistent. *Eventually* all nodes and CloudSolrClients will be aware of\n    // alias changes, but not immediately. If a newly created alias is queried, things should work right away since Solr\n    // will attempt to see if it needs to get the latest aliases when it can't otherwise resolve the name.  However\n    // modifications to an alias will take some time.\n    //\n    // We could levy this requirement on the client but they would probably always add an obligatory sleep, which is\n    // just kicking the can down the road.  Perhaps ideally at this juncture here we could somehow wait until all\n    // Solr nodes in the cluster have the latest aliases?\n    Thread.sleep(100);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46589ed5cc841861bf6b5e2afc55f718ebcd02a0","date":1516984620,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results)\n      throws Exception {\n    final String aliasName = message.getStr(CommonParams.NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (!anyRoutingParams(message)) {\n      callCreatePlainAlias(message, aliasName, zkStateReader);\n    } else {\n      callCreateRoutedAlias(message, aliasName, zkStateReader, state);\n    }\n\n    // Sleep a bit to allow ZooKeeper state propagation.\n    //\n    // THIS IS A KLUDGE.\n    //\n    // Solr's view of the cluster is eventually consistent. *Eventually* all nodes and CloudSolrClients will be aware of\n    // alias changes, but not immediately. If a newly created alias is queried, things should work right away since Solr\n    // will attempt to see if it needs to get the latest aliases when it can't otherwise resolve the name.  However\n    // modifications to an alias will take some time.\n    //\n    // We could levy this requirement on the client but they would probably always add an obligatory sleep, which is\n    // just kicking the can down the road.  Perhaps ideally at this juncture here we could somehow wait until all\n    // Solr nodes in the cluster have the latest aliases?\n    Thread.sleep(100);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results)\n      throws Exception {\n    final String aliasName = message.getStr(CommonParams.NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ZkStateReader.AliasesManager holder = zkStateReader.aliasesHolder;\n\n    //TODO refactor callCreatePlainAlias\n    if (!anyRoutingParams(message)) {\n\n      final List<String> canonicalCollectionList = parseCollectionsParameter(message.get(\"collections\"));\n      final String canonicalCollectionsString = StrUtils.join(canonicalCollectionList, ',');\n      validateAllCollectionsExistAndNoDups(canonicalCollectionList, zkStateReader);\n      holder.applyModificationAndExportToZk(aliases -> aliases.cloneWithCollectionAlias(aliasName, canonicalCollectionsString));\n\n    } else { //TODO refactor callCreateRoutedAlias\n\n      // Validate we got everything we need\n      if (!message.getProperties().keySet().containsAll(REQUIRED_ROUTER_PARAMS)) {\n        throw new SolrException(BAD_REQUEST, \"A routed alias requires these params: \" + REQUIRED_ROUTER_PARAMS\n        + \" plus some create-collection prefixed ones.\");\n      }\n\n      Map<String, String> aliasMetadata = new LinkedHashMap<>();\n      message.getProperties().entrySet().stream()\n          .filter(entry -> PARAM_IS_METADATA.test(entry.getKey()))\n          .forEach(entry -> aliasMetadata.put(entry.getKey(), (String) entry.getValue()));\n\n      //TODO read these from metadata where appropriate. This leads to consistent logic between initial routed alias\n      //  collection creation, and subsequent collections to be created.\n\n      final String routingType = message.getStr(ROUTER_TYPE);\n      final String tz = message.getStr(TZ);\n      final String start = message.getStr(ROUTER_START);\n      final String increment = message.getStr(ROUTER_INCREMENT);\n      final String maxFutureMs = message.getStr(ROUTER_MAX_FUTURE);\n\n      try {\n        if (maxFutureMs != null && 0 > Long.parseLong(maxFutureMs)) {\n          throw new NumberFormatException(\"Negative value not allowed here\");\n        }\n      } catch (NumberFormatException e) {\n        throw new SolrException(BAD_REQUEST, ROUTER_MAX_FUTURE + \" must be a valid long integer representing a number \" +\n            \"of milliseconds greater than or equal to zero\");\n      }\n\n      if (!\"time\".equals(routingType)) {\n        throw new SolrException(BAD_REQUEST, \"Only time based routing is supported at this time\");\n      }\n\n      // Check for invalid timezone\n      TimeZone zone = TimeZoneUtils.parseTimezone(tz);\n\n      // check that the increment is valid date math\n      try {\n        new DateMathParser(zone).parseMath(increment);\n      } catch (ParseException e) {\n        throw new SolrException(BAD_REQUEST,e.getMessage(),e);\n      }\n\n      Instant startTime = parseStart(start, zone);\n\n      // It's too much work to check the routed field against the schema, there seems to be no good way to get\n      // a copy of the schema aside from loading it directly from zookeeper based on the config name, but that\n      // also requires I load solrconfig.xml to check what the value for managedSchemaResourceName is too, (or\n      // discover that managed schema is not turned on and read schema.xml instead... and check for dynamic\n      // field patterns too. As much as it would be nice to validate all inputs it's not worth the effort.\n\n      String initialCollectionName = TimeRoutedAliasUpdateProcessor\n          .formatCollectionNameFromInstant(aliasName, startTime);\n\n      // Create the collection\n      NamedList createResults = new NamedList();\n      RoutedAliasCreateCollectionCmd.createCollectionAndWait(state, createResults, aliasName, aliasMetadata, initialCollectionName, ocmh);\n      validateAllCollectionsExistAndNoDups(Collections.singletonList(initialCollectionName), zkStateReader);\n\n      // Create/update the alias\n      holder.applyModificationAndExportToZk(aliases -> aliases\n          .cloneWithCollectionAlias(aliasName, initialCollectionName)\n          .cloneWithCollectionAliasMetadata(aliasName, aliasMetadata));\n    }\n\n    // Sleep a bit to allow ZooKeeper state propagation.\n    //\n    // THIS IS A KLUDGE.\n    //\n    // Solr's view of the cluster is eventually consistent. *Eventually* all nodes and CloudSolrClients will be aware of\n    // alias changes, but not immediately. If a newly created alias is queried, things should work right away since Solr\n    // will attempt to see if it needs to get the latest aliases when it can't otherwise resolve the name.  However\n    // modifications to an alias will take some time.\n    //\n    // We could levy this requirement on the client but they would probably always add an obligatory sleep, which is\n    // just kicking the can down the road.  Perhaps ideally at this juncture here we could somehow wait until all\n    // Solr nodes in the cluster have the latest aliases?\n    Thread.sleep(100);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59bad1cc1e7f90125a140496e79b06afcedb68ec","date":1554915399,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results)\n      throws Exception {\n    final String aliasName = message.getStr(CommonParams.NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    // make sure we have the latest version of existing aliases\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update();\n    }\n\n    if (!anyRoutingParams(message)) {\n      callCreatePlainAlias(message, aliasName, zkStateReader);\n    } else {\n      callCreateRoutedAlias(message, aliasName, zkStateReader, state);\n    }\n\n    // Sleep a bit to allow ZooKeeper state propagation.\n    //\n    // THIS IS A KLUDGE.\n    //\n    // Solr's view of the cluster is eventually consistent. *Eventually* all nodes and CloudSolrClients will be aware of\n    // alias changes, but not immediately. If a newly created alias is queried, things should work right away since Solr\n    // will attempt to see if it needs to get the latest aliases when it can't otherwise resolve the name.  However\n    // modifications to an alias will take some time.\n    //\n    // We could levy this requirement on the client but they would probably always add an obligatory sleep, which is\n    // just kicking the can down the road.  Perhaps ideally at this juncture here we could somehow wait until all\n    // Solr nodes in the cluster have the latest aliases?\n    Thread.sleep(100);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results)\n      throws Exception {\n    final String aliasName = message.getStr(CommonParams.NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (!anyRoutingParams(message)) {\n      callCreatePlainAlias(message, aliasName, zkStateReader);\n    } else {\n      callCreateRoutedAlias(message, aliasName, zkStateReader, state);\n    }\n\n    // Sleep a bit to allow ZooKeeper state propagation.\n    //\n    // THIS IS A KLUDGE.\n    //\n    // Solr's view of the cluster is eventually consistent. *Eventually* all nodes and CloudSolrClients will be aware of\n    // alias changes, but not immediately. If a newly created alias is queried, things should work right away since Solr\n    // will attempt to see if it needs to get the latest aliases when it can't otherwise resolve the name.  However\n    // modifications to an alias will take some time.\n    //\n    // We could levy this requirement on the client but they would probably always add an obligatory sleep, which is\n    // just kicking the can down the road.  Perhaps ideally at this juncture here we could somehow wait until all\n    // Solr nodes in the cluster have the latest aliases?\n    Thread.sleep(100);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86968c6cf51846df861b8f29bd85b6d9a7c9f19c","date":1591481497,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results)\n      throws Exception {\n    final String aliasName = message.getStr(CommonParams.NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    // make sure we have the latest version of existing aliases\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update();\n    }\n\n    if (!anyRoutingParams(message)) {\n      callCreatePlainAlias(message, aliasName, zkStateReader);\n    } else {\n      callCreateRoutedAlias(message, aliasName, zkStateReader, state);\n    }\n\n    // Sleep a bit to allow ZooKeeper state propagation.\n    //\n    // THIS IS A KLUDGE.\n    //\n    // Solr's view of the cluster is eventually consistent. *Eventually* all nodes and CloudSolrClients will be aware of\n    // alias changes, but not immediately. If a newly created alias is queried, things should work right away since Solr\n    // will attempt to see if it needs to get the latest aliases when it can't otherwise resolve the name.  However\n    // modifications to an alias will take some time.\n    //\n    // We could levy this requirement on the client but they would probably always add an obligatory sleep, which is\n    // just kicking the can down the road.  Perhaps ideally at this juncture here we could somehow wait until all\n    // Solr nodes in the cluster have the latest aliases?\n    Thread.sleep(100);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results)\n      throws Exception {\n    final String aliasName = message.getStr(CommonParams.NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    // make sure we have the latest version of existing aliases\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update();\n    }\n\n    if (!anyRoutingParams(message)) {\n      callCreatePlainAlias(message, aliasName, zkStateReader);\n    } else {\n      callCreateRoutedAlias(message, aliasName, zkStateReader, state);\n    }\n\n    // Sleep a bit to allow ZooKeeper state propagation.\n    //\n    // THIS IS A KLUDGE.\n    //\n    // Solr's view of the cluster is eventually consistent. *Eventually* all nodes and CloudSolrClients will be aware of\n    // alias changes, but not immediately. If a newly created alias is queried, things should work right away since Solr\n    // will attempt to see if it needs to get the latest aliases when it can't otherwise resolve the name.  However\n    // modifications to an alias will take some time.\n    //\n    // We could levy this requirement on the client but they would probably always add an obligatory sleep, which is\n    // just kicking the can down the road.  Perhaps ideally at this juncture here we could somehow wait until all\n    // Solr nodes in the cluster have the latest aliases?\n    Thread.sleep(100);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results)\n      throws Exception {\n    final String aliasName = message.getStr(CommonParams.NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    // make sure we have the latest version of existing aliases\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update();\n    }\n\n    if (!anyRoutingParams(message)) {\n      callCreatePlainAlias(message, aliasName, zkStateReader);\n    } else {\n      callCreateRoutedAlias(message, aliasName, zkStateReader, state, cloudConfig);\n    }\n\n    // Sleep a bit to allow ZooKeeper state propagation.\n    //\n    // THIS IS A KLUDGE.\n    //\n    // Solr's view of the cluster is eventually consistent. *Eventually* all nodes and CloudSolrClients will be aware of\n    // alias changes, but not immediately. If a newly created alias is queried, things should work right away since Solr\n    // will attempt to see if it needs to get the latest aliases when it can't otherwise resolve the name.  However\n    // modifications to an alias will take some time.\n    //\n    // We could levy this requirement on the client but they would probably always add an obligatory sleep, which is\n    // just kicking the can down the road.  Perhaps ideally at this juncture here we could somehow wait until all\n    // Solr nodes in the cluster have the latest aliases?\n    Thread.sleep(100);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results)\n      throws Exception {\n    final String aliasName = message.getStr(CommonParams.NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    // make sure we have the latest version of existing aliases\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update();\n    }\n\n    if (!anyRoutingParams(message)) {\n      callCreatePlainAlias(message, aliasName, zkStateReader);\n    } else {\n      callCreateRoutedAlias(message, aliasName, zkStateReader, state);\n    }\n\n    // Sleep a bit to allow ZooKeeper state propagation.\n    //\n    // THIS IS A KLUDGE.\n    //\n    // Solr's view of the cluster is eventually consistent. *Eventually* all nodes and CloudSolrClients will be aware of\n    // alias changes, but not immediately. If a newly created alias is queried, things should work right away since Solr\n    // will attempt to see if it needs to get the latest aliases when it can't otherwise resolve the name.  However\n    // modifications to an alias will take some time.\n    //\n    // We could levy this requirement on the client but they would probably always add an obligatory sleep, which is\n    // just kicking the can down the road.  Perhaps ideally at this juncture here we could somehow wait until all\n    // Solr nodes in the cluster have the latest aliases?\n    Thread.sleep(100);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateAliasCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results)\n      throws Exception {\n    final String aliasName = message.getStr(CommonParams.NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    // make sure we have the latest version of existing aliases\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update();\n    }\n\n    if (!anyRoutingParams(message)) {\n      callCreatePlainAlias(message, aliasName, zkStateReader);\n    } else {\n      callCreateRoutedAlias(message, aliasName, zkStateReader, state);\n    }\n\n    // Sleep a bit to allow ZooKeeper state propagation.\n    //\n    // THIS IS A KLUDGE.\n    //\n    // Solr's view of the cluster is eventually consistent. *Eventually* all nodes and CloudSolrClients will be aware of\n    // alias changes, but not immediately. If a newly created alias is queried, things should work right away since Solr\n    // will attempt to see if it needs to get the latest aliases when it can't otherwise resolve the name.  However\n    // modifications to an alias will take some time.\n    //\n    // We could levy this requirement on the client but they would probably always add an obligatory sleep, which is\n    // just kicking the can down the road.  Perhaps ideally at this juncture here we could somehow wait until all\n    // Solr nodes in the cluster have the latest aliases?\n    Thread.sleep(100);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results)\n      throws Exception {\n    final String aliasName = message.getStr(CommonParams.NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    // make sure we have the latest version of existing aliases\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update();\n    }\n\n    if (!anyRoutingParams(message)) {\n      callCreatePlainAlias(message, aliasName, zkStateReader);\n    } else {\n      callCreateRoutedAlias(message, aliasName, zkStateReader, state, cloudConfig);\n    }\n\n    // Sleep a bit to allow ZooKeeper state propagation.\n    //\n    // THIS IS A KLUDGE.\n    //\n    // Solr's view of the cluster is eventually consistent. *Eventually* all nodes and CloudSolrClients will be aware of\n    // alias changes, but not immediately. If a newly created alias is queried, things should work right away since Solr\n    // will attempt to see if it needs to get the latest aliases when it can't otherwise resolve the name.  However\n    // modifications to an alias will take some time.\n    //\n    // We could levy this requirement on the client but they would probably always add an obligatory sleep, which is\n    // just kicking the can down the road.  Perhaps ideally at this juncture here we could somehow wait until all\n    // Solr nodes in the cluster have the latest aliases?\n    Thread.sleep(100);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"46589ed5cc841861bf6b5e2afc55f718ebcd02a0":["6857f8205f8c5b4ff39a54d8aebb4fdfb7cfb691"],"c526352db87264a72a7a9ad68c1b769b81e54305":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["59bad1cc1e7f90125a140496e79b06afcedb68ec"],"59bad1cc1e7f90125a140496e79b06afcedb68ec":["46589ed5cc841861bf6b5e2afc55f718ebcd02a0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6857f8205f8c5b4ff39a54d8aebb4fdfb7cfb691":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b94236357aaa22b76c10629851fe4e376e0cea82":["6857f8205f8c5b4ff39a54d8aebb4fdfb7cfb691"],"46589ed5cc841861bf6b5e2afc55f718ebcd02a0":["59bad1cc1e7f90125a140496e79b06afcedb68ec"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["c526352db87264a72a7a9ad68c1b769b81e54305"],"59bad1cc1e7f90125a140496e79b06afcedb68ec":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"6857f8205f8c5b4ff39a54d8aebb4fdfb7cfb691":["46589ed5cc841861bf6b5e2afc55f718ebcd02a0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}