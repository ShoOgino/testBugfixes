{"path":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","commits":[{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":1,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication().mjava","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList slaveConfig = new NamedList();\n      slaveConfig.add(\"fetchFromLeader\", true);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList replicationConfig = new NamedList();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":"  public void startReplication() throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n\n      NamedList slaveConfig = new NamedList();\n      slaveConfig.add(\"fetchFromLeader\", true);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList replicationConfig = new NamedList();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n        if (pollSuccess) {\n          String commitVersion = getCommitVersion(core);\n          if (commitVersion == null) return;\n          if (Long.parseLong(commitVersion) == lastVersion) return;\n          UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n          cuc.setVersion(Long.parseLong(commitVersion));\n          updateLog.copyOverOldUpdates(cuc);\n          lastVersion = Long.parseLong(commitVersion);\n        }\n      });\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList slaveConfig = new NamedList();\n      slaveConfig.add(\"fetchFromLeader\", true);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList replicationConfig = new NamedList();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2cd6ce5cb3daa68675db8981b4f038717c06b94b","date":1496794921,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList slaveConfig = new NamedList();\n      slaveConfig.add(\"fetchFromLeader\", true);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList replicationConfig = new NamedList();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f344bb33ca91f48e99c061980115b46fa84fc8f5","date":1496903283,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList slaveConfig = new NamedList();\n      slaveConfig.add(\"fetchFromLeader\", true);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList replicationConfig = new NamedList();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList slaveConfig = new NamedList();\n      slaveConfig.add(\"fetchFromLeader\", true);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList replicationConfig = new NamedList();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList slaveConfig = new NamedList();\n      slaveConfig.add(\"fetchFromLeader\", true);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList replicationConfig = new NamedList();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73","date":1504185139,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","date":1504848000,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04ecf884544ff74add5faa452748f160c4af904b","date":1506527215,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, switchTransactionLog);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, fetchResult) -> {\n          if (fetchResult == IndexFetcher.IndexFetchResult.INDEX_FETCH_SUCCESS) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","bugFix":["61c45e99cf6676da48f19d7511c73712ad39402b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, switchTransactionLog);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, fetchResult) -> {\n          if (fetchResult == IndexFetcher.IndexFetchResult.INDEX_FETCH_SUCCESS) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, pollSuccess) -> {\n          if (pollSuccess) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1455c941cc4ce652efc776fc23471b0e499246f6","date":1528086751,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, switchTransactionLog);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, fetchResult) -> {\n          if (fetchResult == IndexFetcher.IndexFetchResult.INDEX_FETCH_SUCCESS) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.commitAndSwitchToNewTlog(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, switchTransactionLog);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, fetchResult) -> {\n          if (fetchResult == IndexFetcher.IndexFetchResult.INDEX_FETCH_SUCCESS) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, switchTransactionLog);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, fetchResult) -> {\n          if (fetchResult == IndexFetcher.IndexFetchResult.INDEX_FETCH_SUCCESS) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.commitAndSwitchToNewTlog(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, switchTransactionLog);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, fetchResult) -> {\n          if (fetchResult == IndexFetcher.IndexFetchResult.INDEX_FETCH_SUCCESS) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, switchTransactionLog);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, fetchResult) -> {\n          if (fetchResult == IndexFetcher.IndexFetchResult.INDEX_FETCH_SUCCESS) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.commitAndSwitchToNewTlog(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, switchTransactionLog);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, fetchResult) -> {\n          if (fetchResult == IndexFetcher.IndexFetchResult.INDEX_FETCH_SUCCESS) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.copyOverOldUpdates(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      log.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, switchTransactionLog);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, fetchResult) -> {\n          if (fetchResult == IndexFetcher.IndexFetchResult.INDEX_FETCH_SUCCESS) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.commitAndSwitchToNewTlog(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      LOG.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, switchTransactionLog);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, fetchResult) -> {\n          if (fetchResult == IndexFetcher.IndexFetchResult.INDEX_FETCH_SUCCESS) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.commitAndSwitchToNewTlog(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab85e957e6a6ff40d8dd4f42932789cd24fc8a62","date":1541503153,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (System.getProperty(\"jetty.testMode\") != null) {\n        pollIntervalStr = \"00:00:01\";\n      }\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      log.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, switchTransactionLog);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, fetchResult) -> {\n          if (fetchResult == IndexFetcher.IndexFetchResult.INDEX_FETCH_SUCCESS) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.commitAndSwitchToNewTlog(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      log.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, switchTransactionLog);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, fetchResult) -> {\n          if (fetchResult == IndexFetcher.IndexFetchResult.INDEX_FETCH_SUCCESS) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.commitAndSwitchToNewTlog(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e","date":1596664368,"type":3,"author":"Marcus","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplicateFromLeader#startReplication(boolean).mjava","sourceNew":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (System.getProperty(\"jetty.testMode\") != null) {\n        pollIntervalStr = \"00:00:01\";\n      }\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      log.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> followerConfig = new NamedList<>();\n      followerConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      followerConfig.add(ReplicationHandler.SKIP_COMMIT_ON_LEADER_VERSION_ZERO, switchTransactionLog);\n      followerConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"follower\", followerConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, fetchResult) -> {\n          if (fetchResult == IndexFetcher.IndexFetchResult.INDEX_FETCH_SUCCESS) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.commitAndSwitchToNewTlog(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","sourceOld":"  /**\n   * Start a replication handler thread that will periodically pull indices from the shard leader\n   * @param switchTransactionLog if true, ReplicationHandler will rotate the transaction log once\n   * the replication is done\n   */\n  public void startReplication(boolean switchTransactionLog) throws InterruptedException {\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      SolrConfig.UpdateHandlerInfo uinfo = core.getSolrConfig().getUpdateHandlerInfo();\n      String pollIntervalStr = \"00:00:03\";\n      if (System.getProperty(\"jetty.testMode\") != null) {\n        pollIntervalStr = \"00:00:01\";\n      }\n      if (uinfo.autoCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoCommmitMaxTime/2);\n      } else if (uinfo.autoSoftCommmitMaxTime != -1) {\n        pollIntervalStr = toPollIntervalStr(uinfo.autoSoftCommmitMaxTime/2);\n      }\n      log.info(\"Will start replication from leader with poll interval: {}\", pollIntervalStr );\n\n      NamedList<Object> slaveConfig = new NamedList<>();\n      slaveConfig.add(\"fetchFromLeader\", Boolean.TRUE);\n      slaveConfig.add(ReplicationHandler.SKIP_COMMIT_ON_MASTER_VERSION_ZERO, switchTransactionLog);\n      slaveConfig.add(\"pollInterval\", pollIntervalStr);\n      NamedList<Object> replicationConfig = new NamedList<>();\n      replicationConfig.add(\"slave\", slaveConfig);\n\n      String lastCommitVersion = getCommitVersion(core);\n      if (lastCommitVersion != null) {\n        lastVersion = Long.parseLong(lastCommitVersion);\n      }\n\n      replicationProcess = new ReplicationHandler();\n      if (switchTransactionLog) {\n        replicationProcess.setPollListener((solrCore, fetchResult) -> {\n          if (fetchResult == IndexFetcher.IndexFetchResult.INDEX_FETCH_SUCCESS) {\n            String commitVersion = getCommitVersion(core);\n            if (commitVersion == null) return;\n            if (Long.parseLong(commitVersion) == lastVersion) return;\n            UpdateLog updateLog = solrCore.getUpdateHandler().getUpdateLog();\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);\n            cuc.setVersion(Long.parseLong(commitVersion));\n            updateLog.commitAndSwitchToNewTlog(cuc);\n            lastVersion = Long.parseLong(commitVersion);\n          }\n        });\n      }\n      replicationProcess.init(replicationConfig);\n      replicationProcess.inform(core);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"04ecf884544ff74add5faa452748f160c4af904b":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["ab85e957e6a6ff40d8dd4f42932789cd24fc8a62"],"61c45e99cf6676da48f19d7511c73712ad39402b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2cd6ce5cb3daa68675db8981b4f038717c06b94b":["61c45e99cf6676da48f19d7511c73712ad39402b"],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["61c45e99cf6676da48f19d7511c73712ad39402b","2cd6ce5cb3daa68675db8981b4f038717c06b94b"],"28288370235ed02234a64753cdbf0c6ec096304a":["61c45e99cf6676da48f19d7511c73712ad39402b","f344bb33ca91f48e99c061980115b46fa84fc8f5"],"1455c941cc4ce652efc776fc23471b0e499246f6":["04ecf884544ff74add5faa452748f160c4af904b"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","61c45e99cf6676da48f19d7511c73712ad39402b"],"ab85e957e6a6ff40d8dd4f42932789cd24fc8a62":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["28288370235ed02234a64753cdbf0c6ec096304a","f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","04ecf884544ff74add5faa452748f160c4af904b"],"f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73":["28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["04ecf884544ff74add5faa452748f160c4af904b","1455c941cc4ce652efc776fc23471b0e499246f6"],"f592209545c71895260367152601e9200399776d":["04ecf884544ff74add5faa452748f160c4af904b","1455c941cc4ce652efc776fc23471b0e499246f6"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["e9017cf144952056066919f1ebc7897ff9bd71b1","f344bb33ca91f48e99c061980115b46fa84fc8f5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["1455c941cc4ce652efc776fc23471b0e499246f6"]},"commit2Childs":{"04ecf884544ff74add5faa452748f160c4af904b":["1455c941cc4ce652efc776fc23471b0e499246f6","6240b74b884c5587f2a4062dd27d6c32bf228889","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"61c45e99cf6676da48f19d7511c73712ad39402b":["2cd6ce5cb3daa68675db8981b4f038717c06b94b","f344bb33ca91f48e99c061980115b46fa84fc8f5","28288370235ed02234a64753cdbf0c6ec096304a","e9017cf144952056066919f1ebc7897ff9bd71b1"],"2cd6ce5cb3daa68675db8981b4f038717c06b94b":["f344bb33ca91f48e99c061980115b46fa84fc8f5"],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"28288370235ed02234a64753cdbf0c6ec096304a":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73"],"1455c941cc4ce652efc776fc23471b0e499246f6":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"ab85e957e6a6ff40d8dd4f42932789cd24fc8a62":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["04ecf884544ff74add5faa452748f160c4af904b"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["6240b74b884c5587f2a4062dd27d6c32bf228889"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["61c45e99cf6676da48f19d7511c73712ad39402b","e9017cf144952056066919f1ebc7897ff9bd71b1"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"f592209545c71895260367152601e9200399776d":[],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["ab85e957e6a6ff40d8dd4f42932789cd24fc8a62"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6240b74b884c5587f2a4062dd27d6c32bf228889","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}