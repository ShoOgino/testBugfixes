{"path":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#acceptsSuffixRange(int,int,int).mjava","commits":[{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#acceptsSuffixRange(int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns true if, from this state, the automaton accepts any suffix\n   *  starting with a label between start and end, inclusive.  We just\n   *  look for a transition, matching this range, to the sink state.  */\n  private boolean acceptsSuffixRange(int state, int start, int end) {\n\n    //xif (DEBUG) System.out.println(\"    acceptsSuffixRange state=\" + state + \" start=\" + start + \" end=\" + end);\n\n    int count = automaton.initTransition(state, transition);\n    //xif (DEBUG) System.out.println(\"      transCount=\" + count);\n    //xif (DEBUG) System.out.println(\"      trans=\" + transition);\n    for(int i=0;i<count;i++) {\n      automaton.getNextTransition(transition);\n      if (start >= transition.min && end <= transition.max && transition.dest == sinkState) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#acceptsSuffixRange(int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns true if, from this state, the automaton accepts any suffix\n   *  starting with a label between start and end, inclusive.  We just\n   *  look for a transition, matching this range, to the sink state.  */\n  private boolean acceptsSuffixRange(int state, int start, int end) {\n\n    //xif (DEBUG) System.out.println(\"    acceptsSuffixRange state=\" + state + \" start=\" + start + \" end=\" + end);\n\n    int count = automaton.initTransition(state, transition);\n    //xif (DEBUG) System.out.println(\"      transCount=\" + count);\n    //xif (DEBUG) System.out.println(\"      trans=\" + transition);\n    for(int i=0;i<count;i++) {\n      automaton.getNextTransition(transition);\n      if (start >= transition.min && end <= transition.max && transition.dest == sinkState) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59db5e5f780185e0155d296a323e440a6ecfd3b6","date":1435089559,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#acceptsSuffixRange(int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#acceptsSuffixRange(int,int,int).mjava","sourceNew":"  /** Returns true if, from this state, the automaton accepts any suffix\n   *  starting with a label between start and end, inclusive.  We just\n   *  look for a transition, matching this range, to the sink state.  */\n  private boolean acceptsSuffixRange(int state, int start, int end) {\n\n    int count = automaton.initTransition(state, scratchTransition);\n    for(int i=0;i<count;i++) {\n      automaton.getNextTransition(scratchTransition);\n      if (start >= scratchTransition.min && end <= scratchTransition.max && scratchTransition.dest == sinkState) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":"  /** Returns true if, from this state, the automaton accepts any suffix\n   *  starting with a label between start and end, inclusive.  We just\n   *  look for a transition, matching this range, to the sink state.  */\n  private boolean acceptsSuffixRange(int state, int start, int end) {\n\n    //xif (DEBUG) System.out.println(\"    acceptsSuffixRange state=\" + state + \" start=\" + start + \" end=\" + end);\n\n    int count = automaton.initTransition(state, transition);\n    //xif (DEBUG) System.out.println(\"      transCount=\" + count);\n    //xif (DEBUG) System.out.println(\"      trans=\" + transition);\n    for(int i=0;i<count;i++) {\n      automaton.getNextTransition(transition);\n      if (start >= transition.min && end <= transition.max && transition.dest == sinkState) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd96a930cc08d72beee719cc11ce465b9d9861c3","date":1535640296,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#acceptsSuffixRange(int,int,int).mjava","sourceNew":null,"sourceOld":"  /** Returns true if, from this state, the automaton accepts any suffix\n   *  starting with a label between start and end, inclusive.  We just\n   *  look for a transition, matching this range, to the sink state.  */\n  private boolean acceptsSuffixRange(int state, int start, int end) {\n\n    int count = automaton.initTransition(state, scratchTransition);\n    for(int i=0;i<count;i++) {\n      automaton.getNextTransition(scratchTransition);\n      if (start >= scratchTransition.min && end <= scratchTransition.max && scratchTransition.dest == sinkState) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"59db5e5f780185e0155d296a323e440a6ecfd3b6":["3e8715d826e588419327562287d5d6a8040d63d6"],"dd96a930cc08d72beee719cc11ce465b9d9861c3":["59db5e5f780185e0155d296a323e440a6ecfd3b6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3e8715d826e588419327562287d5d6a8040d63d6"],"3e8715d826e588419327562287d5d6a8040d63d6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dd96a930cc08d72beee719cc11ce465b9d9861c3"]},"commit2Childs":{"59db5e5f780185e0155d296a323e440a6ecfd3b6":["dd96a930cc08d72beee719cc11ce465b9d9861c3"],"dd96a930cc08d72beee719cc11ce465b9d9861c3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"3e8715d826e588419327562287d5d6a8040d63d6":["59db5e5f780185e0155d296a323e440a6ecfd3b6","d2638f781be724518ff6c2263d14a48cf6e68017"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}