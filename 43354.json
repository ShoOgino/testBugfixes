{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer#blockUntilFinished().mjava","commits":[{"id":"7321b77a7bc3edfebd637ef273e9dfaa9969eba6","date":1333023097,"type":1,"author":"Sami Siren","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer#blockUntilFinished().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer#blockUntilFinished().mjava","sourceNew":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      // Wait until no runners are running\n      for (;;) {\n        Runner runner;\n        synchronized (runners) {\n          runner = runners.peek();\n        }\n        if (runner == null)\n          break;\n        runner.runnerLock.lock();\n        runner.runnerLock.unlock();\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","sourceOld":"  public synchronized void blockUntilFinished()\n  {\n    lock = new CountDownLatch(1);\n    try {\n      // Wait until no runners are running\n      for(;;) {\n        Runner runner;\n        synchronized(runners) {\n          runner = runners.peek();\n        }\n        if (runner == null) break;\n        runner.runnerLock.lock();\n        runner.runnerLock.unlock();\n      }\n    } finally {\n      lock.countDown();\n      lock=null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44794c238f06be24c86aaea35a3666b679ef267d","date":1388343498,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer#blockUntilFinished().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer#blockUntilFinished().mjava","sourceNew":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      // Wait until no runners are running\n      for (;;) {\n        Runner runner;\n        synchronized (runners) {\n          runner = runners.peek();\n        }\n        if (runner == null || scheduler.isTerminated())\n          break;\n        runner.runnerLock.lock();\n        runner.runnerLock.unlock();\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","sourceOld":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      // Wait until no runners are running\n      for (;;) {\n        Runner runner;\n        synchronized (runners) {\n          runner = runners.peek();\n        }\n        if (runner == null)\n          break;\n        runner.runnerLock.lock();\n        runner.runnerLock.unlock();\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","bugFix":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2f264dc5db69d2c5c548e800516f98687049ebd1","date":1389923321,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer#blockUntilFinished().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer#blockUntilFinished().mjava","sourceNew":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      // Wait until no runners are running\n      for (;;) {\n        Runner runner;\n        synchronized (runners) {\n          runner = runners.peek();\n        }\n\n        if ((runner == null && queue.isEmpty()) || scheduler.isTerminated())\n          break;\n        runner.runnerLock.lock();\n        runner.runnerLock.unlock();\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","sourceOld":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      // Wait until no runners are running\n      for (;;) {\n        Runner runner;\n        synchronized (runners) {\n          runner = runners.peek();\n        }\n        if (runner == null || scheduler.isTerminated())\n          break;\n        runner.runnerLock.lock();\n        runner.runnerLock.unlock();\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":["945902ae43d8dd7e920418efe36981403c2ee669"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a66541589b120eadd6d744f9f8927c729247ffa7","date":1389924391,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer#blockUntilFinished().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer#blockUntilFinished().mjava","sourceNew":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      // Wait until no runners are running\n      for (;;) {\n        Runner runner;\n        synchronized (runners) {\n          runner = runners.peek();\n        }\n\n        if ((runner == null && queue.isEmpty()) || scheduler.isTerminated())\n          break;\n        \n        if (runner != null) {\n          runner.runnerLock.lock();\n          runner.runnerLock.unlock();\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","sourceOld":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      // Wait until no runners are running\n      for (;;) {\n        Runner runner;\n        synchronized (runners) {\n          runner = runners.peek();\n        }\n\n        if ((runner == null && queue.isEmpty()) || scheduler.isTerminated())\n          break;\n        runner.runnerLock.lock();\n        runner.runnerLock.unlock();\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":["945902ae43d8dd7e920418efe36981403c2ee669"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"638f4e5d45967696943a94868eeb184f9f0c4b8e","date":1389926186,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer#blockUntilFinished().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer#blockUntilFinished().mjava","sourceNew":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      // Wait until no runners are running\n      for (;;) {\n        Runner runner;\n        synchronized (runners) {\n          runner = runners.peek();\n        }\n\n        if ((runner == null && queue.isEmpty()) || scheduler.isTerminated())\n          break;\n        \n        if (runner != null) {\n          runner.runnerLock.lock();\n          runner.runnerLock.unlock();\n        } else if (!queue.isEmpty()) {\n          Runner r = new Runner();\n          runners.add(r);\n          scheduler.execute(r);\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","sourceOld":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      // Wait until no runners are running\n      for (;;) {\n        Runner runner;\n        synchronized (runners) {\n          runner = runners.peek();\n        }\n\n        if ((runner == null && queue.isEmpty()) || scheduler.isTerminated())\n          break;\n        \n        if (runner != null) {\n          runner.runnerLock.lock();\n          runner.runnerLock.unlock();\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":["945902ae43d8dd7e920418efe36981403c2ee669"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1ed88f2d1f6a64c8b31ace51541448a0b2f29606","date":1390186799,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer#blockUntilFinished().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer#blockUntilFinished().mjava","sourceNew":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      // Wait until no runners are running\n      for (;;) {\n        Runner runner;\n        synchronized (runners) {\n          runner = runners.peek();\n        }\n\n        if ((runner == null && queue.isEmpty()) || scheduler.isTerminated())\n          break;\n        \n        if (runner != null) {\n          runner.runnerLock.lock();\n          runner.runnerLock.unlock();\n        } else if (!queue.isEmpty()) {\n          // failsafe - should not be necessary, but a good\n          // precaution to ensure blockUntilFinished guarantees\n          // all updates are emptied from the queue regardless of\n          // any bugs around starting or retaining runners\n          Runner r = new Runner();\n          runners.add(r);\n          scheduler.execute(r);\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","sourceOld":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      // Wait until no runners are running\n      for (;;) {\n        Runner runner;\n        synchronized (runners) {\n          runner = runners.peek();\n        }\n\n        if ((runner == null && queue.isEmpty()) || scheduler.isTerminated())\n          break;\n        \n        if (runner != null) {\n          runner.runnerLock.lock();\n          runner.runnerLock.unlock();\n        } else if (!queue.isEmpty()) {\n          Runner r = new Runner();\n          runners.add(r);\n          scheduler.execute(r);\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":["945902ae43d8dd7e920418efe36981403c2ee669"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"945902ae43d8dd7e920418efe36981403c2ee669","date":1405459741,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer#blockUntilFinished().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer#blockUntilFinished().mjava","sourceNew":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      synchronized (runners) {\n        while (!runners.isEmpty()) {\n          try {\n            runners.wait();\n          } catch (InterruptedException e) {\n            Thread.interrupted();\n          }\n          \n          if (scheduler.isTerminated())\n            break;\n                      \n          // if we reach here, then we probably got the notifyAll, but need to check if\n          // the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          if (queueSize > 0) {\n            log.warn(\"No more runners, but queue still has \"+\n              queueSize+\" adding more runners to process remaining requests on queue\");\n            Runner r = new Runner();\n            runners.add(r);\n            scheduler.execute(r);\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","sourceOld":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      // Wait until no runners are running\n      for (;;) {\n        Runner runner;\n        synchronized (runners) {\n          runner = runners.peek();\n        }\n\n        if ((runner == null && queue.isEmpty()) || scheduler.isTerminated())\n          break;\n        \n        if (runner != null) {\n          runner.runnerLock.lock();\n          runner.runnerLock.unlock();\n        } else if (!queue.isEmpty()) {\n          // failsafe - should not be necessary, but a good\n          // precaution to ensure blockUntilFinished guarantees\n          // all updates are emptied from the queue regardless of\n          // any bugs around starting or retaining runners\n          Runner r = new Runner();\n          runners.add(r);\n          scheduler.execute(r);\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","bugFix":["638f4e5d45967696943a94868eeb184f9f0c4b8e","22ee5eab9703d27221d8940a0c284b42ce57676c","e476c9a1973887c9162cf88ca0988d9bfcfcde38","1ed88f2d1f6a64c8b31ace51541448a0b2f29606","2f264dc5db69d2c5c548e800516f98687049ebd1","7321b77a7bc3edfebd637ef273e9dfaa9969eba6","a66541589b120eadd6d744f9f8927c729247ffa7"],"bugIntro":["50e202028300f452744bbd0e537a0f5c0cf044b6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#blockUntilFinished().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer#blockUntilFinished().mjava","sourceNew":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      synchronized (runners) {\n        while (!runners.isEmpty()) {\n          try {\n            runners.wait();\n          } catch (InterruptedException e) {\n            Thread.interrupted();\n          }\n          \n          if (scheduler.isTerminated())\n            break;\n                      \n          // if we reach here, then we probably got the notifyAll, but need to check if\n          // the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          if (queueSize > 0) {\n            log.warn(\"No more runners, but queue still has \"+\n              queueSize+\" adding more runners to process remaining requests on queue\");\n            Runner r = new Runner();\n            runners.add(r);\n            scheduler.execute(r);\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","sourceOld":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n      synchronized (runners) {\n        while (!runners.isEmpty()) {\n          try {\n            runners.wait();\n          } catch (InterruptedException e) {\n            Thread.interrupted();\n          }\n          \n          if (scheduler.isTerminated())\n            break;\n                      \n          // if we reach here, then we probably got the notifyAll, but need to check if\n          // the queue is empty before really considering this is finished (SOLR-4260)\n          int queueSize = queue.size();\n          if (queueSize > 0) {\n            log.warn(\"No more runners, but queue still has \"+\n              queueSize+\" adding more runners to process remaining requests on queue\");\n            Runner r = new Runner();\n            runners.add(r);\n            scheduler.execute(r);\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"44794c238f06be24c86aaea35a3666b679ef267d":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"1ed88f2d1f6a64c8b31ace51541448a0b2f29606":["638f4e5d45967696943a94868eeb184f9f0c4b8e"],"945902ae43d8dd7e920418efe36981403c2ee669":["1ed88f2d1f6a64c8b31ace51541448a0b2f29606"],"a66541589b120eadd6d744f9f8927c729247ffa7":["2f264dc5db69d2c5c548e800516f98687049ebd1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"638f4e5d45967696943a94868eeb184f9f0c4b8e":["a66541589b120eadd6d744f9f8927c729247ffa7"],"bafca15d8e408346a67f4282ad1143b88023893b":["945902ae43d8dd7e920418efe36981403c2ee669"],"2f264dc5db69d2c5c548e800516f98687049ebd1":["44794c238f06be24c86aaea35a3666b679ef267d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bafca15d8e408346a67f4282ad1143b88023893b"]},"commit2Childs":{"44794c238f06be24c86aaea35a3666b679ef267d":["2f264dc5db69d2c5c548e800516f98687049ebd1"],"1ed88f2d1f6a64c8b31ace51541448a0b2f29606":["945902ae43d8dd7e920418efe36981403c2ee669"],"945902ae43d8dd7e920418efe36981403c2ee669":["bafca15d8e408346a67f4282ad1143b88023893b"],"a66541589b120eadd6d744f9f8927c729247ffa7":["638f4e5d45967696943a94868eeb184f9f0c4b8e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["44794c238f06be24c86aaea35a3666b679ef267d"],"638f4e5d45967696943a94868eeb184f9f0c4b8e":["1ed88f2d1f6a64c8b31ace51541448a0b2f29606"],"2f264dc5db69d2c5c548e800516f98687049ebd1":["a66541589b120eadd6d744f9f8927c729247ffa7"],"bafca15d8e408346a67f4282ad1143b88023893b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}