{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPath#done().mjava","commits":[{"id":"b4e444678504caf66a8060b1d514383aa4feac0c","date":1457399659,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPath#done().mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPath#done().mjava","sourceNew":"  /** Complete the path.\n   */\n  public void done() {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() twice\");\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    isDone = true;\n\n    endPoints = new ArrayList<>(points.size());\n    segments = new ArrayList<>(points.size());\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of\n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end);\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      double lat = points.get(0).getLatitude();\n      double lon = points.get(0).getLongitude();\n      // Compute two points on the circle, with the right angle from the center.  We'll use these\n      // to obtain the perpendicular plane to the circle.\n      double upperLat = lat + cutoffAngle;\n      double upperLon = lon;\n      if (upperLat > Math.PI * 0.5) {\n        upperLon += Math.PI;\n        if (upperLon > Math.PI)\n          upperLon -= 2.0 * Math.PI;\n        upperLat = Math.PI - upperLat;\n      }\n      double lowerLat = lat - cutoffAngle;\n      double lowerLon = lon;\n      if (lowerLat < -Math.PI * 0.5) {\n        lowerLon += Math.PI;\n        if (lowerLon > Math.PI)\n          lowerLon -= 2.0 * Math.PI;\n        lowerLat = -Math.PI - lowerLat;\n      }\n      final GeoPoint upperPoint = new GeoPoint(planetModel, upperLat, upperLon);\n      final GeoPoint lowerPoint = new GeoPoint(planetModel, lowerLat, lowerLon);\n      final GeoPoint point = points.get(0);\n      \n      // Construct normal plane\n      final Plane normalPlane = Plane.constructNormalizedZPlane(upperPoint, lowerPoint, point);\n\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(point, normalPlane, upperPoint, lowerPoint);\n      endPoints.add(onlyEndpoint);\n      this.edgePoints = new GeoPoint[]{onlyEndpoint.circlePlane.getSampleIntersectionPoint(planetModel, normalPlane)};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.URHC, currentSegment.ULHC, currentSegment.LLHC);\n      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.ULHC, currentSegment.LLHC, prevSegment.LRHC);\n      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.LLHC, prevSegment.LRHC, prevSegment.URHC);\n      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);\n\n      if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {\n        // The planes are identical.  We wouldn't need a circle at all except for the possibility of\n        // backing up, which is hard to detect here.\n        final SegmentEndpoint midEndpoint = new SegmentEndpoint(currentSegment.start, \n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        //don't need a circle at all.  Special constructor...\n        endPoints.add(midEndpoint);\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC,\n          candidate1, candidate2, candidate3, candidate4));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","sourceOld":"  /** Complete the path.\n   */\n  public void done() {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() twice\");\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    isDone = true;\n\n    endPoints = new ArrayList<>(points.size());\n    segments = new ArrayList<>(points.size());\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of\n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end);\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      double lat = points.get(0).getLatitude();\n      double lon = points.get(0).getLongitude();\n      // Compute two points on the circle, with the right angle from the center.  We'll use these\n      // to obtain the perpendicular plane to the circle.\n      double upperLat = lat + cutoffAngle;\n      double upperLon = lon;\n      if (upperLat > Math.PI * 0.5) {\n        upperLon += Math.PI;\n        if (upperLon > Math.PI)\n          upperLon -= 2.0 * Math.PI;\n        upperLat = Math.PI - upperLat;\n      }\n      double lowerLat = lat - cutoffAngle;\n      double lowerLon = lon;\n      if (lowerLat < -Math.PI * 0.5) {\n        lowerLon += Math.PI;\n        if (lowerLon > Math.PI)\n          lowerLon -= 2.0 * Math.PI;\n        lowerLat = -Math.PI - lowerLat;\n      }\n      final GeoPoint upperPoint = new GeoPoint(planetModel, upperLat, upperLon);\n      final GeoPoint lowerPoint = new GeoPoint(planetModel, lowerLat, lowerLon);\n      final GeoPoint point = points.get(0);\n      \n      // Construct normal plane\n      final Plane normalPlane = Plane.constructNormalizedZPlane(upperPoint, lowerPoint, point);\n\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(point, normalPlane, upperPoint, lowerPoint);\n      endPoints.add(onlyEndpoint);\n      this.edgePoints = new GeoPoint[]{onlyEndpoint.circlePlane.getSampleIntersectionPoint(planetModel, normalPlane)};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.URHC, currentSegment.ULHC, currentSegment.LLHC);\n      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.ULHC, currentSegment.LLHC, prevSegment.LRHC);\n      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.LLHC, prevSegment.LRHC, prevSegment.URHC);\n      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);\n\n      if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {\n        // The planes are identical.  We wouldn't need a circle at all except for the possibility of\n        // backing up, which is hard to detect here.\n        final SegmentEndpoint midEndpoint = new SegmentEndpoint(currentSegment.start, \n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        //don't need a circle at all.  Special constructor...\n        endPoints.add(midEndpoint);\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC,\n          candidate1, candidate2, candidate3, candidate4));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"760628478e121972168791a2afa6af915192c4a6","date":1459842108,"type":5,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoStandardPath#done().mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPath#done().mjava","sourceNew":"  /** Complete the path.\n   */\n  public void done() {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() twice\");\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    isDone = true;\n\n    endPoints = new ArrayList<>(points.size());\n    segments = new ArrayList<>(points.size());\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of\n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end);\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      double lat = points.get(0).getLatitude();\n      double lon = points.get(0).getLongitude();\n      // Compute two points on the circle, with the right angle from the center.  We'll use these\n      // to obtain the perpendicular plane to the circle.\n      double upperLat = lat + cutoffAngle;\n      double upperLon = lon;\n      if (upperLat > Math.PI * 0.5) {\n        upperLon += Math.PI;\n        if (upperLon > Math.PI)\n          upperLon -= 2.0 * Math.PI;\n        upperLat = Math.PI - upperLat;\n      }\n      double lowerLat = lat - cutoffAngle;\n      double lowerLon = lon;\n      if (lowerLat < -Math.PI * 0.5) {\n        lowerLon += Math.PI;\n        if (lowerLon > Math.PI)\n          lowerLon -= 2.0 * Math.PI;\n        lowerLat = -Math.PI - lowerLat;\n      }\n      final GeoPoint upperPoint = new GeoPoint(planetModel, upperLat, upperLon);\n      final GeoPoint lowerPoint = new GeoPoint(planetModel, lowerLat, lowerLon);\n      final GeoPoint point = points.get(0);\n      \n      // Construct normal plane\n      final Plane normalPlane = Plane.constructNormalizedZPlane(upperPoint, lowerPoint, point);\n\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(point, normalPlane, upperPoint, lowerPoint);\n      endPoints.add(onlyEndpoint);\n      this.edgePoints = new GeoPoint[]{onlyEndpoint.circlePlane.getSampleIntersectionPoint(planetModel, normalPlane)};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.URHC, currentSegment.ULHC, currentSegment.LLHC);\n      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.ULHC, currentSegment.LLHC, prevSegment.LRHC);\n      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.LLHC, prevSegment.LRHC, prevSegment.URHC);\n      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);\n\n      if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {\n        // The planes are identical.  We wouldn't need a circle at all except for the possibility of\n        // backing up, which is hard to detect here.\n        final SegmentEndpoint midEndpoint = new SegmentEndpoint(currentSegment.start, \n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        //don't need a circle at all.  Special constructor...\n        endPoints.add(midEndpoint);\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC,\n          candidate1, candidate2, candidate3, candidate4));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","sourceOld":"  /** Complete the path.\n   */\n  public void done() {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() twice\");\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    isDone = true;\n\n    endPoints = new ArrayList<>(points.size());\n    segments = new ArrayList<>(points.size());\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of\n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end);\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      double lat = points.get(0).getLatitude();\n      double lon = points.get(0).getLongitude();\n      // Compute two points on the circle, with the right angle from the center.  We'll use these\n      // to obtain the perpendicular plane to the circle.\n      double upperLat = lat + cutoffAngle;\n      double upperLon = lon;\n      if (upperLat > Math.PI * 0.5) {\n        upperLon += Math.PI;\n        if (upperLon > Math.PI)\n          upperLon -= 2.0 * Math.PI;\n        upperLat = Math.PI - upperLat;\n      }\n      double lowerLat = lat - cutoffAngle;\n      double lowerLon = lon;\n      if (lowerLat < -Math.PI * 0.5) {\n        lowerLon += Math.PI;\n        if (lowerLon > Math.PI)\n          lowerLon -= 2.0 * Math.PI;\n        lowerLat = -Math.PI - lowerLat;\n      }\n      final GeoPoint upperPoint = new GeoPoint(planetModel, upperLat, upperLon);\n      final GeoPoint lowerPoint = new GeoPoint(planetModel, lowerLat, lowerLon);\n      final GeoPoint point = points.get(0);\n      \n      // Construct normal plane\n      final Plane normalPlane = Plane.constructNormalizedZPlane(upperPoint, lowerPoint, point);\n\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(point, normalPlane, upperPoint, lowerPoint);\n      endPoints.add(onlyEndpoint);\n      this.edgePoints = new GeoPoint[]{onlyEndpoint.circlePlane.getSampleIntersectionPoint(planetModel, normalPlane)};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.URHC, currentSegment.ULHC, currentSegment.LLHC);\n      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.ULHC, currentSegment.LLHC, prevSegment.LRHC);\n      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.LLHC, prevSegment.LRHC, prevSegment.URHC);\n      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);\n\n      if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {\n        // The planes are identical.  We wouldn't need a circle at all except for the possibility of\n        // backing up, which is hard to detect here.\n        final SegmentEndpoint midEndpoint = new SegmentEndpoint(currentSegment.start, \n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        //don't need a circle at all.  Special constructor...\n        endPoints.add(midEndpoint);\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC,\n          candidate1, candidate2, candidate3, candidate4));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09af2c9610ce53a4b25fd99344299b40318a4a1a","date":1459876565,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoStandardPath#done().mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPath#done().mjava","sourceNew":"  /** Complete the path.\n   */\n  public void done() {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() twice\");\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    isDone = true;\n\n    endPoints = new ArrayList<>(points.size());\n    segments = new ArrayList<>(points.size());\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of\n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end);\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      double lat = points.get(0).getLatitude();\n      double lon = points.get(0).getLongitude();\n      // Compute two points on the circle, with the right angle from the center.  We'll use these\n      // to obtain the perpendicular plane to the circle.\n      double upperLat = lat + cutoffAngle;\n      double upperLon = lon;\n      if (upperLat > Math.PI * 0.5) {\n        upperLon += Math.PI;\n        if (upperLon > Math.PI)\n          upperLon -= 2.0 * Math.PI;\n        upperLat = Math.PI - upperLat;\n      }\n      double lowerLat = lat - cutoffAngle;\n      double lowerLon = lon;\n      if (lowerLat < -Math.PI * 0.5) {\n        lowerLon += Math.PI;\n        if (lowerLon > Math.PI)\n          lowerLon -= 2.0 * Math.PI;\n        lowerLat = -Math.PI - lowerLat;\n      }\n      final GeoPoint upperPoint = new GeoPoint(planetModel, upperLat, upperLon);\n      final GeoPoint lowerPoint = new GeoPoint(planetModel, lowerLat, lowerLon);\n      final GeoPoint point = points.get(0);\n      \n      // Construct normal plane\n      final Plane normalPlane = Plane.constructNormalizedZPlane(upperPoint, lowerPoint, point);\n\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(point, normalPlane, upperPoint, lowerPoint);\n      endPoints.add(onlyEndpoint);\n      this.edgePoints = new GeoPoint[]{onlyEndpoint.circlePlane.getSampleIntersectionPoint(planetModel, normalPlane)};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.URHC, currentSegment.ULHC, currentSegment.LLHC);\n      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.ULHC, currentSegment.LLHC, prevSegment.LRHC);\n      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.LLHC, prevSegment.LRHC, prevSegment.URHC);\n      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);\n\n      if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {\n        // The planes are identical.  We wouldn't need a circle at all except for the possibility of\n        // backing up, which is hard to detect here.\n        final SegmentEndpoint midEndpoint = new SegmentEndpoint(currentSegment.start, \n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        //don't need a circle at all.  Special constructor...\n        endPoints.add(midEndpoint);\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC,\n          candidate1, candidate2, candidate3, candidate4));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","sourceOld":"  /** Complete the path.\n   */\n  public void done() {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() twice\");\n    if (points.size() == 0)\n      throw new IllegalArgumentException(\"Path must have at least one point\");\n    isDone = true;\n\n    endPoints = new ArrayList<>(points.size());\n    segments = new ArrayList<>(points.size());\n    // Compute an offset to use for all segments.  This will be based on the minimum magnitude of\n    // the entire ellipsoid.\n    final double cutoffOffset = this.sinAngle * planetModel.getMinimumMagnitude();\n    \n    // First, build all segments.  We'll then go back and build corresponding segment endpoints.\n    GeoPoint lastPoint = null;\n    for (final GeoPoint end : points) {\n      if (lastPoint != null) {\n        final Plane normalizedConnectingPlane = new Plane(lastPoint, end);\n        if (normalizedConnectingPlane == null) {\n          continue;\n        }\n        segments.add(new PathSegment(planetModel, lastPoint, end, normalizedConnectingPlane, cutoffOffset));\n      }\n      lastPoint = end;\n    }\n    \n    if (segments.size() == 0) {\n      // Simple circle\n      double lat = points.get(0).getLatitude();\n      double lon = points.get(0).getLongitude();\n      // Compute two points on the circle, with the right angle from the center.  We'll use these\n      // to obtain the perpendicular plane to the circle.\n      double upperLat = lat + cutoffAngle;\n      double upperLon = lon;\n      if (upperLat > Math.PI * 0.5) {\n        upperLon += Math.PI;\n        if (upperLon > Math.PI)\n          upperLon -= 2.0 * Math.PI;\n        upperLat = Math.PI - upperLat;\n      }\n      double lowerLat = lat - cutoffAngle;\n      double lowerLon = lon;\n      if (lowerLat < -Math.PI * 0.5) {\n        lowerLon += Math.PI;\n        if (lowerLon > Math.PI)\n          lowerLon -= 2.0 * Math.PI;\n        lowerLat = -Math.PI - lowerLat;\n      }\n      final GeoPoint upperPoint = new GeoPoint(planetModel, upperLat, upperLon);\n      final GeoPoint lowerPoint = new GeoPoint(planetModel, lowerLat, lowerLon);\n      final GeoPoint point = points.get(0);\n      \n      // Construct normal plane\n      final Plane normalPlane = Plane.constructNormalizedZPlane(upperPoint, lowerPoint, point);\n\n      final SegmentEndpoint onlyEndpoint = new SegmentEndpoint(point, normalPlane, upperPoint, lowerPoint);\n      endPoints.add(onlyEndpoint);\n      this.edgePoints = new GeoPoint[]{onlyEndpoint.circlePlane.getSampleIntersectionPoint(planetModel, normalPlane)};\n      return;\n    }\n    \n    // Create segment endpoints.  Use an appropriate constructor for the start and end of the path.\n    for (int i = 0; i < segments.size(); i++) {\n      final PathSegment currentSegment = segments.get(i);\n      \n      if (i == 0) {\n        // Starting endpoint\n        final SegmentEndpoint startEndpoint = new SegmentEndpoint(currentSegment.start, \n          currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        endPoints.add(startEndpoint);\n        this.edgePoints = new GeoPoint[]{currentSegment.ULHC};\n        continue;\n      }\n      \n      // General intersection case\n      final PathSegment prevSegment = segments.get(i-1);\n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.URHC, currentSegment.ULHC, currentSegment.LLHC);\n      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.ULHC, currentSegment.LLHC, prevSegment.LRHC);\n      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, currentSegment.LLHC, prevSegment.LRHC, prevSegment.URHC);\n      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);\n\n      if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {\n        // The planes are identical.  We wouldn't need a circle at all except for the possibility of\n        // backing up, which is hard to detect here.\n        final SegmentEndpoint midEndpoint = new SegmentEndpoint(currentSegment.start, \n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);\n        //don't need a circle at all.  Special constructor...\n        endPoints.add(midEndpoint);\n      } else {\n        endPoints.add(new SegmentEndpoint(currentSegment.start,\n          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,\n          prevSegment.URHC, prevSegment.LRHC,\n          currentSegment.ULHC, currentSegment.LLHC,\n          candidate1, candidate2, candidate3, candidate4));\n      }\n    }\n    // Do final endpoint\n    final PathSegment lastSegment = segments.get(segments.size()-1);\n    endPoints.add(new SegmentEndpoint(lastSegment.end,\n      lastSegment.endCutoffPlane, lastSegment.URHC, lastSegment.LRHC));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"760628478e121972168791a2afa6af915192c4a6":["b4e444678504caf66a8060b1d514383aa4feac0c"],"09af2c9610ce53a4b25fd99344299b40318a4a1a":["b4e444678504caf66a8060b1d514383aa4feac0c","760628478e121972168791a2afa6af915192c4a6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b4e444678504caf66a8060b1d514383aa4feac0c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["760628478e121972168791a2afa6af915192c4a6"]},"commit2Childs":{"760628478e121972168791a2afa6af915192c4a6":["09af2c9610ce53a4b25fd99344299b40318a4a1a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"09af2c9610ce53a4b25fd99344299b40318a4a1a":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b4e444678504caf66a8060b1d514383aa4feac0c"],"b4e444678504caf66a8060b1d514383aa4feac0c":["760628478e121972168791a2afa6af915192c4a6","09af2c9610ce53a4b25fd99344299b40318a4a1a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["09af2c9610ce53a4b25fd99344299b40318a4a1a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}