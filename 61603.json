{"path":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeWriter#build(int,int,PathSlice,PathSlice,LongBitSet,IndexOutput,int,int,int,int,int[],long[]).mjava","commits":[{"id":"4e50a8c6cf9370a926c7efe6aa39429e6a18cf96","date":1433340999,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeWriter#build(int,int,PathSlice,PathSlice,LongBitSet,IndexOutput,int,int,int,int,int[],long[]).mjava","pathOld":"/dev/null","sourceNew":"  /** dim=0 means we split on lat, dim=1 means lon.  The incoming PathSlice for the dim we will split is already partitioned/sorted. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice lastLatSorted,\n                     PathSlice lastLonSorted,\n                     LongBitSet bitSet,\n                     IndexOutput out,\n                     int minLatEnc, int maxLatEnc, int minLonEnc, int maxLonEnc,\n                     int[] splitValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    PathSlice source;\n    PathSlice nextSource;\n\n    long latRange = (long) maxLatEnc - (long) minLatEnc;\n    long lonRange = (long) maxLonEnc - (long) minLonEnc;\n\n    int splitDim;\n    if (latRange >= lonRange) {\n      // Split by lat:\n      splitDim = 0;\n      source = lastLatSorted;\n      nextSource = lastLonSorted;\n    } else {\n      // Split by lon:\n      splitDim = 1;\n      source = lastLonSorted;\n      nextSource = lastLatSorted;\n    }\n\n    long count = source.count;\n\n    //if (DEBUG) System.out.println(\"\\nBUILD: nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset + \" splitDim=\" + splitDim + \"\\n  lastLatSorted=\" + lastLatSorted + \"\\n  lastLonSorted=\" + lastLonSorted + \"\\n  count=\" + count + \" lat=\" + decodeLat(minLatEnc) + \" TO \" + decodeLat(maxLatEnc) + \" lon=\" + decodeLon(minLonEnc) + \" TO \" + decodeLon(maxLonEnc));\n\n    if (count == 0) {\n      // Dead end in the tree, due to adversary cases, e.g. many identical points:\n      if (nodeID < splitValues.length) {\n        // Sentinel used to mark that the tree is dead under here:\n        splitValues[nodeID] = Integer.MAX_VALUE;\n      }\n      //if (DEBUG) System.out.println(\"  dead-end sub-tree\");\n      return;\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n      //if (DEBUG) System.out.println(\"  leaf\");\n      assert maxLatEnc > minLatEnc;\n      assert maxLonEnc > minLonEnc;\n\n      //System.out.println(\"\\nleaf:\\n  lat range: \" + ((long) maxLatEnc-minLatEnc));\n      //System.out.println(\"  lon range: \" + ((long) maxLonEnc-minLonEnc));\n\n      assert count == source.count: \"count=\" + count + \" vs source.count=\" + source.count;\n\n      // Sort by docID in the leaf so we can .or(DISI) at search time:\n      LatLonReader reader = source.writer.getReader(source.start);\n\n      int[] docIDs = new int[(int) count];\n\n      boolean success = false;\n      try {\n        for (int i=0;i<source.count;i++) {\n\n          // NOTE: we discard ord at this point; we only needed it temporarily\n          // during building to uniquely identify each point to properly handle\n          // the multi-valued case (one docID having multiple values):\n\n          // We also discard lat/lon, since at search time, we reside on the\n          // wrapped doc values for this:\n\n          boolean result = reader.next();\n          assert result;\n          docIDs[i] = reader.docID();\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader);\n        } else {\n          IOUtils.closeWhileHandlingException(reader);\n        }\n      }\n\n      Arrays.sort(docIDs);\n\n      // Dedup docIDs: for the multi-valued case where more than one value for the doc\n      // wound up in this leaf cell, we only need to store the docID once:\n      int lastDocID = -1;\n      int uniqueCount = 0;\n      for(int i=0;i<docIDs.length;i++) {\n        int docID = docIDs[i];\n        if (docID != lastDocID) {\n          uniqueCount++;\n          lastDocID = docID;\n        }\n      }\n      assert uniqueCount <= count;\n\n      long startFP = out.getFilePointer();\n      out.writeVInt(uniqueCount);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = startFP;\n      //System.out.println(\"    leafFP=\" + startFP);\n\n      lastDocID = -1;\n      for (int i=0;i<docIDs.length;i++) {\n        // Absolute int encode; with \"vInt of deltas\" encoding, the .kdd size dropped from\n        // 697 MB -> 539 MB, but query time for 225 queries went from 1.65 sec -> 2.64 sec.\n        // I think if we also indexed prefix terms here we could do less costly compression\n        // on those lists:\n        int docID = docIDs[i];\n        if (docID != lastDocID) {\n          out.writeInt(docID);\n          lastDocID = docID;\n        }\n      }\n      //long endFP = out.getFilePointer();\n      //System.out.println(\"  bytes/doc: \" + ((endFP - startFP) / count));\n    } else {\n      // Inner node: sort, partition/recurse\n\n      assert nodeID < splitValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitValues.length;\n\n      int[] splitValueArray = new int[1];\n\n      assert source.count == count;\n      long leftCount = markLeftTree(splitDim, source, bitSet, splitValueArray,\n                                    minLatEnc, maxLatEnc, minLonEnc, maxLonEnc);\n      int splitValue = splitValueArray[0];\n\n      // TODO: we could save split value in here so we don't have to re-open file later:\n\n      // Partition nextSource into sorted left and right sets, so we can recurse.  This is somewhat hairy: we partition the next lon set\n      // according to how we had just partitioned the lat set, and vice/versa:\n\n      LatLonWriter leftWriter = null;\n      LatLonWriter rightWriter = null;\n      LatLonReader reader = null;\n\n      boolean success = false;\n\n      int nextLeftCount = 0;\n\n      try {\n        leftWriter = getWriter(leftCount);\n        rightWriter = getWriter(nextSource.count - leftCount);\n\n        //if (DEBUG) System.out.println(\"  partition:\\n    splitValueEnc=\" + splitValue + \"\\n    \" + nextSource + \"\\n      --> leftSorted=\" + leftWriter + \"\\n      --> rightSorted=\" + rightWriter + \")\");\n        assert nextSource.count == count;\n        reader = nextSource.writer.getReader(nextSource.start);\n\n        // TODO: we could compute the split value here for each sub-tree and save an O(N) pass on recursion, but makes code hairier and only\n        // changes the constant factor of building, not the big-oh:\n        for (int i=0;i<nextSource.count;i++) {\n          boolean result = reader.next();\n          assert result;\n          int latEnc = reader.latEnc();\n          int lonEnc = reader.lonEnc();\n          long ord = reader.ord();\n          int docID = reader.docID();\n          assert docID >= 0: \"docID=\" + docID + \" reader=\" + reader;\n          if (bitSet.get(ord)) {\n            if (splitDim == 0) {\n              assert latEnc < splitValue: \"latEnc=\" + latEnc + \" splitValue=\" + splitValue;\n            } else {\n              assert lonEnc < splitValue: \"lonEnc=\" + lonEnc + \" splitValue=\" + splitValue;\n            }\n            leftWriter.append(latEnc, lonEnc, ord, docID);\n            nextLeftCount++;\n          } else {\n            if (splitDim == 0) {\n              assert latEnc >= splitValue: \"latEnc=\" + latEnc + \" splitValue=\" + splitValue;\n            } else {\n              assert lonEnc >= splitValue: \"lonEnc=\" + lonEnc + \" splitValue=\" + splitValue;\n            }\n            rightWriter.append(latEnc, lonEnc, ord, docID);\n          }\n        }\n        bitSet.clear(0, pointCount);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader, leftWriter, rightWriter);\n        } else {\n          IOUtils.closeWhileHandlingException(reader, leftWriter, rightWriter);\n        }\n      }\n\n      assert leftCount == nextLeftCount: \"leftCount=\" + leftCount + \" nextLeftCount=\" + nextLeftCount;\n      assert count == nextSource.count: \"count=\" + count + \" nextSource.count=\" + count;\n\n      success = false;\n      try {\n        if (splitDim == 0) {\n          //if (DEBUG) System.out.println(\"  recurse left\");\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(source.writer, source.start, leftCount),\n                new PathSlice(leftWriter, 0, leftCount),\n                bitSet,\n                out,\n                minLatEnc, splitValue, minLonEnc, maxLonEnc,\n                splitValues, leafBlockFPs);\n          leftWriter.destroy();\n\n          //if (DEBUG) System.out.println(\"  recurse right\");\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(source.writer, source.start+leftCount, count-leftCount),\n                new PathSlice(rightWriter, 0, count - leftCount),\n                bitSet,\n                out,\n                splitValue, maxLatEnc, minLonEnc, maxLonEnc,\n                splitValues, leafBlockFPs);\n          rightWriter.destroy();\n        } else {\n          //if (DEBUG) System.out.println(\"  recurse left\");\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(leftWriter, 0, leftCount),\n                new PathSlice(source.writer, source.start, leftCount),\n                bitSet,\n                out,\n                minLatEnc, maxLatEnc, minLonEnc, splitValue,\n                splitValues, leafBlockFPs);\n\n          leftWriter.destroy();\n\n          //if (DEBUG) System.out.println(\"  recurse right\");\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(rightWriter, 0, count-leftCount),\n                new PathSlice(source.writer, source.start+leftCount, count-leftCount),    \n                bitSet,\n                out,\n                minLatEnc, maxLatEnc, splitValue, maxLonEnc,\n                splitValues, leafBlockFPs);\n          rightWriter.destroy();\n        }\n        success = true;\n      } finally {\n        if (success == false) {\n          try {\n            leftWriter.destroy();\n          } catch (Throwable t) {\n            // Suppress to keep throwing original exc\n          }\n          try {\n            rightWriter.destroy();\n          } catch (Throwable t) {\n            // Suppress to keep throwing original exc\n          }\n        }\n      }\n\n      splitValues[nodeID] = splitValue;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b268bd80fbb9f6c6ab5b033d2aca29588788a0e","date":1433719594,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeWriter#build(int,int,PathSlice,PathSlice,LongBitSet,IndexOutput,int,int,int,int,int[],long[]).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeWriter#build(int,int,PathSlice,PathSlice,LongBitSet,IndexOutput,int,int,int,int,int[],long[]).mjava","sourceNew":"  /** The incoming PathSlice for the dim we will split is already partitioned/sorted. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice lastLatSorted,\n                     PathSlice lastLonSorted,\n                     LongBitSet bitSet,\n                     IndexOutput out,\n                     int minLatEnc, int maxLatEnc, int minLonEnc, int maxLonEnc,\n                     int[] splitValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    PathSlice source;\n    PathSlice nextSource;\n\n    long latRange = (long) maxLatEnc - (long) minLatEnc;\n    long lonRange = (long) maxLonEnc - (long) minLonEnc;\n\n    // Compute which dim we should split on at this level:\n    int splitDim;\n    if (latRange >= lonRange) {\n      // Split by lat:\n      splitDim = 0;\n      source = lastLatSorted;\n      nextSource = lastLonSorted;\n    } else {\n      // Split by lon:\n      splitDim = 1;\n      source = lastLonSorted;\n      nextSource = lastLatSorted;\n    }\n\n    long count = source.count;\n\n    //if (DEBUG) System.out.println(\"\\nBUILD: nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset + \" splitDim=\" + splitDim + \"\\n  lastLatSorted=\" + lastLatSorted + \"\\n  lastLonSorted=\" + lastLonSorted + \"\\n  count=\" + count + \" lat=\" + decodeLat(minLatEnc) + \" TO \" + decodeLat(maxLatEnc) + \" lon=\" + decodeLon(minLonEnc) + \" TO \" + decodeLon(maxLonEnc));\n\n    if (count == 0) {\n      // Dead end in the tree, due to adversary cases, e.g. many identical points:\n      if (nodeID < splitValues.length) {\n        // Sentinel used to mark that the tree is dead under here:\n        splitValues[nodeID] = Integer.MAX_VALUE;\n      }\n      //if (DEBUG) System.out.println(\"  dead-end sub-tree\");\n      return;\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n      //if (DEBUG) System.out.println(\"  leaf\");\n      assert maxLatEnc > minLatEnc;\n      assert maxLonEnc > minLonEnc;\n\n      //System.out.println(\"\\nleaf:\\n  lat range: \" + ((long) maxLatEnc-minLatEnc));\n      //System.out.println(\"  lon range: \" + ((long) maxLonEnc-minLonEnc));\n\n      assert count == source.count: \"count=\" + count + \" vs source.count=\" + source.count;\n\n      // Sort by docID in the leaf so we can .or(DISI) at search time:\n      LatLonReader reader = source.writer.getReader(source.start);\n\n      int[] docIDs = new int[(int) count];\n\n      boolean success = false;\n      try {\n        for (int i=0;i<source.count;i++) {\n\n          // NOTE: we discard ord at this point; we only needed it temporarily\n          // during building to uniquely identify each point to properly handle\n          // the multi-valued case (one docID having multiple values):\n\n          // We also discard lat/lon, since at search time, we reside on the\n          // wrapped doc values for this:\n\n          boolean result = reader.next();\n          assert result;\n          docIDs[i] = reader.docID();\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader);\n        } else {\n          IOUtils.closeWhileHandlingException(reader);\n        }\n      }\n\n      Arrays.sort(docIDs);\n\n      // Dedup docIDs: for the multi-valued case where more than one value for the doc\n      // wound up in this leaf cell, we only need to store the docID once:\n      int lastDocID = -1;\n      int uniqueCount = 0;\n      for(int i=0;i<docIDs.length;i++) {\n        int docID = docIDs[i];\n        if (docID != lastDocID) {\n          uniqueCount++;\n          lastDocID = docID;\n        }\n      }\n      assert uniqueCount <= count;\n\n      long startFP = out.getFilePointer();\n      out.writeVInt(uniqueCount);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = startFP;\n      //System.out.println(\"    leafFP=\" + startFP);\n\n      lastDocID = -1;\n      for (int i=0;i<docIDs.length;i++) {\n        // Absolute int encode; with \"vInt of deltas\" encoding, the .kdd size dropped from\n        // 697 MB -> 539 MB, but query time for 225 queries went from 1.65 sec -> 2.64 sec.\n        // I think if we also indexed prefix terms here we could do less costly compression\n        // on those lists:\n        int docID = docIDs[i];\n        if (docID != lastDocID) {\n          out.writeInt(docID);\n          lastDocID = docID;\n        }\n      }\n      //long endFP = out.getFilePointer();\n      //System.out.println(\"  bytes/doc: \" + ((endFP - startFP) / count));\n    } else {\n      // Inner node: sort, partition/recurse\n\n      assert nodeID < splitValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitValues.length;\n\n      int[] splitValueArray = new int[1];\n\n      assert source.count == count;\n      long leftCount = markLeftTree(splitDim, source, bitSet, splitValueArray,\n                                    minLatEnc, maxLatEnc, minLonEnc, maxLonEnc);\n      int splitValue = splitValueArray[0];\n\n      // TODO: we could save split value in here so we don't have to re-open file later:\n\n      // Partition nextSource into sorted left and right sets, so we can recurse.  This is somewhat hairy: we partition the next lon set\n      // according to how we had just partitioned the lat set, and vice/versa:\n\n      LatLonWriter leftWriter = null;\n      LatLonWriter rightWriter = null;\n      LatLonReader reader = null;\n\n      boolean success = false;\n\n      int nextLeftCount = 0;\n\n      try {\n        leftWriter = getWriter(leftCount);\n        rightWriter = getWriter(nextSource.count - leftCount);\n\n        //if (DEBUG) System.out.println(\"  partition:\\n    splitValueEnc=\" + splitValue + \"\\n    \" + nextSource + \"\\n      --> leftSorted=\" + leftWriter + \"\\n      --> rightSorted=\" + rightWriter + \")\");\n        assert nextSource.count == count;\n        reader = nextSource.writer.getReader(nextSource.start);\n\n        // TODO: we could compute the split value here for each sub-tree and save an O(N) pass on recursion, but makes code hairier and only\n        // changes the constant factor of building, not the big-oh:\n        for (int i=0;i<nextSource.count;i++) {\n          boolean result = reader.next();\n          assert result;\n          int latEnc = reader.latEnc();\n          int lonEnc = reader.lonEnc();\n          long ord = reader.ord();\n          int docID = reader.docID();\n          assert docID >= 0: \"docID=\" + docID + \" reader=\" + reader;\n          if (bitSet.get(ord)) {\n            if (splitDim == 0) {\n              assert latEnc < splitValue: \"latEnc=\" + latEnc + \" splitValue=\" + splitValue;\n            } else {\n              assert lonEnc < splitValue: \"lonEnc=\" + lonEnc + \" splitValue=\" + splitValue;\n            }\n            leftWriter.append(latEnc, lonEnc, ord, docID);\n            nextLeftCount++;\n          } else {\n            if (splitDim == 0) {\n              assert latEnc >= splitValue: \"latEnc=\" + latEnc + \" splitValue=\" + splitValue;\n            } else {\n              assert lonEnc >= splitValue: \"lonEnc=\" + lonEnc + \" splitValue=\" + splitValue;\n            }\n            rightWriter.append(latEnc, lonEnc, ord, docID);\n          }\n        }\n        bitSet.clear(0, pointCount);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader, leftWriter, rightWriter);\n        } else {\n          IOUtils.closeWhileHandlingException(reader, leftWriter, rightWriter);\n        }\n      }\n\n      assert leftCount == nextLeftCount: \"leftCount=\" + leftCount + \" nextLeftCount=\" + nextLeftCount;\n      assert count == nextSource.count: \"count=\" + count + \" nextSource.count=\" + count;\n\n      success = false;\n      try {\n        if (splitDim == 0) {\n          //if (DEBUG) System.out.println(\"  recurse left\");\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(source.writer, source.start, leftCount),\n                new PathSlice(leftWriter, 0, leftCount),\n                bitSet,\n                out,\n                minLatEnc, splitValue, minLonEnc, maxLonEnc,\n                splitValues, leafBlockFPs);\n          leftWriter.destroy();\n\n          //if (DEBUG) System.out.println(\"  recurse right\");\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(source.writer, source.start+leftCount, count-leftCount),\n                new PathSlice(rightWriter, 0, count - leftCount),\n                bitSet,\n                out,\n                splitValue, maxLatEnc, minLonEnc, maxLonEnc,\n                splitValues, leafBlockFPs);\n          rightWriter.destroy();\n        } else {\n          //if (DEBUG) System.out.println(\"  recurse left\");\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(leftWriter, 0, leftCount),\n                new PathSlice(source.writer, source.start, leftCount),\n                bitSet,\n                out,\n                minLatEnc, maxLatEnc, minLonEnc, splitValue,\n                splitValues, leafBlockFPs);\n\n          leftWriter.destroy();\n\n          //if (DEBUG) System.out.println(\"  recurse right\");\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(rightWriter, 0, count-leftCount),\n                new PathSlice(source.writer, source.start+leftCount, count-leftCount),    \n                bitSet,\n                out,\n                minLatEnc, maxLatEnc, splitValue, maxLonEnc,\n                splitValues, leafBlockFPs);\n          rightWriter.destroy();\n        }\n        success = true;\n      } finally {\n        if (success == false) {\n          try {\n            leftWriter.destroy();\n          } catch (Throwable t) {\n            // Suppress to keep throwing original exc\n          }\n          try {\n            rightWriter.destroy();\n          } catch (Throwable t) {\n            // Suppress to keep throwing original exc\n          }\n        }\n      }\n\n      splitValues[nodeID] = splitValue;\n    }\n  }\n\n","sourceOld":"  /** dim=0 means we split on lat, dim=1 means lon.  The incoming PathSlice for the dim we will split is already partitioned/sorted. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice lastLatSorted,\n                     PathSlice lastLonSorted,\n                     LongBitSet bitSet,\n                     IndexOutput out,\n                     int minLatEnc, int maxLatEnc, int minLonEnc, int maxLonEnc,\n                     int[] splitValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    PathSlice source;\n    PathSlice nextSource;\n\n    long latRange = (long) maxLatEnc - (long) minLatEnc;\n    long lonRange = (long) maxLonEnc - (long) minLonEnc;\n\n    int splitDim;\n    if (latRange >= lonRange) {\n      // Split by lat:\n      splitDim = 0;\n      source = lastLatSorted;\n      nextSource = lastLonSorted;\n    } else {\n      // Split by lon:\n      splitDim = 1;\n      source = lastLonSorted;\n      nextSource = lastLatSorted;\n    }\n\n    long count = source.count;\n\n    //if (DEBUG) System.out.println(\"\\nBUILD: nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset + \" splitDim=\" + splitDim + \"\\n  lastLatSorted=\" + lastLatSorted + \"\\n  lastLonSorted=\" + lastLonSorted + \"\\n  count=\" + count + \" lat=\" + decodeLat(minLatEnc) + \" TO \" + decodeLat(maxLatEnc) + \" lon=\" + decodeLon(minLonEnc) + \" TO \" + decodeLon(maxLonEnc));\n\n    if (count == 0) {\n      // Dead end in the tree, due to adversary cases, e.g. many identical points:\n      if (nodeID < splitValues.length) {\n        // Sentinel used to mark that the tree is dead under here:\n        splitValues[nodeID] = Integer.MAX_VALUE;\n      }\n      //if (DEBUG) System.out.println(\"  dead-end sub-tree\");\n      return;\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n      //if (DEBUG) System.out.println(\"  leaf\");\n      assert maxLatEnc > minLatEnc;\n      assert maxLonEnc > minLonEnc;\n\n      //System.out.println(\"\\nleaf:\\n  lat range: \" + ((long) maxLatEnc-minLatEnc));\n      //System.out.println(\"  lon range: \" + ((long) maxLonEnc-minLonEnc));\n\n      assert count == source.count: \"count=\" + count + \" vs source.count=\" + source.count;\n\n      // Sort by docID in the leaf so we can .or(DISI) at search time:\n      LatLonReader reader = source.writer.getReader(source.start);\n\n      int[] docIDs = new int[(int) count];\n\n      boolean success = false;\n      try {\n        for (int i=0;i<source.count;i++) {\n\n          // NOTE: we discard ord at this point; we only needed it temporarily\n          // during building to uniquely identify each point to properly handle\n          // the multi-valued case (one docID having multiple values):\n\n          // We also discard lat/lon, since at search time, we reside on the\n          // wrapped doc values for this:\n\n          boolean result = reader.next();\n          assert result;\n          docIDs[i] = reader.docID();\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader);\n        } else {\n          IOUtils.closeWhileHandlingException(reader);\n        }\n      }\n\n      Arrays.sort(docIDs);\n\n      // Dedup docIDs: for the multi-valued case where more than one value for the doc\n      // wound up in this leaf cell, we only need to store the docID once:\n      int lastDocID = -1;\n      int uniqueCount = 0;\n      for(int i=0;i<docIDs.length;i++) {\n        int docID = docIDs[i];\n        if (docID != lastDocID) {\n          uniqueCount++;\n          lastDocID = docID;\n        }\n      }\n      assert uniqueCount <= count;\n\n      long startFP = out.getFilePointer();\n      out.writeVInt(uniqueCount);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = startFP;\n      //System.out.println(\"    leafFP=\" + startFP);\n\n      lastDocID = -1;\n      for (int i=0;i<docIDs.length;i++) {\n        // Absolute int encode; with \"vInt of deltas\" encoding, the .kdd size dropped from\n        // 697 MB -> 539 MB, but query time for 225 queries went from 1.65 sec -> 2.64 sec.\n        // I think if we also indexed prefix terms here we could do less costly compression\n        // on those lists:\n        int docID = docIDs[i];\n        if (docID != lastDocID) {\n          out.writeInt(docID);\n          lastDocID = docID;\n        }\n      }\n      //long endFP = out.getFilePointer();\n      //System.out.println(\"  bytes/doc: \" + ((endFP - startFP) / count));\n    } else {\n      // Inner node: sort, partition/recurse\n\n      assert nodeID < splitValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitValues.length;\n\n      int[] splitValueArray = new int[1];\n\n      assert source.count == count;\n      long leftCount = markLeftTree(splitDim, source, bitSet, splitValueArray,\n                                    minLatEnc, maxLatEnc, minLonEnc, maxLonEnc);\n      int splitValue = splitValueArray[0];\n\n      // TODO: we could save split value in here so we don't have to re-open file later:\n\n      // Partition nextSource into sorted left and right sets, so we can recurse.  This is somewhat hairy: we partition the next lon set\n      // according to how we had just partitioned the lat set, and vice/versa:\n\n      LatLonWriter leftWriter = null;\n      LatLonWriter rightWriter = null;\n      LatLonReader reader = null;\n\n      boolean success = false;\n\n      int nextLeftCount = 0;\n\n      try {\n        leftWriter = getWriter(leftCount);\n        rightWriter = getWriter(nextSource.count - leftCount);\n\n        //if (DEBUG) System.out.println(\"  partition:\\n    splitValueEnc=\" + splitValue + \"\\n    \" + nextSource + \"\\n      --> leftSorted=\" + leftWriter + \"\\n      --> rightSorted=\" + rightWriter + \")\");\n        assert nextSource.count == count;\n        reader = nextSource.writer.getReader(nextSource.start);\n\n        // TODO: we could compute the split value here for each sub-tree and save an O(N) pass on recursion, but makes code hairier and only\n        // changes the constant factor of building, not the big-oh:\n        for (int i=0;i<nextSource.count;i++) {\n          boolean result = reader.next();\n          assert result;\n          int latEnc = reader.latEnc();\n          int lonEnc = reader.lonEnc();\n          long ord = reader.ord();\n          int docID = reader.docID();\n          assert docID >= 0: \"docID=\" + docID + \" reader=\" + reader;\n          if (bitSet.get(ord)) {\n            if (splitDim == 0) {\n              assert latEnc < splitValue: \"latEnc=\" + latEnc + \" splitValue=\" + splitValue;\n            } else {\n              assert lonEnc < splitValue: \"lonEnc=\" + lonEnc + \" splitValue=\" + splitValue;\n            }\n            leftWriter.append(latEnc, lonEnc, ord, docID);\n            nextLeftCount++;\n          } else {\n            if (splitDim == 0) {\n              assert latEnc >= splitValue: \"latEnc=\" + latEnc + \" splitValue=\" + splitValue;\n            } else {\n              assert lonEnc >= splitValue: \"lonEnc=\" + lonEnc + \" splitValue=\" + splitValue;\n            }\n            rightWriter.append(latEnc, lonEnc, ord, docID);\n          }\n        }\n        bitSet.clear(0, pointCount);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader, leftWriter, rightWriter);\n        } else {\n          IOUtils.closeWhileHandlingException(reader, leftWriter, rightWriter);\n        }\n      }\n\n      assert leftCount == nextLeftCount: \"leftCount=\" + leftCount + \" nextLeftCount=\" + nextLeftCount;\n      assert count == nextSource.count: \"count=\" + count + \" nextSource.count=\" + count;\n\n      success = false;\n      try {\n        if (splitDim == 0) {\n          //if (DEBUG) System.out.println(\"  recurse left\");\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(source.writer, source.start, leftCount),\n                new PathSlice(leftWriter, 0, leftCount),\n                bitSet,\n                out,\n                minLatEnc, splitValue, minLonEnc, maxLonEnc,\n                splitValues, leafBlockFPs);\n          leftWriter.destroy();\n\n          //if (DEBUG) System.out.println(\"  recurse right\");\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(source.writer, source.start+leftCount, count-leftCount),\n                new PathSlice(rightWriter, 0, count - leftCount),\n                bitSet,\n                out,\n                splitValue, maxLatEnc, minLonEnc, maxLonEnc,\n                splitValues, leafBlockFPs);\n          rightWriter.destroy();\n        } else {\n          //if (DEBUG) System.out.println(\"  recurse left\");\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(leftWriter, 0, leftCount),\n                new PathSlice(source.writer, source.start, leftCount),\n                bitSet,\n                out,\n                minLatEnc, maxLatEnc, minLonEnc, splitValue,\n                splitValues, leafBlockFPs);\n\n          leftWriter.destroy();\n\n          //if (DEBUG) System.out.println(\"  recurse right\");\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(rightWriter, 0, count-leftCount),\n                new PathSlice(source.writer, source.start+leftCount, count-leftCount),    \n                bitSet,\n                out,\n                minLatEnc, maxLatEnc, splitValue, maxLonEnc,\n                splitValues, leafBlockFPs);\n          rightWriter.destroy();\n        }\n        success = true;\n      } finally {\n        if (success == false) {\n          try {\n            leftWriter.destroy();\n          } catch (Throwable t) {\n            // Suppress to keep throwing original exc\n          }\n          try {\n            rightWriter.destroy();\n          } catch (Throwable t) {\n            // Suppress to keep throwing original exc\n          }\n        }\n      }\n\n      splitValues[nodeID] = splitValue;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f64b7098768253180859cd8faeae6b1a185b06ed","date":1441223971,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeWriter#build(int,int,PathSlice,PathSlice,LongBitSet,IndexOutput,int,int,int,int,int[],long[]).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeWriter#build(int,int,PathSlice,PathSlice,LongBitSet,IndexOutput,int,int,int,int,int[],long[]).mjava","sourceNew":"  /** The incoming PathSlice for the dim we will split is already partitioned/sorted. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice lastLatSorted,\n                     PathSlice lastLonSorted,\n                     LongBitSet bitSet,\n                     IndexOutput out,\n                     int minLatEnc, int maxLatEnc, int minLonEnc, int maxLonEnc,\n                     int[] splitValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    PathSlice source;\n    PathSlice nextSource;\n\n    long latRange = (long) maxLatEnc - (long) minLatEnc;\n    long lonRange = (long) maxLonEnc - (long) minLonEnc;\n\n    assert lastLatSorted.count == lastLonSorted.count;\n\n    // Compute which dim we should split on at this level:\n    int splitDim;\n    if (latRange >= lonRange) {\n      // Split by lat:\n      splitDim = 0;\n      source = lastLatSorted;\n      nextSource = lastLonSorted;\n    } else {\n      // Split by lon:\n      splitDim = 1;\n      source = lastLonSorted;\n      nextSource = lastLatSorted;\n    }\n\n    long count = source.count;\n\n    //if (DEBUG) System.out.println(\"\\nBUILD: nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset + \" splitDim=\" + splitDim + \"\\n  lastLatSorted=\" + lastLatSorted + \"\\n  lastLonSorted=\" + lastLonSorted + \"\\n  count=\" + count + \" lat=\" + decodeLat(minLatEnc) + \" TO \" + decodeLat(maxLatEnc) + \" lon=\" + decodeLon(minLonEnc) + \" TO \" + decodeLon(maxLonEnc));\n\n    if (count == 0) {\n      // Dead end in the tree, due to adversary cases, e.g. many identical points:\n      if (nodeID < splitValues.length) {\n        // Sentinel used to mark that the tree is dead under here:\n        splitValues[nodeID] = Integer.MAX_VALUE;\n      }\n      //if (DEBUG) System.out.println(\"  dead-end sub-tree\");\n      return;\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n      //if (DEBUG) System.out.println(\"  leaf\");\n      assert maxLatEnc > minLatEnc;\n      assert maxLonEnc > minLonEnc;\n\n      //System.out.println(\"\\nleaf:\\n  lat range: \" + ((long) maxLatEnc-minLatEnc));\n      //System.out.println(\"  lon range: \" + ((long) maxLonEnc-minLonEnc));\n\n      // Sort by docID in the leaf so we get sequentiality at search time (may not matter?):\n      LatLonReader reader = source.writer.getReader(source.start);\n\n      // TODO: we can reuse this\n      int[] docIDs = new int[(int) count];\n\n      boolean success = false;\n      try {\n        for (int i=0;i<source.count;i++) {\n\n          // NOTE: we discard ord at this point; we only needed it temporarily\n          // during building to uniquely identify each point to properly handle\n          // the multi-valued case (one docID having multiple values):\n\n          // We also discard lat/lon, since at search time, we reside on the\n          // wrapped doc values for this:\n\n          boolean result = reader.next();\n          assert result;\n          docIDs[i] = reader.docID();\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader);\n        } else {\n          IOUtils.closeWhileHandlingException(reader);\n        }\n      }\n\n      Arrays.sort(docIDs);\n\n      // Dedup docIDs: for the multi-valued case where more than one value for the doc\n      // wound up in this leaf cell, we only need to store the docID once:\n      int lastDocID = -1;\n      int uniqueCount = 0;\n      for(int i=0;i<docIDs.length;i++) {\n        int docID = docIDs[i];\n        if (docID != lastDocID) {\n          uniqueCount++;\n          lastDocID = docID;\n        }\n      }\n      assert uniqueCount <= count;\n\n      long startFP = out.getFilePointer();\n      out.writeVInt(uniqueCount);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = startFP;\n      //System.out.println(\"    leafFP=\" + startFP);\n\n      lastDocID = -1;\n      for (int i=0;i<docIDs.length;i++) {\n        // Absolute int encode; with \"vInt of deltas\" encoding, the .kdd size dropped from\n        // 697 MB -> 539 MB, but query time for 225 queries went from 1.65 sec -> 2.64 sec.\n        // I think if we also indexed prefix terms here we could do less costly compression\n        // on those lists:\n        int docID = docIDs[i];\n        if (docID != lastDocID) {\n          out.writeInt(docID);\n          lastDocID = docID;\n        }\n      }\n      //long endFP = out.getFilePointer();\n      //System.out.println(\"  bytes/doc: \" + ((endFP - startFP) / count));\n    } else {\n      // Inner node: partition/recurse\n\n      assert nodeID < splitValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitValues.length;\n\n      int[] splitValueArray = new int[1];\n\n      long leftCount = markLeftTree(splitDim, source, bitSet, splitValueArray,\n                                    minLatEnc, maxLatEnc, minLonEnc, maxLonEnc);\n      int splitValue = splitValueArray[0];\n\n      // TODO: we could save split value in here so we don't have to re-open file later:\n\n      // Partition nextSource into sorted left and right sets, so we can recurse.  This is somewhat hairy: we partition the next lon set\n      // according to how we had just partitioned the lat set, and vice/versa:\n\n      LatLonWriter leftWriter = null;\n      LatLonWriter rightWriter = null;\n      LatLonReader reader = null;\n\n      boolean success = false;\n\n      int nextLeftCount = 0;\n\n      try {\n        leftWriter = getWriter(leftCount);\n        rightWriter = getWriter(count - leftCount);\n\n        //if (DEBUG) System.out.println(\"  partition:\\n    splitValueEnc=\" + splitValue + \"\\n    \" + nextSource + \"\\n      --> leftSorted=\" + leftWriter + \"\\n      --> rightSorted=\" + rightWriter + \")\");\n        reader = nextSource.writer.getReader(nextSource.start);\n\n        // TODO: we could compute the split value here for each sub-tree and save an O(N) pass on recursion, but makes code hairier and only\n        // changes the constant factor of building, not the big-oh:\n        for (int i=0;i<count;i++) {\n          boolean result = reader.next();\n          assert result;\n          int latEnc = reader.latEnc();\n          int lonEnc = reader.lonEnc();\n          long ord = reader.ord();\n          int docID = reader.docID();\n          assert docID >= 0: \"docID=\" + docID + \" reader=\" + reader;\n          if (bitSet.get(ord)) {\n            if (splitDim == 0) {\n              assert latEnc < splitValue: \"latEnc=\" + latEnc + \" splitValue=\" + splitValue;\n            } else {\n              assert lonEnc < splitValue: \"lonEnc=\" + lonEnc + \" splitValue=\" + splitValue;\n            }\n            leftWriter.append(latEnc, lonEnc, ord, docID);\n            nextLeftCount++;\n          } else {\n            if (splitDim == 0) {\n              assert latEnc >= splitValue: \"latEnc=\" + latEnc + \" splitValue=\" + splitValue;\n            } else {\n              assert lonEnc >= splitValue: \"lonEnc=\" + lonEnc + \" splitValue=\" + splitValue;\n            }\n            rightWriter.append(latEnc, lonEnc, ord, docID);\n          }\n        }\n        bitSet.clear(0, pointCount);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader, leftWriter, rightWriter);\n        } else {\n          IOUtils.closeWhileHandlingException(reader, leftWriter, rightWriter);\n        }\n      }\n\n      assert leftCount == nextLeftCount: \"leftCount=\" + leftCount + \" nextLeftCount=\" + nextLeftCount;\n\n      success = false;\n      try {\n        if (splitDim == 0) {\n          //if (DEBUG) System.out.println(\"  recurse left\");\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(source.writer, source.start, leftCount),\n                new PathSlice(leftWriter, 0, leftCount),\n                bitSet,\n                out,\n                minLatEnc, splitValue, minLonEnc, maxLonEnc,\n                splitValues, leafBlockFPs);\n          leftWriter.destroy();\n\n          //if (DEBUG) System.out.println(\"  recurse right\");\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(source.writer, source.start+leftCount, count-leftCount),\n                new PathSlice(rightWriter, 0, count - leftCount),\n                bitSet,\n                out,\n                splitValue, maxLatEnc, minLonEnc, maxLonEnc,\n                splitValues, leafBlockFPs);\n          rightWriter.destroy();\n        } else {\n          //if (DEBUG) System.out.println(\"  recurse left\");\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(leftWriter, 0, leftCount),\n                new PathSlice(source.writer, source.start, leftCount),\n                bitSet,\n                out,\n                minLatEnc, maxLatEnc, minLonEnc, splitValue,\n                splitValues, leafBlockFPs);\n\n          leftWriter.destroy();\n\n          //if (DEBUG) System.out.println(\"  recurse right\");\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(rightWriter, 0, count-leftCount),\n                new PathSlice(source.writer, source.start+leftCount, count-leftCount),    \n                bitSet,\n                out,\n                minLatEnc, maxLatEnc, splitValue, maxLonEnc,\n                splitValues, leafBlockFPs);\n          rightWriter.destroy();\n        }\n        success = true;\n      } finally {\n        if (success == false) {\n          try {\n            leftWriter.destroy();\n          } catch (Throwable t) {\n            // Suppress to keep throwing original exc\n          }\n          try {\n            rightWriter.destroy();\n          } catch (Throwable t) {\n            // Suppress to keep throwing original exc\n          }\n        }\n      }\n\n      splitValues[nodeID] = splitValue;\n    }\n  }\n\n","sourceOld":"  /** The incoming PathSlice for the dim we will split is already partitioned/sorted. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice lastLatSorted,\n                     PathSlice lastLonSorted,\n                     LongBitSet bitSet,\n                     IndexOutput out,\n                     int minLatEnc, int maxLatEnc, int minLonEnc, int maxLonEnc,\n                     int[] splitValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    PathSlice source;\n    PathSlice nextSource;\n\n    long latRange = (long) maxLatEnc - (long) minLatEnc;\n    long lonRange = (long) maxLonEnc - (long) minLonEnc;\n\n    // Compute which dim we should split on at this level:\n    int splitDim;\n    if (latRange >= lonRange) {\n      // Split by lat:\n      splitDim = 0;\n      source = lastLatSorted;\n      nextSource = lastLonSorted;\n    } else {\n      // Split by lon:\n      splitDim = 1;\n      source = lastLonSorted;\n      nextSource = lastLatSorted;\n    }\n\n    long count = source.count;\n\n    //if (DEBUG) System.out.println(\"\\nBUILD: nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset + \" splitDim=\" + splitDim + \"\\n  lastLatSorted=\" + lastLatSorted + \"\\n  lastLonSorted=\" + lastLonSorted + \"\\n  count=\" + count + \" lat=\" + decodeLat(minLatEnc) + \" TO \" + decodeLat(maxLatEnc) + \" lon=\" + decodeLon(minLonEnc) + \" TO \" + decodeLon(maxLonEnc));\n\n    if (count == 0) {\n      // Dead end in the tree, due to adversary cases, e.g. many identical points:\n      if (nodeID < splitValues.length) {\n        // Sentinel used to mark that the tree is dead under here:\n        splitValues[nodeID] = Integer.MAX_VALUE;\n      }\n      //if (DEBUG) System.out.println(\"  dead-end sub-tree\");\n      return;\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n      //if (DEBUG) System.out.println(\"  leaf\");\n      assert maxLatEnc > minLatEnc;\n      assert maxLonEnc > minLonEnc;\n\n      //System.out.println(\"\\nleaf:\\n  lat range: \" + ((long) maxLatEnc-minLatEnc));\n      //System.out.println(\"  lon range: \" + ((long) maxLonEnc-minLonEnc));\n\n      assert count == source.count: \"count=\" + count + \" vs source.count=\" + source.count;\n\n      // Sort by docID in the leaf so we can .or(DISI) at search time:\n      LatLonReader reader = source.writer.getReader(source.start);\n\n      int[] docIDs = new int[(int) count];\n\n      boolean success = false;\n      try {\n        for (int i=0;i<source.count;i++) {\n\n          // NOTE: we discard ord at this point; we only needed it temporarily\n          // during building to uniquely identify each point to properly handle\n          // the multi-valued case (one docID having multiple values):\n\n          // We also discard lat/lon, since at search time, we reside on the\n          // wrapped doc values for this:\n\n          boolean result = reader.next();\n          assert result;\n          docIDs[i] = reader.docID();\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader);\n        } else {\n          IOUtils.closeWhileHandlingException(reader);\n        }\n      }\n\n      Arrays.sort(docIDs);\n\n      // Dedup docIDs: for the multi-valued case where more than one value for the doc\n      // wound up in this leaf cell, we only need to store the docID once:\n      int lastDocID = -1;\n      int uniqueCount = 0;\n      for(int i=0;i<docIDs.length;i++) {\n        int docID = docIDs[i];\n        if (docID != lastDocID) {\n          uniqueCount++;\n          lastDocID = docID;\n        }\n      }\n      assert uniqueCount <= count;\n\n      long startFP = out.getFilePointer();\n      out.writeVInt(uniqueCount);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = startFP;\n      //System.out.println(\"    leafFP=\" + startFP);\n\n      lastDocID = -1;\n      for (int i=0;i<docIDs.length;i++) {\n        // Absolute int encode; with \"vInt of deltas\" encoding, the .kdd size dropped from\n        // 697 MB -> 539 MB, but query time for 225 queries went from 1.65 sec -> 2.64 sec.\n        // I think if we also indexed prefix terms here we could do less costly compression\n        // on those lists:\n        int docID = docIDs[i];\n        if (docID != lastDocID) {\n          out.writeInt(docID);\n          lastDocID = docID;\n        }\n      }\n      //long endFP = out.getFilePointer();\n      //System.out.println(\"  bytes/doc: \" + ((endFP - startFP) / count));\n    } else {\n      // Inner node: sort, partition/recurse\n\n      assert nodeID < splitValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitValues.length;\n\n      int[] splitValueArray = new int[1];\n\n      assert source.count == count;\n      long leftCount = markLeftTree(splitDim, source, bitSet, splitValueArray,\n                                    minLatEnc, maxLatEnc, minLonEnc, maxLonEnc);\n      int splitValue = splitValueArray[0];\n\n      // TODO: we could save split value in here so we don't have to re-open file later:\n\n      // Partition nextSource into sorted left and right sets, so we can recurse.  This is somewhat hairy: we partition the next lon set\n      // according to how we had just partitioned the lat set, and vice/versa:\n\n      LatLonWriter leftWriter = null;\n      LatLonWriter rightWriter = null;\n      LatLonReader reader = null;\n\n      boolean success = false;\n\n      int nextLeftCount = 0;\n\n      try {\n        leftWriter = getWriter(leftCount);\n        rightWriter = getWriter(nextSource.count - leftCount);\n\n        //if (DEBUG) System.out.println(\"  partition:\\n    splitValueEnc=\" + splitValue + \"\\n    \" + nextSource + \"\\n      --> leftSorted=\" + leftWriter + \"\\n      --> rightSorted=\" + rightWriter + \")\");\n        assert nextSource.count == count;\n        reader = nextSource.writer.getReader(nextSource.start);\n\n        // TODO: we could compute the split value here for each sub-tree and save an O(N) pass on recursion, but makes code hairier and only\n        // changes the constant factor of building, not the big-oh:\n        for (int i=0;i<nextSource.count;i++) {\n          boolean result = reader.next();\n          assert result;\n          int latEnc = reader.latEnc();\n          int lonEnc = reader.lonEnc();\n          long ord = reader.ord();\n          int docID = reader.docID();\n          assert docID >= 0: \"docID=\" + docID + \" reader=\" + reader;\n          if (bitSet.get(ord)) {\n            if (splitDim == 0) {\n              assert latEnc < splitValue: \"latEnc=\" + latEnc + \" splitValue=\" + splitValue;\n            } else {\n              assert lonEnc < splitValue: \"lonEnc=\" + lonEnc + \" splitValue=\" + splitValue;\n            }\n            leftWriter.append(latEnc, lonEnc, ord, docID);\n            nextLeftCount++;\n          } else {\n            if (splitDim == 0) {\n              assert latEnc >= splitValue: \"latEnc=\" + latEnc + \" splitValue=\" + splitValue;\n            } else {\n              assert lonEnc >= splitValue: \"lonEnc=\" + lonEnc + \" splitValue=\" + splitValue;\n            }\n            rightWriter.append(latEnc, lonEnc, ord, docID);\n          }\n        }\n        bitSet.clear(0, pointCount);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader, leftWriter, rightWriter);\n        } else {\n          IOUtils.closeWhileHandlingException(reader, leftWriter, rightWriter);\n        }\n      }\n\n      assert leftCount == nextLeftCount: \"leftCount=\" + leftCount + \" nextLeftCount=\" + nextLeftCount;\n      assert count == nextSource.count: \"count=\" + count + \" nextSource.count=\" + count;\n\n      success = false;\n      try {\n        if (splitDim == 0) {\n          //if (DEBUG) System.out.println(\"  recurse left\");\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(source.writer, source.start, leftCount),\n                new PathSlice(leftWriter, 0, leftCount),\n                bitSet,\n                out,\n                minLatEnc, splitValue, minLonEnc, maxLonEnc,\n                splitValues, leafBlockFPs);\n          leftWriter.destroy();\n\n          //if (DEBUG) System.out.println(\"  recurse right\");\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(source.writer, source.start+leftCount, count-leftCount),\n                new PathSlice(rightWriter, 0, count - leftCount),\n                bitSet,\n                out,\n                splitValue, maxLatEnc, minLonEnc, maxLonEnc,\n                splitValues, leafBlockFPs);\n          rightWriter.destroy();\n        } else {\n          //if (DEBUG) System.out.println(\"  recurse left\");\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(leftWriter, 0, leftCount),\n                new PathSlice(source.writer, source.start, leftCount),\n                bitSet,\n                out,\n                minLatEnc, maxLatEnc, minLonEnc, splitValue,\n                splitValues, leafBlockFPs);\n\n          leftWriter.destroy();\n\n          //if (DEBUG) System.out.println(\"  recurse right\");\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(rightWriter, 0, count-leftCount),\n                new PathSlice(source.writer, source.start+leftCount, count-leftCount),    \n                bitSet,\n                out,\n                minLatEnc, maxLatEnc, splitValue, maxLonEnc,\n                splitValues, leafBlockFPs);\n          rightWriter.destroy();\n        }\n        success = true;\n      } finally {\n        if (success == false) {\n          try {\n            leftWriter.destroy();\n          } catch (Throwable t) {\n            // Suppress to keep throwing original exc\n          }\n          try {\n            rightWriter.destroy();\n          } catch (Throwable t) {\n            // Suppress to keep throwing original exc\n          }\n        }\n      }\n\n      splitValues[nodeID] = splitValue;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07c50cb1eca5629cac5b6702dd0f5e06157af61a","date":1445464748,"type":3,"author":"Nick Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeWriter#build(int,int,PathSlice,PathSlice,LongBitSet,IndexOutput,int,int,int,int,int[],long[]).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeWriter#build(int,int,PathSlice,PathSlice,LongBitSet,IndexOutput,int,int,int,int,int[],long[]).mjava","sourceNew":"  /** The incoming PathSlice for the dim we will split is already partitioned/sorted. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice lastLatSorted,\n                     PathSlice lastLonSorted,\n                     LongBitSet bitSet,\n                     IndexOutput out,\n                     int minLatEnc, int maxLatEnc, int minLonEnc, int maxLonEnc,\n                     int[] splitValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    PathSlice source;\n    PathSlice nextSource;\n\n    long latRange = (long) maxLatEnc - (long) minLatEnc;\n    long lonRange = (long) maxLonEnc - (long) minLonEnc;\n\n    assert lastLatSorted.count == lastLonSorted.count;\n\n    // Compute which dim we should split on at this level:\n    int splitDim;\n    if (latRange >= lonRange) {\n      // Split by lat:\n      splitDim = 0;\n      source = lastLatSorted;\n      nextSource = lastLonSorted;\n    } else {\n      // Split by lon:\n      splitDim = 1;\n      source = lastLonSorted;\n      nextSource = lastLatSorted;\n    }\n\n    long count = source.count;\n\n    //if (DEBUG) System.out.println(\"\\nBUILD: nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset + \" splitDim=\" + splitDim + \"\\n  lastLatSorted=\" + lastLatSorted + \"\\n  lastLonSorted=\" + lastLonSorted + \"\\n  count=\" + count + \" lat=\" + decodeLat(minLatEnc) + \" TO \" + decodeLat(maxLatEnc) + \" lon=\" + decodeLon(minLonEnc) + \" TO \" + decodeLon(maxLonEnc));\n\n    if (count == 0) {\n      // Dead end in the tree, due to adversary cases, e.g. many identical points:\n      if (nodeID < splitValues.length) {\n        // Sentinel used to mark that the tree is dead under here:\n        splitValues[nodeID] = Integer.MAX_VALUE;\n      }\n      //if (DEBUG) System.out.println(\"  dead-end sub-tree\");\n      return;\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n      //if (DEBUG) System.out.println(\"  leaf\");\n      assert maxLatEnc > minLatEnc;\n      assert maxLonEnc > minLonEnc;\n\n      //System.out.println(\"\\nleaf:\\n  lat range: \" + ((long) maxLatEnc-minLatEnc));\n      //System.out.println(\"  lon range: \" + ((long) maxLonEnc-minLonEnc));\n\n      // Sort by docID in the leaf so we get sequentiality at search time (may not matter?):\n      LatLonReader reader = source.writer.getReader(source.start);\n\n      // TODO: we can reuse this\n      int[] docIDs = new int[(int) count];\n\n      boolean success = false;\n      try {\n        for (int i=0;i<source.count;i++) {\n\n          // NOTE: we discard ord at this point; we only needed it temporarily\n          // during building to uniquely identify each point to properly handle\n          // the multi-valued case (one docID having multiple values):\n\n          // We also discard lat/lon, since at search time, we reside on the\n          // wrapped doc values for this:\n\n          boolean result = reader.next();\n          assert result;\n          docIDs[i] = reader.docID();\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader);\n        } else {\n          IOUtils.closeWhileHandlingException(reader);\n        }\n      }\n\n      Arrays.sort(docIDs);\n\n      // Dedup docIDs: for the multi-valued case where more than one value for the doc\n      // wound up in this leaf cell, we only need to store the docID once:\n      int lastDocID = -1;\n      int uniqueCount = 0;\n      for(int i=0;i<docIDs.length;i++) {\n        int docID = docIDs[i];\n        if (docID != lastDocID) {\n          uniqueCount++;\n          lastDocID = docID;\n        }\n      }\n      assert uniqueCount <= count;\n\n      long startFP = out.getFilePointer();\n      out.writeVInt(uniqueCount);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = startFP;\n      //System.out.println(\"    leafFP=\" + startFP);\n\n      lastDocID = -1;\n      for (int i=0;i<docIDs.length;i++) {\n        // Absolute int encode; with \"vInt of deltas\" encoding, the .kdd size dropped from\n        // 697 MB -> 539 MB, but query time for 225 queries went from 1.65 sec -> 2.64 sec.\n        // I think if we also indexed prefix terms here we could do less costly compression\n        // on those lists:\n        int docID = docIDs[i];\n        if (docID != lastDocID) {\n          //System.out.println(\"  docID=\" + docID);\n          out.writeInt(docID);\n          lastDocID = docID;\n        }\n      }\n      //long endFP = out.getFilePointer();\n      //System.out.println(\"  bytes/doc: \" + ((endFP - startFP) / count));\n    } else {\n      // Inner node: partition/recurse\n\n      assert nodeID < splitValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitValues.length;\n\n      int[] splitValueArray = new int[1];\n\n      long leftCount = markLeftTree(splitDim, source, bitSet, splitValueArray,\n                                    minLatEnc, maxLatEnc, minLonEnc, maxLonEnc);\n      int splitValue = splitValueArray[0];\n\n      // TODO: we could save split value in here so we don't have to re-open file later:\n\n      // Partition nextSource into sorted left and right sets, so we can recurse.  This is somewhat hairy: we partition the next lon set\n      // according to how we had just partitioned the lat set, and vice/versa:\n\n      LatLonWriter leftWriter = null;\n      LatLonWriter rightWriter = null;\n      LatLonReader reader = null;\n\n      boolean success = false;\n\n      int nextLeftCount = 0;\n\n      try {\n        leftWriter = getWriter(leftCount);\n        rightWriter = getWriter(count - leftCount);\n\n        //if (DEBUG) System.out.println(\"  partition:\\n    splitValueEnc=\" + splitValue + \"\\n    \" + nextSource + \"\\n      --> leftSorted=\" + leftWriter + \"\\n      --> rightSorted=\" + rightWriter + \")\");\n        reader = nextSource.writer.getReader(nextSource.start);\n\n        // TODO: we could compute the split value here for each sub-tree and save an O(N) pass on recursion, but makes code hairier and only\n        // changes the constant factor of building, not the big-oh:\n        for (int i=0;i<count;i++) {\n          boolean result = reader.next();\n          assert result;\n          int latEnc = reader.latEnc();\n          int lonEnc = reader.lonEnc();\n          long ord = reader.ord();\n          int docID = reader.docID();\n          assert docID >= 0: \"docID=\" + docID + \" reader=\" + reader;\n          if (bitSet.get(ord)) {\n            if (splitDim == 0) {\n              assert latEnc < splitValue: \"latEnc=\" + latEnc + \" splitValue=\" + splitValue;\n            } else {\n              assert lonEnc < splitValue: \"lonEnc=\" + lonEnc + \" splitValue=\" + splitValue;\n            }\n            leftWriter.append(latEnc, lonEnc, ord, docID);\n            nextLeftCount++;\n          } else {\n            if (splitDim == 0) {\n              assert latEnc >= splitValue: \"latEnc=\" + latEnc + \" splitValue=\" + splitValue;\n            } else {\n              assert lonEnc >= splitValue: \"lonEnc=\" + lonEnc + \" splitValue=\" + splitValue;\n            }\n            rightWriter.append(latEnc, lonEnc, ord, docID);\n          }\n        }\n        bitSet.clear(0, pointCount);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader, leftWriter, rightWriter);\n        } else {\n          IOUtils.closeWhileHandlingException(reader, leftWriter, rightWriter);\n        }\n      }\n\n      assert leftCount == nextLeftCount: \"leftCount=\" + leftCount + \" nextLeftCount=\" + nextLeftCount;\n\n      success = false;\n      try {\n        if (splitDim == 0) {\n          //if (DEBUG) System.out.println(\"  recurse left\");\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(source.writer, source.start, leftCount),\n                new PathSlice(leftWriter, 0, leftCount),\n                bitSet,\n                out,\n                minLatEnc, splitValue, minLonEnc, maxLonEnc,\n                splitValues, leafBlockFPs);\n          leftWriter.destroy();\n\n          //if (DEBUG) System.out.println(\"  recurse right\");\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(source.writer, source.start+leftCount, count-leftCount),\n                new PathSlice(rightWriter, 0, count - leftCount),\n                bitSet,\n                out,\n                splitValue, maxLatEnc, minLonEnc, maxLonEnc,\n                splitValues, leafBlockFPs);\n          rightWriter.destroy();\n        } else {\n          //if (DEBUG) System.out.println(\"  recurse left\");\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(leftWriter, 0, leftCount),\n                new PathSlice(source.writer, source.start, leftCount),\n                bitSet,\n                out,\n                minLatEnc, maxLatEnc, minLonEnc, splitValue,\n                splitValues, leafBlockFPs);\n\n          leftWriter.destroy();\n\n          //if (DEBUG) System.out.println(\"  recurse right\");\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(rightWriter, 0, count-leftCount),\n                new PathSlice(source.writer, source.start+leftCount, count-leftCount),    \n                bitSet,\n                out,\n                minLatEnc, maxLatEnc, splitValue, maxLonEnc,\n                splitValues, leafBlockFPs);\n          rightWriter.destroy();\n        }\n        success = true;\n      } finally {\n        if (success == false) {\n          try {\n            leftWriter.destroy();\n          } catch (Throwable t) {\n            // Suppress to keep throwing original exc\n          }\n          try {\n            rightWriter.destroy();\n          } catch (Throwable t) {\n            // Suppress to keep throwing original exc\n          }\n        }\n      }\n\n      splitValues[nodeID] = splitValue;\n    }\n  }\n\n","sourceOld":"  /** The incoming PathSlice for the dim we will split is already partitioned/sorted. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice lastLatSorted,\n                     PathSlice lastLonSorted,\n                     LongBitSet bitSet,\n                     IndexOutput out,\n                     int minLatEnc, int maxLatEnc, int minLonEnc, int maxLonEnc,\n                     int[] splitValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    PathSlice source;\n    PathSlice nextSource;\n\n    long latRange = (long) maxLatEnc - (long) minLatEnc;\n    long lonRange = (long) maxLonEnc - (long) minLonEnc;\n\n    assert lastLatSorted.count == lastLonSorted.count;\n\n    // Compute which dim we should split on at this level:\n    int splitDim;\n    if (latRange >= lonRange) {\n      // Split by lat:\n      splitDim = 0;\n      source = lastLatSorted;\n      nextSource = lastLonSorted;\n    } else {\n      // Split by lon:\n      splitDim = 1;\n      source = lastLonSorted;\n      nextSource = lastLatSorted;\n    }\n\n    long count = source.count;\n\n    //if (DEBUG) System.out.println(\"\\nBUILD: nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset + \" splitDim=\" + splitDim + \"\\n  lastLatSorted=\" + lastLatSorted + \"\\n  lastLonSorted=\" + lastLonSorted + \"\\n  count=\" + count + \" lat=\" + decodeLat(minLatEnc) + \" TO \" + decodeLat(maxLatEnc) + \" lon=\" + decodeLon(minLonEnc) + \" TO \" + decodeLon(maxLonEnc));\n\n    if (count == 0) {\n      // Dead end in the tree, due to adversary cases, e.g. many identical points:\n      if (nodeID < splitValues.length) {\n        // Sentinel used to mark that the tree is dead under here:\n        splitValues[nodeID] = Integer.MAX_VALUE;\n      }\n      //if (DEBUG) System.out.println(\"  dead-end sub-tree\");\n      return;\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n      //if (DEBUG) System.out.println(\"  leaf\");\n      assert maxLatEnc > minLatEnc;\n      assert maxLonEnc > minLonEnc;\n\n      //System.out.println(\"\\nleaf:\\n  lat range: \" + ((long) maxLatEnc-minLatEnc));\n      //System.out.println(\"  lon range: \" + ((long) maxLonEnc-minLonEnc));\n\n      // Sort by docID in the leaf so we get sequentiality at search time (may not matter?):\n      LatLonReader reader = source.writer.getReader(source.start);\n\n      // TODO: we can reuse this\n      int[] docIDs = new int[(int) count];\n\n      boolean success = false;\n      try {\n        for (int i=0;i<source.count;i++) {\n\n          // NOTE: we discard ord at this point; we only needed it temporarily\n          // during building to uniquely identify each point to properly handle\n          // the multi-valued case (one docID having multiple values):\n\n          // We also discard lat/lon, since at search time, we reside on the\n          // wrapped doc values for this:\n\n          boolean result = reader.next();\n          assert result;\n          docIDs[i] = reader.docID();\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader);\n        } else {\n          IOUtils.closeWhileHandlingException(reader);\n        }\n      }\n\n      Arrays.sort(docIDs);\n\n      // Dedup docIDs: for the multi-valued case where more than one value for the doc\n      // wound up in this leaf cell, we only need to store the docID once:\n      int lastDocID = -1;\n      int uniqueCount = 0;\n      for(int i=0;i<docIDs.length;i++) {\n        int docID = docIDs[i];\n        if (docID != lastDocID) {\n          uniqueCount++;\n          lastDocID = docID;\n        }\n      }\n      assert uniqueCount <= count;\n\n      long startFP = out.getFilePointer();\n      out.writeVInt(uniqueCount);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = startFP;\n      //System.out.println(\"    leafFP=\" + startFP);\n\n      lastDocID = -1;\n      for (int i=0;i<docIDs.length;i++) {\n        // Absolute int encode; with \"vInt of deltas\" encoding, the .kdd size dropped from\n        // 697 MB -> 539 MB, but query time for 225 queries went from 1.65 sec -> 2.64 sec.\n        // I think if we also indexed prefix terms here we could do less costly compression\n        // on those lists:\n        int docID = docIDs[i];\n        if (docID != lastDocID) {\n          out.writeInt(docID);\n          lastDocID = docID;\n        }\n      }\n      //long endFP = out.getFilePointer();\n      //System.out.println(\"  bytes/doc: \" + ((endFP - startFP) / count));\n    } else {\n      // Inner node: partition/recurse\n\n      assert nodeID < splitValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitValues.length;\n\n      int[] splitValueArray = new int[1];\n\n      long leftCount = markLeftTree(splitDim, source, bitSet, splitValueArray,\n                                    minLatEnc, maxLatEnc, minLonEnc, maxLonEnc);\n      int splitValue = splitValueArray[0];\n\n      // TODO: we could save split value in here so we don't have to re-open file later:\n\n      // Partition nextSource into sorted left and right sets, so we can recurse.  This is somewhat hairy: we partition the next lon set\n      // according to how we had just partitioned the lat set, and vice/versa:\n\n      LatLonWriter leftWriter = null;\n      LatLonWriter rightWriter = null;\n      LatLonReader reader = null;\n\n      boolean success = false;\n\n      int nextLeftCount = 0;\n\n      try {\n        leftWriter = getWriter(leftCount);\n        rightWriter = getWriter(count - leftCount);\n\n        //if (DEBUG) System.out.println(\"  partition:\\n    splitValueEnc=\" + splitValue + \"\\n    \" + nextSource + \"\\n      --> leftSorted=\" + leftWriter + \"\\n      --> rightSorted=\" + rightWriter + \")\");\n        reader = nextSource.writer.getReader(nextSource.start);\n\n        // TODO: we could compute the split value here for each sub-tree and save an O(N) pass on recursion, but makes code hairier and only\n        // changes the constant factor of building, not the big-oh:\n        for (int i=0;i<count;i++) {\n          boolean result = reader.next();\n          assert result;\n          int latEnc = reader.latEnc();\n          int lonEnc = reader.lonEnc();\n          long ord = reader.ord();\n          int docID = reader.docID();\n          assert docID >= 0: \"docID=\" + docID + \" reader=\" + reader;\n          if (bitSet.get(ord)) {\n            if (splitDim == 0) {\n              assert latEnc < splitValue: \"latEnc=\" + latEnc + \" splitValue=\" + splitValue;\n            } else {\n              assert lonEnc < splitValue: \"lonEnc=\" + lonEnc + \" splitValue=\" + splitValue;\n            }\n            leftWriter.append(latEnc, lonEnc, ord, docID);\n            nextLeftCount++;\n          } else {\n            if (splitDim == 0) {\n              assert latEnc >= splitValue: \"latEnc=\" + latEnc + \" splitValue=\" + splitValue;\n            } else {\n              assert lonEnc >= splitValue: \"lonEnc=\" + lonEnc + \" splitValue=\" + splitValue;\n            }\n            rightWriter.append(latEnc, lonEnc, ord, docID);\n          }\n        }\n        bitSet.clear(0, pointCount);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader, leftWriter, rightWriter);\n        } else {\n          IOUtils.closeWhileHandlingException(reader, leftWriter, rightWriter);\n        }\n      }\n\n      assert leftCount == nextLeftCount: \"leftCount=\" + leftCount + \" nextLeftCount=\" + nextLeftCount;\n\n      success = false;\n      try {\n        if (splitDim == 0) {\n          //if (DEBUG) System.out.println(\"  recurse left\");\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(source.writer, source.start, leftCount),\n                new PathSlice(leftWriter, 0, leftCount),\n                bitSet,\n                out,\n                minLatEnc, splitValue, minLonEnc, maxLonEnc,\n                splitValues, leafBlockFPs);\n          leftWriter.destroy();\n\n          //if (DEBUG) System.out.println(\"  recurse right\");\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(source.writer, source.start+leftCount, count-leftCount),\n                new PathSlice(rightWriter, 0, count - leftCount),\n                bitSet,\n                out,\n                splitValue, maxLatEnc, minLonEnc, maxLonEnc,\n                splitValues, leafBlockFPs);\n          rightWriter.destroy();\n        } else {\n          //if (DEBUG) System.out.println(\"  recurse left\");\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(leftWriter, 0, leftCount),\n                new PathSlice(source.writer, source.start, leftCount),\n                bitSet,\n                out,\n                minLatEnc, maxLatEnc, minLonEnc, splitValue,\n                splitValues, leafBlockFPs);\n\n          leftWriter.destroy();\n\n          //if (DEBUG) System.out.println(\"  recurse right\");\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(rightWriter, 0, count-leftCount),\n                new PathSlice(source.writer, source.start+leftCount, count-leftCount),    \n                bitSet,\n                out,\n                minLatEnc, maxLatEnc, splitValue, maxLonEnc,\n                splitValues, leafBlockFPs);\n          rightWriter.destroy();\n        }\n        success = true;\n      } finally {\n        if (success == false) {\n          try {\n            leftWriter.destroy();\n          } catch (Throwable t) {\n            // Suppress to keep throwing original exc\n          }\n          try {\n            rightWriter.destroy();\n          } catch (Throwable t) {\n            // Suppress to keep throwing original exc\n          }\n        }\n      }\n\n      splitValues[nodeID] = splitValue;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeWriter#build(int,int,PathSlice,PathSlice,LongBitSet,IndexOutput,int,int,int,int,int[],long[]).mjava","sourceNew":null,"sourceOld":"  /** The incoming PathSlice for the dim we will split is already partitioned/sorted. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice lastLatSorted,\n                     PathSlice lastLonSorted,\n                     LongBitSet bitSet,\n                     IndexOutput out,\n                     int minLatEnc, int maxLatEnc, int minLonEnc, int maxLonEnc,\n                     int[] splitValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    PathSlice source;\n    PathSlice nextSource;\n\n    long latRange = (long) maxLatEnc - (long) minLatEnc;\n    long lonRange = (long) maxLonEnc - (long) minLonEnc;\n\n    assert lastLatSorted.count == lastLonSorted.count;\n\n    // Compute which dim we should split on at this level:\n    int splitDim;\n    if (latRange >= lonRange) {\n      // Split by lat:\n      splitDim = 0;\n      source = lastLatSorted;\n      nextSource = lastLonSorted;\n    } else {\n      // Split by lon:\n      splitDim = 1;\n      source = lastLonSorted;\n      nextSource = lastLatSorted;\n    }\n\n    long count = source.count;\n\n    //if (DEBUG) System.out.println(\"\\nBUILD: nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset + \" splitDim=\" + splitDim + \"\\n  lastLatSorted=\" + lastLatSorted + \"\\n  lastLonSorted=\" + lastLonSorted + \"\\n  count=\" + count + \" lat=\" + decodeLat(minLatEnc) + \" TO \" + decodeLat(maxLatEnc) + \" lon=\" + decodeLon(minLonEnc) + \" TO \" + decodeLon(maxLonEnc));\n\n    if (count == 0) {\n      // Dead end in the tree, due to adversary cases, e.g. many identical points:\n      if (nodeID < splitValues.length) {\n        // Sentinel used to mark that the tree is dead under here:\n        splitValues[nodeID] = Integer.MAX_VALUE;\n      }\n      //if (DEBUG) System.out.println(\"  dead-end sub-tree\");\n      return;\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n      //if (DEBUG) System.out.println(\"  leaf\");\n      assert maxLatEnc > minLatEnc;\n      assert maxLonEnc > minLonEnc;\n\n      //System.out.println(\"\\nleaf:\\n  lat range: \" + ((long) maxLatEnc-minLatEnc));\n      //System.out.println(\"  lon range: \" + ((long) maxLonEnc-minLonEnc));\n\n      // Sort by docID in the leaf so we get sequentiality at search time (may not matter?):\n      LatLonReader reader = source.writer.getReader(source.start);\n\n      // TODO: we can reuse this\n      int[] docIDs = new int[(int) count];\n\n      boolean success = false;\n      try {\n        for (int i=0;i<source.count;i++) {\n\n          // NOTE: we discard ord at this point; we only needed it temporarily\n          // during building to uniquely identify each point to properly handle\n          // the multi-valued case (one docID having multiple values):\n\n          // We also discard lat/lon, since at search time, we reside on the\n          // wrapped doc values for this:\n\n          boolean result = reader.next();\n          assert result;\n          docIDs[i] = reader.docID();\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader);\n        } else {\n          IOUtils.closeWhileHandlingException(reader);\n        }\n      }\n\n      Arrays.sort(docIDs);\n\n      // Dedup docIDs: for the multi-valued case where more than one value for the doc\n      // wound up in this leaf cell, we only need to store the docID once:\n      int lastDocID = -1;\n      int uniqueCount = 0;\n      for(int i=0;i<docIDs.length;i++) {\n        int docID = docIDs[i];\n        if (docID != lastDocID) {\n          uniqueCount++;\n          lastDocID = docID;\n        }\n      }\n      assert uniqueCount <= count;\n\n      long startFP = out.getFilePointer();\n      out.writeVInt(uniqueCount);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = startFP;\n      //System.out.println(\"    leafFP=\" + startFP);\n\n      lastDocID = -1;\n      for (int i=0;i<docIDs.length;i++) {\n        // Absolute int encode; with \"vInt of deltas\" encoding, the .kdd size dropped from\n        // 697 MB -> 539 MB, but query time for 225 queries went from 1.65 sec -> 2.64 sec.\n        // I think if we also indexed prefix terms here we could do less costly compression\n        // on those lists:\n        int docID = docIDs[i];\n        if (docID != lastDocID) {\n          //System.out.println(\"  docID=\" + docID);\n          out.writeInt(docID);\n          lastDocID = docID;\n        }\n      }\n      //long endFP = out.getFilePointer();\n      //System.out.println(\"  bytes/doc: \" + ((endFP - startFP) / count));\n    } else {\n      // Inner node: partition/recurse\n\n      assert nodeID < splitValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitValues.length;\n\n      int[] splitValueArray = new int[1];\n\n      long leftCount = markLeftTree(splitDim, source, bitSet, splitValueArray,\n                                    minLatEnc, maxLatEnc, minLonEnc, maxLonEnc);\n      int splitValue = splitValueArray[0];\n\n      // TODO: we could save split value in here so we don't have to re-open file later:\n\n      // Partition nextSource into sorted left and right sets, so we can recurse.  This is somewhat hairy: we partition the next lon set\n      // according to how we had just partitioned the lat set, and vice/versa:\n\n      LatLonWriter leftWriter = null;\n      LatLonWriter rightWriter = null;\n      LatLonReader reader = null;\n\n      boolean success = false;\n\n      int nextLeftCount = 0;\n\n      try {\n        leftWriter = getWriter(leftCount);\n        rightWriter = getWriter(count - leftCount);\n\n        //if (DEBUG) System.out.println(\"  partition:\\n    splitValueEnc=\" + splitValue + \"\\n    \" + nextSource + \"\\n      --> leftSorted=\" + leftWriter + \"\\n      --> rightSorted=\" + rightWriter + \")\");\n        reader = nextSource.writer.getReader(nextSource.start);\n\n        // TODO: we could compute the split value here for each sub-tree and save an O(N) pass on recursion, but makes code hairier and only\n        // changes the constant factor of building, not the big-oh:\n        for (int i=0;i<count;i++) {\n          boolean result = reader.next();\n          assert result;\n          int latEnc = reader.latEnc();\n          int lonEnc = reader.lonEnc();\n          long ord = reader.ord();\n          int docID = reader.docID();\n          assert docID >= 0: \"docID=\" + docID + \" reader=\" + reader;\n          if (bitSet.get(ord)) {\n            if (splitDim == 0) {\n              assert latEnc < splitValue: \"latEnc=\" + latEnc + \" splitValue=\" + splitValue;\n            } else {\n              assert lonEnc < splitValue: \"lonEnc=\" + lonEnc + \" splitValue=\" + splitValue;\n            }\n            leftWriter.append(latEnc, lonEnc, ord, docID);\n            nextLeftCount++;\n          } else {\n            if (splitDim == 0) {\n              assert latEnc >= splitValue: \"latEnc=\" + latEnc + \" splitValue=\" + splitValue;\n            } else {\n              assert lonEnc >= splitValue: \"lonEnc=\" + lonEnc + \" splitValue=\" + splitValue;\n            }\n            rightWriter.append(latEnc, lonEnc, ord, docID);\n          }\n        }\n        bitSet.clear(0, pointCount);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader, leftWriter, rightWriter);\n        } else {\n          IOUtils.closeWhileHandlingException(reader, leftWriter, rightWriter);\n        }\n      }\n\n      assert leftCount == nextLeftCount: \"leftCount=\" + leftCount + \" nextLeftCount=\" + nextLeftCount;\n\n      success = false;\n      try {\n        if (splitDim == 0) {\n          //if (DEBUG) System.out.println(\"  recurse left\");\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(source.writer, source.start, leftCount),\n                new PathSlice(leftWriter, 0, leftCount),\n                bitSet,\n                out,\n                minLatEnc, splitValue, minLonEnc, maxLonEnc,\n                splitValues, leafBlockFPs);\n          leftWriter.destroy();\n\n          //if (DEBUG) System.out.println(\"  recurse right\");\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(source.writer, source.start+leftCount, count-leftCount),\n                new PathSlice(rightWriter, 0, count - leftCount),\n                bitSet,\n                out,\n                splitValue, maxLatEnc, minLonEnc, maxLonEnc,\n                splitValues, leafBlockFPs);\n          rightWriter.destroy();\n        } else {\n          //if (DEBUG) System.out.println(\"  recurse left\");\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(leftWriter, 0, leftCount),\n                new PathSlice(source.writer, source.start, leftCount),\n                bitSet,\n                out,\n                minLatEnc, maxLatEnc, minLonEnc, splitValue,\n                splitValues, leafBlockFPs);\n\n          leftWriter.destroy();\n\n          //if (DEBUG) System.out.println(\"  recurse right\");\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(rightWriter, 0, count-leftCount),\n                new PathSlice(source.writer, source.start+leftCount, count-leftCount),    \n                bitSet,\n                out,\n                minLatEnc, maxLatEnc, splitValue, maxLonEnc,\n                splitValues, leafBlockFPs);\n          rightWriter.destroy();\n        }\n        success = true;\n      } finally {\n        if (success == false) {\n          try {\n            leftWriter.destroy();\n          } catch (Throwable t) {\n            // Suppress to keep throwing original exc\n          }\n          try {\n            rightWriter.destroy();\n          } catch (Throwable t) {\n            // Suppress to keep throwing original exc\n          }\n        }\n      }\n\n      splitValues[nodeID] = splitValue;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8b268bd80fbb9f6c6ab5b033d2aca29588788a0e":["4e50a8c6cf9370a926c7efe6aa39429e6a18cf96"],"f64b7098768253180859cd8faeae6b1a185b06ed":["8b268bd80fbb9f6c6ab5b033d2aca29588788a0e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1904709ea0185dc04e3d77ea01c79e909caf2796":["07c50cb1eca5629cac5b6702dd0f5e06157af61a"],"07c50cb1eca5629cac5b6702dd0f5e06157af61a":["f64b7098768253180859cd8faeae6b1a185b06ed"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"4e50a8c6cf9370a926c7efe6aa39429e6a18cf96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"8b268bd80fbb9f6c6ab5b033d2aca29588788a0e":["f64b7098768253180859cd8faeae6b1a185b06ed"],"f64b7098768253180859cd8faeae6b1a185b06ed":["07c50cb1eca5629cac5b6702dd0f5e06157af61a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4e50a8c6cf9370a926c7efe6aa39429e6a18cf96"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"07c50cb1eca5629cac5b6702dd0f5e06157af61a":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"4e50a8c6cf9370a926c7efe6aa39429e6a18cf96":["8b268bd80fbb9f6c6ab5b033d2aca29588788a0e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}