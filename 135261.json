{"path":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit2().mjava","commits":[{"id":"685af99397b6da31116a2cac747ed255d217d080","date":1530038134,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit2().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testSplitAfterFailedSplit2() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureAfterReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      // should be cleaned up\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertNull(shard10);\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertNull(shard11);\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit2().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testSplitAfterFailedSplit2() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureAfterReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      // should be cleaned up\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertNull(shard10);\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertNull(shard11);\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit2().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testSplitAfterFailedSplit2() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureAfterReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      // should be cleaned up\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertNull(shard10);\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertNull(shard11);\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0bf7adf1ef036dfc4a41cfc97d66997a0d54a0ca","date":1534412996,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit2().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit2().mjava","sourceNew":"  @Test\n  public void testSplitAfterFailedSplit2() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureAfterReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      splitAfterFailedSplit();\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testSplitAfterFailedSplit2() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureAfterReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      // should be cleaned up\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertNull(shard10);\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertNull(shard11);\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit2().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit2().mjava","sourceNew":"  @Test\n  @Nightly\n  public void testSplitAfterFailedSplit2() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureAfterReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      splitAfterFailedSplit();\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testSplitAfterFailedSplit2() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureAfterReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      splitAfterFailedSplit();\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"add1e7dd742ea533ff4318cea83ca0a1f669f662","date":1585262285,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit2().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit2().mjava","sourceNew":"  @Test\n  @Nightly\n  public void testSplitAfterFailedSplit2() throws Exception {\n    waitForThingsToLevelOut(15, TimeUnit.SECONDS);\n\n    TestInjection.splitFailureAfterReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      splitAfterFailedSplit();\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":"  @Test\n  @Nightly\n  public void testSplitAfterFailedSplit2() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureAfterReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      splitAfterFailedSplit();\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","685af99397b6da31116a2cac747ed255d217d080"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["0bf7adf1ef036dfc4a41cfc97d66997a0d54a0ca"],"685af99397b6da31116a2cac747ed255d217d080":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0bf7adf1ef036dfc4a41cfc97d66997a0d54a0ca":["685af99397b6da31116a2cac747ed255d217d080"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"add1e7dd742ea533ff4318cea83ca0a1f669f662":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["add1e7dd742ea533ff4318cea83ca0a1f669f662"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","685af99397b6da31116a2cac747ed255d217d080"]},"commit2Childs":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["add1e7dd742ea533ff4318cea83ca0a1f669f662"],"685af99397b6da31116a2cac747ed255d217d080":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","0bf7adf1ef036dfc4a41cfc97d66997a0d54a0ca","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","685af99397b6da31116a2cac747ed255d217d080","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0bf7adf1ef036dfc4a41cfc97d66997a0d54a0ca":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"add1e7dd742ea533ff4318cea83ca0a1f669f662":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}