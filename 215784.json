{"path":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#ensureAllReplicasAreActive(String,int,int).mjava","commits":[{"id":"14d5815ecbef89580f5c48990bcd433f04f8563a","date":1399564106,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#ensureAllReplicasAreActive(String,int,int).mjava","pathOld":"/dev/null","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == 1); // shards == 1\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = zkr.getClusterState();\n      assertNotNull(cs);\n      for (Slice shard : cs.getActiveSlices(testCollectionName)) {\n        allReplicasUp = true; // assume true\n        Collection<Replica> replicas = shard.getReplicas();\n        assertTrue(replicas.size() == rf);\n        leader = shard.getLeader();\n        assertNotNull(leader);\n        \n        // ensure all replicas are \"active\" and identify the non-leader replica\n        for (Replica replica : replicas) {\n          String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n          if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n            log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n            allReplicasUp = false;\n          }\n          \n          if (!leader.equals(replica)) \n            notLeaders.put(replica.getName(), replica);\n        }\n        \n        if (!allReplicasUp) {\n          try {\n            Thread.sleep(500L);\n          } catch (Exception ignoreMe) {}\n          waitMs += 500L;\n        }\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas come up within \" + maxWaitMs + \" ms! ClusterState: \" + cs);\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + cs);\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["67d524cb1b29233f0dfbd6e9cba60e5aa0341dd9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"67d524cb1b29233f0dfbd6e9cba60e5aa0341dd9","date":1400695553,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#ensureAllReplicasAreActive(String,int,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#ensureAllReplicasAreActive(String,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == 1); // shards == 1\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = zkr.getClusterState();\n      assertNotNull(cs);\n      for (Slice shard : cs.getActiveSlices(testCollectionName)) {\n        allReplicasUp = true; // assume true\n        Collection<Replica> replicas = shard.getReplicas();\n        assertTrue(replicas.size() == rf);\n        leader = shard.getLeader();\n        assertNotNull(leader);\n        \n        // ensure all replicas are \"active\" and identify the non-leader replica\n        for (Replica replica : replicas) {\n          String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n          if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n            log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n            allReplicasUp = false;\n          }\n          \n          if (!leader.equals(replica)) \n            notLeaders.put(replica.getName(), replica);\n        }\n        \n        if (!allReplicasUp) {\n          try {\n            Thread.sleep(500L);\n          } catch (Exception ignoreMe) {}\n          waitMs += 500L;\n        }\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas come up within \" + maxWaitMs + \n          \" ms! ClusterState: \" + printClusterStateInfo());\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + \n         printClusterStateInfo());\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == 1); // shards == 1\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = zkr.getClusterState();\n      assertNotNull(cs);\n      for (Slice shard : cs.getActiveSlices(testCollectionName)) {\n        allReplicasUp = true; // assume true\n        Collection<Replica> replicas = shard.getReplicas();\n        assertTrue(replicas.size() == rf);\n        leader = shard.getLeader();\n        assertNotNull(leader);\n        \n        // ensure all replicas are \"active\" and identify the non-leader replica\n        for (Replica replica : replicas) {\n          String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n          if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n            log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n            allReplicasUp = false;\n          }\n          \n          if (!leader.equals(replica)) \n            notLeaders.put(replica.getName(), replica);\n        }\n        \n        if (!allReplicasUp) {\n          try {\n            Thread.sleep(500L);\n          } catch (Exception ignoreMe) {}\n          waitMs += 500L;\n        }\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas come up within \" + maxWaitMs + \" ms! ClusterState: \" + cs);\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + cs);\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","bugFix":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#ensureAllReplicasAreActive(String,int,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#ensureAllReplicasAreActive(String,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == 1); // shards == 1\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = zkr.getClusterState();\n      assertNotNull(cs);\n      for (Slice shard : cs.getActiveSlices(testCollectionName)) {\n        allReplicasUp = true; // assume true\n        Collection<Replica> replicas = shard.getReplicas();\n        assertTrue(replicas.size() == rf);\n        leader = shard.getLeader();\n        assertNotNull(leader);\n        \n        // ensure all replicas are \"active\" and identify the non-leader replica\n        for (Replica replica : replicas) {\n          String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n          if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n            log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n            allReplicasUp = false;\n          }\n          \n          if (!leader.equals(replica)) \n            notLeaders.put(replica.getName(), replica);\n        }\n        \n        if (!allReplicasUp) {\n          try {\n            Thread.sleep(500L);\n          } catch (Exception ignoreMe) {}\n          waitMs += 500L;\n        }\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas come up within \" + maxWaitMs + \n          \" ms! ClusterState: \" + printClusterStateInfo());\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + \n         printClusterStateInfo());\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == 1); // shards == 1\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = zkr.getClusterState();\n      assertNotNull(cs);\n      for (Slice shard : cs.getActiveSlices(testCollectionName)) {\n        allReplicasUp = true; // assume true\n        Collection<Replica> replicas = shard.getReplicas();\n        assertTrue(replicas.size() == rf);\n        leader = shard.getLeader();\n        assertNotNull(leader);\n        \n        // ensure all replicas are \"active\" and identify the non-leader replica\n        for (Replica replica : replicas) {\n          String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n          if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n            log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n            allReplicasUp = false;\n          }\n          \n          if (!leader.equals(replica)) \n            notLeaders.put(replica.getName(), replica);\n        }\n        \n        if (!allReplicasUp) {\n          try {\n            Thread.sleep(500L);\n          } catch (Exception ignoreMe) {}\n          waitMs += 500L;\n        }\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas come up within \" + maxWaitMs + \" ms! ClusterState: \" + cs);\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + cs);\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9043cd220362869f58e50f635c13c362f8377da","date":1404227796,"type":4,"author":"Timothy Potter","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#ensureAllReplicasAreActive(String,int,int).mjava","sourceNew":null,"sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == 1); // shards == 1\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = zkr.getClusterState();\n      assertNotNull(cs);\n      for (Slice shard : cs.getActiveSlices(testCollectionName)) {\n        allReplicasUp = true; // assume true\n        Collection<Replica> replicas = shard.getReplicas();\n        assertTrue(replicas.size() == rf);\n        leader = shard.getLeader();\n        assertNotNull(leader);\n        \n        // ensure all replicas are \"active\" and identify the non-leader replica\n        for (Replica replica : replicas) {\n          String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n          if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n            log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n            allReplicasUp = false;\n          }\n          \n          if (!leader.equals(replica)) \n            notLeaders.put(replica.getName(), replica);\n        }\n        \n        if (!allReplicasUp) {\n          try {\n            Thread.sleep(500L);\n          } catch (Exception ignoreMe) {}\n          waitMs += 500L;\n        }\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas come up within \" + maxWaitMs + \n          \" ms! ClusterState: \" + printClusterStateInfo());\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + \n         printClusterStateInfo());\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"14d5815ecbef89580f5c48990bcd433f04f8563a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b7605579001505896d48b07160075a5c8b8e128e":["14d5815ecbef89580f5c48990bcd433f04f8563a","67d524cb1b29233f0dfbd6e9cba60e5aa0341dd9"],"f9043cd220362869f58e50f635c13c362f8377da":["67d524cb1b29233f0dfbd6e9cba60e5aa0341dd9"],"67d524cb1b29233f0dfbd6e9cba60e5aa0341dd9":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f9043cd220362869f58e50f635c13c362f8377da"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["b7605579001505896d48b07160075a5c8b8e128e","67d524cb1b29233f0dfbd6e9cba60e5aa0341dd9"],"b7605579001505896d48b07160075a5c8b8e128e":[],"f9043cd220362869f58e50f635c13c362f8377da":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"67d524cb1b29233f0dfbd6e9cba60e5aa0341dd9":["b7605579001505896d48b07160075a5c8b8e128e","f9043cd220362869f58e50f635c13c362f8377da"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7605579001505896d48b07160075a5c8b8e128e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}