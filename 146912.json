{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","commits":[{"id":"8ff44d836e8863507fa8711d2b1b2dd723516ca0","date":1461653163,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (thePoint != null && edge.plane.evaluateIsZero(thePoint) && edge.startPlane.isWithin(thePoint) && edge.endPlane.isWithin(thePoint)) {\n        return false;\n      }\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n      }\n      return true;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0108af7050cbe916cac082bcce73081e33e46ce","date":1461692987,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (thePoint != null && edge.plane.evaluateIsZero(thePoint) && edge.startPlane.isWithin(thePoint) && edge.endPlane.isWithin(thePoint)) {\n        return false;\n      }\n      // If the intersection point lies on this edge, we should still be able to consider crossing points only.\n      // Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing\n      // for at least one of the two planes in order to be a legitimate crossing of the combined path.\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (thePoint != null && edge.plane.evaluateIsZero(thePoint) && edge.startPlane.isWithin(thePoint) && edge.endPlane.isWithin(thePoint)) {\n        return false;\n      }\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a","date":1461845562,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      System.err.println(\"Processing edge \"+edge);\n      // Early exit if the point is on the edge.\n      if (thePoint != null && edge.plane.evaluateIsZero(thePoint) && edge.startPlane.isWithin(thePoint) && edge.endPlane.isWithin(thePoint)) {\n        System.err.println(\" Check point is on edge: isWithin = true\");\n        return false;\n      }\n      // If the intersection point lies on this edge, we should still be able to consider crossing points only.\n      // Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing\n      // for at least one of the two planes in order to be a legitimate crossing of the combined path.\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n        System.err.println(\" All crossing points processed\");\n      } else {\n        System.err.println(\" No crossing points!\");\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (thePoint != null && edge.plane.evaluateIsZero(thePoint) && edge.startPlane.isWithin(thePoint) && edge.endPlane.isWithin(thePoint)) {\n        return false;\n      }\n      // If the intersection point lies on this edge, we should still be able to consider crossing points only.\n      // Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing\n      // for at least one of the two planes in order to be a legitimate crossing of the combined path.\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43631d6552f924eb58c0b507e3e10215c53754f8","date":1461863675,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      System.err.println(\"Processing edge \"+edge+\", startpoint=\"+edge.startPoint+\" endpoint=\"+edge.endPoint);\n      // Early exit if the point is on the edge.\n      if (thePoint != null && edge.plane.evaluateIsZero(thePoint) && edge.startPlane.isWithin(thePoint) && edge.endPlane.isWithin(thePoint)) {\n        System.err.println(\" Check point is on edge: isWithin = true\");\n        return false;\n      }\n      // If the intersection point lies on this edge, we should still be able to consider crossing points only.\n      // Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing\n      // for at least one of the two planes in order to be a legitimate crossing of the combined path.\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        System.err.println(\" check point plane = \"+travelPlane);\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        System.err.println(\" test point plane = \"+testPointPlane);\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n        System.err.println(\" All crossing points processed\");\n      } else {\n        System.err.println(\" No crossing points!\");\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      System.err.println(\"Processing edge \"+edge);\n      // Early exit if the point is on the edge.\n      if (thePoint != null && edge.plane.evaluateIsZero(thePoint) && edge.startPlane.isWithin(thePoint) && edge.endPlane.isWithin(thePoint)) {\n        System.err.println(\" Check point is on edge: isWithin = true\");\n        return false;\n      }\n      // If the intersection point lies on this edge, we should still be able to consider crossing points only.\n      // Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing\n      // for at least one of the two planes in order to be a legitimate crossing of the combined path.\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n        System.err.println(\" All crossing points processed\");\n      } else {\n        System.err.println(\" No crossing points!\");\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"414d7bcd2f513d7e7162dae022e9a9f3cd930277","date":1461885603,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      //System.err.println(\"Processing edge \"+edge+\", startpoint=\"+edge.startPoint+\" endpoint=\"+edge.endPoint);\n      // Early exit if the point is on the edge.\n      if (thePoint != null && edge.plane.evaluateIsZero(thePoint) && edge.startPlane.isWithin(thePoint) && edge.endPlane.isWithin(thePoint)) {\n        //System.err.println(\" Check point is on edge: isWithin = true\");\n        return false;\n      }\n      // If the intersection point lies on this edge, we should still be able to consider crossing points only.\n      // Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing\n      // for at least one of the two planes in order to be a legitimate crossing of the combined path.\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        //System.err.println(\" check point plane = \"+travelPlane);\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        //System.err.println(\" test point plane = \"+testPointPlane);\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n        //System.err.println(\" All crossing points processed\");\n      } else {\n        //System.err.println(\" No crossing points!\");\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      System.err.println(\"Processing edge \"+edge+\", startpoint=\"+edge.startPoint+\" endpoint=\"+edge.endPoint);\n      // Early exit if the point is on the edge.\n      if (thePoint != null && edge.plane.evaluateIsZero(thePoint) && edge.startPlane.isWithin(thePoint) && edge.endPlane.isWithin(thePoint)) {\n        System.err.println(\" Check point is on edge: isWithin = true\");\n        return false;\n      }\n      // If the intersection point lies on this edge, we should still be able to consider crossing points only.\n      // Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing\n      // for at least one of the two planes in order to be a legitimate crossing of the combined path.\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        System.err.println(\" check point plane = \"+travelPlane);\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        System.err.println(\" test point plane = \"+testPointPlane);\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n        System.err.println(\" All crossing points processed\");\n      } else {\n        System.err.println(\" No crossing points!\");\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","date":1461888019,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      //System.err.println(\"Processing edge \"+edge+\", startpoint=\"+edge.startPoint+\" endpoint=\"+edge.endPoint);\n      // Early exit if the point is on the edge.\n      if (thePoint != null && edge.plane.evaluateIsZero(thePoint) && edge.startPlane.isWithin(thePoint) && edge.endPlane.isWithin(thePoint)) {\n        //System.err.println(\" Check point is on edge: isWithin = true\");\n        return false;\n      }\n      // If the intersection point lies on this edge, we should still be able to consider crossing points only.\n      // Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing\n      // for at least one of the two planes in order to be a legitimate crossing of the combined path.\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        //System.err.println(\" check point plane = \"+travelPlane);\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        //System.err.println(\" test point plane = \"+testPointPlane);\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n        //System.err.println(\" All crossing points processed\");\n      } else {\n        //System.err.println(\" No crossing points!\");\n      }\n      return true;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      //System.err.println(\"Processing edge \"+edge+\", startpoint=\"+edge.startPoint+\" endpoint=\"+edge.endPoint);\n      // Early exit if the point is on the edge.\n      if (thePoint != null && edge.plane.evaluateIsZero(thePoint) && edge.startPlane.isWithin(thePoint) && edge.endPlane.isWithin(thePoint)) {\n        //System.err.println(\" Check point is on edge: isWithin = true\");\n        return false;\n      }\n      // If the intersection point lies on this edge, we should still be able to consider crossing points only.\n      // Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing\n      // for at least one of the two planes in order to be a legitimate crossing of the combined path.\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        //System.err.println(\" check point plane = \"+travelPlane);\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        //System.err.println(\" test point plane = \"+testPointPlane);\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n        //System.err.println(\" All crossing points processed\");\n      } else {\n        //System.err.println(\" No crossing points!\");\n      }\n      return true;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7fe41964e49958f662028ea7ed8c224e0955edae","date":1462534610,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      //System.err.println(\"Processing edge \"+edge+\", startpoint=\"+edge.startPoint+\" endpoint=\"+edge.endPoint);\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        //System.err.println(\" Check point is on edge: isWithin = true\");\n        return false;\n      }\n      // If the intersection point lies on this edge, we should still be able to consider crossing points only.\n      // Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing\n      // for at least one of the two planes in order to be a legitimate crossing of the combined path.\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        //System.err.println(\" check point plane = \"+travelPlane);\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        //System.err.println(\" test point plane = \"+testPointPlane);\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n        //System.err.println(\" All crossing points processed\");\n      } else {\n        //System.err.println(\" No crossing points!\");\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      //System.err.println(\"Processing edge \"+edge+\", startpoint=\"+edge.startPoint+\" endpoint=\"+edge.endPoint);\n      // Early exit if the point is on the edge.\n      if (thePoint != null && edge.plane.evaluateIsZero(thePoint) && edge.startPlane.isWithin(thePoint) && edge.endPlane.isWithin(thePoint)) {\n        //System.err.println(\" Check point is on edge: isWithin = true\");\n        return false;\n      }\n      // If the intersection point lies on this edge, we should still be able to consider crossing points only.\n      // Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing\n      // for at least one of the two planes in order to be a legitimate crossing of the combined path.\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        //System.err.println(\" check point plane = \"+travelPlane);\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        //System.err.println(\" test point plane = \"+testPointPlane);\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n        //System.err.println(\" All crossing points processed\");\n      } else {\n        //System.err.println(\" No crossing points!\");\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":["affd6585e0a92f8483e2f9dd579c1927505c7377"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      //System.err.println(\"Processing edge \"+edge+\", startpoint=\"+edge.startPoint+\" endpoint=\"+edge.endPoint);\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        //System.err.println(\" Check point is on edge: isWithin = true\");\n        return false;\n      }\n      // If the intersection point lies on this edge, we should still be able to consider crossing points only.\n      // Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing\n      // for at least one of the two planes in order to be a legitimate crossing of the combined path.\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        //System.err.println(\" check point plane = \"+travelPlane);\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        //System.err.println(\" test point plane = \"+testPointPlane);\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n        //System.err.println(\" All crossing points processed\");\n      } else {\n        //System.err.println(\" No crossing points!\");\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      //System.err.println(\"Processing edge \"+edge+\", startpoint=\"+edge.startPoint+\" endpoint=\"+edge.endPoint);\n      // Early exit if the point is on the edge.\n      if (thePoint != null && edge.plane.evaluateIsZero(thePoint) && edge.startPlane.isWithin(thePoint) && edge.endPlane.isWithin(thePoint)) {\n        //System.err.println(\" Check point is on edge: isWithin = true\");\n        return false;\n      }\n      // If the intersection point lies on this edge, we should still be able to consider crossing points only.\n      // Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing\n      // for at least one of the two planes in order to be a legitimate crossing of the combined path.\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        //System.err.println(\" check point plane = \"+travelPlane);\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        //System.err.println(\" test point plane = \"+testPointPlane);\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n        //System.err.println(\" All crossing points processed\");\n      } else {\n        //System.err.println(\" No crossing points!\");\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      //System.err.println(\"Processing edge \"+edge+\", startpoint=\"+edge.startPoint+\" endpoint=\"+edge.endPoint);\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        //System.err.println(\" Check point is on edge: isWithin = true\");\n        return false;\n      }\n      // If the intersection point lies on this edge, we should still be able to consider crossing points only.\n      // Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing\n      // for at least one of the two planes in order to be a legitimate crossing of the combined path.\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        //System.err.println(\" check point plane = \"+travelPlane);\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        //System.err.println(\" test point plane = \"+testPointPlane);\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n        //System.err.println(\" All crossing points processed\");\n      } else {\n        //System.err.println(\" No crossing points!\");\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      //System.err.println(\"Processing edge \"+edge+\", startpoint=\"+edge.startPoint+\" endpoint=\"+edge.endPoint);\n      // Early exit if the point is on the edge.\n      if (thePoint != null && edge.plane.evaluateIsZero(thePoint) && edge.startPlane.isWithin(thePoint) && edge.endPlane.isWithin(thePoint)) {\n        //System.err.println(\" Check point is on edge: isWithin = true\");\n        return false;\n      }\n      // If the intersection point lies on this edge, we should still be able to consider crossing points only.\n      // Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing\n      // for at least one of the two planes in order to be a legitimate crossing of the combined path.\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        //System.err.println(\" check point plane = \"+travelPlane);\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        //System.err.println(\" test point plane = \"+testPointPlane);\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n        //System.err.println(\" All crossing points processed\");\n      } else {\n        //System.err.println(\" No crossing points!\");\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b879b14da40ab73551b75835099a61e622a83d3","date":1522406622,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      //System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /*\n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n      System.out.println(\"\");\n      */\n      \n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] travelInnerCrossings = travelInsidePlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, insideTravelCutoffPlane, edge.startPlane, edge.endPlane);\n      final GeoPoint[] travelOuterCrossings = travelOutsidePlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, outsideTravelCutoffPlane, edge.startPlane, edge.endPlane);\n      final GeoPoint[] testPointInnerCrossings = testPointInsidePlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, insideTestPointCutoffPlane, edge.startPlane, edge.endPlane);\n      final GeoPoint[] testPointOuterCrossings = testPointOutsidePlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, outsideTestPointCutoffPlane, edge.startPlane, edge.endPlane);\n      \n      // If the edge goes through the inner-inner intersection point, or the outer-outer intersection point, we need to be sure we count that only once.\n      // It may appear in both lists.  Use a hash for this right now.\n      final Set<GeoPoint> countingHash = new HashSet<>(2);\n      \n      if (travelInnerCrossings != null) {\n        for (final GeoPoint crossing : travelInnerCrossings) {\n          //System.out.println(\"  Travel inner point \"+crossing);\n          countingHash.add(crossing);\n        }\n      }\n      if (testPointInnerCrossings != null) {\n        for (final GeoPoint crossing : testPointInnerCrossings) {\n          //System.out.println(\"  Test point inner point \"+crossing);\n          countingHash.add(crossing);\n        }\n      }\n      //System.out.println(\" Edge added \"+countingHash.size()+\" to innerCrossingCount\");\n      innerCrossingCount += countingHash.size();\n      \n      countingHash.clear();\n      if (travelOuterCrossings != null) {\n        for (final GeoPoint crossing : travelOuterCrossings) {\n          //System.out.println(\"  Travel outer point \"+crossing);\n          countingHash.add(crossing);\n        }\n      }\n      if (testPointOuterCrossings != null) {\n        for (final GeoPoint crossing : testPointOuterCrossings) {\n          //System.out.println(\"  Test point outer point \"+crossing);\n          countingHash.add(crossing);\n        }\n      }\n      //System.out.println(\" Edge added \"+countingHash.size()+\" to outerCrossingCount\");\n      outerCrossingCount += countingHash.size();\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      //System.err.println(\"Processing edge \"+edge+\", startpoint=\"+edge.startPoint+\" endpoint=\"+edge.endPoint);\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        //System.err.println(\" Check point is on edge: isWithin = true\");\n        return false;\n      }\n      // If the intersection point lies on this edge, we should still be able to consider crossing points only.\n      // Even if an intersection point is eliminated because it's not a crossing of one plane, it will have to be a crossing\n      // for at least one of the two planes in order to be a legitimate crossing of the combined path.\n      final GeoPoint[] crossingPoints;\n      if (isSecondLeg) {\n        //System.err.println(\" check point plane = \"+travelPlane);\n        crossingPoints = travelPlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      } else {\n        //System.err.println(\" test point plane = \"+testPointPlane);\n        crossingPoints = testPointPlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      }\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n        //System.err.println(\" All crossing points processed\");\n      } else {\n        //System.err.println(\" No crossing points!\");\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"65d6841593942b33f59f72a2448d918225940311","date":1523319192,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /*\n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n      System.out.println(\"\");\n      */\n      \n      //System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          // As a last resort, see if the edge endpoints are on either plane.  This is sometimes necessary because the\n          // intersection computation logic might not detect near-miss edges otherwise.\n          if (!travelPlane.evaluateIsZero(edge.startPoint) && !travelPlane.evaluateIsZero(edge.endPoint) &&\n            !testPointPlane.evaluateIsZero(edge.startPoint) && !testPointPlane.evaluateIsZero(edge.endPoint)) {\n            return true;\n          }\n        }\n      }\n\n      /*\n      System.out.println(\n        \" start point travel dist=\"+travelPlane.evaluate(edge.startPoint)+\"; end point travel dist=\"+travelPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel above dist=\"+travelAbovePlane.evaluate(edge.startPoint)+\"; end point travel above dist=\"+travelAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel below dist=\"+travelBelowPlane.evaluate(edge.startPoint)+\"; end point travel below dist=\"+travelBelowPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint dist=\"+testPointPlane.evaluate(edge.startPoint)+\"; end point testpoint dist=\"+testPointPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.startPoint)+\"; end point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.startPoint)+\"; end point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.endPoint));\n      */\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] travelInnerCrossings = travelInsidePlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, insideTravelCutoffPlane, edge.startPlane, edge.endPlane);\n      final GeoPoint[] travelOuterCrossings = travelOutsidePlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, outsideTravelCutoffPlane, edge.startPlane, edge.endPlane);\n      final GeoPoint[] testPointInnerCrossings = testPointInsidePlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, insideTestPointCutoffPlane, edge.startPlane, edge.endPlane);\n      final GeoPoint[] testPointOuterCrossings = testPointOutsidePlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, outsideTestPointCutoffPlane, edge.startPlane, edge.endPlane);\n      \n      // If the edge goes through the inner-inner intersection point, or the outer-outer intersection point, we need to be sure we count that only once.\n      // It may appear in both lists.  Use a hash for this right now.\n      final Set<GeoPoint> countingHash = new HashSet<>(2);\n      \n      if (travelInnerCrossings != null) {\n        for (final GeoPoint crossing : travelInnerCrossings) {\n          //System.out.println(\"  Travel inner point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; travelInsidePlane=\"+travelInsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n          countingHash.add(crossing);\n        }\n      }\n      if (testPointInnerCrossings != null) {\n        for (final GeoPoint crossing : testPointInnerCrossings) {\n          //System.out.println(\"  Test point inner point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; testPointInsidePlane=\"+testPointInsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n          countingHash.add(crossing);\n        }\n      }\n      //System.out.println(\" Edge added \"+countingHash.size()+\" to innerCrossingCount\");\n      innerCrossingCount += countingHash.size();\n      \n      countingHash.clear();\n      if (travelOuterCrossings != null) {\n        for (final GeoPoint crossing : travelOuterCrossings) {\n          //System.out.println(\"  Travel outer point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; travelOutsidePlane=\"+travelOutsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n          countingHash.add(crossing);\n        }\n      }\n      if (testPointOuterCrossings != null) {\n        for (final GeoPoint crossing : testPointOuterCrossings) {\n          //System.out.println(\"  Test point outer point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; testPointOutsidePlane=\"+testPointOutsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n          countingHash.add(crossing);\n        }\n      }\n      //System.out.println(\" Edge added \"+countingHash.size()+\" to outerCrossingCount\");\n      outerCrossingCount += countingHash.size();\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      //System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /*\n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n      System.out.println(\"\");\n      */\n      \n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] travelInnerCrossings = travelInsidePlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, insideTravelCutoffPlane, edge.startPlane, edge.endPlane);\n      final GeoPoint[] travelOuterCrossings = travelOutsidePlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, outsideTravelCutoffPlane, edge.startPlane, edge.endPlane);\n      final GeoPoint[] testPointInnerCrossings = testPointInsidePlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, insideTestPointCutoffPlane, edge.startPlane, edge.endPlane);\n      final GeoPoint[] testPointOuterCrossings = testPointOutsidePlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, outsideTestPointCutoffPlane, edge.startPlane, edge.endPlane);\n      \n      // If the edge goes through the inner-inner intersection point, or the outer-outer intersection point, we need to be sure we count that only once.\n      // It may appear in both lists.  Use a hash for this right now.\n      final Set<GeoPoint> countingHash = new HashSet<>(2);\n      \n      if (travelInnerCrossings != null) {\n        for (final GeoPoint crossing : travelInnerCrossings) {\n          //System.out.println(\"  Travel inner point \"+crossing);\n          countingHash.add(crossing);\n        }\n      }\n      if (testPointInnerCrossings != null) {\n        for (final GeoPoint crossing : testPointInnerCrossings) {\n          //System.out.println(\"  Test point inner point \"+crossing);\n          countingHash.add(crossing);\n        }\n      }\n      //System.out.println(\" Edge added \"+countingHash.size()+\" to innerCrossingCount\");\n      innerCrossingCount += countingHash.size();\n      \n      countingHash.clear();\n      if (travelOuterCrossings != null) {\n        for (final GeoPoint crossing : travelOuterCrossings) {\n          //System.out.println(\"  Travel outer point \"+crossing);\n          countingHash.add(crossing);\n        }\n      }\n      if (testPointOuterCrossings != null) {\n        for (final GeoPoint crossing : testPointOuterCrossings) {\n          //System.out.println(\"  Test point outer point \"+crossing);\n          countingHash.add(crossing);\n        }\n      }\n      //System.out.println(\" Edge added \"+countingHash.size()+\" to outerCrossingCount\");\n      outerCrossingCount += countingHash.size();\n\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1cf8d8275024d808d6f5e5a1a07e8fa2b010706a","date":1523373040,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /*\n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n      */\n      \n      //System.out.println(\"\");\n      //System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        //System.out.println(\" No intersections with travel plane...\");\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          // As a last resort, see if the edge endpoints are on either plane.  This is sometimes necessary because the\n          // intersection computation logic might not detect near-miss edges otherwise.\n          //System.out.println(\" No intersections with testpoint plane...\");\n          if (!travelPlane.evaluateIsZero(edge.startPoint) && !travelPlane.evaluateIsZero(edge.endPoint) &&\n            !testPointPlane.evaluateIsZero(edge.startPoint) && !testPointPlane.evaluateIsZero(edge.endPoint)) {\n            return true;\n          } else {\n            //System.out.println(\" Startpoint/travelPlane=\"+travelPlane.evaluate(edge.startPoint)+\" Startpoint/testPointPlane=\"+testPointPlane.evaluate(edge.startPoint));\n            //System.out.println(\" Endpoint/travelPlane=\"+travelPlane.evaluate(edge.endPoint)+\" Endpoint/testPointPlane=\"+testPointPlane.evaluate(edge.endPoint));\n          }\n        } else {\n          //System.out.println(\" Intersection found with testPoint plane...\");\n        }\n      } else {\n        //System.out.println(\" Intersection found with travel plane...\");\n      }\n\n      //System.out.println(\" Edge intersects travel or testPoint plane\");\n      /*\n      System.out.println(\n        \" start point travel dist=\"+travelPlane.evaluate(edge.startPoint)+\"; end point travel dist=\"+travelPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel above dist=\"+travelAbovePlane.evaluate(edge.startPoint)+\"; end point travel above dist=\"+travelAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel below dist=\"+travelBelowPlane.evaluate(edge.startPoint)+\"; end point travel below dist=\"+travelBelowPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint dist=\"+testPointPlane.evaluate(edge.startPoint)+\"; end point testpoint dist=\"+testPointPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.startPoint)+\"; end point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.startPoint)+\"; end point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.endPoint));\n      */\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] travelInnerCrossings = computeCrossings(travelInsidePlane, edge, checkPointCutoffPlane, insideTravelCutoffPlane);\n      final GeoPoint[] travelOuterCrossings = computeCrossings(travelOutsidePlane, edge, checkPointCutoffPlane, outsideTravelCutoffPlane);\n      final GeoPoint[] testPointInnerCrossings = computeCrossings(testPointInsidePlane, edge, testPointCutoffPlane, insideTestPointCutoffPlane);\n      final GeoPoint[] testPointOuterCrossings = computeCrossings(testPointOutsidePlane, edge, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      \n      // If the edge goes through the inner-inner intersection point, or the outer-outer intersection point, we need to be sure we count that only once.\n      // It may appear in both lists.  Use a hash for this right now.\n      final Set<GeoPoint> countingHash = new HashSet<>(2);\n      \n      if (travelInnerCrossings != null) {\n        for (final GeoPoint crossing : travelInnerCrossings) {\n          //System.out.println(\"  Travel inner point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; travelInsidePlane=\"+travelInsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n          countingHash.add(crossing);\n        }\n      }\n      if (testPointInnerCrossings != null) {\n        for (final GeoPoint crossing : testPointInnerCrossings) {\n          //System.out.println(\"  Test point inner point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; testPointInsidePlane=\"+testPointInsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n          countingHash.add(crossing);\n        }\n      }\n      //System.out.println(\" Edge added \"+countingHash.size()+\" to innerCrossingCount\");\n      innerCrossingCount += countingHash.size();\n      \n      countingHash.clear();\n      if (travelOuterCrossings != null) {\n        for (final GeoPoint crossing : travelOuterCrossings) {\n          //System.out.println(\"  Travel outer point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; travelOutsidePlane=\"+travelOutsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n          countingHash.add(crossing);\n        }\n      }\n      if (testPointOuterCrossings != null) {\n        for (final GeoPoint crossing : testPointOuterCrossings) {\n          //System.out.println(\"  Test point outer point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; testPointOutsidePlane=\"+testPointOutsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n          countingHash.add(crossing);\n        }\n      }\n      //System.out.println(\" Edge added \"+countingHash.size()+\" to outerCrossingCount\");\n      outerCrossingCount += countingHash.size();\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /*\n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n      System.out.println(\"\");\n      */\n      \n      //System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          // As a last resort, see if the edge endpoints are on either plane.  This is sometimes necessary because the\n          // intersection computation logic might not detect near-miss edges otherwise.\n          if (!travelPlane.evaluateIsZero(edge.startPoint) && !travelPlane.evaluateIsZero(edge.endPoint) &&\n            !testPointPlane.evaluateIsZero(edge.startPoint) && !testPointPlane.evaluateIsZero(edge.endPoint)) {\n            return true;\n          }\n        }\n      }\n\n      /*\n      System.out.println(\n        \" start point travel dist=\"+travelPlane.evaluate(edge.startPoint)+\"; end point travel dist=\"+travelPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel above dist=\"+travelAbovePlane.evaluate(edge.startPoint)+\"; end point travel above dist=\"+travelAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel below dist=\"+travelBelowPlane.evaluate(edge.startPoint)+\"; end point travel below dist=\"+travelBelowPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint dist=\"+testPointPlane.evaluate(edge.startPoint)+\"; end point testpoint dist=\"+testPointPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.startPoint)+\"; end point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.startPoint)+\"; end point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.endPoint));\n      */\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] travelInnerCrossings = travelInsidePlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, insideTravelCutoffPlane, edge.startPlane, edge.endPlane);\n      final GeoPoint[] travelOuterCrossings = travelOutsidePlane.findCrossings(planetModel, edge.plane, checkPointCutoffPlane, outsideTravelCutoffPlane, edge.startPlane, edge.endPlane);\n      final GeoPoint[] testPointInnerCrossings = testPointInsidePlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, insideTestPointCutoffPlane, edge.startPlane, edge.endPlane);\n      final GeoPoint[] testPointOuterCrossings = testPointOutsidePlane.findCrossings(planetModel, edge.plane, testPointCutoffPlane, outsideTestPointCutoffPlane, edge.startPlane, edge.endPlane);\n      \n      // If the edge goes through the inner-inner intersection point, or the outer-outer intersection point, we need to be sure we count that only once.\n      // It may appear in both lists.  Use a hash for this right now.\n      final Set<GeoPoint> countingHash = new HashSet<>(2);\n      \n      if (travelInnerCrossings != null) {\n        for (final GeoPoint crossing : travelInnerCrossings) {\n          //System.out.println(\"  Travel inner point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; travelInsidePlane=\"+travelInsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n          countingHash.add(crossing);\n        }\n      }\n      if (testPointInnerCrossings != null) {\n        for (final GeoPoint crossing : testPointInnerCrossings) {\n          //System.out.println(\"  Test point inner point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; testPointInsidePlane=\"+testPointInsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n          countingHash.add(crossing);\n        }\n      }\n      //System.out.println(\" Edge added \"+countingHash.size()+\" to innerCrossingCount\");\n      innerCrossingCount += countingHash.size();\n      \n      countingHash.clear();\n      if (travelOuterCrossings != null) {\n        for (final GeoPoint crossing : travelOuterCrossings) {\n          //System.out.println(\"  Travel outer point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; travelOutsidePlane=\"+travelOutsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n          countingHash.add(crossing);\n        }\n      }\n      if (testPointOuterCrossings != null) {\n        for (final GeoPoint crossing : testPointOuterCrossings) {\n          //System.out.println(\"  Test point outer point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; testPointOutsidePlane=\"+testPointOutsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n          countingHash.add(crossing);\n        }\n      }\n      //System.out.println(\" Edge added \"+countingHash.size()+\" to outerCrossingCount\");\n      outerCrossingCount += countingHash.size();\n\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d564e0296db7f80d73dd62b17710f61c85f38c50","date":1523483630,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /* \n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n      */\n      /*\n      System.out.println(\"\");\n      System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n      */\n      \n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        //System.out.println(\" No intersections with travel plane...\");\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          // As a last resort, see if the edge endpoints are on either plane.  This is sometimes necessary because the\n          // intersection computation logic might not detect near-miss edges otherwise.\n          //System.out.println(\" No intersections with testpoint plane...\");\n          if (!travelPlane.evaluateIsZero(edge.startPoint) && !travelPlane.evaluateIsZero(edge.endPoint) &&\n            !testPointPlane.evaluateIsZero(edge.startPoint) && !testPointPlane.evaluateIsZero(edge.endPoint)) {\n            return true;\n          } else {\n            //System.out.println(\" Startpoint/travelPlane=\"+travelPlane.evaluate(edge.startPoint)+\" Startpoint/testPointPlane=\"+testPointPlane.evaluate(edge.startPoint));\n            //System.out.println(\" Endpoint/travelPlane=\"+travelPlane.evaluate(edge.endPoint)+\" Endpoint/testPointPlane=\"+testPointPlane.evaluate(edge.endPoint));\n          }\n        } else {\n          //System.out.println(\" Intersection found with testPoint plane...\");\n        }\n      } else {\n        //System.out.println(\" Intersection found with travel plane...\");\n      }\n\n      //System.out.println(\" Edge intersects travel or testPoint plane\");\n      /*\n      System.out.println(\n        \" start point travel dist=\"+travelPlane.evaluate(edge.startPoint)+\"; end point travel dist=\"+travelPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel above dist=\"+travelAbovePlane.evaluate(edge.startPoint)+\"; end point travel above dist=\"+travelAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel below dist=\"+travelBelowPlane.evaluate(edge.startPoint)+\"; end point travel below dist=\"+travelBelowPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint dist=\"+testPointPlane.evaluate(edge.startPoint)+\"; end point testpoint dist=\"+testPointPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.startPoint)+\"; end point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.startPoint)+\"; end point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.endPoint));\n      */\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      //System.out.println(\" Assessing inner crossings...\");\n      innerCrossingCount += countCrossings(edge, travelInsidePlane, checkPointCutoffPlane, insideTravelCutoffPlane, testPointInsidePlane, testPointCutoffPlane, insideTestPointCutoffPlane);\n      //System.out.println(\" Assessing outer crossings...\");\n      outerCrossingCount += countCrossings(edge, travelOutsidePlane, checkPointCutoffPlane, outsideTravelCutoffPlane, testPointOutsidePlane, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      /*\n      final GeoPoint[] travelInnerCrossings = computeCrossings(travelInsidePlane, edge, checkPointCutoffPlane, insideTravelCutoffPlane);\n      final GeoPoint[] travelOuterCrossings = computeCrossings(travelOutsidePlane, edge, checkPointCutoffPlane, outsideTravelCutoffPlane);\n      final GeoPoint[] testPointInnerCrossings = computeCrossings(testPointInsidePlane, edge, testPointCutoffPlane, insideTestPointCutoffPlane);\n      final GeoPoint[] testPointOuterCrossings = computeCrossings(testPointOutsidePlane, edge, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      */\n      \n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /*\n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n      */\n      \n      //System.out.println(\"\");\n      //System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        //System.out.println(\" No intersections with travel plane...\");\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          // As a last resort, see if the edge endpoints are on either plane.  This is sometimes necessary because the\n          // intersection computation logic might not detect near-miss edges otherwise.\n          //System.out.println(\" No intersections with testpoint plane...\");\n          if (!travelPlane.evaluateIsZero(edge.startPoint) && !travelPlane.evaluateIsZero(edge.endPoint) &&\n            !testPointPlane.evaluateIsZero(edge.startPoint) && !testPointPlane.evaluateIsZero(edge.endPoint)) {\n            return true;\n          } else {\n            //System.out.println(\" Startpoint/travelPlane=\"+travelPlane.evaluate(edge.startPoint)+\" Startpoint/testPointPlane=\"+testPointPlane.evaluate(edge.startPoint));\n            //System.out.println(\" Endpoint/travelPlane=\"+travelPlane.evaluate(edge.endPoint)+\" Endpoint/testPointPlane=\"+testPointPlane.evaluate(edge.endPoint));\n          }\n        } else {\n          //System.out.println(\" Intersection found with testPoint plane...\");\n        }\n      } else {\n        //System.out.println(\" Intersection found with travel plane...\");\n      }\n\n      //System.out.println(\" Edge intersects travel or testPoint plane\");\n      /*\n      System.out.println(\n        \" start point travel dist=\"+travelPlane.evaluate(edge.startPoint)+\"; end point travel dist=\"+travelPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel above dist=\"+travelAbovePlane.evaluate(edge.startPoint)+\"; end point travel above dist=\"+travelAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel below dist=\"+travelBelowPlane.evaluate(edge.startPoint)+\"; end point travel below dist=\"+travelBelowPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint dist=\"+testPointPlane.evaluate(edge.startPoint)+\"; end point testpoint dist=\"+testPointPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.startPoint)+\"; end point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.startPoint)+\"; end point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.endPoint));\n      */\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] travelInnerCrossings = computeCrossings(travelInsidePlane, edge, checkPointCutoffPlane, insideTravelCutoffPlane);\n      final GeoPoint[] travelOuterCrossings = computeCrossings(travelOutsidePlane, edge, checkPointCutoffPlane, outsideTravelCutoffPlane);\n      final GeoPoint[] testPointInnerCrossings = computeCrossings(testPointInsidePlane, edge, testPointCutoffPlane, insideTestPointCutoffPlane);\n      final GeoPoint[] testPointOuterCrossings = computeCrossings(testPointOutsidePlane, edge, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      \n      // If the edge goes through the inner-inner intersection point, or the outer-outer intersection point, we need to be sure we count that only once.\n      // It may appear in both lists.  Use a hash for this right now.\n      final Set<GeoPoint> countingHash = new HashSet<>(2);\n      \n      if (travelInnerCrossings != null) {\n        for (final GeoPoint crossing : travelInnerCrossings) {\n          //System.out.println(\"  Travel inner point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; travelInsidePlane=\"+travelInsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n          countingHash.add(crossing);\n        }\n      }\n      if (testPointInnerCrossings != null) {\n        for (final GeoPoint crossing : testPointInnerCrossings) {\n          //System.out.println(\"  Test point inner point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; testPointInsidePlane=\"+testPointInsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n          countingHash.add(crossing);\n        }\n      }\n      //System.out.println(\" Edge added \"+countingHash.size()+\" to innerCrossingCount\");\n      innerCrossingCount += countingHash.size();\n      \n      countingHash.clear();\n      if (travelOuterCrossings != null) {\n        for (final GeoPoint crossing : travelOuterCrossings) {\n          //System.out.println(\"  Travel outer point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; travelOutsidePlane=\"+travelOutsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n          countingHash.add(crossing);\n        }\n      }\n      if (testPointOuterCrossings != null) {\n        for (final GeoPoint crossing : testPointOuterCrossings) {\n          //System.out.println(\"  Test point outer point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; testPointOutsidePlane=\"+testPointOutsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n          countingHash.add(crossing);\n        }\n      }\n      //System.out.println(\" Edge added \"+countingHash.size()+\" to outerCrossingCount\");\n      outerCrossingCount += countingHash.size();\n\n      return true;\n    }\n\n","bugFix":null,"bugIntro":["4417cae689ce0fc964a3546ded2b0ab6e374f1b0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e872ee16caf3bf386b6a55f3654fabb2840d8fc9","date":1523529572,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /*\n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n\n      System.out.println(\"\");\n      System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n      */\n      \n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        //System.out.println(\" No intersections with travel plane...\");\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          // As a last resort, see if the edge endpoints are on either plane.  This is sometimes necessary because the\n          // intersection computation logic might not detect near-miss edges otherwise.\n          //System.out.println(\" No intersections with testpoint plane...\");\n          if (!travelPlane.evaluateIsZero(edge.startPoint) && !travelPlane.evaluateIsZero(edge.endPoint) &&\n            !testPointPlane.evaluateIsZero(edge.startPoint) && !testPointPlane.evaluateIsZero(edge.endPoint)) {\n            return true;\n          } else {\n            //System.out.println(\" Startpoint/travelPlane=\"+travelPlane.evaluate(edge.startPoint)+\" Startpoint/testPointPlane=\"+testPointPlane.evaluate(edge.startPoint));\n            //System.out.println(\" Endpoint/travelPlane=\"+travelPlane.evaluate(edge.endPoint)+\" Endpoint/testPointPlane=\"+testPointPlane.evaluate(edge.endPoint));\n          }\n        } else {\n          //System.out.println(\" Intersection found with testPoint plane...\");\n        }\n      } else {\n        //System.out.println(\" Intersection found with travel plane...\");\n      }\n\n      //System.out.println(\" Edge intersects travel or testPoint plane\");\n      /*\n      System.out.println(\n        \" start point travel dist=\"+travelPlane.evaluate(edge.startPoint)+\"; end point travel dist=\"+travelPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel above dist=\"+travelAbovePlane.evaluate(edge.startPoint)+\"; end point travel above dist=\"+travelAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel below dist=\"+travelBelowPlane.evaluate(edge.startPoint)+\"; end point travel below dist=\"+travelBelowPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint dist=\"+testPointPlane.evaluate(edge.startPoint)+\"; end point testpoint dist=\"+testPointPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.startPoint)+\"; end point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.startPoint)+\"; end point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.endPoint));\n      */\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      //System.out.println(\" Assessing inner crossings...\");\n      innerCrossingCount += countCrossings(edge, travelInsidePlane, checkPointCutoffPlane, insideTravelCutoffPlane, testPointInsidePlane, testPointCutoffPlane, insideTestPointCutoffPlane);\n      //System.out.println(\" Assessing outer crossings...\");\n      outerCrossingCount += countCrossings(edge, travelOutsidePlane, checkPointCutoffPlane, outsideTravelCutoffPlane, testPointOutsidePlane, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      /*\n      final GeoPoint[] travelInnerCrossings = computeCrossings(travelInsidePlane, edge, checkPointCutoffPlane, insideTravelCutoffPlane);\n      final GeoPoint[] travelOuterCrossings = computeCrossings(travelOutsidePlane, edge, checkPointCutoffPlane, outsideTravelCutoffPlane);\n      final GeoPoint[] testPointInnerCrossings = computeCrossings(testPointInsidePlane, edge, testPointCutoffPlane, insideTestPointCutoffPlane);\n      final GeoPoint[] testPointOuterCrossings = computeCrossings(testPointOutsidePlane, edge, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      */\n      \n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /* \n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n      */\n      /*\n      System.out.println(\"\");\n      System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n      */\n      \n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        //System.out.println(\" No intersections with travel plane...\");\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          // As a last resort, see if the edge endpoints are on either plane.  This is sometimes necessary because the\n          // intersection computation logic might not detect near-miss edges otherwise.\n          //System.out.println(\" No intersections with testpoint plane...\");\n          if (!travelPlane.evaluateIsZero(edge.startPoint) && !travelPlane.evaluateIsZero(edge.endPoint) &&\n            !testPointPlane.evaluateIsZero(edge.startPoint) && !testPointPlane.evaluateIsZero(edge.endPoint)) {\n            return true;\n          } else {\n            //System.out.println(\" Startpoint/travelPlane=\"+travelPlane.evaluate(edge.startPoint)+\" Startpoint/testPointPlane=\"+testPointPlane.evaluate(edge.startPoint));\n            //System.out.println(\" Endpoint/travelPlane=\"+travelPlane.evaluate(edge.endPoint)+\" Endpoint/testPointPlane=\"+testPointPlane.evaluate(edge.endPoint));\n          }\n        } else {\n          //System.out.println(\" Intersection found with testPoint plane...\");\n        }\n      } else {\n        //System.out.println(\" Intersection found with travel plane...\");\n      }\n\n      //System.out.println(\" Edge intersects travel or testPoint plane\");\n      /*\n      System.out.println(\n        \" start point travel dist=\"+travelPlane.evaluate(edge.startPoint)+\"; end point travel dist=\"+travelPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel above dist=\"+travelAbovePlane.evaluate(edge.startPoint)+\"; end point travel above dist=\"+travelAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel below dist=\"+travelBelowPlane.evaluate(edge.startPoint)+\"; end point travel below dist=\"+travelBelowPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint dist=\"+testPointPlane.evaluate(edge.startPoint)+\"; end point testpoint dist=\"+testPointPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.startPoint)+\"; end point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.startPoint)+\"; end point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.endPoint));\n      */\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      //System.out.println(\" Assessing inner crossings...\");\n      innerCrossingCount += countCrossings(edge, travelInsidePlane, checkPointCutoffPlane, insideTravelCutoffPlane, testPointInsidePlane, testPointCutoffPlane, insideTestPointCutoffPlane);\n      //System.out.println(\" Assessing outer crossings...\");\n      outerCrossingCount += countCrossings(edge, travelOutsidePlane, checkPointCutoffPlane, outsideTravelCutoffPlane, testPointOutsidePlane, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      /*\n      final GeoPoint[] travelInnerCrossings = computeCrossings(travelInsidePlane, edge, checkPointCutoffPlane, insideTravelCutoffPlane);\n      final GeoPoint[] travelOuterCrossings = computeCrossings(travelOutsidePlane, edge, checkPointCutoffPlane, outsideTravelCutoffPlane);\n      final GeoPoint[] testPointInnerCrossings = computeCrossings(testPointInsidePlane, edge, testPointCutoffPlane, insideTestPointCutoffPlane);\n      final GeoPoint[] testPointOuterCrossings = computeCrossings(testPointOutsidePlane, edge, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      */\n      \n      return true;\n    }\n\n","bugFix":null,"bugIntro":["4417cae689ce0fc964a3546ded2b0ab6e374f1b0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"61208df9977bdd3054d6b9792eb6a18be9d32837","date":1523626771,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /*\n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n\n      System.out.println(\"\");\n      System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n      */\n\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        //System.out.println(\" No intersections with travel plane...\");\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          // As a last resort, see if the edge endpoints are on either plane.  This is sometimes necessary because the\n          // intersection computation logic might not detect near-miss edges otherwise.\n          //System.out.println(\" No intersections with testpoint plane...\");\n          if (!travelPlane.evaluateIsZero(edge.startPoint) && !travelPlane.evaluateIsZero(edge.endPoint) &&\n            !testPointPlane.evaluateIsZero(edge.startPoint) && !testPointPlane.evaluateIsZero(edge.endPoint)) {\n            return true;\n          } else {\n            //System.out.println(\" Startpoint/travelPlane=\"+travelPlane.evaluate(edge.startPoint)+\" Startpoint/testPointPlane=\"+testPointPlane.evaluate(edge.startPoint));\n            //System.out.println(\" Endpoint/travelPlane=\"+travelPlane.evaluate(edge.endPoint)+\" Endpoint/testPointPlane=\"+testPointPlane.evaluate(edge.endPoint));\n          }\n        } else {\n          //System.out.println(\" Intersection found with testPoint plane...\");\n        }\n      } else {\n        //System.out.println(\" Intersection found with travel plane...\");\n      }\n\n      //System.out.println(\" Edge intersects travel or testPoint plane\");\n      /*\n      System.out.println(\n        \" start point travel dist=\"+travelPlane.evaluate(edge.startPoint)+\"; end point travel dist=\"+travelPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel above dist=\"+travelAbovePlane.evaluate(edge.startPoint)+\"; end point travel above dist=\"+travelAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel below dist=\"+travelBelowPlane.evaluate(edge.startPoint)+\"; end point travel below dist=\"+travelBelowPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint dist=\"+testPointPlane.evaluate(edge.startPoint)+\"; end point testpoint dist=\"+testPointPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.startPoint)+\"; end point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.startPoint)+\"; end point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.endPoint));\n      */\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      //System.out.println(\" Assessing inner crossings...\");\n      innerCrossingCount += countCrossings(edge, travelInsidePlane, checkPointCutoffPlane, insideTravelCutoffPlane, testPointInsidePlane, testPointCutoffPlane, insideTestPointCutoffPlane);\n      //System.out.println(\" Assessing outer crossings...\");\n      outerCrossingCount += countCrossings(edge, travelOutsidePlane, checkPointCutoffPlane, outsideTravelCutoffPlane, testPointOutsidePlane, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      /*\n      final GeoPoint[] travelInnerCrossings = computeCrossings(travelInsidePlane, edge, checkPointCutoffPlane, insideTravelCutoffPlane);\n      final GeoPoint[] travelOuterCrossings = computeCrossings(travelOutsidePlane, edge, checkPointCutoffPlane, outsideTravelCutoffPlane);\n      final GeoPoint[] testPointInnerCrossings = computeCrossings(testPointInsidePlane, edge, testPointCutoffPlane, insideTestPointCutoffPlane);\n      final GeoPoint[] testPointOuterCrossings = computeCrossings(testPointOutsidePlane, edge, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      */\n      \n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /*\n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n\n      System.out.println(\"\");\n      System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n      */\n      \n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        //System.out.println(\" No intersections with travel plane...\");\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          // As a last resort, see if the edge endpoints are on either plane.  This is sometimes necessary because the\n          // intersection computation logic might not detect near-miss edges otherwise.\n          //System.out.println(\" No intersections with testpoint plane...\");\n          if (!travelPlane.evaluateIsZero(edge.startPoint) && !travelPlane.evaluateIsZero(edge.endPoint) &&\n            !testPointPlane.evaluateIsZero(edge.startPoint) && !testPointPlane.evaluateIsZero(edge.endPoint)) {\n            return true;\n          } else {\n            //System.out.println(\" Startpoint/travelPlane=\"+travelPlane.evaluate(edge.startPoint)+\" Startpoint/testPointPlane=\"+testPointPlane.evaluate(edge.startPoint));\n            //System.out.println(\" Endpoint/travelPlane=\"+travelPlane.evaluate(edge.endPoint)+\" Endpoint/testPointPlane=\"+testPointPlane.evaluate(edge.endPoint));\n          }\n        } else {\n          //System.out.println(\" Intersection found with testPoint plane...\");\n        }\n      } else {\n        //System.out.println(\" Intersection found with travel plane...\");\n      }\n\n      //System.out.println(\" Edge intersects travel or testPoint plane\");\n      /*\n      System.out.println(\n        \" start point travel dist=\"+travelPlane.evaluate(edge.startPoint)+\"; end point travel dist=\"+travelPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel above dist=\"+travelAbovePlane.evaluate(edge.startPoint)+\"; end point travel above dist=\"+travelAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel below dist=\"+travelBelowPlane.evaluate(edge.startPoint)+\"; end point travel below dist=\"+travelBelowPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint dist=\"+testPointPlane.evaluate(edge.startPoint)+\"; end point testpoint dist=\"+testPointPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.startPoint)+\"; end point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.startPoint)+\"; end point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.endPoint));\n      */\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      //System.out.println(\" Assessing inner crossings...\");\n      innerCrossingCount += countCrossings(edge, travelInsidePlane, checkPointCutoffPlane, insideTravelCutoffPlane, testPointInsidePlane, testPointCutoffPlane, insideTestPointCutoffPlane);\n      //System.out.println(\" Assessing outer crossings...\");\n      outerCrossingCount += countCrossings(edge, travelOutsidePlane, checkPointCutoffPlane, outsideTravelCutoffPlane, testPointOutsidePlane, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      /*\n      final GeoPoint[] travelInnerCrossings = computeCrossings(travelInsidePlane, edge, checkPointCutoffPlane, insideTravelCutoffPlane);\n      final GeoPoint[] travelOuterCrossings = computeCrossings(travelOutsidePlane, edge, checkPointCutoffPlane, outsideTravelCutoffPlane);\n      final GeoPoint[] testPointInnerCrossings = computeCrossings(testPointInsidePlane, edge, testPointCutoffPlane, insideTestPointCutoffPlane);\n      final GeoPoint[] testPointOuterCrossings = computeCrossings(testPointOutsidePlane, edge, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      */\n      \n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4417cae689ce0fc964a3546ded2b0ab6e374f1b0","date":1523635542,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /*\n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n      */\n      \n      //System.out.println(\"\");\n      //System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        //System.out.println(\" No intersections with travel plane...\");\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          // As a last resort, see if the edge endpoints are on either plane.  This is sometimes necessary because the\n          // intersection computation logic might not detect near-miss edges otherwise.\n          //System.out.println(\" No intersections with testpoint plane...\");\n          if (!travelPlane.evaluateIsZero(edge.startPoint) && !travelPlane.evaluateIsZero(edge.endPoint) &&\n            !testPointPlane.evaluateIsZero(edge.startPoint) && !testPointPlane.evaluateIsZero(edge.endPoint)) {\n            return true;\n          } else {\n            //System.out.println(\" Startpoint/travelPlane=\"+travelPlane.evaluate(edge.startPoint)+\" Startpoint/testPointPlane=\"+testPointPlane.evaluate(edge.startPoint));\n            //System.out.println(\" Endpoint/travelPlane=\"+travelPlane.evaluate(edge.endPoint)+\" Endpoint/testPointPlane=\"+testPointPlane.evaluate(edge.endPoint));\n          }\n        } else {\n          //System.out.println(\" Intersection found with testPoint plane...\");\n        }\n      } else {\n        //System.out.println(\" Intersection found with travel plane...\");\n      }\n\n      //System.out.println(\" Edge intersects travel or testPoint plane\");\n      /*\n      System.out.println(\n        \" start point travel dist=\"+travelPlane.evaluate(edge.startPoint)+\"; end point travel dist=\"+travelPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel above dist=\"+travelAbovePlane.evaluate(edge.startPoint)+\"; end point travel above dist=\"+travelAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel below dist=\"+travelBelowPlane.evaluate(edge.startPoint)+\"; end point travel below dist=\"+travelBelowPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint dist=\"+testPointPlane.evaluate(edge.startPoint)+\"; end point testpoint dist=\"+testPointPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.startPoint)+\"; end point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.startPoint)+\"; end point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.endPoint));\n      */\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      //System.out.println(\" Assessing inner crossings...\");\n      innerCrossingCount += countCrossings(edge, travelInsidePlane, checkPointCutoffPlane, insideTravelCutoffPlane, testPointInsidePlane, testPointCutoffPlane, insideTestPointCutoffPlane);\n      //System.out.println(\" Assessing outer crossings...\");\n      outerCrossingCount += countCrossings(edge, travelOutsidePlane, checkPointCutoffPlane, outsideTravelCutoffPlane, testPointOutsidePlane, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      /*\n      final GeoPoint[] travelInnerCrossings = computeCrossings(travelInsidePlane, edge, checkPointCutoffPlane, insideTravelCutoffPlane);\n      final GeoPoint[] travelOuterCrossings = computeCrossings(travelOutsidePlane, edge, checkPointCutoffPlane, outsideTravelCutoffPlane);\n      final GeoPoint[] testPointInnerCrossings = computeCrossings(testPointInsidePlane, edge, testPointCutoffPlane, insideTestPointCutoffPlane);\n      final GeoPoint[] testPointOuterCrossings = computeCrossings(testPointOutsidePlane, edge, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      */\n      \n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /*\n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n\n      System.out.println(\"\");\n      System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n      */\n\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        //System.out.println(\" No intersections with travel plane...\");\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          // As a last resort, see if the edge endpoints are on either plane.  This is sometimes necessary because the\n          // intersection computation logic might not detect near-miss edges otherwise.\n          //System.out.println(\" No intersections with testpoint plane...\");\n          if (!travelPlane.evaluateIsZero(edge.startPoint) && !travelPlane.evaluateIsZero(edge.endPoint) &&\n            !testPointPlane.evaluateIsZero(edge.startPoint) && !testPointPlane.evaluateIsZero(edge.endPoint)) {\n            return true;\n          } else {\n            //System.out.println(\" Startpoint/travelPlane=\"+travelPlane.evaluate(edge.startPoint)+\" Startpoint/testPointPlane=\"+testPointPlane.evaluate(edge.startPoint));\n            //System.out.println(\" Endpoint/travelPlane=\"+travelPlane.evaluate(edge.endPoint)+\" Endpoint/testPointPlane=\"+testPointPlane.evaluate(edge.endPoint));\n          }\n        } else {\n          //System.out.println(\" Intersection found with testPoint plane...\");\n        }\n      } else {\n        //System.out.println(\" Intersection found with travel plane...\");\n      }\n\n      //System.out.println(\" Edge intersects travel or testPoint plane\");\n      /*\n      System.out.println(\n        \" start point travel dist=\"+travelPlane.evaluate(edge.startPoint)+\"; end point travel dist=\"+travelPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel above dist=\"+travelAbovePlane.evaluate(edge.startPoint)+\"; end point travel above dist=\"+travelAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel below dist=\"+travelBelowPlane.evaluate(edge.startPoint)+\"; end point travel below dist=\"+travelBelowPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint dist=\"+testPointPlane.evaluate(edge.startPoint)+\"; end point testpoint dist=\"+testPointPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.startPoint)+\"; end point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.startPoint)+\"; end point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.endPoint));\n      */\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      //System.out.println(\" Assessing inner crossings...\");\n      innerCrossingCount += countCrossings(edge, travelInsidePlane, checkPointCutoffPlane, insideTravelCutoffPlane, testPointInsidePlane, testPointCutoffPlane, insideTestPointCutoffPlane);\n      //System.out.println(\" Assessing outer crossings...\");\n      outerCrossingCount += countCrossings(edge, travelOutsidePlane, checkPointCutoffPlane, outsideTravelCutoffPlane, testPointOutsidePlane, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      /*\n      final GeoPoint[] travelInnerCrossings = computeCrossings(travelInsidePlane, edge, checkPointCutoffPlane, insideTravelCutoffPlane);\n      final GeoPoint[] travelOuterCrossings = computeCrossings(travelOutsidePlane, edge, checkPointCutoffPlane, outsideTravelCutoffPlane);\n      final GeoPoint[] testPointInnerCrossings = computeCrossings(testPointInsidePlane, edge, testPointCutoffPlane, insideTestPointCutoffPlane);\n      final GeoPoint[] testPointOuterCrossings = computeCrossings(testPointOutsidePlane, edge, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      */\n      \n      return true;\n    }\n\n","bugFix":["d564e0296db7f80d73dd62b17710f61c85f38c50","e872ee16caf3bf386b6a55f3654fabb2840d8fc9"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"affd6585e0a92f8483e2f9dd579c1927505c7377","date":1523947544,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /*\n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n      */\n      \n      //System.out.println(\"\");\n      //System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        //System.out.println(\" No intersections with travel plane...\");\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          // As a last resort, see if the edge endpoints are on either plane.  This is sometimes necessary because the\n          // intersection computation logic might not detect near-miss edges otherwise.\n          //System.out.println(\" No intersections with testpoint plane...\");\n          if (!travelPlane.evaluateIsZero(edge.startPoint) && !travelPlane.evaluateIsZero(edge.endPoint) &&\n            !testPointPlane.evaluateIsZero(edge.startPoint) && !testPointPlane.evaluateIsZero(edge.endPoint)) {\n            return true;\n          } else {\n            //System.out.println(\" Startpoint/travelPlane=\"+travelPlane.evaluate(edge.startPoint)+\" Startpoint/testPointPlane=\"+testPointPlane.evaluate(edge.startPoint));\n            //System.out.println(\" Endpoint/travelPlane=\"+travelPlane.evaluate(edge.endPoint)+\" Endpoint/testPointPlane=\"+testPointPlane.evaluate(edge.endPoint));\n          }\n        } else {\n          //System.out.println(\" Intersection found with testPoint plane...\");\n        }\n      } else {\n        //System.out.println(\" Intersection found with travel plane...\");\n      }\n\n      //System.out.println(\" Edge intersects travel or testPoint plane\");\n      /*\n      System.out.println(\n        \" start point travel dist=\"+travelPlane.evaluate(edge.startPoint)+\"; end point travel dist=\"+travelPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel above dist=\"+travelAbovePlane.evaluate(edge.startPoint)+\"; end point travel above dist=\"+travelAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel below dist=\"+travelBelowPlane.evaluate(edge.startPoint)+\"; end point travel below dist=\"+travelBelowPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint dist=\"+testPointPlane.evaluate(edge.startPoint)+\"; end point testpoint dist=\"+testPointPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.startPoint)+\"; end point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.startPoint)+\"; end point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.endPoint));\n      */\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      //System.out.println(\" Assessing inner crossings...\");\n      innerCrossingCount += countCrossings(edge, travelInsidePlane, checkPointCutoffPlane, insideTravelCutoffPlane, testPointInsidePlane, testPointCutoffPlane, insideTestPointCutoffPlane);\n      //System.out.println(\" Assessing outer crossings...\");\n      outerCrossingCount += countCrossings(edge, travelOutsidePlane, checkPointCutoffPlane, outsideTravelCutoffPlane, testPointOutsidePlane, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      /*\n      final GeoPoint[] travelInnerCrossings = computeCrossings(travelInsidePlane, edge, checkPointCutoffPlane, insideTravelCutoffPlane);\n      final GeoPoint[] travelOuterCrossings = computeCrossings(travelOutsidePlane, edge, checkPointCutoffPlane, outsideTravelCutoffPlane);\n      final GeoPoint[] testPointInnerCrossings = computeCrossings(testPointInsidePlane, edge, testPointCutoffPlane, insideTestPointCutoffPlane);\n      final GeoPoint[] testPointOuterCrossings = computeCrossings(testPointOutsidePlane, edge, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      */\n      \n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /*\n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n      */\n      \n      //System.out.println(\"\");\n      //System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        //System.out.println(\" No intersections with travel plane...\");\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          // As a last resort, see if the edge endpoints are on either plane.  This is sometimes necessary because the\n          // intersection computation logic might not detect near-miss edges otherwise.\n          //System.out.println(\" No intersections with testpoint plane...\");\n          if (!travelPlane.evaluateIsZero(edge.startPoint) && !travelPlane.evaluateIsZero(edge.endPoint) &&\n            !testPointPlane.evaluateIsZero(edge.startPoint) && !testPointPlane.evaluateIsZero(edge.endPoint)) {\n            return true;\n          } else {\n            //System.out.println(\" Startpoint/travelPlane=\"+travelPlane.evaluate(edge.startPoint)+\" Startpoint/testPointPlane=\"+testPointPlane.evaluate(edge.startPoint));\n            //System.out.println(\" Endpoint/travelPlane=\"+travelPlane.evaluate(edge.endPoint)+\" Endpoint/testPointPlane=\"+testPointPlane.evaluate(edge.endPoint));\n          }\n        } else {\n          //System.out.println(\" Intersection found with testPoint plane...\");\n        }\n      } else {\n        //System.out.println(\" Intersection found with travel plane...\");\n      }\n\n      //System.out.println(\" Edge intersects travel or testPoint plane\");\n      /*\n      System.out.println(\n        \" start point travel dist=\"+travelPlane.evaluate(edge.startPoint)+\"; end point travel dist=\"+travelPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel above dist=\"+travelAbovePlane.evaluate(edge.startPoint)+\"; end point travel above dist=\"+travelAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel below dist=\"+travelBelowPlane.evaluate(edge.startPoint)+\"; end point travel below dist=\"+travelBelowPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint dist=\"+testPointPlane.evaluate(edge.startPoint)+\"; end point testpoint dist=\"+testPointPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.startPoint)+\"; end point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.startPoint)+\"; end point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.endPoint));\n      */\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      //System.out.println(\" Assessing inner crossings...\");\n      innerCrossingCount += countCrossings(edge, travelInsidePlane, checkPointCutoffPlane, insideTravelCutoffPlane, testPointInsidePlane, testPointCutoffPlane, insideTestPointCutoffPlane);\n      //System.out.println(\" Assessing outer crossings...\");\n      outerCrossingCount += countCrossings(edge, travelOutsidePlane, checkPointCutoffPlane, outsideTravelCutoffPlane, testPointOutsidePlane, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      /*\n      final GeoPoint[] travelInnerCrossings = computeCrossings(travelInsidePlane, edge, checkPointCutoffPlane, insideTravelCutoffPlane);\n      final GeoPoint[] travelOuterCrossings = computeCrossings(travelOutsidePlane, edge, checkPointCutoffPlane, outsideTravelCutoffPlane);\n      final GeoPoint[] testPointInnerCrossings = computeCrossings(testPointInsidePlane, edge, testPointCutoffPlane, insideTestPointCutoffPlane);\n      final GeoPoint[] testPointOuterCrossings = computeCrossings(testPointOutsidePlane, edge, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      */\n      \n      return true;\n    }\n\n","bugFix":["7fe41964e49958f662028ea7ed8c224e0955edae"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"039615f2ceafe5881c61222281f45a0631b90174","date":1524725949,"type":4,"author":"Karl Wright","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","sourceNew":null,"sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /*\n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n      */\n      \n      //System.out.println(\"\");\n      //System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        //System.out.println(\" No intersections with travel plane...\");\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          // As a last resort, see if the edge endpoints are on either plane.  This is sometimes necessary because the\n          // intersection computation logic might not detect near-miss edges otherwise.\n          //System.out.println(\" No intersections with testpoint plane...\");\n          if (!travelPlane.evaluateIsZero(edge.startPoint) && !travelPlane.evaluateIsZero(edge.endPoint) &&\n            !testPointPlane.evaluateIsZero(edge.startPoint) && !testPointPlane.evaluateIsZero(edge.endPoint)) {\n            return true;\n          } else {\n            //System.out.println(\" Startpoint/travelPlane=\"+travelPlane.evaluate(edge.startPoint)+\" Startpoint/testPointPlane=\"+testPointPlane.evaluate(edge.startPoint));\n            //System.out.println(\" Endpoint/travelPlane=\"+travelPlane.evaluate(edge.endPoint)+\" Endpoint/testPointPlane=\"+testPointPlane.evaluate(edge.endPoint));\n          }\n        } else {\n          //System.out.println(\" Intersection found with testPoint plane...\");\n        }\n      } else {\n        //System.out.println(\" Intersection found with travel plane...\");\n      }\n\n      //System.out.println(\" Edge intersects travel or testPoint plane\");\n      /*\n      System.out.println(\n        \" start point travel dist=\"+travelPlane.evaluate(edge.startPoint)+\"; end point travel dist=\"+travelPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel above dist=\"+travelAbovePlane.evaluate(edge.startPoint)+\"; end point travel above dist=\"+travelAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel below dist=\"+travelBelowPlane.evaluate(edge.startPoint)+\"; end point travel below dist=\"+travelBelowPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint dist=\"+testPointPlane.evaluate(edge.startPoint)+\"; end point testpoint dist=\"+testPointPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.startPoint)+\"; end point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.startPoint)+\"; end point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.endPoint));\n      */\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      //System.out.println(\" Assessing inner crossings...\");\n      innerCrossingCount += countCrossings(edge, travelInsidePlane, checkPointCutoffPlane, insideTravelCutoffPlane, testPointInsidePlane, testPointCutoffPlane, insideTestPointCutoffPlane);\n      //System.out.println(\" Assessing outer crossings...\");\n      outerCrossingCount += countCrossings(edge, travelOutsidePlane, checkPointCutoffPlane, outsideTravelCutoffPlane, testPointOutsidePlane, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      /*\n      final GeoPoint[] travelInnerCrossings = computeCrossings(travelInsidePlane, edge, checkPointCutoffPlane, insideTravelCutoffPlane);\n      final GeoPoint[] travelOuterCrossings = computeCrossings(travelOutsidePlane, edge, checkPointCutoffPlane, outsideTravelCutoffPlane);\n      final GeoPoint[] testPointInnerCrossings = computeCrossings(testPointInsidePlane, edge, testPointCutoffPlane, insideTestPointCutoffPlane);\n      final GeoPoint[] testPointOuterCrossings = computeCrossings(testPointOutsidePlane, edge, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      */\n      \n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e456381ade0a256838cbf558702284e345c8d3d6","date":1524920804,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#matches(Edge).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge, in which case we accidentally discovered the answer.\n      if (edge.isWithin(thePointX, thePointY, thePointZ)) {\n        onEdge = true;\n        return false;\n      }\n      \n      // All edges that touch the travel planes get assessed the same.  So, for each intersecting edge on both legs:\n      // (1) If the edge contains the intersection point, we analyze it on only one leg.  For the other leg, we do nothing.\n      // (2) We compute the crossings of the edge with ALL FOUR inner and outer bounding planes.\n      // (3) We add the numbers of each kind of crossing to the total for that class of crossing (innerTotal and outerTotal).\n      // (4) When done all edges tallied in this way, we take min(innerTotal, outerTotal) and assume that is the number of crossings.\n      //\n      // Q: What if we see the same edge in both traversals?\n      // A: We should really evaluate it only in one.  Keep a hash of the edges we've looked at already and don't process edges twice.\n\n      // Every edge should be looked at only once.\n      if (seenEdges != null && seenEdges.contains(edge)) {\n        return true;\n      }\n      if (seenEdges == null) {\n        seenEdges = new HashSet<>();\n      }\n      seenEdges.add(edge);\n      \n      // We've never seen this edge before.  Evaluate it in the context of inner and outer planes.\n      computeInsideOutside();\n\n      /*\n      System.out.println(\"\\nThe following edges should intersect the travel/testpoint planes:\");\n      Edge thisEdge = edge;\n      while (true) {\n        final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, thisEdge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (travelCrossings == null || travelCrossings.length > 0) {\n          System.out.println(\"Travel plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, thisEdge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, thisEdge.startPlane, thisEdge.endPlane);\n        if (testPointCrossings == null || testPointCrossings.length > 0) {\n          System.out.println(\"Test point plane: \"+thisEdge.startPoint+\" -> \"+thisEdge.endPoint);\n        }\n        thisEdge = thisEdge.next;\n        if (thisEdge == edge) {\n          break;\n        }\n      }\n      */\n      \n      //System.out.println(\"\");\n      //System.out.println(\"Considering edge \"+(edge.startPoint)+\" -> \"+(edge.endPoint));\n\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n      if (travelCrossings != null && travelCrossings.length == 0) {\n        //System.out.println(\" No intersections with travel plane...\");\n        final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n        if (testPointCrossings != null && testPointCrossings.length == 0) {\n          // As a last resort, see if the edge endpoints are on either plane.  This is sometimes necessary because the\n          // intersection computation logic might not detect near-miss edges otherwise.\n          //System.out.println(\" No intersections with testpoint plane...\");\n          if (!travelPlane.evaluateIsZero(edge.startPoint) && !travelPlane.evaluateIsZero(edge.endPoint) &&\n            !testPointPlane.evaluateIsZero(edge.startPoint) && !testPointPlane.evaluateIsZero(edge.endPoint)) {\n            return true;\n          } else {\n            //System.out.println(\" Startpoint/travelPlane=\"+travelPlane.evaluate(edge.startPoint)+\" Startpoint/testPointPlane=\"+testPointPlane.evaluate(edge.startPoint));\n            //System.out.println(\" Endpoint/travelPlane=\"+travelPlane.evaluate(edge.endPoint)+\" Endpoint/testPointPlane=\"+testPointPlane.evaluate(edge.endPoint));\n          }\n        } else {\n          //System.out.println(\" Intersection found with testPoint plane...\");\n        }\n      } else {\n        //System.out.println(\" Intersection found with travel plane...\");\n      }\n\n      //System.out.println(\" Edge intersects travel or testPoint plane\");\n      /*\n      System.out.println(\n        \" start point travel dist=\"+travelPlane.evaluate(edge.startPoint)+\"; end point travel dist=\"+travelPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel above dist=\"+travelAbovePlane.evaluate(edge.startPoint)+\"; end point travel above dist=\"+travelAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point travel below dist=\"+travelBelowPlane.evaluate(edge.startPoint)+\"; end point travel below dist=\"+travelBelowPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint dist=\"+testPointPlane.evaluate(edge.startPoint)+\"; end point testpoint dist=\"+testPointPlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.startPoint)+\"; end point testpoint above dist=\"+testPointAbovePlane.evaluate(edge.endPoint));\n      System.out.println(\n        \" start point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.startPoint)+\"; end point testpoint below dist=\"+testPointBelowPlane.evaluate(edge.endPoint));\n      */\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      //System.out.println(\" Assessing inner crossings...\");\n      innerCrossingCount += countCrossings(edge, travelInsidePlane, checkPointCutoffPlane, insideTravelCutoffPlane, testPointInsidePlane, testPointCutoffPlane, insideTestPointCutoffPlane);\n      //System.out.println(\" Assessing outer crossings...\");\n      outerCrossingCount += countCrossings(edge, travelOutsidePlane, checkPointCutoffPlane, outsideTravelCutoffPlane, testPointOutsidePlane, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      /*\n      final GeoPoint[] travelInnerCrossings = computeCrossings(travelInsidePlane, edge, checkPointCutoffPlane, insideTravelCutoffPlane);\n      final GeoPoint[] travelOuterCrossings = computeCrossings(travelOutsidePlane, edge, checkPointCutoffPlane, outsideTravelCutoffPlane);\n      final GeoPoint[] testPointInnerCrossings = computeCrossings(testPointInsidePlane, edge, testPointCutoffPlane, insideTestPointCutoffPlane);\n      final GeoPoint[] testPointOuterCrossings = computeCrossings(testPointOutsidePlane, edge, testPointCutoffPlane, outsideTestPointCutoffPlane);\n      */\n      \n      return true;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1cf8d8275024d808d6f5e5a1a07e8fa2b010706a":["65d6841593942b33f59f72a2448d918225940311"],"8b879b14da40ab73551b75835099a61e622a83d3":["7fe41964e49958f662028ea7ed8c224e0955edae"],"e456381ade0a256838cbf558702284e345c8d3d6":["039615f2ceafe5881c61222281f45a0631b90174"],"d564e0296db7f80d73dd62b17710f61c85f38c50":["1cf8d8275024d808d6f5e5a1a07e8fa2b010706a"],"43631d6552f924eb58c0b507e3e10215c53754f8":["5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a"],"4417cae689ce0fc964a3546ded2b0ab6e374f1b0":["61208df9977bdd3054d6b9792eb6a18be9d32837"],"61208df9977bdd3054d6b9792eb6a18be9d32837":["e872ee16caf3bf386b6a55f3654fabb2840d8fc9"],"65d6841593942b33f59f72a2448d918225940311":["8b879b14da40ab73551b75835099a61e622a83d3"],"e872ee16caf3bf386b6a55f3654fabb2840d8fc9":["d564e0296db7f80d73dd62b17710f61c85f38c50"],"039615f2ceafe5881c61222281f45a0631b90174":["affd6585e0a92f8483e2f9dd579c1927505c7377"],"8ff44d836e8863507fa8711d2b1b2dd723516ca0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"affd6585e0a92f8483e2f9dd579c1927505c7377":["4417cae689ce0fc964a3546ded2b0ab6e374f1b0"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["55b50463286869f584cf849d1587a0fcd54d1dfa","7fe41964e49958f662028ea7ed8c224e0955edae"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"a0108af7050cbe916cac082bcce73081e33e46ce":["8ff44d836e8863507fa8711d2b1b2dd723516ca0"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","7fe41964e49958f662028ea7ed8c224e0955edae"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","414d7bcd2f513d7e7162dae022e9a9f3cd930277"],"414d7bcd2f513d7e7162dae022e9a9f3cd930277":["43631d6552f924eb58c0b507e3e10215c53754f8"],"7fe41964e49958f662028ea7ed8c224e0955edae":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a":["a0108af7050cbe916cac082bcce73081e33e46ce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e456381ade0a256838cbf558702284e345c8d3d6"]},"commit2Childs":{"1cf8d8275024d808d6f5e5a1a07e8fa2b010706a":["d564e0296db7f80d73dd62b17710f61c85f38c50"],"8b879b14da40ab73551b75835099a61e622a83d3":["65d6841593942b33f59f72a2448d918225940311"],"e456381ade0a256838cbf558702284e345c8d3d6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d564e0296db7f80d73dd62b17710f61c85f38c50":["e872ee16caf3bf386b6a55f3654fabb2840d8fc9"],"43631d6552f924eb58c0b507e3e10215c53754f8":["414d7bcd2f513d7e7162dae022e9a9f3cd930277"],"65d6841593942b33f59f72a2448d918225940311":["1cf8d8275024d808d6f5e5a1a07e8fa2b010706a"],"4417cae689ce0fc964a3546ded2b0ab6e374f1b0":["affd6585e0a92f8483e2f9dd579c1927505c7377"],"61208df9977bdd3054d6b9792eb6a18be9d32837":["4417cae689ce0fc964a3546ded2b0ab6e374f1b0"],"e872ee16caf3bf386b6a55f3654fabb2840d8fc9":["61208df9977bdd3054d6b9792eb6a18be9d32837"],"039615f2ceafe5881c61222281f45a0631b90174":["e456381ade0a256838cbf558702284e345c8d3d6"],"8ff44d836e8863507fa8711d2b1b2dd723516ca0":["a0108af7050cbe916cac082bcce73081e33e46ce"],"affd6585e0a92f8483e2f9dd579c1927505c7377":["039615f2ceafe5881c61222281f45a0631b90174"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0108af7050cbe916cac082bcce73081e33e46ce":["5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8ff44d836e8863507fa8711d2b1b2dd723516ca0","55b50463286869f584cf849d1587a0fcd54d1dfa","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["55b50463286869f584cf849d1587a0fcd54d1dfa","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","7fe41964e49958f662028ea7ed8c224e0955edae"],"414d7bcd2f513d7e7162dae022e9a9f3cd930277":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"7fe41964e49958f662028ea7ed8c224e0955edae":["8b879b14da40ab73551b75835099a61e622a83d3","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904"],"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a":["43631d6552f924eb58c0b507e3e10215c53754f8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}