{"path":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","commits":[{"id":"4cf7d991c51b580d4b7bf2ad583dba058c0a2dd1","date":1310612214,"type":1,"author":"Christopher John Male","isMerge":false,"pathNew":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    init();\n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericField.DataType type : NumericField.DataType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n      \n      NumericField field = new NumericField(type.name(), PRECISION_STEP,\n          Field.Store.YES, true);\n      \n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n      \n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericField.DataType.LONG));\n    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP,\n        Field.Store.YES, true);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n\n//  SimpleDateFormat df = new SimpleDateFormat( \n//      \"yyyy.MM.dd G 'at' HH:mm:ss z\", LOCALE.ENGLISH);\n// assumes localized date pattern will have at least year, month, day, hour, minute\n  SimpleDateFormat df = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n      randomDateStyle(random), randomDateStyle(random), LOCALE.ENGLISH);\n  System.out.println(df.toPattern());\n  // most of date pattern do not include era, so we add it here. Also,\n  // sometimes second is not available, we make sure it's present too\n  df.applyPattern(df.toPattern() + \" G s Z yyyy\");\n  df.setTimeZone(TIMEZONE);\n  System.out.println(TIMEZONE);\n  System.out.println(TIMEZONE);\n  System.out.println(TIMEZONE);\n  long l1 = 0;\n  long l2 = -30000;\n  String d1 = df.format(new Date(l1));\n  String d2 = df.format(new Date(l2));\n  long newL1 = df.parse(d1).getTime();\n  long newL2 = df.parse(d2).getTime();\n  \n  System.out.println(l1 + \" => \" + d1 + \" => \" + newL1);\n  System.out.println(l2 + \" => \" + d2 + \" => \" + newL2);\n  \n   \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    init();\n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericField.DataType type : NumericField.DataType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n      \n      NumericField field = new NumericField(type.name(), PRECISION_STEP,\n          Field.Store.YES, true);\n      \n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n      \n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericField.DataType.LONG));\n    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP,\n        Field.Store.YES, true);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n\n//  SimpleDateFormat df = new SimpleDateFormat( \n//      \"yyyy.MM.dd G 'at' HH:mm:ss z\", LOCALE.ENGLISH);\n// assumes localized date pattern will have at least year, month, day, hour, minute\n  SimpleDateFormat df = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n      randomDateStyle(random), randomDateStyle(random), LOCALE.ENGLISH);\n  System.out.println(df.toPattern());\n  // most of date pattern do not include era, so we add it here. Also,\n  // sometimes second is not available, we make sure it's present too\n  df.applyPattern(df.toPattern() + \" G s Z yyyy\");\n  df.setTimeZone(TIMEZONE);\n  System.out.println(TIMEZONE);\n  System.out.println(TIMEZONE);\n  System.out.println(TIMEZONE);\n  long l1 = 0;\n  long l2 = -30000;\n  String d1 = df.format(new Date(l1));\n  String d2 = df.format(new Date(l2));\n  long newL1 = df.parse(d1).getTime();\n  long newL2 = df.parse(d2).getTime();\n  \n  System.out.println(l1 + \" => \" + d1 + \" => \" + newL1);\n  System.out.println(l2 + \" => \" + d2 + \" => \" + newL2);\n  \n   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a3a0dd9de3bad9333161d00088f49f120c2098d","date":1310713717,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random);\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random);\n      TIMEZONE = randomTimeZone(random);\n      DATE_STYLE = randomDateStyle(random);\n      TIME_STYLE = randomDateStyle(random);\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat\n          .getDateTimeInstance(DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random.nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n\n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random.nextInt() & 20) + 1);\n\n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random.nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random.nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random.nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random.nextInt()))\n        .intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericField.DataType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericField.DataType.INT.name(), randomInt);\n    randomNumberMap.put(NumericField.DataType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericField.DataType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n\n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericField.DataType type : NumericField.DataType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n      \n      NumericField field = new NumericField(type.name(), PRECISION_STEP,\n          Field.Store.YES, true);\n      \n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n      \n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericField.DataType.LONG));\n    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP,\n        Field.Store.YES, true);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n   \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    init();\n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericField.DataType type : NumericField.DataType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n      \n      NumericField field = new NumericField(type.name(), PRECISION_STEP,\n          Field.Store.YES, true);\n      \n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n      \n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericField.DataType.LONG));\n    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP,\n        Field.Store.YES, true);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n\n//  SimpleDateFormat df = new SimpleDateFormat( \n//      \"yyyy.MM.dd G 'at' HH:mm:ss z\", LOCALE.ENGLISH);\n// assumes localized date pattern will have at least year, month, day, hour, minute\n  SimpleDateFormat df = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n      randomDateStyle(random), randomDateStyle(random), LOCALE.ENGLISH);\n  System.out.println(df.toPattern());\n  // most of date pattern do not include era, so we add it here. Also,\n  // sometimes second is not available, we make sure it's present too\n  df.applyPattern(df.toPattern() + \" G s Z yyyy\");\n  df.setTimeZone(TIMEZONE);\n  System.out.println(TIMEZONE);\n  System.out.println(TIMEZONE);\n  System.out.println(TIMEZONE);\n  long l1 = 0;\n  long l2 = -30000;\n  String d1 = df.format(new Date(l1));\n  String d2 = df.format(new Date(l2));\n  long newL1 = df.parse(d1).getTime();\n  long newL2 = df.parse(d2).getTime();\n  \n  System.out.println(l1 + \" => \" + d1 + \" => \" + newL1);\n  System.out.println(l2 + \" => \" + d2 + \" => \" + newL2);\n  \n   \n  }\n\n","bugFix":null,"bugIntro":["a78a90fc9701e511308346ea29f4f5e548bb39fe","e91b7614171e0a6a82351457c2870d2a0124ba9a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e91b7614171e0a6a82351457c2870d2a0124ba9a","date":1312225025,"type":3,"author":"Adriano Crestani Campos","isMerge":false,"pathNew":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random);\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random);\n      TIMEZONE = randomTimeZone(random);\n      DATE_STYLE = randomDateStyle(random);\n      TIME_STYLE = randomDateStyle(random);\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random.nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random.nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random.nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random.nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random.nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random.nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericField.DataType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericField.DataType.INT.name(), randomInt);\n    randomNumberMap.put(NumericField.DataType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericField.DataType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericField.DataType type : NumericField.DataType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n      \n      NumericField field = new NumericField(type.name(), PRECISION_STEP,\n          Field.Store.YES, true);\n      \n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n      \n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericField.DataType.LONG));\n    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP,\n        Field.Store.YES, true);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random);\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random);\n      TIMEZONE = randomTimeZone(random);\n      DATE_STYLE = randomDateStyle(random);\n      TIME_STYLE = randomDateStyle(random);\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat\n          .getDateTimeInstance(DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random.nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n\n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random.nextInt() & 20) + 1);\n\n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random.nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random.nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random.nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random.nextInt()))\n        .intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericField.DataType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericField.DataType.INT.name(), randomInt);\n    randomNumberMap.put(NumericField.DataType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericField.DataType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n\n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericField.DataType type : NumericField.DataType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n      \n      NumericField field = new NumericField(type.name(), PRECISION_STEP,\n          Field.Store.YES, true);\n      \n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n      \n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericField.DataType.LONG));\n    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP,\n        Field.Store.YES, true);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n   \n  }\n\n","bugFix":["8a3a0dd9de3bad9333161d00088f49f120c2098d","a7e86426ca0513cfc495c3a2c0bb0c7abe03988d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random);\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random);\n      TIMEZONE = randomTimeZone(random);\n      DATE_STYLE = randomDateStyle(random);\n      TIME_STYLE = randomDateStyle(random);\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random.nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random.nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random.nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random.nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random.nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random.nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericField.DataType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericField.DataType.INT.name(), randomInt);\n    randomNumberMap.put(NumericField.DataType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericField.DataType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericField.DataType type : NumericField.DataType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n      \n      NumericField field = new NumericField(type.name(), PRECISION_STEP, NumericField.TYPE_STORED);\n      \n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n      \n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericField.DataType.LONG));\n    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP, NumericField.TYPE_STORED);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random);\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random);\n      TIMEZONE = randomTimeZone(random);\n      DATE_STYLE = randomDateStyle(random);\n      TIME_STYLE = randomDateStyle(random);\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random.nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random.nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random.nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random.nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random.nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random.nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericField.DataType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericField.DataType.INT.name(), randomInt);\n    randomNumberMap.put(NumericField.DataType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericField.DataType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericField.DataType type : NumericField.DataType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n      \n      NumericField field = new NumericField(type.name(), PRECISION_STEP,\n          Field.Store.YES, true);\n      \n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n      \n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericField.DataType.LONG));\n    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP,\n        Field.Store.YES, true);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":["fa0f44f887719e97183771e977cfc4bfb485b766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fa0f44f887719e97183771e977cfc4bfb485b766","date":1326668713,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random);\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random);\n      TIMEZONE = randomTimeZone(random);\n      DATE_STYLE = randomDateStyle(random);\n      TIME_STYLE = randomDateStyle(random);\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random.nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random.nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random.nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random.nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random.nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random.nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericField.DataType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericField.DataType.INT.name(), randomInt);\n    randomNumberMap.put(NumericField.DataType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericField.DataType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericField.DataType type : NumericField.DataType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(NumericField.getFieldType(type, true));\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      final NumericField field;\n\n      switch(type) {\n      case INT:\n        field = new NumericField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new NumericField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new NumericField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new NumericField(type.name(), 0.0, ft);\n        break;\n      default:\n        assert false;\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericField.DataType.LONG));\n    FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.LONG, true));\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    NumericField dateField = new NumericField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random);\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random);\n      TIMEZONE = randomTimeZone(random);\n      DATE_STYLE = randomDateStyle(random);\n      TIME_STYLE = randomDateStyle(random);\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random.nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random.nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random.nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random.nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random.nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random.nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericField.DataType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericField.DataType.INT.name(), randomInt);\n    randomNumberMap.put(NumericField.DataType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericField.DataType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericField.DataType type : NumericField.DataType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n      \n      NumericField field = new NumericField(type.name(), PRECISION_STEP, NumericField.TYPE_STORED);\n      \n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n      \n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericField.DataType.LONG));\n    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP, NumericField.TYPE_STORED);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":["a7e86426ca0513cfc495c3a2c0bb0c7abe03988d","1509f151d7692d84fae414b2b799ac06ba60fcb4"],"bugIntro":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a78a90fc9701e511308346ea29f4f5e548bb39fe","date":1329489995,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random);\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random);\n      TIMEZONE = randomTimeZone(random);\n      DATE_STYLE = randomDateStyle(random);\n      TIME_STYLE = randomDateStyle(random);\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random.nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random.nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random.nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random.nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random.nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random.nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        assert false;\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random);\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random);\n      TIMEZONE = randomTimeZone(random);\n      DATE_STYLE = randomDateStyle(random);\n      TIME_STYLE = randomDateStyle(random);\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random.nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random.nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random.nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random.nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random.nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random.nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericField.DataType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericField.DataType.INT.name(), randomInt);\n    randomNumberMap.put(NumericField.DataType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericField.DataType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericField.DataType type : NumericField.DataType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(NumericField.getFieldType(type, true));\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      final NumericField field;\n\n      switch(type) {\n      case INT:\n        field = new NumericField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new NumericField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new NumericField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new NumericField(type.name(), 0.0, ft);\n        break;\n      default:\n        assert false;\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericField.DataType.LONG));\n    FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.LONG, true));\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    NumericField dateField = new NumericField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":["fa0f44f887719e97183771e977cfc4bfb485b766","8a3a0dd9de3bad9333161d00088f49f120c2098d","a7e86426ca0513cfc495c3a2c0bb0c7abe03988d"],"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        assert false;\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random);\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random);\n      TIMEZONE = randomTimeZone(random);\n      DATE_STYLE = randomDateStyle(random);\n      TIME_STYLE = randomDateStyle(random);\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random.nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random.nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random.nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random.nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random.nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random.nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random.nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        assert false;\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","pathOld":"modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        assert false;\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<String,Number>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(NumericType.LONG.name(), randomLong);\n    randomNumberMap.put(NumericType.INT.name(), randomInt);\n    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMaxBufferedDocs(_TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();\n    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (NumericType type : NumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(IntField.TYPE);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new IntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new FloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new DoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        assert false;\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, NumericType.LONG));\n    FieldType ft = new FieldType(LongField.TYPE);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"4cf7d991c51b580d4b7bf2ad583dba058c0a2dd1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["fa0f44f887719e97183771e977cfc4bfb485b766"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fa0f44f887719e97183771e977cfc4bfb485b766":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["e91b7614171e0a6a82351457c2870d2a0124ba9a"],"8a3a0dd9de3bad9333161d00088f49f120c2098d":["4cf7d991c51b580d4b7bf2ad583dba058c0a2dd1"],"e91b7614171e0a6a82351457c2870d2a0124ba9a":["8a3a0dd9de3bad9333161d00088f49f120c2098d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"4cf7d991c51b580d4b7bf2ad583dba058c0a2dd1":["8a3a0dd9de3bad9333161d00088f49f120c2098d"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4cf7d991c51b580d4b7bf2ad583dba058c0a2dd1"],"fa0f44f887719e97183771e977cfc4bfb485b766":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["fa0f44f887719e97183771e977cfc4bfb485b766"],"8a3a0dd9de3bad9333161d00088f49f120c2098d":["e91b7614171e0a6a82351457c2870d2a0124ba9a"],"e91b7614171e0a6a82351457c2870d2a0124ba9a":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}