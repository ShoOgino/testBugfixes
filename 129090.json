{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","commits":[{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateCloudState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... \");\n          clusterState = new ClusterState(liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n      }\n\n      this.clusterState = clusterState;\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateCloudState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      CloudState clusterState;\n      synchronized (getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null, true);\n      Set<String> liveNodesSet = new HashSet<String>();\n      liveNodesSet.addAll(liveNodes);\n      \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = CloudState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... \");\n          clusterState = new CloudState(liveNodesSet,\n              ZkStateReader.this.cloudState.getCollectionStates());\n        }\n      }\n\n      this.cloudState = clusterState;\n    } else {\n      if (cloudStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      cloudStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            cloudStateUpdateScheduled = false;\n            CloudState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = CloudState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new CloudState(liveNodesSet, ZkStateReader.this.cloudState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.cloudState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.cloudState = cloudState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da94fd5fcff99442877e118f00fb42094b59f497","date":1344115365,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... \");\n          clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n      }\n\n      this.clusterState = clusterState;\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState .getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... \");\n          clusterState = new ClusterState(liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n      }\n\n      this.clusterState = clusterState;\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateCloudState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... \");\n          clusterState = new ClusterState(liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n      }\n\n      this.clusterState = clusterState;\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateCloudState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      CloudState clusterState;\n      synchronized (getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null, true);\n      Set<String> liveNodesSet = new HashSet<String>();\n      liveNodesSet.addAll(liveNodes);\n      \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = CloudState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... \");\n          clusterState = new CloudState(liveNodesSet,\n              ZkStateReader.this.cloudState.getCollectionStates());\n        }\n      }\n\n      this.cloudState = clusterState;\n    } else {\n      if (cloudStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      cloudStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            cloudStateUpdateScheduled = false;\n            CloudState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = CloudState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new CloudState(liveNodesSet, ZkStateReader.this.cloudState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.cloudState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.cloudState = cloudState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... \");\n          clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n      }\n\n      this.clusterState = clusterState;\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState .getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... \");\n          clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n      }\n\n      this.clusterState = clusterState;\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState .getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... \");\n          clusterState = new ClusterState(liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n      }\n\n      this.clusterState = clusterState;\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1525b4dfbc0d413b8d7247da232009778e624836","date":1351101135,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n      }\n\n      this.clusterState = clusterState;\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState .getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... \");\n          clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n      }\n\n      this.clusterState = clusterState;\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState .getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n      }\n\n      this.clusterState = clusterState;\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState .getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... \");\n          clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n      }\n\n      this.clusterState = clusterState;\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState .getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce7cfca1a733d2ed1f7089b339faf006bdcc7b70","date":1386334715,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet,this);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n          /*clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());*/\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet,ZkStateReader.this);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet,this);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n          /*clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());*/\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet,ZkStateReader.this);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet,this);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n          /*clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());*/\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet,ZkStateReader.this);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<String>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet,this);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n          /*clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());*/\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet,ZkStateReader.this);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0622fbd990643ae4cacb693db6a0c82cf8916ae2","date":1397637446,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet,this);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n        updateCollectionNames();\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet,ZkStateReader.this);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    synchronized (this) {\n      for (String watchedCollection : watchedCollections) {\n        externalWatchedCollections.put(watchedCollection, getExternCollectionFresh(this, watchedCollection));\n      }\n    }\n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet,this);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n          /*clusterState = new ClusterState(\n              ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet,\n              ZkStateReader.this.clusterState.getCollectionStates());*/\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet,ZkStateReader.this);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = new ClusterState(ZkStateReader.this.clusterState.getZkClusterStateVersion(), liveNodesSet, ZkStateReader.this.clusterState.getCollectionStates());\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5a233896b7f16ac9b4ed601ef8207d98f1f0500","date":1398857046,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet,this);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet,ZkStateReader.this);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n\n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet,this);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n        updateCollectionNames();\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet,ZkStateReader.this);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    synchronized (this) {\n      for (String watchedCollection : watchedCollections) {\n        externalWatchedCollections.put(watchedCollection, getExternCollectionFresh(this, watchedCollection));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.debug(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet,this);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n        updateCollectionNames();\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet,ZkStateReader.this);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    synchronized (this) {\n      for (String watchedCollection : watchedCollections) {\n        watchedCollectionStates.put(watchedCollection, getCollectionLive(this, watchedCollection));\n      }\n    }\n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet,this);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet,ZkStateReader.this);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet,this);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet,ZkStateReader.this);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n\n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.debug(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet,this);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n        updateCollectionNames();\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet,ZkStateReader.this);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n    synchronized (this) {\n      for (String watchedCollection : watchedCollections) {\n        watchedCollectionStates.put(watchedCollection, getCollectionLive(this, watchedCollection));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ad7bdba3e91cf3373cda2e52239cb761fc0b452","date":1408019547,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.debug(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet,this);\n        } else {\n          log.debug(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.debug(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.debug(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.debug(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.debug(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet,ZkStateReader.this);\n              } else {\n                log.debug(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n\n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.info(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet,this);\n        } else {\n          log.info(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.info(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.info(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.info(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.info(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet,ZkStateReader.this);\n              } else {\n                log.info(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.debug(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = constructState(liveNodesSet,null);\n        } else {\n          log.debug(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n      }\n      synchronized (ZkStateReader.this) {\n        for (String watchedCollection : watchedCollections) {\n          updateWatchedCollection(getCollectionLive(this, watchedCollection));\n        }\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.debug(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.debug(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.debug(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.debug(\"Updating cloud state from ZooKeeper... \");\n\n                clusterState = constructState(liveNodesSet,null);\n              } else {\n                log.debug(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n\n            synchronized (ZkStateReader.this) {\n              for (String watchedCollection : watchedCollections) {\n                updateWatchedCollection(getCollectionLive(ZkStateReader.this, watchedCollection));\n              }\n            }\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.debug(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = ClusterState.load(zkClient, liveNodesSet,this);\n        } else {\n          log.debug(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.debug(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.debug(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.debug(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.debug(\"Updating cloud state from ZooKeeper... \");\n                \n                clusterState = ClusterState.load(zkClient, liveNodesSet,ZkStateReader.this);\n              } else {\n                log.debug(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["1ce872f8af1c62041fc7720f70eee3d4c97de84e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"624a78aada85c97f657fe582ce06976b10067343","date":1420577629,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.debug(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = constructState(liveNodesSet,null);\n        } else {\n          log.debug(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n      }\n      synchronized (ZkStateReader.this) {\n        for (String watchedCollection : watchedCollections) {\n          DocCollection live = getCollectionLive(this, watchedCollection);\n          assert live != null;\n          if (live != null) {\n            updateWatchedCollection(live);\n          }\n        }\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.debug(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.debug(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.debug(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.debug(\"Updating cloud state from ZooKeeper... \");\n\n                clusterState = constructState(liveNodesSet,null);\n              } else {\n                log.debug(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n\n            synchronized (ZkStateReader.this) {\n              for (String watchedCollection : watchedCollections) {\n                DocCollection live = getCollectionLive(ZkStateReader.this, watchedCollection);\n                assert live != null;\n                if (live != null) {\n                  updateWatchedCollection(live);\n                }\n              }\n            }\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.debug(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = constructState(liveNodesSet,null);\n        } else {\n          log.debug(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n      }\n      synchronized (ZkStateReader.this) {\n        for (String watchedCollection : watchedCollections) {\n          updateWatchedCollection(getCollectionLive(this, watchedCollection));\n        }\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.debug(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.debug(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.debug(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.debug(\"Updating cloud state from ZooKeeper... \");\n\n                clusterState = constructState(liveNodesSet,null);\n              } else {\n                log.debug(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n\n            synchronized (ZkStateReader.this) {\n              for (String watchedCollection : watchedCollections) {\n                updateWatchedCollection(getCollectionLive(ZkStateReader.this, watchedCollection));\n              }\n            }\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n  }\n\n","bugFix":null,"bugIntro":["8d9d4213830e8d2b2e350302a857ac9fdbf9a359","1ce872f8af1c62041fc7720f70eee3d4c97de84e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8d9d4213830e8d2b2e350302a857ac9fdbf9a359","date":1422643609,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.debug(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = constructState(liveNodesSet,null);\n        } else {\n          log.debug(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n      }\n      synchronized (ZkStateReader.this) {\n        for (String watchedCollection : watchedCollections) {\n          DocCollection live = getCollectionLive(this, watchedCollection);\n          if (live != null) {\n            updateWatchedCollection(live);\n          }\n        }\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.debug(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.debug(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.debug(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.debug(\"Updating cloud state from ZooKeeper... \");\n\n                clusterState = constructState(liveNodesSet,null);\n              } else {\n                log.debug(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n\n            synchronized (ZkStateReader.this) {\n              for (String watchedCollection : watchedCollections) {\n                DocCollection live = getCollectionLive(ZkStateReader.this, watchedCollection);\n                assert live != null;\n                if (live != null) {\n                  updateWatchedCollection(live);\n                }\n              }\n            }\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.debug(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = constructState(liveNodesSet,null);\n        } else {\n          log.debug(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n      }\n      synchronized (ZkStateReader.this) {\n        for (String watchedCollection : watchedCollections) {\n          DocCollection live = getCollectionLive(this, watchedCollection);\n          assert live != null;\n          if (live != null) {\n            updateWatchedCollection(live);\n          }\n        }\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.debug(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.debug(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.debug(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.debug(\"Updating cloud state from ZooKeeper... \");\n\n                clusterState = constructState(liveNodesSet,null);\n              } else {\n                log.debug(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n\n            synchronized (ZkStateReader.this) {\n              for (String watchedCollection : watchedCollections) {\n                DocCollection live = getCollectionLive(ZkStateReader.this, watchedCollection);\n                assert live != null;\n                if (live != null) {\n                  updateWatchedCollection(live);\n                }\n              }\n            }\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n  }\n\n","bugFix":["624a78aada85c97f657fe582ce06976b10067343"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"78659e56d5a8c1ce0316a13dea09532e1ccb2dd6","date":1434002938,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null, true);\n        Set<String> liveNodesSet = new HashSet<>(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.debug(\"Updating cloud state from ZooKeeper... \");\n          clusterState = constructState(liveNodesSet, null);\n        } else {\n          log.debug(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n      }\n      synchronized (ZkStateReader.this) {\n        for (String watchedCollection : watchedCollections) {\n          DocCollection live = getCollectionLive(this, watchedCollection);\n          if (live != null) {\n            updateWatchedCollection(live);\n          }\n        }\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.debug(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.debug(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.debug(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.debug(\"Updating cloud state from ZooKeeper... \");\n\n                clusterState = constructState(liveNodesSet,null);\n              } else {\n                log.debug(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n\n            synchronized (ZkStateReader.this) {\n              for (String watchedCollection : watchedCollections) {\n                DocCollection live = getCollectionLive(ZkStateReader.this, watchedCollection);\n                assert live != null;\n                if (live != null) {\n                  updateWatchedCollection(live);\n                }\n              }\n            }\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null,\n            true);\n        Set<String> liveNodesSet = new HashSet<>();\n        liveNodesSet.addAll(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.debug(\"Updating cloud state from ZooKeeper... \");\n          \n          clusterState = constructState(liveNodesSet,null);\n        } else {\n          log.debug(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n      }\n      synchronized (ZkStateReader.this) {\n        for (String watchedCollection : watchedCollections) {\n          DocCollection live = getCollectionLive(this, watchedCollection);\n          if (live != null) {\n            updateWatchedCollection(live);\n          }\n        }\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.debug(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.debug(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.debug(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>();\n              liveNodesSet.addAll(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.debug(\"Updating cloud state from ZooKeeper... \");\n\n                clusterState = constructState(liveNodesSet,null);\n              } else {\n                log.debug(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n\n            synchronized (ZkStateReader.this) {\n              for (String watchedCollection : watchedCollections) {\n                DocCollection live = getCollectionLive(ZkStateReader.this, watchedCollection);\n                assert live != null;\n                if (live != null) {\n                  updateWatchedCollection(live);\n                }\n              }\n            }\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1ce872f8af1c62041fc7720f70eee3d4c97de84e","date":1438173847,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null, true);\n        Set<String> liveNodesSet = new HashSet<>(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.debug(\"Updating cloud state from ZooKeeper... \");\n          clusterState = constructState(liveNodesSet, null);\n        } else {\n          log.debug(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n      }\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.debug(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.debug(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.debug(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.debug(\"Updating cloud state from ZooKeeper... \");\n\n                clusterState = constructState(liveNodesSet,null);\n              } else {\n                log.debug(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n\n            synchronized (ZkStateReader.this) {\n              for (String watchedCollection : watchedCollections) {\n                DocCollection live = getCollectionLive(ZkStateReader.this, watchedCollection);\n                assert live != null;\n                if (live != null) {\n                  updateWatchedCollection(live);\n                }\n              }\n            }\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n  }\n\n","sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null, true);\n        Set<String> liveNodesSet = new HashSet<>(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.debug(\"Updating cloud state from ZooKeeper... \");\n          clusterState = constructState(liveNodesSet, null);\n        } else {\n          log.debug(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n      }\n      synchronized (ZkStateReader.this) {\n        for (String watchedCollection : watchedCollections) {\n          DocCollection live = getCollectionLive(this, watchedCollection);\n          if (live != null) {\n            updateWatchedCollection(live);\n          }\n        }\n      }\n\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.debug(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.debug(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.debug(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.debug(\"Updating cloud state from ZooKeeper... \");\n\n                clusterState = constructState(liveNodesSet,null);\n              } else {\n                log.debug(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n\n            synchronized (ZkStateReader.this) {\n              for (String watchedCollection : watchedCollections) {\n                DocCollection live = getCollectionLive(ZkStateReader.this, watchedCollection);\n                assert live != null;\n                if (live != null) {\n                  updateWatchedCollection(live);\n                }\n              }\n            }\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","624a78aada85c97f657fe582ce06976b10067343","9279b175e5e66258442d2123a50f052219a9cc1b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"102da6baafc0f534a59f31729343dbab9d3b9e9a","date":1438410244,"type":4,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState(boolean,boolean).mjava","sourceNew":null,"sourceOld":"  // load and publish a new CollectionInfo\n  private synchronized void updateClusterState(boolean immediate,\n      final boolean onlyLiveNodes) throws KeeperException,\n      InterruptedException {\n    // build immutable CloudInfo\n    \n    if (immediate) {\n      ClusterState clusterState;\n      synchronized (getUpdateLock()) {\n        List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE, null, true);\n        Set<String> liveNodesSet = new HashSet<>(liveNodes);\n        \n        if (!onlyLiveNodes) {\n          log.debug(\"Updating cloud state from ZooKeeper... \");\n          clusterState = constructState(liveNodesSet, null);\n        } else {\n          log.debug(\"Updating live nodes from ZooKeeper... ({})\", liveNodesSet.size());\n          clusterState = this.clusterState;\n          clusterState.setLiveNodes(liveNodesSet);\n        }\n        this.clusterState = clusterState;\n      }\n    } else {\n      if (clusterStateUpdateScheduled) {\n        log.debug(\"Cloud state update for ZooKeeper already scheduled\");\n        return;\n      }\n      log.debug(\"Scheduling cloud state update from ZooKeeper...\");\n      clusterStateUpdateScheduled = true;\n      updateCloudExecutor.schedule(new Runnable() {\n        \n        @Override\n        public void run() {\n          log.debug(\"Updating cluster state from ZooKeeper...\");\n          synchronized (getUpdateLock()) {\n            clusterStateUpdateScheduled = false;\n            ClusterState clusterState;\n            try {\n              List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n                  null, true);\n              Set<String> liveNodesSet = new HashSet<>(liveNodes);\n              \n              if (!onlyLiveNodes) {\n                log.debug(\"Updating cloud state from ZooKeeper... \");\n\n                clusterState = constructState(liveNodesSet,null);\n              } else {\n                log.debug(\"Updating live nodes from ZooKeeper... \");\n                clusterState = ZkStateReader.this.clusterState;\n                clusterState.setLiveNodes(liveNodesSet);\n              }\n              \n              ZkStateReader.this.clusterState = clusterState;\n              \n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                return;\n              }\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              log.error(\"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } \n            // update volatile\n            ZkStateReader.this.clusterState = clusterState;\n\n            synchronized (ZkStateReader.this) {\n              for (String watchedCollection : watchedCollections) {\n                DocCollection live = getCollectionLive(ZkStateReader.this, watchedCollection);\n                assert live != null;\n                if (live != null) {\n                  updateWatchedCollection(live);\n                }\n              }\n            }\n          }\n        }\n      }, SOLRCLOUD_UPDATE_DELAY, TimeUnit.MILLISECONDS);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["d9405f486872f1e416304dfe389741f4ee2f8a4d","7530de27b87b961b51f01bd1299b7004d46e8823"],"8d9d4213830e8d2b2e350302a857ac9fdbf9a359":["624a78aada85c97f657fe582ce06976b10067343"],"ce7cfca1a733d2ed1f7089b339faf006bdcc7b70":["7530de27b87b961b51f01bd1299b7004d46e8823"],"1ce872f8af1c62041fc7720f70eee3d4c97de84e":["78659e56d5a8c1ce0316a13dea09532e1ccb2dd6"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["1525b4dfbc0d413b8d7247da232009778e624836"],"78659e56d5a8c1ce0316a13dea09532e1ccb2dd6":["8d9d4213830e8d2b2e350302a857ac9fdbf9a359"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["8fd5be977c105554c6a7b68afcdbc511439723ab","da94fd5fcff99442877e118f00fb42094b59f497"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f2126b84bd093fa3d921582a109a0ee578c28126":["da94fd5fcff99442877e118f00fb42094b59f497","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ce7cfca1a733d2ed1f7089b339faf006bdcc7b70"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["1ce872f8af1c62041fc7720f70eee3d4c97de84e"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3f767f8c99eaedb984df754fe61f21c5de260f94"],"9279b175e5e66258442d2123a50f052219a9cc1b":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"624a78aada85c97f657fe582ce06976b10067343":["9279b175e5e66258442d2123a50f052219a9cc1b"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","da94fd5fcff99442877e118f00fb42094b59f497"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["7530de27b87b961b51f01bd1299b7004d46e8823","ce7cfca1a733d2ed1f7089b339faf006bdcc7b70"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"da94fd5fcff99442877e118f00fb42094b59f497":["3f767f8c99eaedb984df754fe61f21c5de260f94"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"1525b4dfbc0d413b8d7247da232009778e624836":["da94fd5fcff99442877e118f00fb42094b59f497"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["102da6baafc0f534a59f31729343dbab9d3b9e9a"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"8d9d4213830e8d2b2e350302a857ac9fdbf9a359":["78659e56d5a8c1ce0316a13dea09532e1ccb2dd6"],"ce7cfca1a733d2ed1f7089b339faf006bdcc7b70":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"1ce872f8af1c62041fc7720f70eee3d4c97de84e":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","f2126b84bd093fa3d921582a109a0ee578c28126","7530de27b87b961b51f01bd1299b7004d46e8823"],"78659e56d5a8c1ce0316a13dea09532e1ccb2dd6":["1ce872f8af1c62041fc7720f70eee3d4c97de84e"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8fd5be977c105554c6a7b68afcdbc511439723ab","3f767f8c99eaedb984df754fe61f21c5de260f94","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"9279b175e5e66258442d2123a50f052219a9cc1b":["624a78aada85c97f657fe582ce06976b10067343"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["8fd5be977c105554c6a7b68afcdbc511439723ab","da94fd5fcff99442877e118f00fb42094b59f497"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"624a78aada85c97f657fe582ce06976b10067343":["8d9d4213830e8d2b2e350302a857ac9fdbf9a359"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["9279b175e5e66258442d2123a50f052219a9cc1b"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","ce7cfca1a733d2ed1f7089b339faf006bdcc7b70","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"da94fd5fcff99442877e118f00fb42094b59f497":["c7869f64c874ebf7f317d22c00baf2b6857797a6","f2126b84bd093fa3d921582a109a0ee578c28126","d6f074e73200c07d54f242d3880a8da5a35ff97b","1525b4dfbc0d413b8d7247da232009778e624836"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"1525b4dfbc0d413b8d7247da232009778e624836":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","c7869f64c874ebf7f317d22c00baf2b6857797a6","f2126b84bd093fa3d921582a109a0ee578c28126","d6f074e73200c07d54f242d3880a8da5a35ff97b","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}