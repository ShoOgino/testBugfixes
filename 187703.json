{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    Aliases aliases = zkStateReader.getAliases();\n    final String collection = message.getStr(NAME);\n    for (Map.Entry<String, List<String>> ent :  aliases.getCollectionAliasListMap().entrySet()) {\n      if (ent.getValue().contains(collection)) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Collection : \" + collection + \" is part of alias \" + ent.getKey() + \" remove or modify the alias before removing this collection.\");\n      }\n    }\n\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    Aliases aliases = zkStateReader.getAliases();\n    final String collection = message.getStr(NAME);\n    for (Map.Entry<String, List<String>> ent :  aliases.getCollectionAliasListMap().entrySet()) {\n      if (ent.getValue().contains(collection)) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Collection : \" + collection + \" is part of alias \" + ent.getKey() + \" remove or modify the alias before removing this collection.\");\n      }\n    }\n\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    Aliases aliases = zkStateReader.getAliases();\n    final String collection = message.getStr(NAME);\n    for (Map.Entry<String, List<String>> ent :  aliases.getCollectionAliasListMap().entrySet()) {\n      if (ent.getValue().contains(collection)) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Collection : \" + collection + \" is part of alias \" + ent.getKey() + \" remove or modify the alias before removing this collection.\");\n      }\n    }\n\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"06263309947a9804c326e35ce627be8768e123a4","date":1517286624,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    Aliases aliases = zkStateReader.getAliases();\n    final String collection = message.getStr(NAME);\n    for (Map.Entry<String, List<String>> ent :  aliases.getCollectionAliasListMap().entrySet()) {\n      if (ent.getValue().contains(collection)) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Collection : \" + collection + \" is part of alias \" + ent.getKey() + \" remove or modify the alias before removing this collection.\");\n      }\n    }\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n      for (Replica failedRepilca : failedReplicas) {\n        boolean isSharedFS = failedRepilca.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedRepilca.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    Aliases aliases = zkStateReader.getAliases();\n    final String collection = message.getStr(NAME);\n    for (Map.Entry<String, List<String>> ent :  aliases.getCollectionAliasListMap().entrySet()) {\n      if (ent.getValue().contains(collection)) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Collection : \" + collection + \" is part of alias \" + ent.getKey() + \" remove or modify the alias before removing this collection.\");\n      }\n    }\n\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":["993d0b0d77c623d30cb24cdadbff9bb3b5f516bb","66e0b82bd39567aa2bf534e5282d05fb4a4a2c76"],"bugIntro":["69e6520a21709190413a63084ed135271aab1a7c","69e6520a21709190413a63084ed135271aab1a7c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7d9def7b715c2324a9f84c1fc2e60a5c03c73331","date":1524626711,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String collection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    checkNotReferencedByAlias(zkStateReader, collection);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n      for (Replica failedRepilca : failedReplicas) {\n        boolean isSharedFS = failedRepilca.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedRepilca.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    Aliases aliases = zkStateReader.getAliases();\n    final String collection = message.getStr(NAME);\n    for (Map.Entry<String, List<String>> ent :  aliases.getCollectionAliasListMap().entrySet()) {\n      if (ent.getValue().contains(collection)) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Collection : \" + collection + \" is part of alias \" + ent.getKey() + \" remove or modify the alias before removing this collection.\");\n      }\n    }\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n      for (Replica failedRepilca : failedReplicas) {\n        boolean isSharedFS = failedRepilca.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedRepilca.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":["4b342321d8906f4b19f6f87ea33ea3fff12bffa7","66e0b82bd39567aa2bf534e5282d05fb4a4a2c76"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a","date":1527582939,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String collection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    checkNotReferencedByAlias(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n      for (Replica failedRepilca : failedReplicas) {\n        boolean isSharedFS = failedRepilca.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedRepilca.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String collection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    checkNotReferencedByAlias(zkStateReader, collection);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n      for (Replica failedRepilca : failedReplicas) {\n        boolean isSharedFS = failedRepilca.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedRepilca.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"27639bb5e041490ce599065875dd2f6d8beef62a","date":1532829373,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String collection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    checkNotReferencedByAlias(zkStateReader, collection);\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n      for (Replica failedRepilca : failedReplicas) {\n        boolean isSharedFS = failedRepilca.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedRepilca.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String collection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    checkNotReferencedByAlias(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n      for (Replica failedRepilca : failedReplicas) {\n        boolean isSharedFS = failedRepilca.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedRepilca.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String collection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    checkNotReferencedByAlias(zkStateReader, collection);\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n      for (Replica failedRepilca : failedReplicas) {\n        boolean isSharedFS = failedRepilca.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedRepilca.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionState == null);\n      \n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String collection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    checkNotReferencedByAlias(zkStateReader, collection);\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n      for (Replica failedRepilca : failedReplicas) {\n        boolean isSharedFS = failedRepilca.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedRepilca.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":["993d0b0d77c623d30cb24cdadbff9bb3b5f516bb","2ffd63d34721624b26ed9880b4822f7d0bbbe6dc","4ee5a5186e7187cd42c6f7ff64b6e7206a780325","1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","19498030e0adab22f604f935cae3c03dcf0952a6","bcf9886c8ff537aafde14de48ebf744f5673f08b","66e0b82bd39567aa2bf534e5282d05fb4a4a2c76"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"59bad1cc1e7f90125a140496e79b06afcedb68ec","date":1554915399,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    String aliasReference = checkAliasReference(zkStateReader, extCollection);\n\n    Aliases aliases = zkStateReader.getAliases();\n    String collection = aliases.resolveSimpleAlias(extCollection);\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique alias\n      if (aliasReference != null) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(aliasReference, null));\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String collection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    checkNotReferencedByAlias(zkStateReader, collection);\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n      for (Replica failedRepilca : failedReplicas) {\n        boolean isSharedFS = failedRepilca.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedRepilca.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionState == null);\n      \n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"69e6520a21709190413a63084ed135271aab1a7c","date":1556607462,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    String aliasReference = checkAliasReference(zkStateReader, extCollection);\n\n    Aliases aliases = zkStateReader.getAliases();\n    String collection = aliases.resolveSimpleAlias(extCollection);\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique alias\n      if (aliasReference != null) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(aliasReference, null));\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    String aliasReference = checkAliasReference(zkStateReader, extCollection);\n\n    Aliases aliases = zkStateReader.getAliases();\n    String collection = aliases.resolveSimpleAlias(extCollection);\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique alias\n      if (aliasReference != null) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(aliasReference, null));\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":["3bbb741690cdafda7f1f7549c26351c912917a69","06263309947a9804c326e35ce627be8768e123a4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6e5eb1137994855cee975febe08850fcb7726d3","date":1558358375,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection);\n\n    Aliases aliases = zkStateReader.getAliases();\n    String collection = aliases.resolveSimpleAlias(extCollection);\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    String aliasReference = checkAliasReference(zkStateReader, extCollection);\n\n    Aliases aliases = zkStateReader.getAliases();\n    String collection = aliases.resolveSimpleAlias(extCollection);\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique alias\n      if (aliasReference != null) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(aliasReference, null));\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b366e7dd3172289251a86be96031af4002cd19c","date":1560790783,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection);\n\n    Aliases aliases = zkStateReader.getAliases();\n    String collection = aliases.resolveSimpleAlias(extCollection);\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection);\n\n    Aliases aliases = zkStateReader.getAliases();\n    String collection = aliases.resolveSimpleAlias(extCollection);\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (liveNodes, collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c","date":1562161956,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection);\n\n    Aliases aliases = zkStateReader.getAliases();\n    String collection = aliases.resolveSimpleAlias(extCollection);\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(message, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eebf1b080530bdd7572c4927fb2bb52334b7a86","date":1563199033,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    Object o = message.get(MaintainRoutedAliasCmd.INVOKED_BY_ROUTED_ALIAS);\n    if (o != null) {\n      ((Runnable)o).run(); // this will ensure the collection is removed from the alias before it disappears.\n    }\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86968c6cf51846df861b8f29bd85b6d9a7c9f19c","date":1591481497,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    Object o = message.get(MaintainRoutedAliasCmd.INVOKED_BY_ROUTED_ALIAS);\n    if (o != null) {\n      ((Runnable)o).run(); // this will ensure the collection is removed from the alias before it disappears.\n    }\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      @SuppressWarnings({\"unchecked\"})\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    Object o = message.get(MaintainRoutedAliasCmd.INVOKED_BY_ROUTED_ALIAS);\n    if (o != null) {\n      ((Runnable)o).run(); // this will ensure the collection is removed from the alias before it disappears.\n    }\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"121de2b1a2f90238d017b11597526f7441dd0792","date":1598038996,"type":3,"author":"Anderson Dorow","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    Object o = message.get(MaintainRoutedAliasCmd.INVOKED_BY_ROUTED_ALIAS);\n    if (o != null) {\n      ((Runnable)o).run(); // this will ensure the collection is removed from the alias before it disappears.\n    }\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      @SuppressWarnings({\"unchecked\"})\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n      // delete related config set iff: it is auto generated AND not related to any other collection\n      String configSetName = zkStateReader.readConfigName(collection);\n\n      if (ConfigSetsHandlerApi.isAutoGeneratedConfigSet(configSetName)) {\n        boolean configSetIsUsedByOtherCollection = false;\n\n        // make sure the configSet is not shared with other collections\n        // Similar to what happens in: OverseerConfigSetMessageHandler::deleteConfigSet\n        for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n          String otherConfigSetName = null;\n          try {\n            otherConfigSetName = zkStateReader.readConfigName(entry.getKey());\n          } catch (KeeperException ex) {\n            // ignore 'no config found' errors\n          }\n          if (configSetName.equals(otherConfigSetName)) {\n            configSetIsUsedByOtherCollection = true;\n            break;\n          }\n        }\n\n        if (!configSetIsUsedByOtherCollection) {\n          // delete the config set\n          zkStateReader.getConfigManager().deleteConfigDir(configSetName);\n        }\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    Object o = message.get(MaintainRoutedAliasCmd.INVOKED_BY_ROUTED_ALIAS);\n    if (o != null) {\n      ((Runnable)o).run(); // this will ensure the collection is removed from the alias before it disappears.\n    }\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      @SuppressWarnings({\"unchecked\"})\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    Object o = message.get(MaintainRoutedAliasCmd.INVOKED_BY_ROUTED_ALIAS);\n    if (o != null) {\n      ((Runnable)o).run(); // this will ensure the collection is removed from the alias before it disappears.\n    }\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      @SuppressWarnings({\"unchecked\"})\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n      // delete related config set iff: it is auto generated AND not related to any other collection\n      String configSetName = zkStateReader.readConfigName(collection);\n\n      if (ConfigSetsHandlerApi.isAutoGeneratedConfigSet(configSetName)) {\n        boolean configSetIsUsedByOtherCollection = false;\n\n        // make sure the configSet is not shared with other collections\n        // Similar to what happens in: OverseerConfigSetMessageHandler::deleteConfigSet\n        for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n          String otherConfigSetName = null;\n          try {\n            otherConfigSetName = zkStateReader.readConfigName(entry.getKey());\n          } catch (KeeperException ex) {\n            // ignore 'no config found' errors\n          }\n          if (configSetName.equals(otherConfigSetName)) {\n            configSetIsUsedByOtherCollection = true;\n            break;\n          }\n        }\n\n        if (!configSetIsUsedByOtherCollection) {\n          // delete the config set\n          zkStateReader.getConfigManager().deleteConfigDir(configSetName);\n        }\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    Object o = message.get(MaintainRoutedAliasCmd.INVOKED_BY_ROUTED_ALIAS);\n    if (o != null) {\n      ((Runnable)o).run(); // this will ensure the collection is removed from the alias before it disappears.\n    }\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      @SuppressWarnings({\"unchecked\"})\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n      // delete related config set iff: it is auto generated AND not related to any other collection\n      String configSetName = zkStateReader.readConfigName(collection);\n\n      if (ConfigSetsHandlerApi.isAutoGeneratedConfigSet(configSetName)) {\n        boolean configSetIsUsedByOtherCollection = false;\n\n        // make sure the configSet is not shared with other collections\n        // Similar to what happens in: OverseerConfigSetMessageHandler::deleteConfigSet\n        for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n          String otherConfigSetName = null;\n          try {\n            otherConfigSetName = zkStateReader.readConfigName(entry.getKey());\n          } catch (KeeperException ex) {\n            // ignore 'no config found' errors\n          }\n          if (configSetName.equals(otherConfigSetName)) {\n            configSetIsUsedByOtherCollection = true;\n            break;\n          }\n        }\n\n        if (!configSetIsUsedByOtherCollection) {\n          // delete the config set\n          zkStateReader.getConfigManager().deleteConfigDir(configSetName);\n        }\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    Object o = message.get(MaintainRoutedAliasCmd.INVOKED_BY_ROUTED_ALIAS);\n    if (o != null) {\n      ((Runnable)o).run(); // this will ensure the collection is removed from the alias before it disappears.\n    }\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      @SuppressWarnings({\"unchecked\"})\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n      // delete related config set iff: it is auto generated AND not related to any other collection\n      String configSetName = zkStateReader.readConfigName(collection);\n\n      if (ConfigSetsHandlerApi.isAutoGeneratedConfigSet(configSetName)) {\n        boolean configSetIsUsedByOtherCollection = false;\n\n        // make sure the configSet is not shared with other collections\n        // Similar to what happens in: OverseerConfigSetMessageHandler::deleteConfigSet\n        for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n          String otherConfigSetName = null;\n          try {\n            otherConfigSetName = zkStateReader.readConfigName(entry.getKey());\n          } catch (KeeperException ex) {\n            // ignore 'no config found' errors\n          }\n          if (configSetName.equals(otherConfigSetName)) {\n            configSetIsUsedByOtherCollection = true;\n            break;\n          }\n        }\n\n        if (!configSetIsUsedByOtherCollection) {\n          // delete the config set\n          zkStateReader.getConfigManager().deleteConfigDir(configSetName);\n        }\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    Object o = message.get(MaintainRoutedAliasCmd.INVOKED_BY_ROUTED_ALIAS);\n    if (o != null) {\n      ((Runnable)o).run(); // this will ensure the collection is removed from the alias before it disappears.\n    }\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      @SuppressWarnings({\"unchecked\"})\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n      // delete related config set iff: it is auto generated AND not related to any other collection\n      String configSetName = zkStateReader.readConfigName(collection);\n\n      if (ConfigSetsHandlerApi.isAutoGeneratedConfigSet(configSetName)) {\n        boolean configSetIsUsedByOtherCollection = false;\n\n        // make sure the configSet is not shared with other collections\n        // Similar to what happens in: OverseerConfigSetMessageHandler::deleteConfigSet\n        for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n          String otherConfigSetName = null;\n          try {\n            otherConfigSetName = zkStateReader.readConfigName(entry.getKey());\n          } catch (KeeperException ex) {\n            // ignore 'no config found' errors\n          }\n          if (configSetName.equals(otherConfigSetName)) {\n            configSetIsUsedByOtherCollection = true;\n            break;\n          }\n        }\n\n        if (!configSetIsUsedByOtherCollection) {\n          // delete the config set\n          zkStateReader.getConfigManager().deleteConfigDir(configSetName);\n        }\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1852cb03cf4922477072449dd9de2fab588d1adb","date":1600862151,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    Object o = message.get(MaintainRoutedAliasCmd.INVOKED_BY_ROUTED_ALIAS);\n    if (o != null) {\n      ((Runnable)o).run(); // this will ensure the collection is removed from the alias before it disappears.\n    }\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      @SuppressWarnings({\"unchecked\"})\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n      // delete related config set iff: it is auto generated AND not related to any other collection\n      String configSetName = zkStateReader.readConfigName(collection);\n\n      if (ConfigSetsHandler.isAutoGeneratedConfigSet(configSetName)) {\n        boolean configSetIsUsedByOtherCollection = false;\n\n        // make sure the configSet is not shared with other collections\n        // Similar to what happens in: OverseerConfigSetMessageHandler::deleteConfigSet\n        for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n          String otherConfigSetName = null;\n          try {\n            otherConfigSetName = zkStateReader.readConfigName(entry.getKey());\n          } catch (KeeperException ex) {\n            // ignore 'no config found' errors\n          }\n          if (configSetName.equals(otherConfigSetName)) {\n            configSetIsUsedByOtherCollection = true;\n            break;\n          }\n        }\n\n        if (!configSetIsUsedByOtherCollection) {\n          // delete the config set\n          zkStateReader.getConfigManager().deleteConfigDir(configSetName);\n        }\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    Object o = message.get(MaintainRoutedAliasCmd.INVOKED_BY_ROUTED_ALIAS);\n    if (o != null) {\n      ((Runnable)o).run(); // this will ensure the collection is removed from the alias before it disappears.\n    }\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      @SuppressWarnings({\"unchecked\"})\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n      // delete related config set iff: it is auto generated AND not related to any other collection\n      String configSetName = zkStateReader.readConfigName(collection);\n\n      if (ConfigSetsHandlerApi.isAutoGeneratedConfigSet(configSetName)) {\n        boolean configSetIsUsedByOtherCollection = false;\n\n        // make sure the configSet is not shared with other collections\n        // Similar to what happens in: OverseerConfigSetMessageHandler::deleteConfigSet\n        for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n          String otherConfigSetName = null;\n          try {\n            otherConfigSetName = zkStateReader.readConfigName(entry.getKey());\n          } catch (KeeperException ex) {\n            // ignore 'no config found' errors\n          }\n          if (configSetName.equals(otherConfigSetName)) {\n            configSetIsUsedByOtherCollection = true;\n            break;\n          }\n        }\n\n        if (!configSetIsUsedByOtherCollection) {\n          // delete the config set\n          zkStateReader.getConfigManager().deleteConfigDir(configSetName);\n        }\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"7d9def7b715c2324a9f84c1fc2e60a5c03c73331":["06263309947a9804c326e35ce627be8768e123a4"],"c526352db87264a72a7a9ad68c1b769b81e54305":["121de2b1a2f90238d017b11597526f7441dd0792"],"59bad1cc1e7f90125a140496e79b06afcedb68ec":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["27639bb5e041490ce599065875dd2f6d8beef62a"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7b366e7dd3172289251a86be96031af4002cd19c":["b6e5eb1137994855cee975febe08850fcb7726d3"],"1852cb03cf4922477072449dd9de2fab588d1adb":["e7b17e79a71117668ecbf8d3417c876e41396565"],"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c":["7b366e7dd3172289251a86be96031af4002cd19c"],"121de2b1a2f90238d017b11597526f7441dd0792":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"06263309947a9804c326e35ce627be8768e123a4":["b94236357aaa22b76c10629851fe4e376e0cea82"],"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a":["7d9def7b715c2324a9f84c1fc2e60a5c03c73331"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"69e6520a21709190413a63084ed135271aab1a7c":["59bad1cc1e7f90125a140496e79b06afcedb68ec"],"b6e5eb1137994855cee975febe08850fcb7726d3":["69e6520a21709190413a63084ed135271aab1a7c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c"],"27639bb5e041490ce599065875dd2f6d8beef62a":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1852cb03cf4922477072449dd9de2fab588d1adb"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["1852cb03cf4922477072449dd9de2fab588d1adb"],"b94236357aaa22b76c10629851fe4e376e0cea82":["06263309947a9804c326e35ce627be8768e123a4"],"7d9def7b715c2324a9f84c1fc2e60a5c03c73331":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"59bad1cc1e7f90125a140496e79b06afcedb68ec":["69e6520a21709190413a63084ed135271aab1a7c"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["59bad1cc1e7f90125a140496e79b06afcedb68ec"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"7b366e7dd3172289251a86be96031af4002cd19c":["d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c"],"1852cb03cf4922477072449dd9de2fab588d1adb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"06263309947a9804c326e35ce627be8768e123a4":["7d9def7b715c2324a9f84c1fc2e60a5c03c73331"],"121de2b1a2f90238d017b11597526f7441dd0792":["c526352db87264a72a7a9ad68c1b769b81e54305"],"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a":["27639bb5e041490ce599065875dd2f6d8beef62a"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["121de2b1a2f90238d017b11597526f7441dd0792"],"69e6520a21709190413a63084ed135271aab1a7c":["b6e5eb1137994855cee975febe08850fcb7726d3"],"b6e5eb1137994855cee975febe08850fcb7726d3":["7b366e7dd3172289251a86be96031af4002cd19c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"27639bb5e041490ce599065875dd2f6d8beef62a":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}