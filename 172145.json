{"path":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","sourceNew":"    public FieldsReader(final SegmentReadState readState) throws IOException {\n\n      // Read _X.per and init each format:\n      boolean success = false;\n      try {\n        new VisitPerFieldFile(readState.dir, readState.segmentInfo.name, readState.segmentSuffix) {\n          @Override\n          protected void visitOneFormat(String segmentSuffix, PostingsFormat postingsFormat) throws IOException {\n            formats.put(postingsFormat, postingsFormat.fieldsProducer(new SegmentReadState(readState, segmentSuffix)));\n          }\n\n          @Override\n          protected void visitOneField(String fieldName, PostingsFormat postingsFormat) throws IOException {\n            assert formats.containsKey(postingsFormat);\n            fields.put(fieldName, formats.get(postingsFormat));\n          }\n        };\n        success = true;\n      } finally {\n        if (!success) {\n          IOUtils.closeWhileHandlingException(formats.values());\n        }\n      }\n    }\n\n","sourceOld":"    public FieldsReader(final SegmentReadState readState) throws IOException {\n\n      // Read _X.per and init each format:\n      boolean success = false;\n      try {\n        new VisitPerFieldFile(readState.dir, readState.segmentInfo.name, readState.segmentSuffix) {\n          @Override\n          protected void visitOneFormat(String segmentSuffix, PostingsFormat postingsFormat) throws IOException {\n            formats.put(postingsFormat, postingsFormat.fieldsProducer(new SegmentReadState(readState, segmentSuffix)));\n          }\n\n          @Override\n          protected void visitOneField(String fieldName, PostingsFormat postingsFormat) throws IOException {\n            assert formats.containsKey(postingsFormat);\n            fields.put(fieldName, formats.get(postingsFormat));\n          }\n        };\n        success = true;\n      } finally {\n        if (!success) {\n          IOUtils.closeWhileHandlingException(formats.values());\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e816e693615395fd0e107b08e48caff42938190","date":1337635314,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","sourceNew":"    public FieldsReader(final SegmentReadState readState) throws IOException {\n\n      // Read _X.per and init each format:\n      boolean success = false;\n      try {\n        // Read field name -> format name\n        for (FieldInfo fi : readState.fieldInfos) {\n          if (fi.isIndexed()) {\n            final String fieldName = fi.name;\n            final String formatName = fi.getAttribute(PER_FIELD_FORMAT_KEY);\n            if (formatName != null) {\n              // null formatName means the field is in fieldInfos, but has no postings!\n              PostingsFormat format = PostingsFormat.forName(formatName);\n              if (!formats.containsKey(format)) {\n                formats.put(format, format.fieldsProducer(new SegmentReadState(readState, formatName)));\n              }\n              fields.put(fieldName, formats.get(format));\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          IOUtils.closeWhileHandlingException(formats.values());\n        }\n      }\n    }\n\n","sourceOld":"    public FieldsReader(final SegmentReadState readState) throws IOException {\n\n      // Read _X.per and init each format:\n      boolean success = false;\n      try {\n        new VisitPerFieldFile(readState.dir, readState.segmentInfo.name, readState.segmentSuffix) {\n          @Override\n          protected void visitOneFormat(String segmentSuffix, PostingsFormat postingsFormat) throws IOException {\n            formats.put(postingsFormat, postingsFormat.fieldsProducer(new SegmentReadState(readState, segmentSuffix)));\n          }\n\n          @Override\n          protected void visitOneField(String fieldName, PostingsFormat postingsFormat) throws IOException {\n            assert formats.containsKey(postingsFormat);\n            fields.put(fieldName, formats.get(postingsFormat));\n          }\n        };\n        success = true;\n      } finally {\n        if (!success) {\n          IOUtils.closeWhileHandlingException(formats.values());\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["b0c99c9b095ebe88603d5dc33606fdfe7782cb2f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","sourceNew":"    public FieldsReader(final SegmentReadState readState) throws IOException {\n\n      // Read _X.per and init each format:\n      boolean success = false;\n      try {\n        // Read field name -> format name\n        for (FieldInfo fi : readState.fieldInfos) {\n          if (fi.isIndexed()) {\n            final String fieldName = fi.name;\n            final String formatName = fi.getAttribute(PER_FIELD_FORMAT_KEY);\n            if (formatName != null) {\n              // null formatName means the field is in fieldInfos, but has no postings!\n              PostingsFormat format = PostingsFormat.forName(formatName);\n              if (!formats.containsKey(format)) {\n                formats.put(format, format.fieldsProducer(new SegmentReadState(readState, formatName)));\n              }\n              fields.put(fieldName, formats.get(format));\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          IOUtils.closeWhileHandlingException(formats.values());\n        }\n      }\n    }\n\n","sourceOld":"    public FieldsReader(final SegmentReadState readState) throws IOException {\n\n      // Read _X.per and init each format:\n      boolean success = false;\n      try {\n        new VisitPerFieldFile(readState.dir, readState.segmentInfo.name, readState.segmentSuffix) {\n          @Override\n          protected void visitOneFormat(String segmentSuffix, PostingsFormat postingsFormat) throws IOException {\n            formats.put(postingsFormat, postingsFormat.fieldsProducer(new SegmentReadState(readState, segmentSuffix)));\n          }\n\n          @Override\n          protected void visitOneField(String fieldName, PostingsFormat postingsFormat) throws IOException {\n            assert formats.containsKey(postingsFormat);\n            fields.put(fieldName, formats.get(postingsFormat));\n          }\n        };\n        success = true;\n      } finally {\n        if (!success) {\n          IOUtils.closeWhileHandlingException(formats.values());\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0c99c9b095ebe88603d5dc33606fdfe7782cb2f","date":1338408958,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","sourceNew":"    public FieldsReader(final SegmentReadState readState) throws IOException {\n\n      // Read _X.per and init each format:\n      boolean success = false;\n      try {\n        // Read field name -> format name\n        for (FieldInfo fi : readState.fieldInfos) {\n          if (fi.isIndexed()) {\n            final String fieldName = fi.name;\n            final String formatName = fi.getAttribute(PER_FIELD_FORMAT_KEY);\n            if (formatName != null) {\n              // null formatName means the field is in fieldInfos, but has no postings!\n              final String suffix = fi.getAttribute(PER_FIELD_SUFFIX_KEY);\n              assert suffix != null;\n              PostingsFormat format = PostingsFormat.forName(formatName);\n              String segmentSuffix = getSuffix(formatName, suffix);\n              if (!formats.containsKey(segmentSuffix)) {\n                formats.put(segmentSuffix, format.fieldsProducer(new SegmentReadState(readState, segmentSuffix)));\n              }\n              fields.put(fieldName, formats.get(segmentSuffix));\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          IOUtils.closeWhileHandlingException(formats.values());\n        }\n      }\n    }\n\n","sourceOld":"    public FieldsReader(final SegmentReadState readState) throws IOException {\n\n      // Read _X.per and init each format:\n      boolean success = false;\n      try {\n        // Read field name -> format name\n        for (FieldInfo fi : readState.fieldInfos) {\n          if (fi.isIndexed()) {\n            final String fieldName = fi.name;\n            final String formatName = fi.getAttribute(PER_FIELD_FORMAT_KEY);\n            if (formatName != null) {\n              // null formatName means the field is in fieldInfos, but has no postings!\n              PostingsFormat format = PostingsFormat.forName(formatName);\n              if (!formats.containsKey(format)) {\n                formats.put(format, format.fieldsProducer(new SegmentReadState(readState, formatName)));\n              }\n              fields.put(fieldName, formats.get(format));\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          IOUtils.closeWhileHandlingException(formats.values());\n        }\n      }\n    }\n\n","bugFix":["2e816e693615395fd0e107b08e48caff42938190"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ee4acc14f03bf124a6f983def032db2489bd00d","date":1411815313,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","sourceNew":"    public FieldsReader(final SegmentReadState readState) throws IOException {\n\n      // Read _X.per and init each format:\n      boolean success = false;\n      try {\n        // Read field name -> format name\n        for (FieldInfo fi : readState.fieldInfos) {\n          if (fi.isIndexed()) {\n            final String fieldName = fi.name;\n            final String formatName = fi.getAttribute(PER_FIELD_FORMAT_KEY);\n            if (formatName != null) {\n              // null formatName means the field is in fieldInfos, but has no postings!\n              final String suffix = fi.getAttribute(PER_FIELD_SUFFIX_KEY);\n              if (suffix == null) {\n                throw new IllegalStateException(\"missing attribute: \" + PER_FIELD_SUFFIX_KEY + \" for field: \" + fieldName);\n              }\n              PostingsFormat format = PostingsFormat.forName(formatName);\n              String segmentSuffix = getSuffix(formatName, suffix);\n              if (!formats.containsKey(segmentSuffix)) {\n                formats.put(segmentSuffix, format.fieldsProducer(new SegmentReadState(readState, segmentSuffix)));\n              }\n              fields.put(fieldName, formats.get(segmentSuffix));\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          IOUtils.closeWhileHandlingException(formats.values());\n        }\n      }\n    }\n\n","sourceOld":"    public FieldsReader(final SegmentReadState readState) throws IOException {\n\n      // Read _X.per and init each format:\n      boolean success = false;\n      try {\n        // Read field name -> format name\n        for (FieldInfo fi : readState.fieldInfos) {\n          if (fi.isIndexed()) {\n            final String fieldName = fi.name;\n            final String formatName = fi.getAttribute(PER_FIELD_FORMAT_KEY);\n            if (formatName != null) {\n              // null formatName means the field is in fieldInfos, but has no postings!\n              final String suffix = fi.getAttribute(PER_FIELD_SUFFIX_KEY);\n              assert suffix != null;\n              PostingsFormat format = PostingsFormat.forName(formatName);\n              String segmentSuffix = getSuffix(formatName, suffix);\n              if (!formats.containsKey(segmentSuffix)) {\n                formats.put(segmentSuffix, format.fieldsProducer(new SegmentReadState(readState, segmentSuffix)));\n              }\n              fields.put(fieldName, formats.get(segmentSuffix));\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          IOUtils.closeWhileHandlingException(formats.values());\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bb9a29a5e71a90295f175df8919802993142c9a","date":1412517673,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","sourceNew":"    public FieldsReader(final SegmentReadState readState) throws IOException {\n\n      // Read _X.per and init each format:\n      boolean success = false;\n      try {\n        // Read field name -> format name\n        for (FieldInfo fi : readState.fieldInfos) {\n          if (fi.isIndexed()) {\n            final String fieldName = fi.name;\n            final String formatName = fi.getAttribute(PER_FIELD_FORMAT_KEY);\n            if (formatName != null) {\n              // null formatName means the field is in fieldInfos, but has no postings!\n              final String suffix = fi.getAttribute(PER_FIELD_SUFFIX_KEY);\n              if (suffix == null) {\n                throw new IllegalStateException(\"missing attribute: \" + PER_FIELD_SUFFIX_KEY + \" for field: \" + fieldName);\n              }\n              PostingsFormat format = PostingsFormat.forName(formatName);\n              String segmentSuffix = getSuffix(formatName, suffix);\n              if (!formats.containsKey(segmentSuffix)) {\n                formats.put(segmentSuffix, format.fieldsProducer(new SegmentReadState(readState, segmentSuffix)));\n              }\n              fields.put(fieldName, formats.get(segmentSuffix));\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          IOUtils.closeWhileHandlingException(formats.values());\n        }\n      }\n    }\n\n","sourceOld":"    public FieldsReader(final SegmentReadState readState) throws IOException {\n\n      // Read _X.per and init each format:\n      boolean success = false;\n      try {\n        // Read field name -> format name\n        for (FieldInfo fi : readState.fieldInfos) {\n          if (fi.isIndexed()) {\n            final String fieldName = fi.name;\n            final String formatName = fi.getAttribute(PER_FIELD_FORMAT_KEY);\n            if (formatName != null) {\n              // null formatName means the field is in fieldInfos, but has no postings!\n              final String suffix = fi.getAttribute(PER_FIELD_SUFFIX_KEY);\n              assert suffix != null;\n              PostingsFormat format = PostingsFormat.forName(formatName);\n              String segmentSuffix = getSuffix(formatName, suffix);\n              if (!formats.containsKey(segmentSuffix)) {\n                formats.put(segmentSuffix, format.fieldsProducer(new SegmentReadState(readState, segmentSuffix)));\n              }\n              fields.put(fieldName, formats.get(segmentSuffix));\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          IOUtils.closeWhileHandlingException(formats.values());\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"556a4aab886d75371b2af129d87be3c2795cea76","date":1414954991,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","sourceNew":"    public FieldsReader(final SegmentReadState readState) throws IOException {\n\n      // Read _X.per and init each format:\n      boolean success = false;\n      try {\n        // Read field name -> format name\n        for (FieldInfo fi : readState.fieldInfos) {\n          if (fi.getIndexOptions() != IndexOptions.NONE) {\n            final String fieldName = fi.name;\n            final String formatName = fi.getAttribute(PER_FIELD_FORMAT_KEY);\n            if (formatName != null) {\n              // null formatName means the field is in fieldInfos, but has no postings!\n              final String suffix = fi.getAttribute(PER_FIELD_SUFFIX_KEY);\n              if (suffix == null) {\n                throw new IllegalStateException(\"missing attribute: \" + PER_FIELD_SUFFIX_KEY + \" for field: \" + fieldName);\n              }\n              PostingsFormat format = PostingsFormat.forName(formatName);\n              String segmentSuffix = getSuffix(formatName, suffix);\n              if (!formats.containsKey(segmentSuffix)) {\n                formats.put(segmentSuffix, format.fieldsProducer(new SegmentReadState(readState, segmentSuffix)));\n              }\n              fields.put(fieldName, formats.get(segmentSuffix));\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          IOUtils.closeWhileHandlingException(formats.values());\n        }\n      }\n    }\n\n","sourceOld":"    public FieldsReader(final SegmentReadState readState) throws IOException {\n\n      // Read _X.per and init each format:\n      boolean success = false;\n      try {\n        // Read field name -> format name\n        for (FieldInfo fi : readState.fieldInfos) {\n          if (fi.isIndexed()) {\n            final String fieldName = fi.name;\n            final String formatName = fi.getAttribute(PER_FIELD_FORMAT_KEY);\n            if (formatName != null) {\n              // null formatName means the field is in fieldInfos, but has no postings!\n              final String suffix = fi.getAttribute(PER_FIELD_SUFFIX_KEY);\n              if (suffix == null) {\n                throw new IllegalStateException(\"missing attribute: \" + PER_FIELD_SUFFIX_KEY + \" for field: \" + fieldName);\n              }\n              PostingsFormat format = PostingsFormat.forName(formatName);\n              String segmentSuffix = getSuffix(formatName, suffix);\n              if (!formats.containsKey(segmentSuffix)) {\n                formats.put(segmentSuffix, format.fieldsProducer(new SegmentReadState(readState, segmentSuffix)));\n              }\n              fields.put(fieldName, formats.get(segmentSuffix));\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          IOUtils.closeWhileHandlingException(formats.values());\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"35fb92999b9df7df2ce2b35b83a044cbede61f45","date":1429037650,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsReader#FieldsReader(SegmentReadState).mjava","sourceNew":"    public FieldsReader(final SegmentReadState readState) throws IOException {\n\n      // Read _X.per and init each format:\n      boolean success = false;\n      try {\n        // Read field name -> format name\n        for (FieldInfo fi : readState.fieldInfos) {\n          if (fi.getIndexOptions() != IndexOptions.NONE) {\n            final String fieldName = fi.name;\n            final String formatName = fi.getAttribute(PER_FIELD_FORMAT_KEY);\n            if (formatName != null) {\n              // null formatName means the field is in fieldInfos, but has no postings!\n              final String suffix = fi.getAttribute(PER_FIELD_SUFFIX_KEY);\n              if (suffix == null) {\n                throw new IllegalStateException(\"missing attribute: \" + PER_FIELD_SUFFIX_KEY + \" for field: \" + fieldName);\n              }\n              PostingsFormat format = PostingsFormat.forName(formatName);\n              String segmentSuffix = getSuffix(formatName, suffix);\n              if (!formats.containsKey(segmentSuffix)) {\n                formats.put(segmentSuffix, format.fieldsProducer(new SegmentReadState(readState, segmentSuffix)));\n              }\n              fields.put(fieldName, formats.get(segmentSuffix));\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          IOUtils.closeWhileHandlingException(formats.values());\n        }\n      }\n\n      this.segment = readState.segmentInfo.name;\n    }\n\n","sourceOld":"    public FieldsReader(final SegmentReadState readState) throws IOException {\n\n      // Read _X.per and init each format:\n      boolean success = false;\n      try {\n        // Read field name -> format name\n        for (FieldInfo fi : readState.fieldInfos) {\n          if (fi.getIndexOptions() != IndexOptions.NONE) {\n            final String fieldName = fi.name;\n            final String formatName = fi.getAttribute(PER_FIELD_FORMAT_KEY);\n            if (formatName != null) {\n              // null formatName means the field is in fieldInfos, but has no postings!\n              final String suffix = fi.getAttribute(PER_FIELD_SUFFIX_KEY);\n              if (suffix == null) {\n                throw new IllegalStateException(\"missing attribute: \" + PER_FIELD_SUFFIX_KEY + \" for field: \" + fieldName);\n              }\n              PostingsFormat format = PostingsFormat.forName(formatName);\n              String segmentSuffix = getSuffix(formatName, suffix);\n              if (!formats.containsKey(segmentSuffix)) {\n                formats.put(segmentSuffix, format.fieldsProducer(new SegmentReadState(readState, segmentSuffix)));\n              }\n              fields.put(fieldName, formats.get(segmentSuffix));\n            }\n          }\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          IOUtils.closeWhileHandlingException(formats.values());\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b0c99c9b095ebe88603d5dc33606fdfe7782cb2f":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","2e816e693615395fd0e107b08e48caff42938190"],"35fb92999b9df7df2ce2b35b83a044cbede61f45":["556a4aab886d75371b2af129d87be3c2795cea76"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9bb9a29a5e71a90295f175df8919802993142c9a":["b0c99c9b095ebe88603d5dc33606fdfe7782cb2f","8ee4acc14f03bf124a6f983def032db2489bd00d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8ee4acc14f03bf124a6f983def032db2489bd00d":["b0c99c9b095ebe88603d5dc33606fdfe7782cb2f"],"2e816e693615395fd0e107b08e48caff42938190":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"556a4aab886d75371b2af129d87be3c2795cea76":["9bb9a29a5e71a90295f175df8919802993142c9a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["35fb92999b9df7df2ce2b35b83a044cbede61f45"]},"commit2Childs":{"b0c99c9b095ebe88603d5dc33606fdfe7782cb2f":["9bb9a29a5e71a90295f175df8919802993142c9a","8ee4acc14f03bf124a6f983def032db2489bd00d"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["b0c99c9b095ebe88603d5dc33606fdfe7782cb2f"],"35fb92999b9df7df2ce2b35b83a044cbede61f45":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","2e816e693615395fd0e107b08e48caff42938190"],"9bb9a29a5e71a90295f175df8919802993142c9a":["556a4aab886d75371b2af129d87be3c2795cea76"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"8ee4acc14f03bf124a6f983def032db2489bd00d":["9bb9a29a5e71a90295f175df8919802993142c9a"],"2e816e693615395fd0e107b08e48caff42938190":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"556a4aab886d75371b2af129d87be3c2795cea76":["35fb92999b9df7df2ce2b35b83a044cbede61f45"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}