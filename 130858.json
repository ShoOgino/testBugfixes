{"path":"solr/core/src/test/org/apache/solr/search/function/TestMinMaxOnMultiValuedField#testExpectedSortOrdering(String,List[SolrInputDocument]).mjava","commits":[{"id":"4cf2282b6a7c3f113e7a233b785b80527c03d590","date":1516129064,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestMinMaxOnMultiValuedField#testExpectedSortOrdering(String,List[SolrInputDocument]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Given a sort clause, and a list of documents in sorted order, this method will clear the index \n   * and then add the documents in a random order (to ensure the index insertion order is not a factor) \n   * and then validate that a <code>*:*</code> query returns the documents in the original order.\n   *\n   * @see #buildMultiValueSortedDocuments\n   * @see #clearIndex\n   */   \n  private void testExpectedSortOrdering(final String sort,\n                                        final List<SolrInputDocument> sortedDocs) {\n    clearIndex();\n\n    // shuffle a copy of the doc list (to ensure index order isn't linked to uniqueKey order)\n    List<SolrInputDocument> randOrderedDocs = new ArrayList<>(sortedDocs);\n    Collections.shuffle(randOrderedDocs, random());\n\n    for (SolrInputDocument doc : randOrderedDocs) {\n      assertU(adoc(doc));\n    }\n    assertU(commit());\n\n    // now use the original sorted docs to build up the expected sort order as a list of xpath\n    List<String> xpaths = new ArrayList<>(sortedDocs.size() + 1);\n    xpaths.add(\"//result[@numFound='\"+sortedDocs.size()+\"']\");\n    int seq = 0;\n    for (SolrInputDocument doc : sortedDocs) {\n      xpaths.add(\"//result/doc[\"+(++seq)+\"]/str[@name='id']='\"+doc.getFieldValue(\"id\")+\"'\");\n    }\n    assertQ(req(\"q\", \"*:*\", \"rows\", \"\" + sortedDocs.size(), \"sort\", sort),\n            xpaths.toArray(new String[xpaths.size()]));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestMinMaxOnMultiValuedField#testExpectedSortOrdering(String,List[SolrInputDocument]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Given a sort clause, and a list of documents in sorted order, this method will clear the index \n   * and then add the documents in a random order (to ensure the index insertion order is not a factor) \n   * and then validate that a <code>*:*</code> query returns the documents in the original order.\n   *\n   * @see #buildMultiValueSortedDocuments\n   * @see #clearIndex\n   */   \n  private void testExpectedSortOrdering(final String sort,\n                                        final List<SolrInputDocument> sortedDocs) {\n    clearIndex();\n\n    // shuffle a copy of the doc list (to ensure index order isn't linked to uniqueKey order)\n    List<SolrInputDocument> randOrderedDocs = new ArrayList<>(sortedDocs);\n    Collections.shuffle(randOrderedDocs, random());\n\n    for (SolrInputDocument doc : randOrderedDocs) {\n      assertU(adoc(doc));\n    }\n    assertU(commit());\n\n    // now use the original sorted docs to build up the expected sort order as a list of xpath\n    List<String> xpaths = new ArrayList<>(sortedDocs.size() + 1);\n    xpaths.add(\"//result[@numFound='\"+sortedDocs.size()+\"']\");\n    int seq = 0;\n    for (SolrInputDocument doc : sortedDocs) {\n      xpaths.add(\"//result/doc[\"+(++seq)+\"]/str[@name='id']='\"+doc.getFieldValue(\"id\")+\"'\");\n    }\n    assertQ(req(\"q\", \"*:*\", \"rows\", \"\" + sortedDocs.size(), \"sort\", sort),\n            xpaths.toArray(new String[xpaths.size()]));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4cf2282b6a7c3f113e7a233b785b80527c03d590"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cf2282b6a7c3f113e7a233b785b80527c03d590":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","4cf2282b6a7c3f113e7a233b785b80527c03d590"],"4cf2282b6a7c3f113e7a233b785b80527c03d590":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}