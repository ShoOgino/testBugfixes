{"path":"solr/core/src/test/org/apache/solr/search/facet/TestCloudJSONFacetSKGEquiv#assertFacetSKGsAreConsistent(Map[String,TermFacet],String,String,String).mjava","commits":[{"id":"c5ec3c464e62e57df598ba20e010313bf6d5d7b4","date":1589998565,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestCloudJSONFacetSKGEquiv#assertFacetSKGsAreConsistent(Map[String,TermFacet],String,String,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Given a set of term facets, and top level query strings, asserts that \n   * the results of these queries are identical even when varying the <code>method_val</code> param\n   */\n  private void assertFacetSKGsAreConsistent(final Map<String,TermFacet> facets,\n                                            final String query,\n                                            final String foreQ,\n                                            final String backQ) throws SolrServerException, IOException {\n    final SolrParams basicParams = params(\"rows\",\"0\",\n                                          \"q\", query, \"fore\", foreQ, \"back\", backQ,\n                                          \"json.facet\", Facet.toJSONFacetParamValue(facets));\n    \n    log.info(\"Doing full run: {}\", basicParams);\n    try {\n\n      // start by recording the results of the purely \"default\" behavior...\n      final NamedList expected = getFacetResponse(basicParams);\n\n      // now loop over all processors and compare them to the \"default\"...\n      for (FacetMethod method : EnumSet.allOf(FacetMethod.class)) {\n        ModifiableSolrParams options = params(\"method_val\", method.toString().toLowerCase(Locale.ROOT));\n          \n        final NamedList actual = getFacetResponse(SolrParams.wrapAppended(options, basicParams));\n\n        // we can't rely on a trivial assertEquals() comparison...\n        // \n        // the order of the sub-facet keys can change between\n        // processors.  (notably: method:enum vs method:smart when sort:\"index asc\")\n        // \n        // NOTE: this doesn't ignore the order of the buckets,\n        // it ignores the order of the keys in each bucket...\n        final String pathToMismatch = BaseDistributedSearchTestCase.compare\n          (expected, actual, 0,\n           Collections.singletonMap(\"buckets\", BaseDistributedSearchTestCase.UNORDERED));\n        if (null != pathToMismatch) {\n          log.error(\"{}: expected = {}\", options, expected);\n          log.error(\"{}: actual = {}\", options, actual);\n          fail(\"Mismatch: \" + pathToMismatch + \" using \" + options);\n        }\n      }\n    } catch (AssertionError e) {\n      throw new AssertionError(basicParams + \" ===> \" + e.getMessage(), e);\n    } finally {\n      log.info(\"Ending full run\"); \n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestCloudJSONFacetSKGEquiv#assertFacetSKGsAreConsistent(Map[String,TermFacet],String,String,String).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestCloudJSONFacetSKGEquiv#assertFacetSKGsAreConsistent(Map[String,TermFacet],String,String,String).mjava","sourceNew":"  /**\n   * Given a set of term facets, and top level query strings, asserts that \n   * the results of these queries are identical even when varying the <code>method_val</code> param\n   */\n  private void assertFacetSKGsAreConsistent(final Map<String,TermFacet> facets,\n                                            final String query,\n                                            final String foreQ,\n                                            final String backQ) throws SolrServerException, IOException {\n    final SolrParams basicParams = params(\"rows\",\"0\",\n                                          \"q\", query, \"fore\", foreQ, \"back\", backQ,\n                                          \"json.facet\", Facet.toJSONFacetParamValue(facets));\n    \n    log.info(\"Doing full run: {}\", basicParams);\n    try {\n\n      // start by recording the results of the purely \"default\" behavior...\n      @SuppressWarnings({\"rawtypes\"})\n      final NamedList expected = getFacetResponse(basicParams);\n\n      // now loop over all processors and compare them to the \"default\"...\n      for (FacetMethod method : EnumSet.allOf(FacetMethod.class)) {\n        ModifiableSolrParams options = params(\"method_val\", method.toString().toLowerCase(Locale.ROOT));\n          \n        @SuppressWarnings({\"rawtypes\"})\n        final NamedList actual = getFacetResponse(SolrParams.wrapAppended(options, basicParams));\n\n        // we can't rely on a trivial assertEquals() comparison...\n        // \n        // the order of the sub-facet keys can change between\n        // processors.  (notably: method:enum vs method:smart when sort:\"index asc\")\n        // \n        // NOTE: this doesn't ignore the order of the buckets,\n        // it ignores the order of the keys in each bucket...\n        final String pathToMismatch = BaseDistributedSearchTestCase.compare\n          (expected, actual, 0,\n           Collections.singletonMap(\"buckets\", BaseDistributedSearchTestCase.UNORDERED));\n        if (null != pathToMismatch) {\n          log.error(\"{}: expected = {}\", options, expected);\n          log.error(\"{}: actual = {}\", options, actual);\n          fail(\"Mismatch: \" + pathToMismatch + \" using \" + options);\n        }\n      }\n    } catch (AssertionError e) {\n      throw new AssertionError(basicParams + \" ===> \" + e.getMessage(), e);\n    } finally {\n      log.info(\"Ending full run\"); \n    }\n  }\n\n","sourceOld":"  /**\n   * Given a set of term facets, and top level query strings, asserts that \n   * the results of these queries are identical even when varying the <code>method_val</code> param\n   */\n  private void assertFacetSKGsAreConsistent(final Map<String,TermFacet> facets,\n                                            final String query,\n                                            final String foreQ,\n                                            final String backQ) throws SolrServerException, IOException {\n    final SolrParams basicParams = params(\"rows\",\"0\",\n                                          \"q\", query, \"fore\", foreQ, \"back\", backQ,\n                                          \"json.facet\", Facet.toJSONFacetParamValue(facets));\n    \n    log.info(\"Doing full run: {}\", basicParams);\n    try {\n\n      // start by recording the results of the purely \"default\" behavior...\n      final NamedList expected = getFacetResponse(basicParams);\n\n      // now loop over all processors and compare them to the \"default\"...\n      for (FacetMethod method : EnumSet.allOf(FacetMethod.class)) {\n        ModifiableSolrParams options = params(\"method_val\", method.toString().toLowerCase(Locale.ROOT));\n          \n        final NamedList actual = getFacetResponse(SolrParams.wrapAppended(options, basicParams));\n\n        // we can't rely on a trivial assertEquals() comparison...\n        // \n        // the order of the sub-facet keys can change between\n        // processors.  (notably: method:enum vs method:smart when sort:\"index asc\")\n        // \n        // NOTE: this doesn't ignore the order of the buckets,\n        // it ignores the order of the keys in each bucket...\n        final String pathToMismatch = BaseDistributedSearchTestCase.compare\n          (expected, actual, 0,\n           Collections.singletonMap(\"buckets\", BaseDistributedSearchTestCase.UNORDERED));\n        if (null != pathToMismatch) {\n          log.error(\"{}: expected = {}\", options, expected);\n          log.error(\"{}: actual = {}\", options, actual);\n          fail(\"Mismatch: \" + pathToMismatch + \" using \" + options);\n        }\n      }\n    } catch (AssertionError e) {\n      throw new AssertionError(basicParams + \" ===> \" + e.getMessage(), e);\n    } finally {\n      log.info(\"Ending full run\"); \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2f9e4bd10604489b5817ee29e35ac96a3148cbec","date":1594345357,"type":3,"author":"Michael Gibney","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestCloudJSONFacetSKGEquiv#assertFacetSKGsAreConsistent(Map[String,TermFacet],String,String,String).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestCloudJSONFacetSKGEquiv#assertFacetSKGsAreConsistent(Map[String,TermFacet],String,String,String).mjava","sourceNew":"  /**\n   * Given a set of term facets, and top level query strings, asserts that \n   * the results of these queries are identical even when varying the <code>method_val</code> param\n   * and when varying the <code>{@value RelatednessAgg#SWEEP_COLLECTION}</code> param; either by explicitly setting to \n   * <code>true</code> or <code>false</code> or by changing the param key to not set it at all.\n   */\n  private void assertFacetSKGsAreConsistent(final Map<String,TermFacet> facets,\n                                            final String query,\n                                            final String foreQ,\n                                            final String backQ) throws SolrServerException, IOException {\n    final SolrParams basicParams = params(\"rows\",\"0\",\n                                          \"q\", query, \"fore\", foreQ, \"back\", backQ,\n                                          \"json.facet\", Facet.toJSONFacetParamValue(facets));\n    \n    log.info(\"Doing full run: {}\", basicParams);\n    try {\n\n      // start by recording the results of the purely \"default\" behavior...\n      @SuppressWarnings({\"rawtypes\"})\n      final NamedList expected = getFacetResponse(basicParams);\n\n      // now loop over all permutations of processors and sweep values and and compare them to the \"default\"...\n      for (FacetMethod method : EnumSet.allOf(FacetMethod.class)) {\n        for (Boolean sweep : Arrays.asList(true, false, null)) {\n          final ModifiableSolrParams options = params(\"method_val\", method.toString().toLowerCase(Locale.ROOT));\n          if (null != sweep) {\n            options.add(\"sweep_key\", RelatednessAgg.SWEEP_COLLECTION);\n            options.add(\"sweep_val\", sweep.toString());\n          }\n          \n          @SuppressWarnings({\"rawtypes\"})\n          final NamedList actual = getFacetResponse(SolrParams.wrapAppended(options, basicParams));\n          \n          // we can't rely on a trivial assertEquals() comparison...\n          // \n          // the order of the sub-facet keys can change between\n          // processors.  (notably: method:enum vs method:smart when sort:\"index asc\")\n          // \n          // NOTE: this doesn't ignore the order of the buckets,\n          // it ignores the order of the keys in each bucket...\n          final String pathToMismatch = BaseDistributedSearchTestCase.compare\n            (expected, actual, 0,\n             Collections.singletonMap(\"buckets\", BaseDistributedSearchTestCase.UNORDERED));\n          if (null != pathToMismatch) {\n            log.error(\"{}: expected = {}\", options, expected);\n            log.error(\"{}: actual = {}\", options, actual);\n            fail(\"Mismatch: \" + pathToMismatch + \" using \" + options);\n          }\n        }\n      }\n    } catch (AssertionError e) {\n      throw new AssertionError(basicParams + \" ===> \" + e.getMessage(), e);\n    } finally {\n      log.info(\"Ending full run\"); \n    }\n  }\n\n","sourceOld":"  /**\n   * Given a set of term facets, and top level query strings, asserts that \n   * the results of these queries are identical even when varying the <code>method_val</code> param\n   */\n  private void assertFacetSKGsAreConsistent(final Map<String,TermFacet> facets,\n                                            final String query,\n                                            final String foreQ,\n                                            final String backQ) throws SolrServerException, IOException {\n    final SolrParams basicParams = params(\"rows\",\"0\",\n                                          \"q\", query, \"fore\", foreQ, \"back\", backQ,\n                                          \"json.facet\", Facet.toJSONFacetParamValue(facets));\n    \n    log.info(\"Doing full run: {}\", basicParams);\n    try {\n\n      // start by recording the results of the purely \"default\" behavior...\n      @SuppressWarnings({\"rawtypes\"})\n      final NamedList expected = getFacetResponse(basicParams);\n\n      // now loop over all processors and compare them to the \"default\"...\n      for (FacetMethod method : EnumSet.allOf(FacetMethod.class)) {\n        ModifiableSolrParams options = params(\"method_val\", method.toString().toLowerCase(Locale.ROOT));\n          \n        @SuppressWarnings({\"rawtypes\"})\n        final NamedList actual = getFacetResponse(SolrParams.wrapAppended(options, basicParams));\n\n        // we can't rely on a trivial assertEquals() comparison...\n        // \n        // the order of the sub-facet keys can change between\n        // processors.  (notably: method:enum vs method:smart when sort:\"index asc\")\n        // \n        // NOTE: this doesn't ignore the order of the buckets,\n        // it ignores the order of the keys in each bucket...\n        final String pathToMismatch = BaseDistributedSearchTestCase.compare\n          (expected, actual, 0,\n           Collections.singletonMap(\"buckets\", BaseDistributedSearchTestCase.UNORDERED));\n        if (null != pathToMismatch) {\n          log.error(\"{}: expected = {}\", options, expected);\n          log.error(\"{}: actual = {}\", options, actual);\n          fail(\"Mismatch: \" + pathToMismatch + \" using \" + options);\n        }\n      }\n    } catch (AssertionError e) {\n      throw new AssertionError(basicParams + \" ===> \" + e.getMessage(), e);\n    } finally {\n      log.info(\"Ending full run\"); \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c5ec3c464e62e57df598ba20e010313bf6d5d7b4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2f9e4bd10604489b5817ee29e35ac96a3148cbec":["e98520789adb1d5ad05afb4956eca0944a929688"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2f9e4bd10604489b5817ee29e35ac96a3148cbec"],"e98520789adb1d5ad05afb4956eca0944a929688":["c5ec3c464e62e57df598ba20e010313bf6d5d7b4"]},"commit2Childs":{"c5ec3c464e62e57df598ba20e010313bf6d5d7b4":["e98520789adb1d5ad05afb4956eca0944a929688"],"2f9e4bd10604489b5817ee29e35ac96a3148cbec":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c5ec3c464e62e57df598ba20e010313bf6d5d7b4"],"e98520789adb1d5ad05afb4956eca0944a929688":["2f9e4bd10604489b5817ee29e35ac96a3148cbec"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}