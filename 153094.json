{"path":"lucene/core/src/test/org/apache/lucene/index/TestSegmentInfos#testBitFlippedTriggersCorruptIndexException().mjava","commits":[{"id":"a490d7ce18bee8274e513491417782768950258a","date":1590757176,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestSegmentInfos#testBitFlippedTriggersCorruptIndexException().mjava","pathOld":"/dev/null","sourceNew":"  public void testBitFlippedTriggersCorruptIndexException() throws IOException {\n    BaseDirectoryWrapper dir = newDirectory();\n    dir.setCheckIndexOnClose(false);\n    byte id[] = StringHelper.randomId();\n    Codec codec = Codec.getDefault();\n\n    SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n    SegmentInfo info = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"_0\", 1, false, Codec.getDefault(),\n                                       Collections.<String,String>emptyMap(), id, Collections.<String,String>emptyMap(), null);\n    info.setFiles(Collections.<String>emptySet());\n    codec.segmentInfoFormat().write(dir, info, IOContext.DEFAULT);\n    SegmentCommitInfo commitInfo = new SegmentCommitInfo(info, 0, 0, -1, -1, -1, StringHelper.randomId());\n    sis.add(commitInfo);\n\n    info = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"_1\", 1, false, Codec.getDefault(),\n                           Collections.<String,String>emptyMap(), id, Collections.<String,String>emptyMap(), null);\n    info.setFiles(Collections.<String>emptySet());\n    codec.segmentInfoFormat().write(dir, info, IOContext.DEFAULT);\n    commitInfo = new SegmentCommitInfo(info, 0, 0,-1, -1, -1, StringHelper.randomId());\n    sis.add(commitInfo);\n\n    sis.commit(dir);\n\n    BaseDirectoryWrapper corruptDir = newDirectory();\n    corruptDir.setCheckIndexOnClose(false);\n    boolean corrupt = false;\n    for (String file : dir.listAll()) {\n      if (file.startsWith(IndexFileNames.SEGMENTS)) {\n        try (IndexInput in = dir.openInput(file, IOContext.DEFAULT);\n            IndexOutput out = corruptDir.createOutput(file, IOContext.DEFAULT)) {\n          final long corruptIndex = TestUtil.nextLong(random(), 0, in.length() - 1);\n          out.copyBytes(in, corruptIndex);\n          final int b = Byte.toUnsignedInt(in.readByte()) + TestUtil.nextInt(random(), 0x01, 0xff);\n          out.writeByte((byte) b);\n          out.copyBytes(in, in.length() - in.getFilePointer());\n        }\n        try (IndexInput in = corruptDir.openInput(file, IOContext.DEFAULT)) {\n          CodecUtil.checksumEntireFile(in);\n          if (VERBOSE) {\n            System.out.println(\"TEST: Altering the file did not update the checksum, aborting...\");\n          }\n          return;\n        } catch (CorruptIndexException e) {\n          // ok\n        }\n        corrupt = true;\n      } else if (slowFileExists(corruptDir, file) == false) { // extraFS\n        corruptDir.copyFrom(dir, file, file, IOContext.DEFAULT);\n      }\n    }\n    assertTrue(\"No segments file found\", corrupt);\n\n    expectThrows(CorruptIndexException.class, () -> SegmentInfos.readLatestCommit(corruptDir));\n    dir.close();\n    corruptDir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f8652918b4c62d30cbc4af2d62c2b944cb7fd17","date":1590759951,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestSegmentInfos#testBitFlippedTriggersCorruptIndexException().mjava","sourceNew":null,"sourceOld":"  public void testBitFlippedTriggersCorruptIndexException() throws IOException {\n    BaseDirectoryWrapper dir = newDirectory();\n    dir.setCheckIndexOnClose(false);\n    byte id[] = StringHelper.randomId();\n    Codec codec = Codec.getDefault();\n\n    SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n    SegmentInfo info = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"_0\", 1, false, Codec.getDefault(),\n                                       Collections.<String,String>emptyMap(), id, Collections.<String,String>emptyMap(), null);\n    info.setFiles(Collections.<String>emptySet());\n    codec.segmentInfoFormat().write(dir, info, IOContext.DEFAULT);\n    SegmentCommitInfo commitInfo = new SegmentCommitInfo(info, 0, 0, -1, -1, -1, StringHelper.randomId());\n    sis.add(commitInfo);\n\n    info = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"_1\", 1, false, Codec.getDefault(),\n                           Collections.<String,String>emptyMap(), id, Collections.<String,String>emptyMap(), null);\n    info.setFiles(Collections.<String>emptySet());\n    codec.segmentInfoFormat().write(dir, info, IOContext.DEFAULT);\n    commitInfo = new SegmentCommitInfo(info, 0, 0,-1, -1, -1, StringHelper.randomId());\n    sis.add(commitInfo);\n\n    sis.commit(dir);\n\n    BaseDirectoryWrapper corruptDir = newDirectory();\n    corruptDir.setCheckIndexOnClose(false);\n    boolean corrupt = false;\n    for (String file : dir.listAll()) {\n      if (file.startsWith(IndexFileNames.SEGMENTS)) {\n        try (IndexInput in = dir.openInput(file, IOContext.DEFAULT);\n            IndexOutput out = corruptDir.createOutput(file, IOContext.DEFAULT)) {\n          final long corruptIndex = TestUtil.nextLong(random(), 0, in.length() - 1);\n          out.copyBytes(in, corruptIndex);\n          final int b = Byte.toUnsignedInt(in.readByte()) + TestUtil.nextInt(random(), 0x01, 0xff);\n          out.writeByte((byte) b);\n          out.copyBytes(in, in.length() - in.getFilePointer());\n        }\n        try (IndexInput in = corruptDir.openInput(file, IOContext.DEFAULT)) {\n          CodecUtil.checksumEntireFile(in);\n          if (VERBOSE) {\n            System.out.println(\"TEST: Altering the file did not update the checksum, aborting...\");\n          }\n          return;\n        } catch (CorruptIndexException e) {\n          // ok\n        }\n        corrupt = true;\n      } else if (slowFileExists(corruptDir, file) == false) { // extraFS\n        corruptDir.copyFrom(dir, file, file, IOContext.DEFAULT);\n      }\n    }\n    assertTrue(\"No segments file found\", corrupt);\n\n    expectThrows(CorruptIndexException.class, () -> SegmentInfos.readLatestCommit(corruptDir));\n    dir.close();\n    corruptDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"814d2f5bda7af5560ba72150a2df22f38276b794","date":1590761146,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestSegmentInfos#testBitFlippedTriggersCorruptIndexException().mjava","pathOld":"/dev/null","sourceNew":"  public void testBitFlippedTriggersCorruptIndexException() throws IOException {\n    BaseDirectoryWrapper dir = newDirectory();\n    dir.setCheckIndexOnClose(false);\n    byte id[] = StringHelper.randomId();\n    Codec codec = Codec.getDefault();\n\n    SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n    SegmentInfo info = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"_0\", 1, false, Codec.getDefault(),\n                                       Collections.<String,String>emptyMap(), id, Collections.<String,String>emptyMap(), null);\n    info.setFiles(Collections.<String>emptySet());\n    codec.segmentInfoFormat().write(dir, info, IOContext.DEFAULT);\n    SegmentCommitInfo commitInfo = new SegmentCommitInfo(info, 0, 0, -1, -1, -1, StringHelper.randomId());\n    sis.add(commitInfo);\n\n    info = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"_1\", 1, false, Codec.getDefault(),\n                           Collections.<String,String>emptyMap(), id, Collections.<String,String>emptyMap(), null);\n    info.setFiles(Collections.<String>emptySet());\n    codec.segmentInfoFormat().write(dir, info, IOContext.DEFAULT);\n    commitInfo = new SegmentCommitInfo(info, 0, 0,-1, -1, -1, StringHelper.randomId());\n    sis.add(commitInfo);\n\n    sis.commit(dir);\n\n    BaseDirectoryWrapper corruptDir = newDirectory();\n    corruptDir.setCheckIndexOnClose(false);\n    boolean corrupt = false;\n    for (String file : dir.listAll()) {\n      if (file.startsWith(IndexFileNames.SEGMENTS)) {\n        try (IndexInput in = dir.openInput(file, IOContext.DEFAULT);\n            IndexOutput out = corruptDir.createOutput(file, IOContext.DEFAULT)) {\n          final long corruptIndex = TestUtil.nextLong(random(), 0, in.length() - 1);\n          out.copyBytes(in, corruptIndex);\n          final int b = Byte.toUnsignedInt(in.readByte()) + TestUtil.nextInt(random(), 0x01, 0xff);\n          out.writeByte((byte) b);\n          out.copyBytes(in, in.length() - in.getFilePointer());\n        }\n        try (IndexInput in = corruptDir.openInput(file, IOContext.DEFAULT)) {\n          CodecUtil.checksumEntireFile(in);\n          if (VERBOSE) {\n            System.out.println(\"TEST: Altering the file did not update the checksum, aborting...\");\n          }\n          return;\n        } catch (CorruptIndexException e) {\n          // ok\n        }\n        corrupt = true;\n      } else if (slowFileExists(corruptDir, file) == false) { // extraFS\n        corruptDir.copyFrom(dir, file, file, IOContext.DEFAULT);\n      }\n    }\n    assertTrue(\"No segments file found\", corrupt);\n\n    expectThrows(CorruptIndexException.class, () -> SegmentInfos.readLatestCommit(corruptDir));\n    dir.close();\n    corruptDir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cba8b96cbf39fa939a42401d24b42d8065da90b2","date":1590779770,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestSegmentInfos#testBitFlippedTriggersCorruptIndexException().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestSegmentInfos#testBitFlippedTriggersCorruptIndexException().mjava","sourceNew":"  public void testBitFlippedTriggersCorruptIndexException() throws IOException {\n    BaseDirectoryWrapper dir = newDirectory();\n    dir.setCheckIndexOnClose(false);\n    byte id[] = StringHelper.randomId();\n    Codec codec = Codec.getDefault();\n\n    SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n    SegmentInfo info = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"_0\", 1, false, Codec.getDefault(),\n                                       Collections.<String,String>emptyMap(), id, Collections.<String,String>emptyMap(), null);\n    info.setFiles(Collections.<String>emptySet());\n    codec.segmentInfoFormat().write(dir, info, IOContext.DEFAULT);\n    SegmentCommitInfo commitInfo = new SegmentCommitInfo(info, 0, 0, -1, -1, -1, StringHelper.randomId());\n    sis.add(commitInfo);\n\n    info = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"_1\", 1, false, Codec.getDefault(),\n                           Collections.<String,String>emptyMap(), id, Collections.<String,String>emptyMap(), null);\n    info.setFiles(Collections.<String>emptySet());\n    codec.segmentInfoFormat().write(dir, info, IOContext.DEFAULT);\n    commitInfo = new SegmentCommitInfo(info, 0, 0,-1, -1, -1, StringHelper.randomId());\n    sis.add(commitInfo);\n\n    sis.commit(dir);\n\n    BaseDirectoryWrapper corruptDir = newDirectory();\n    corruptDir.setCheckIndexOnClose(false);\n    boolean corrupt = false;\n    for (String file : dir.listAll()) {\n      if (file.startsWith(IndexFileNames.SEGMENTS)) {\n        try (IndexInput in = dir.openInput(file, IOContext.DEFAULT);\n            IndexOutput out = corruptDir.createOutput(file, IOContext.DEFAULT)) {\n          final long corruptIndex = TestUtil.nextLong(random(), 0, in.length() - 1);\n          out.copyBytes(in, corruptIndex);\n          final int b = Byte.toUnsignedInt(in.readByte()) + TestUtil.nextInt(random(), 0x01, 0xff);\n          out.writeByte((byte) b);\n          out.copyBytes(in, in.length() - in.getFilePointer());\n        }\n        try (IndexInput in = corruptDir.openInput(file, IOContext.DEFAULT)) {\n          CodecUtil.checksumEntireFile(in);\n          if (VERBOSE) {\n            System.out.println(\"TEST: Altering the file did not update the checksum, aborting...\");\n          }\n          return;\n        } catch (CorruptIndexException e) {\n          // ok\n        }\n        corrupt = true;\n      } else if (slowFileExists(corruptDir, file) == false) { // extraFS\n        corruptDir.copyFrom(dir, file, file, IOContext.DEFAULT);\n      }\n    }\n    assertTrue(\"No segments file found\", corrupt);\n\n    expectThrowsAnyOf(\n        Arrays.asList(CorruptIndexException.class, IndexFormatTooOldException.class, IndexFormatTooNewException.class),\n        () -> SegmentInfos.readLatestCommit(corruptDir));\n    dir.close();\n    corruptDir.close();\n  }\n\n","sourceOld":"  public void testBitFlippedTriggersCorruptIndexException() throws IOException {\n    BaseDirectoryWrapper dir = newDirectory();\n    dir.setCheckIndexOnClose(false);\n    byte id[] = StringHelper.randomId();\n    Codec codec = Codec.getDefault();\n\n    SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n    SegmentInfo info = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"_0\", 1, false, Codec.getDefault(),\n                                       Collections.<String,String>emptyMap(), id, Collections.<String,String>emptyMap(), null);\n    info.setFiles(Collections.<String>emptySet());\n    codec.segmentInfoFormat().write(dir, info, IOContext.DEFAULT);\n    SegmentCommitInfo commitInfo = new SegmentCommitInfo(info, 0, 0, -1, -1, -1, StringHelper.randomId());\n    sis.add(commitInfo);\n\n    info = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"_1\", 1, false, Codec.getDefault(),\n                           Collections.<String,String>emptyMap(), id, Collections.<String,String>emptyMap(), null);\n    info.setFiles(Collections.<String>emptySet());\n    codec.segmentInfoFormat().write(dir, info, IOContext.DEFAULT);\n    commitInfo = new SegmentCommitInfo(info, 0, 0,-1, -1, -1, StringHelper.randomId());\n    sis.add(commitInfo);\n\n    sis.commit(dir);\n\n    BaseDirectoryWrapper corruptDir = newDirectory();\n    corruptDir.setCheckIndexOnClose(false);\n    boolean corrupt = false;\n    for (String file : dir.listAll()) {\n      if (file.startsWith(IndexFileNames.SEGMENTS)) {\n        try (IndexInput in = dir.openInput(file, IOContext.DEFAULT);\n            IndexOutput out = corruptDir.createOutput(file, IOContext.DEFAULT)) {\n          final long corruptIndex = TestUtil.nextLong(random(), 0, in.length() - 1);\n          out.copyBytes(in, corruptIndex);\n          final int b = Byte.toUnsignedInt(in.readByte()) + TestUtil.nextInt(random(), 0x01, 0xff);\n          out.writeByte((byte) b);\n          out.copyBytes(in, in.length() - in.getFilePointer());\n        }\n        try (IndexInput in = corruptDir.openInput(file, IOContext.DEFAULT)) {\n          CodecUtil.checksumEntireFile(in);\n          if (VERBOSE) {\n            System.out.println(\"TEST: Altering the file did not update the checksum, aborting...\");\n          }\n          return;\n        } catch (CorruptIndexException e) {\n          // ok\n        }\n        corrupt = true;\n      } else if (slowFileExists(corruptDir, file) == false) { // extraFS\n        corruptDir.copyFrom(dir, file, file, IOContext.DEFAULT);\n      }\n    }\n    assertTrue(\"No segments file found\", corrupt);\n\n    expectThrows(CorruptIndexException.class, () -> SegmentInfos.readLatestCommit(corruptDir));\n    dir.close();\n    corruptDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5b0c4a3fc0bf36cf1333cc83b91c9537d62dfd6","date":1592379362,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestSegmentInfos#testBitFlippedTriggersCorruptIndexException().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestSegmentInfos#testBitFlippedTriggersCorruptIndexException().mjava","sourceNew":"  public void testBitFlippedTriggersCorruptIndexException() throws IOException {\n    BaseDirectoryWrapper dir = newDirectory();\n    dir.setCheckIndexOnClose(false);\n    byte id[] = StringHelper.randomId();\n    Codec codec = Codec.getDefault();\n\n    SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n    SegmentInfo info = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"_0\", 1, false, Codec.getDefault(),\n                                       Collections.<String,String>emptyMap(), id, Collections.<String,String>emptyMap(), null);\n    info.setFiles(Collections.<String>emptySet());\n    codec.segmentInfoFormat().write(dir, info, IOContext.DEFAULT);\n    SegmentCommitInfo commitInfo = new SegmentCommitInfo(info, 0, 0, -1, -1, -1, StringHelper.randomId());\n    sis.add(commitInfo);\n\n    info = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"_1\", 1, false, Codec.getDefault(),\n                           Collections.<String,String>emptyMap(), id, Collections.<String,String>emptyMap(), null);\n    info.setFiles(Collections.<String>emptySet());\n    codec.segmentInfoFormat().write(dir, info, IOContext.DEFAULT);\n    commitInfo = new SegmentCommitInfo(info, 0, 0,-1, -1, -1, StringHelper.randomId());\n    sis.add(commitInfo);\n\n    sis.commit(dir);\n\n    BaseDirectoryWrapper corruptDir = newDirectory();\n    corruptDir.setCheckIndexOnClose(false);\n    boolean corrupt = false;\n    for (String file : dir.listAll()) {\n      if (file.startsWith(IndexFileNames.SEGMENTS)) {\n        try (IndexInput in = dir.openInput(file, IOContext.DEFAULT);\n            IndexOutput out = corruptDir.createOutput(file, IOContext.DEFAULT)) {\n          final long corruptIndex = TestUtil.nextLong(random(), 0, in.length() - 1);\n          out.copyBytes(in, corruptIndex);\n          final int b = Byte.toUnsignedInt(in.readByte()) + TestUtil.nextInt(random(), 0x01, 0xff);\n          out.writeByte((byte) b);\n          out.copyBytes(in, in.length() - in.getFilePointer());\n        }\n        try (IndexInput in = corruptDir.openInput(file, IOContext.DEFAULT)) {\n          CodecUtil.checksumEntireFile(in);\n          if (VERBOSE) {\n            System.out.println(\"TEST: Altering the file did not update the checksum, aborting...\");\n          }\n          return;\n        } catch (CorruptIndexException e) {\n          // ok\n        }\n        corrupt = true;\n      } else if (ExtrasFS.isExtra(file) == false) {\n        corruptDir.copyFrom(dir, file, file, IOContext.DEFAULT);\n      }\n    }\n    assertTrue(\"No segments file found\", corrupt);\n\n    expectThrowsAnyOf(\n        Arrays.asList(CorruptIndexException.class, IndexFormatTooOldException.class, IndexFormatTooNewException.class),\n        () -> SegmentInfos.readLatestCommit(corruptDir));\n    dir.close();\n    corruptDir.close();\n  }\n\n","sourceOld":"  public void testBitFlippedTriggersCorruptIndexException() throws IOException {\n    BaseDirectoryWrapper dir = newDirectory();\n    dir.setCheckIndexOnClose(false);\n    byte id[] = StringHelper.randomId();\n    Codec codec = Codec.getDefault();\n\n    SegmentInfos sis = new SegmentInfos(Version.LATEST.major);\n    SegmentInfo info = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"_0\", 1, false, Codec.getDefault(),\n                                       Collections.<String,String>emptyMap(), id, Collections.<String,String>emptyMap(), null);\n    info.setFiles(Collections.<String>emptySet());\n    codec.segmentInfoFormat().write(dir, info, IOContext.DEFAULT);\n    SegmentCommitInfo commitInfo = new SegmentCommitInfo(info, 0, 0, -1, -1, -1, StringHelper.randomId());\n    sis.add(commitInfo);\n\n    info = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"_1\", 1, false, Codec.getDefault(),\n                           Collections.<String,String>emptyMap(), id, Collections.<String,String>emptyMap(), null);\n    info.setFiles(Collections.<String>emptySet());\n    codec.segmentInfoFormat().write(dir, info, IOContext.DEFAULT);\n    commitInfo = new SegmentCommitInfo(info, 0, 0,-1, -1, -1, StringHelper.randomId());\n    sis.add(commitInfo);\n\n    sis.commit(dir);\n\n    BaseDirectoryWrapper corruptDir = newDirectory();\n    corruptDir.setCheckIndexOnClose(false);\n    boolean corrupt = false;\n    for (String file : dir.listAll()) {\n      if (file.startsWith(IndexFileNames.SEGMENTS)) {\n        try (IndexInput in = dir.openInput(file, IOContext.DEFAULT);\n            IndexOutput out = corruptDir.createOutput(file, IOContext.DEFAULT)) {\n          final long corruptIndex = TestUtil.nextLong(random(), 0, in.length() - 1);\n          out.copyBytes(in, corruptIndex);\n          final int b = Byte.toUnsignedInt(in.readByte()) + TestUtil.nextInt(random(), 0x01, 0xff);\n          out.writeByte((byte) b);\n          out.copyBytes(in, in.length() - in.getFilePointer());\n        }\n        try (IndexInput in = corruptDir.openInput(file, IOContext.DEFAULT)) {\n          CodecUtil.checksumEntireFile(in);\n          if (VERBOSE) {\n            System.out.println(\"TEST: Altering the file did not update the checksum, aborting...\");\n          }\n          return;\n        } catch (CorruptIndexException e) {\n          // ok\n        }\n        corrupt = true;\n      } else if (slowFileExists(corruptDir, file) == false) { // extraFS\n        corruptDir.copyFrom(dir, file, file, IOContext.DEFAULT);\n      }\n    }\n    assertTrue(\"No segments file found\", corrupt);\n\n    expectThrowsAnyOf(\n        Arrays.asList(CorruptIndexException.class, IndexFormatTooOldException.class, IndexFormatTooNewException.class),\n        () -> SegmentInfos.readLatestCommit(corruptDir));\n    dir.close();\n    corruptDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7f8652918b4c62d30cbc4af2d62c2b944cb7fd17":["a490d7ce18bee8274e513491417782768950258a"],"c5b0c4a3fc0bf36cf1333cc83b91c9537d62dfd6":["cba8b96cbf39fa939a42401d24b42d8065da90b2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"814d2f5bda7af5560ba72150a2df22f38276b794":["7f8652918b4c62d30cbc4af2d62c2b944cb7fd17"],"a490d7ce18bee8274e513491417782768950258a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c5b0c4a3fc0bf36cf1333cc83b91c9537d62dfd6"],"cba8b96cbf39fa939a42401d24b42d8065da90b2":["814d2f5bda7af5560ba72150a2df22f38276b794"]},"commit2Childs":{"7f8652918b4c62d30cbc4af2d62c2b944cb7fd17":["814d2f5bda7af5560ba72150a2df22f38276b794"],"c5b0c4a3fc0bf36cf1333cc83b91c9537d62dfd6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a490d7ce18bee8274e513491417782768950258a"],"814d2f5bda7af5560ba72150a2df22f38276b794":["cba8b96cbf39fa939a42401d24b42d8065da90b2"],"a490d7ce18bee8274e513491417782768950258a":["7f8652918b4c62d30cbc4af2d62c2b944cb7fd17"],"cba8b96cbf39fa939a42401d24b42d8065da90b2":["c5b0c4a3fc0bf36cf1333cc83b91c9537d62dfd6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}