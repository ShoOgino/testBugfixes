{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","commits":[{"id":"7ca08c071cb75a8796c36ae6a1c90d7473c2a6df","date":1425554964,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbClient.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbClient.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","pathOld":"/dev/null","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbClient.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95","date":1429031018,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n            @Override\n            public NamedList<?> call() throws Exception {\n              return lbClient.request(lbRequest).getResponse();\n            }\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbClient.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"015571db92de1e6f75d89f34faeb520f99f07b97","date":1431466334,"type":3,"author":"Shawn Heisey","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n            @Override\n            public NamedList<?> call() throws Exception {\n              return lbClient.request(lbRequest).getResponse();\n            }\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n            @Override\n            public NamedList<?> call() throws Exception {\n              return lbClient.request(lbRequest).getResponse();\n            }\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":["bafca15d8e408346a67f4282ad1143b88023893b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3ca9e9e0800e26a0d02f8fcf73ec4f8362d0214","date":1442387183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n            @Override\n            public NamedList<?> call() throws Exception {\n              return lbClient.request(lbRequest).getResponse();\n            }\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n            @Override\n            public NamedList<?> call() throws Exception {\n              return lbClient.request(lbRequest).getResponse();\n            }\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":["bafca15d8e408346a67f4282ad1143b88023893b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"043df2e9a841864922c32756a44c939ed768cb89","date":1459876536,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n            @Override\n            public NamedList<?> call() throws Exception {\n              return lbClient.request(lbRequest).getResponse();\n            }\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6284684320a9808c41a5e43de958b2da22f89bd","date":1459977490,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n            @Override\n            public NamedList<?> call() throws Exception {\n              return lbClient.request(lbRequest).getResponse();\n            }\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b4f056774365da0f54c1678f478e2f9d1cbf07b","date":1462525042,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2233462ade0e629affa69a6f1e8d0205e4d6e596","date":1462534852,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"291857aeee5ec20518ddce131ac4362c0075ebe1","date":1467882201,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"920b078f38927d1129b28d683b5e89228a27edc0","date":1474295383,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<LBHttpSolrClient.Rsp>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest)));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<LBHttpSolrClient.Rsp>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<LBHttpSolrClient.Rsp> responseFuture = entry.getValue();\n        try {\n          LBHttpSolrClient.Rsp response = responseFuture.get();\n          shardResponses.add(url, response.getResponse());\n          if (url.startsWith(response.getServer())) { // startsWith to deal with stray trailing slashes\n            // we didn't hit our first-preference server, which means that our cached\n            // collection state is no longer valid\n            invalidateCollectionState(collection);\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          LBHttpSolrClient.Rsp response = lbClient.request(lbRequest);\n          NamedList<Object> rsp = response.getResponse();\n          shardResponses.add(url, rsp);\n          if (response.getServer().equals(url) == false) {\n            // we didn't hit our first-preference server, which means that our cached\n            // collection state is no longer valid\n            invalidateCollectionState(collection);\n          }\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d34a674b360fc9af16fceeb9df37363eceb3484","date":1474378553,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<LBHttpSolrClient.Rsp>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest)));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<LBHttpSolrClient.Rsp>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<LBHttpSolrClient.Rsp> responseFuture = entry.getValue();\n        try {\n          LBHttpSolrClient.Rsp response = responseFuture.get();\n          shardResponses.add(url, response.getResponse());\n          if (url.startsWith(response.getServer())) { // startsWith to deal with stray trailing slashes\n            // we didn't hit our first-preference server, which means that our cached\n            // collection state is no longer valid\n            invalidateCollectionState(collection);\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          LBHttpSolrClient.Rsp response = lbClient.request(lbRequest);\n          NamedList<Object> rsp = response.getResponse();\n          shardResponses.add(url, rsp);\n          if (response.getServer().equals(url) == false) {\n            // we didn't hit our first-preference server, which means that our cached\n            // collection state is no longer valid\n            invalidateCollectionState(collection);\n          }\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"03e91774ac3ed0db43b41f92ae954c447e50bdfb","date":1474437614,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<LBHttpSolrClient.Rsp>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest)));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<LBHttpSolrClient.Rsp>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<LBHttpSolrClient.Rsp> responseFuture = entry.getValue();\n        try {\n          LBHttpSolrClient.Rsp response = responseFuture.get();\n          shardResponses.add(url, response.getResponse());\n          if (url.startsWith(response.getServer())) { // startsWith to deal with stray trailing slashes\n            // we didn't hit our first-preference server, which means that our cached\n            // collection state is no longer valid\n            invalidateCollectionState(collection);\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          LBHttpSolrClient.Rsp response = lbClient.request(lbRequest);\n          NamedList<Object> rsp = response.getResponse();\n          shardResponses.add(url, rsp);\n          if (response.getServer().equals(url) == false) {\n            // we didn't hit our first-preference server, which means that our cached\n            // collection state is no longer valid\n            invalidateCollectionState(collection);\n          }\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3eaeb36333664e8cb92108ef03f68a7b90beb759","date":1480015298,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    collection = stateProvider.getCollectionName(collection);\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":5,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    collection = stateProvider.getCollectionName(collection);\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"043df2e9a841864922c32756a44c939ed768cb89":["a3ca9e9e0800e26a0d02f8fcf73ec4f8362d0214"],"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95":["7ca08c071cb75a8796c36ae6a1c90d7473c2a6df"],"03e91774ac3ed0db43b41f92ae954c447e50bdfb":["920b078f38927d1129b28d683b5e89228a27edc0","7d34a674b360fc9af16fceeb9df37363eceb3484"],"a3ca9e9e0800e26a0d02f8fcf73ec4f8362d0214":["015571db92de1e6f75d89f34faeb520f99f07b97"],"3eaeb36333664e8cb92108ef03f68a7b90beb759":["291857aeee5ec20518ddce131ac4362c0075ebe1"],"2233462ade0e629affa69a6f1e8d0205e4d6e596":["b6284684320a9808c41a5e43de958b2da22f89bd","2b4f056774365da0f54c1678f478e2f9d1cbf07b"],"920b078f38927d1129b28d683b5e89228a27edc0":["291857aeee5ec20518ddce131ac4362c0075ebe1"],"015571db92de1e6f75d89f34faeb520f99f07b97":["6a96b173f2f573ac82bc8279dfdd3cbe2b948f95"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["b6284684320a9808c41a5e43de958b2da22f89bd","291857aeee5ec20518ddce131ac4362c0075ebe1"],"7ca08c071cb75a8796c36ae6a1c90d7473c2a6df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7ca08c071cb75a8796c36ae6a1c90d7473c2a6df"],"727bb765ff2542275f6d31f67be18d7104bae148":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3eaeb36333664e8cb92108ef03f68a7b90beb759"],"7d34a674b360fc9af16fceeb9df37363eceb3484":["920b078f38927d1129b28d683b5e89228a27edc0"],"b6284684320a9808c41a5e43de958b2da22f89bd":["a3ca9e9e0800e26a0d02f8fcf73ec4f8362d0214","043df2e9a841864922c32756a44c939ed768cb89"],"2b4f056774365da0f54c1678f478e2f9d1cbf07b":["b6284684320a9808c41a5e43de958b2da22f89bd"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["b6284684320a9808c41a5e43de958b2da22f89bd","2233462ade0e629affa69a6f1e8d0205e4d6e596"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"291857aeee5ec20518ddce131ac4362c0075ebe1":["2233462ade0e629affa69a6f1e8d0205e4d6e596"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3eaeb36333664e8cb92108ef03f68a7b90beb759"]},"commit2Childs":{"043df2e9a841864922c32756a44c939ed768cb89":["b6284684320a9808c41a5e43de958b2da22f89bd"],"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95":["015571db92de1e6f75d89f34faeb520f99f07b97"],"03e91774ac3ed0db43b41f92ae954c447e50bdfb":[],"a3ca9e9e0800e26a0d02f8fcf73ec4f8362d0214":["043df2e9a841864922c32756a44c939ed768cb89","b6284684320a9808c41a5e43de958b2da22f89bd"],"3eaeb36333664e8cb92108ef03f68a7b90beb759":["727bb765ff2542275f6d31f67be18d7104bae148","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"920b078f38927d1129b28d683b5e89228a27edc0":["03e91774ac3ed0db43b41f92ae954c447e50bdfb","7d34a674b360fc9af16fceeb9df37363eceb3484"],"2233462ade0e629affa69a6f1e8d0205e4d6e596":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","291857aeee5ec20518ddce131ac4362c0075ebe1"],"015571db92de1e6f75d89f34faeb520f99f07b97":["a3ca9e9e0800e26a0d02f8fcf73ec4f8362d0214"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["727bb765ff2542275f6d31f67be18d7104bae148"],"7ca08c071cb75a8796c36ae6a1c90d7473c2a6df":["6a96b173f2f573ac82bc8279dfdd3cbe2b948f95","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"7d34a674b360fc9af16fceeb9df37363eceb3484":["03e91774ac3ed0db43b41f92ae954c447e50bdfb"],"727bb765ff2542275f6d31f67be18d7104bae148":[],"b6284684320a9808c41a5e43de958b2da22f89bd":["2233462ade0e629affa69a6f1e8d0205e4d6e596","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","2b4f056774365da0f54c1678f478e2f9d1cbf07b","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904"],"2b4f056774365da0f54c1678f478e2f9d1cbf07b":["2233462ade0e629affa69a6f1e8d0205e4d6e596"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7ca08c071cb75a8796c36ae6a1c90d7473c2a6df","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"291857aeee5ec20518ddce131ac4362c0075ebe1":["3eaeb36333664e8cb92108ef03f68a7b90beb759","920b078f38927d1129b28d683b5e89228a27edc0","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["03e91774ac3ed0db43b41f92ae954c447e50bdfb","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","727bb765ff2542275f6d31f67be18d7104bae148","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}