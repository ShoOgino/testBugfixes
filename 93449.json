{"path":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(StoredDocument,String,SolrQueryRequest).mjava","commits":[{"id":"1ba83a7997a13459d756c436cc76ee2570d2128f","date":1432215022,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(StoredDocument,String,SolrQueryRequest).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(StoredDocument doc, String fieldName, SolrQueryRequest req) {\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n    StorableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (StorableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","date":1453060490,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,String,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(StoredDocument,String,SolrQueryRequest).mjava","sourceNew":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, String fieldName, SolrQueryRequest req) {\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","sourceOld":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(StoredDocument doc, String fieldName, SolrQueryRequest req) {\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n    StorableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (StorableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1ba83a7997a13459d756c436cc76ee2570d2128f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["1ba83a7997a13459d756c436cc76ee2570d2128f"]},"commit2Childs":{"1ba83a7997a13459d756c436cc76ee2570d2128f":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1ba83a7997a13459d756c436cc76ee2570d2128f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}