{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.KeyParser#KeyParser(String).mjava","commits":[{"id":"f7623716022a9a68898e329e8ffe6c36d168fba7","date":1384524101,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.KeyParser#KeyParser(String).mjava","pathOld":"/dev/null","sourceNew":"    public KeyParser(String key) {\n      String[] parts = key.split(SEPARATOR);\n      this.key = key;\n      pieces = parts.length;\n      hashes = new int[pieces];\n      numBits = new int[2];\n      if(key.endsWith(\"!\"))\n        pieces++;\n      if(pieces == 3) {\n        numBits[0] = 8;\n        numBits[1] = 8;\n        triLevel = true;\n      } else {\n        numBits[0] = 16;\n        triLevel = false;\n\n      }\n\n      for(int i=0;i<parts.length;i++) {\n        int commaIdx = parts[i].indexOf(bitsSeparator);\n\n        if(commaIdx > 0) {\n          numBits[i] = getNumBits(parts[i], commaIdx);\n          parts[i] = parts[i].substring(0, commaIdx);\n        }\n        hashes[i] = Hash.murmurhash3_x86_32(parts[i], 0, parts[i].length(), 0);\n      }\n      masks = getMasks();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5fe03bc79bce6cdaa190cac905d8f82a01e8edcc","f9a6292fc3940c131b3e108d897f0c2ee2063db9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe","date":1384867512,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.KeyParser#KeyParser(String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.KeyParser#KeyParser(String).mjava","sourceNew":"    public KeyParser(String key) {\n      String[] parts = key.split(SEPARATOR);\n      this.key = key;\n      pieces = parts.length;\n      hashes = new int[pieces];\n      numBits = new int[2];\n      if (key.endsWith(\"!\"))\n        pieces++;\n      if (pieces == 3) {\n        numBits[0] = 8;\n        numBits[1] = 8;\n        triLevel = true;\n      } else {\n        numBits[0] = 16;\n        triLevel = false;\n\n      }\n\n      for (int i = 0; i < parts.length; i++) {\n        int commaIdx = parts[i].indexOf(bitsSeparator);\n\n        if (commaIdx > 0) {\n          numBits[i] = getNumBits(parts[i], commaIdx);\n          parts[i] = parts[i].substring(0, commaIdx);\n        }\n        hashes[i] = Hash.murmurhash3_x86_32(parts[i], 0, parts[i].length(), 0);\n      }\n      masks = getMasks();\n    }\n\n","sourceOld":"    public KeyParser(String key) {\n      String[] parts = key.split(SEPARATOR);\n      this.key = key;\n      pieces = parts.length;\n      hashes = new int[pieces];\n      numBits = new int[2];\n      if(key.endsWith(\"!\"))\n        pieces++;\n      if(pieces == 3) {\n        numBits[0] = 8;\n        numBits[1] = 8;\n        triLevel = true;\n      } else {\n        numBits[0] = 16;\n        triLevel = false;\n\n      }\n\n      for(int i=0;i<parts.length;i++) {\n        int commaIdx = parts[i].indexOf(bitsSeparator);\n\n        if(commaIdx > 0) {\n          numBits[i] = getNumBits(parts[i], commaIdx);\n          parts[i] = parts[i].substring(0, commaIdx);\n        }\n        hashes[i] = Hash.murmurhash3_x86_32(parts[i], 0, parts[i].length(), 0);\n      }\n      masks = getMasks();\n    }\n\n","bugFix":null,"bugIntro":["f9a6292fc3940c131b3e108d897f0c2ee2063db9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"180464626ce8630fd4ec3bc3dafafdd02316e6f2","date":1386087058,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.KeyParser#KeyParser(String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.KeyParser#KeyParser(String).mjava","sourceNew":"    public KeyParser(String key) {\n      String[] parts = key.split(SEPARATOR);\n      this.key = key;\n      pieces = parts.length;\n      hashes = new int[pieces];\n      numBits = new int[2];\n      if (key.endsWith(\"!\"))\n        pieces++;\n      if (pieces == 3) {\n        numBits[0] = 8;\n        numBits[1] = 8;\n        triLevel = true;\n      } else {\n        numBits[0] = 16;\n        triLevel = false;\n      }\n\n      for (int i = 0; i < parts.length; i++) {\n        if (i < pieces - 1) {\n          int commaIdx = parts[i].indexOf(bitsSeparator);\n\n          if (commaIdx > 0) {\n            numBits[i] = getNumBits(parts[i], commaIdx);\n            parts[i] = parts[i].substring(0, commaIdx);\n          }\n        }\n        hashes[i] = Hash.murmurhash3_x86_32(parts[i], 0, parts[i].length(), 0);\n      }\n      masks = getMasks();\n    }\n\n","sourceOld":"    public KeyParser(String key) {\n      String[] parts = key.split(SEPARATOR);\n      this.key = key;\n      pieces = parts.length;\n      hashes = new int[pieces];\n      numBits = new int[2];\n      if (key.endsWith(\"!\"))\n        pieces++;\n      if (pieces == 3) {\n        numBits[0] = 8;\n        numBits[1] = 8;\n        triLevel = true;\n      } else {\n        numBits[0] = 16;\n        triLevel = false;\n\n      }\n\n      for (int i = 0; i < parts.length; i++) {\n        int commaIdx = parts[i].indexOf(bitsSeparator);\n\n        if (commaIdx > 0) {\n          numBits[i] = getNumBits(parts[i], commaIdx);\n          parts[i] = parts[i].substring(0, commaIdx);\n        }\n        hashes[i] = Hash.murmurhash3_x86_32(parts[i], 0, parts[i].length(), 0);\n      }\n      masks = getMasks();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.KeyParser#KeyParser(String).mjava","pathOld":"/dev/null","sourceNew":"    public KeyParser(String key) {\n      String[] parts = key.split(SEPARATOR);\n      this.key = key;\n      pieces = parts.length;\n      hashes = new int[pieces];\n      numBits = new int[2];\n      if (key.endsWith(\"!\"))\n        pieces++;\n      if (pieces == 3) {\n        numBits[0] = 8;\n        numBits[1] = 8;\n        triLevel = true;\n      } else {\n        numBits[0] = 16;\n        triLevel = false;\n      }\n\n      for (int i = 0; i < parts.length; i++) {\n        if (i < pieces - 1) {\n          int commaIdx = parts[i].indexOf(bitsSeparator);\n\n          if (commaIdx > 0) {\n            numBits[i] = getNumBits(parts[i], commaIdx);\n            parts[i] = parts[i].substring(0, commaIdx);\n          }\n        }\n        hashes[i] = Hash.murmurhash3_x86_32(parts[i], 0, parts[i].length(), 0);\n      }\n      masks = getMasks();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9a6292fc3940c131b3e108d897f0c2ee2063db9","date":1391760827,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.KeyParser#KeyParser(String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.KeyParser#KeyParser(String).mjava","sourceNew":"    public KeyParser(String key) {\n      String[] parts = key.split(SEPARATOR);\n      this.key = key;\n      pieces = parts.length;\n      numBits = new int[2];\n      if (key.endsWith(\"!\") && pieces < 3)\n        pieces++;\n      hashes = new int[pieces];\n\n      if (pieces == 3) {\n        numBits[0] = 8;\n        numBits[1] = 8;\n        triLevel = true;\n      } else {\n        numBits[0] = 16;\n        triLevel = false;\n      }\n\n      for (int i = 0; i < pieces; i++) {\n        if (i < pieces - 1) {\n          int commaIdx = parts[i].indexOf(bitsSeparator);\n\n          if (commaIdx > 0) {\n            numBits[i] = getNumBits(parts[i], commaIdx);\n            parts[i] = parts[i].substring(0, commaIdx);\n          }\n        }\n        //Last component of an ID that ends with a '!'\n        if(i >= parts.length)\n          hashes[i] = Hash.murmurhash3_x86_32(\"\", 0, \"\".length(), 0);\n        else\n          hashes[i] = Hash.murmurhash3_x86_32(parts[i], 0, parts[i].length(), 0);\n      }\n      masks = getMasks();\n    }\n\n","sourceOld":"    public KeyParser(String key) {\n      String[] parts = key.split(SEPARATOR);\n      this.key = key;\n      pieces = parts.length;\n      hashes = new int[pieces];\n      numBits = new int[2];\n      if (key.endsWith(\"!\"))\n        pieces++;\n      if (pieces == 3) {\n        numBits[0] = 8;\n        numBits[1] = 8;\n        triLevel = true;\n      } else {\n        numBits[0] = 16;\n        triLevel = false;\n      }\n\n      for (int i = 0; i < parts.length; i++) {\n        if (i < pieces - 1) {\n          int commaIdx = parts[i].indexOf(bitsSeparator);\n\n          if (commaIdx > 0) {\n            numBits[i] = getNumBits(parts[i], commaIdx);\n            parts[i] = parts[i].substring(0, commaIdx);\n          }\n        }\n        hashes[i] = Hash.murmurhash3_x86_32(parts[i], 0, parts[i].length(), 0);\n      }\n      masks = getMasks();\n    }\n\n","bugFix":["f7623716022a9a68898e329e8ffe6c36d168fba7","c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5fe03bc79bce6cdaa190cac905d8f82a01e8edcc","date":1405792133,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.KeyParser#KeyParser(String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.KeyParser#KeyParser(String).mjava","sourceNew":"    public KeyParser(final String key) {\n      this.key = key;\n      List<String> partsList = new ArrayList<>(3);\n      int firstSeparatorPos = key.indexOf(SEPARATOR);\n      if (-1 == firstSeparatorPos) {\n        partsList.add(key);\n      } else {\n        partsList.add(key.substring(0, firstSeparatorPos));\n        int lastPos = key.length() - 1;\n        // Don't make any more parts if the first separator is the last char\n        if (firstSeparatorPos < lastPos) {\n          int secondSeparatorPos = key.indexOf(SEPARATOR, firstSeparatorPos + 1);\n          if (-1 == secondSeparatorPos) {\n            partsList.add(key.substring(firstSeparatorPos + 1));\n          } else if (secondSeparatorPos == lastPos) {\n            // Don't make any more parts if the key has exactly two separators and \n            // they're the last two chars - back-compatibility with the behavior of\n            // String.split() - see SOLR-6257.\n            if (firstSeparatorPos < secondSeparatorPos - 1) {\n              partsList.add(key.substring(firstSeparatorPos + 1, secondSeparatorPos));\n            }\n          } else { // The second separator is not the last char\n            partsList.add(key.substring(firstSeparatorPos + 1, secondSeparatorPos));\n            partsList.add(key.substring(secondSeparatorPos + 1));\n          }\n          // Ignore any further separators beyond the first two\n        }\n      }\n      pieces = partsList.size();\n      String[] parts = partsList.toArray(new String[pieces]);\n      numBits = new int[2];\n      if (key.endsWith(\"!\") && pieces < 3)\n        pieces++;\n      hashes = new int[pieces];\n\n      if (pieces == 3) {\n        numBits[0] = 8;\n        numBits[1] = 8;\n        triLevel = true;\n      } else {\n        numBits[0] = 16;\n        triLevel = false;\n      }\n\n      for (int i = 0; i < pieces; i++) {\n        if (i < pieces - 1) {\n          int commaIdx = parts[i].indexOf(bitsSeparator);\n\n          if (commaIdx > 0) {\n            numBits[i] = getNumBits(parts[i], commaIdx);\n            parts[i] = parts[i].substring(0, commaIdx);\n          }\n        }\n        //Last component of an ID that ends with a '!'\n        if(i >= parts.length)\n          hashes[i] = Hash.murmurhash3_x86_32(\"\", 0, \"\".length(), 0);\n        else\n          hashes[i] = Hash.murmurhash3_x86_32(parts[i], 0, parts[i].length(), 0);\n      }\n      masks = getMasks();\n    }\n\n","sourceOld":"    public KeyParser(String key) {\n      String[] parts = key.split(SEPARATOR);\n      this.key = key;\n      pieces = parts.length;\n      numBits = new int[2];\n      if (key.endsWith(\"!\") && pieces < 3)\n        pieces++;\n      hashes = new int[pieces];\n\n      if (pieces == 3) {\n        numBits[0] = 8;\n        numBits[1] = 8;\n        triLevel = true;\n      } else {\n        numBits[0] = 16;\n        triLevel = false;\n      }\n\n      for (int i = 0; i < pieces; i++) {\n        if (i < pieces - 1) {\n          int commaIdx = parts[i].indexOf(bitsSeparator);\n\n          if (commaIdx > 0) {\n            numBits[i] = getNumBits(parts[i], commaIdx);\n            parts[i] = parts[i].substring(0, commaIdx);\n          }\n        }\n        //Last component of an ID that ends with a '!'\n        if(i >= parts.length)\n          hashes[i] = Hash.murmurhash3_x86_32(\"\", 0, \"\".length(), 0);\n        else\n          hashes[i] = Hash.murmurhash3_x86_32(parts[i], 0, parts[i].length(), 0);\n      }\n      masks = getMasks();\n    }\n\n","bugFix":["f7623716022a9a68898e329e8ffe6c36d168fba7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5fe03bc79bce6cdaa190cac905d8f82a01e8edcc":["f9a6292fc3940c131b3e108d897f0c2ee2063db9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f9a6292fc3940c131b3e108d897f0c2ee2063db9":["180464626ce8630fd4ec3bc3dafafdd02316e6f2"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","180464626ce8630fd4ec3bc3dafafdd02316e6f2"],"c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe":["f7623716022a9a68898e329e8ffe6c36d168fba7"],"f7623716022a9a68898e329e8ffe6c36d168fba7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"180464626ce8630fd4ec3bc3dafafdd02316e6f2":["c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5fe03bc79bce6cdaa190cac905d8f82a01e8edcc"]},"commit2Childs":{"5fe03bc79bce6cdaa190cac905d8f82a01e8edcc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","f7623716022a9a68898e329e8ffe6c36d168fba7"],"f9a6292fc3940c131b3e108d897f0c2ee2063db9":["5fe03bc79bce6cdaa190cac905d8f82a01e8edcc"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe":["180464626ce8630fd4ec3bc3dafafdd02316e6f2"],"f7623716022a9a68898e329e8ffe6c36d168fba7":["c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe"],"180464626ce8630fd4ec3bc3dafafdd02316e6f2":["f9a6292fc3940c131b3e108d897f0c2ee2063db9","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}