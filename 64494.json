{"path":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","commits":[{"id":"d80013b5e260def972025c93a0b08524f9c38f49","date":1170102801,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"/dev/null","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = core.getRequestHandler( path );\n        if( handler != null ) {\n          SolrQueryRequest solrReq = parsers.parse( path, req );\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          core.execute( handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["34fbb4b6afaf74f6f1e09e04694d548ec3dc85b0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43c800be98a24a96d9d21e62c645822de478f6a2","date":1171769593,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrQueryRequest solrReq = null;\n        SolrRequestHandler handler = core.getRequestHandler( path );\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( path, req );\n            String qt = solrReq.getParams().get( SolrParams.QT );\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( 400, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = core.getRequestHandler( path );\n        if( handler != null ) {\n          SolrQueryRequest solrReq = parsers.parse( path, req );\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          core.execute( handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":["eb87f7aa1c87656073021ebf4269992ab26f2b51","1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eb87f7aa1c87656073021ebf4269992ab26f2b51","date":1172518941,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = core.getRequestHandler( path );\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( path, req );\n            String qt = solrReq.getParams().get( SolrParams.QT );\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( 400, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrQueryRequest solrReq = null;\n        SolrRequestHandler handler = core.getRequestHandler( path );\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( path, req );\n            String qt = solrReq.getParams().get( SolrParams.QT );\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( 400, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":["43c800be98a24a96d9d21e62c645822de478f6a2"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"368c8927753a9ca6ee214a251da2746ff35aeef6","date":1177630664,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = core.getRequestHandler( path );\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( path, req );\n            String qt = solrReq.getParams().get( SolrParams.QT );\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( 400, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = core.getRequestHandler( path );\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( path, req );\n            String qt = solrReq.getParams().get( SolrParams.QT );\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( 400, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e1f4fbaec89fd319b1a74548fc4c728c327e584e","date":1178010128,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = core.getRequestHandler( path );\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( path, req );\n            String qt = solrReq.getParams().get( SolrParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( 400, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( 400, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = core.getRequestHandler( path );\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( path, req );\n            String qt = solrReq.getParams().get( SolrParams.QT );\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( 400, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"34fbb4b6afaf74f6f1e09e04694d548ec3dc85b0","date":1178551112,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = null;\n        if( path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( path, req );\n            String qt = solrReq.getParams().get( SolrParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( 400, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( 400, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = core.getRequestHandler( path );\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( path, req );\n            String qt = solrReq.getParams().get( SolrParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( 400, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( 400, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":["d80013b5e260def972025c93a0b08524f9c38f49"],"bugIntro":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996","date":1180477701,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = null;\n        if( path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( path, req );\n            String qt = solrReq.getParams().get( SolrParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = null;\n        if( path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( path, req );\n            String qt = solrReq.getParams().get( SolrParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( 400, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( 400, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43a89c1b665c7572c870f5fd6951c7822f003763","date":1180565082,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = null;\n        if( path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( path, req );\n            String qt = solrReq.getParams().get( SolrParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = null;\n        if( path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( path, req );\n            String qt = solrReq.getParams().get( SolrParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef","date":1185993405,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = null;\n        if( path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( path, req );\n            String qt = solrReq.getParams().get( CommonParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = null;\n        if( path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( path, req );\n            String qt = solrReq.getParams().get( SolrParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abbfb3ad1f90df8ebf4751c8e72b2756ace50699","date":1190497478,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = null;\n        if( path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( core, path, req );\n            String qt = solrReq.getParams().get( CommonParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( core, path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = null;\n        if( path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( path, req );\n            String qt = solrReq.getParams().get( CommonParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"048361614025800e582bfc7a7b0329dc6fd6a95e","date":1196999392,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        SolrCore core = singlecore;\n        if( core == null ) {\n          // try to get the corename as a request parameter first\n          String corename = request.getParameter(\"core\");\n          if( corename == null && path.startsWith( \"/@\" ) ) { // multicore\n            idx = path.indexOf( '/', 2 );\n            if( idx < 1 ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \n                  \"MultiCore path must contain a '/'.  For example: /@corename/handlerpath\" );\n            }\n            corename = path.substring( 2, idx );\n            path = path.substring( idx );\n          }\n          if (corename != null) {\n            core = multicore.getCore( corename );\n            if( core == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \n                \"Can not find core: '\"+corename+\"'\" );\n            }\n          }\n          else {\n            core = multicore.getDefaultCore();\n          }\n        }\n        \n        SolrRequestHandler handler = null;\n        if( path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( core, path, req );\n            String qt = solrReq.getParams().get( CommonParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n            }\n          }\n        }\n\n        // Perhaps this is a muli-core admin page?\n        if( handler == null && path.equals( multicore.getAdminPath() ) ) {\n          handler = multicore.getMultiCoreHandler();\n        } \n        \n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( core, path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n        // otherwise, let's ensure the core is in the SolrCore request attribute so\n        // the servlet can retrieve it\n        else {\n          req.setAttribute(\"org.apache.solr.SolrCore\", core);\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        SolrRequestHandler handler = null;\n        if( path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( core, path, req );\n            String qt = solrReq.getParams().get( CommonParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( core, path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fbcab5528ccee291c99ac3f46ecc2a712aed15c0","date":1197099313,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        SolrCore core = singlecore;\n        if( core == null ) {\n          // try to get the corename as a request parameter first\n          String corename = null;\n          if( path.startsWith( \"/@\" ) ) { // multicore\n            idx = path.indexOf( '/', 2 );\n            if( idx < 1 ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \n                  \"MultiCore path must contain a '/'.  For example: /@corename/handlerpath\" );\n            }\n            corename = path.substring( 2, idx );\n            path = path.substring( idx );\n            \n            core = multicore.getCore( corename );\n            if( core == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \n                \"Can not find core: '\"+corename+\"'\" );\n            }\n          }\n          else {\n            core = multicore.getDefaultCore();\n          }\n        }\n        \n        SolrRequestHandler handler = null;\n        if( path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( core, path, req );\n            String qt = solrReq.getParams().get( CommonParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n            }\n          }\n        }\n\n        // Perhaps this is a muli-core admin page?\n        if( handler == null && path.equals( multicore.getAdminPath() ) ) {\n          handler = multicore.getMultiCoreHandler();\n        } \n        \n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( core, path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n        // otherwise, let's ensure the core is in the SolrCore request attribute so\n        // the servlet can retrieve it\n        else {\n          req.setAttribute(\"org.apache.solr.SolrCore\", core);\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        SolrCore core = singlecore;\n        if( core == null ) {\n          // try to get the corename as a request parameter first\n          String corename = request.getParameter(\"core\");\n          if( corename == null && path.startsWith( \"/@\" ) ) { // multicore\n            idx = path.indexOf( '/', 2 );\n            if( idx < 1 ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \n                  \"MultiCore path must contain a '/'.  For example: /@corename/handlerpath\" );\n            }\n            corename = path.substring( 2, idx );\n            path = path.substring( idx );\n          }\n          if (corename != null) {\n            core = multicore.getCore( corename );\n            if( core == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \n                \"Can not find core: '\"+corename+\"'\" );\n            }\n          }\n          else {\n            core = multicore.getDefaultCore();\n          }\n        }\n        \n        SolrRequestHandler handler = null;\n        if( path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( core, path, req );\n            String qt = solrReq.getParams().get( CommonParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n            }\n          }\n        }\n\n        // Perhaps this is a muli-core admin page?\n        if( handler == null && path.equals( multicore.getAdminPath() ) ) {\n          handler = multicore.getMultiCoreHandler();\n        } \n        \n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( core, path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n        // otherwise, let's ensure the core is in the SolrCore request attribute so\n        // the servlet can retrieve it\n        else {\n          req.setAttribute(\"org.apache.solr.SolrCore\", core);\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e1483ce01863c48b3b586ccaf6c5cde5e4404f5c","date":1197386495,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        SolrCore core = singlecore;\n        if( core == null ) {\n          // try to get the corename as a request parameter first\n          String corename = null;\n          if( path.startsWith( \"/@\" ) ) { // multicore\n            idx = path.indexOf( '/', 2 );\n            if( idx < 1 ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \n                  \"MultiCore path must contain a '/'.  For example: /@corename/handlerpath\" );\n            }\n            corename = path.substring( 2, idx );\n            path = path.substring( idx );\n            \n            core = multicore.getCore( corename );\n            if( core == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \n                \"Can not find core: '\"+corename+\"'\" );\n            }\n          }\n          else {\n            core = multicore.getDefaultCore();\n          }\n        }\n        \n        SolrRequestHandler handler = null;\n        if( path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( core, path, req );\n            String qt = solrReq.getParams().get( CommonParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n            }\n          }\n        }\n\n        // Perhaps this is a muli-core admin page?\n        if( handler == null && path.equals( multicore.getAdminPath() ) ) {\n          handler = multicore.getMultiCoreHandler();\n        } \n        \n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( core, path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n        // otherwise, let's ensure the core is in the SolrCore request attribute so\n        // the servlet can retrieve it\n        else {\n          // TEMP -- to support /admin multicore grab the core from the request\n          // TODO -- for muticore /admin support, strip the corename from the path\n          // and forward to the /admin jsp file\n          //  req.getRequestDispatcher( path ).forward( request, response );\n          String corename = request.getParameter(\"core\");\n          if( corename != null ) {\n            core = multicore.getCore( corename );\n            if( core == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \n                \"Can not find core: '\"+corename+\"'\" );\n            }\n          }\n          req.setAttribute(\"org.apache.solr.SolrCore\", core);\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        SolrCore core = singlecore;\n        if( core == null ) {\n          // try to get the corename as a request parameter first\n          String corename = null;\n          if( path.startsWith( \"/@\" ) ) { // multicore\n            idx = path.indexOf( '/', 2 );\n            if( idx < 1 ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \n                  \"MultiCore path must contain a '/'.  For example: /@corename/handlerpath\" );\n            }\n            corename = path.substring( 2, idx );\n            path = path.substring( idx );\n            \n            core = multicore.getCore( corename );\n            if( core == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \n                \"Can not find core: '\"+corename+\"'\" );\n            }\n          }\n          else {\n            core = multicore.getDefaultCore();\n          }\n        }\n        \n        SolrRequestHandler handler = null;\n        if( path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( core, path, req );\n            String qt = solrReq.getParams().get( CommonParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n            }\n          }\n        }\n\n        // Perhaps this is a muli-core admin page?\n        if( handler == null && path.equals( multicore.getAdminPath() ) ) {\n          handler = multicore.getMultiCoreHandler();\n        } \n        \n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( core, path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n        // otherwise, let's ensure the core is in the SolrCore request attribute so\n        // the servlet can retrieve it\n        else {\n          req.setAttribute(\"org.apache.solr.SolrCore\", core);\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a45fbd60083428b1b13884c5c8c2e33e7e71ee7","date":1198275819,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        SolrRequestHandler handler = null;\n        SolrCore core = singlecore;\n        if( core == null ) {\n          // Perhaps this is a muli-core admin page?\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n          }\n          else {\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n              // invalid core name is ok.  It could fall through to some other request\n            }\n          }\n        }\n        \n        if( core != null ) {\n          // Only try to parse the handler *if* a valid core exists\n          // when multi-core is enabled, the path can lead to a null core.\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n          }\n          if( handler == null && handleSelect ) {\n            if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n              solrReq = parsers.parse( core, path, req );\n              String qt = solrReq.getParams().get( CommonParams.QT );\n              if( qt != null && qt.startsWith( \"/\" ) ) {\n                throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n              }\n              handler = core.getRequestHandler( qt );\n              if( handler == null ) {\n                throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n              }\n            }\n          }\n        }\n        \n        if( handler != null ) {\n          if( core == null ) {\n            core = multicore.getDefaultCore();\n          }\n          \n          if( solrReq == null ) {\n            solrReq = parsers.parse( core, path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n        // otherwise, let's ensure the core is in the SolrCore request attribute so\n        // the servlet/jsp can retrieve it\n        else {\n          req.setAttribute(\"org.apache.solr.SolrCore\", core);\n          \n          // Modify the request so each core gets its own /admin\n          if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n            req.getRequestDispatcher( path ).forward( request, response );\n            return;\n          }\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        SolrCore core = singlecore;\n        if( core == null ) {\n          // try to get the corename as a request parameter first\n          String corename = null;\n          if( path.startsWith( \"/@\" ) ) { // multicore\n            idx = path.indexOf( '/', 2 );\n            if( idx < 1 ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \n                  \"MultiCore path must contain a '/'.  For example: /@corename/handlerpath\" );\n            }\n            corename = path.substring( 2, idx );\n            path = path.substring( idx );\n            \n            core = multicore.getCore( corename );\n            if( core == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \n                \"Can not find core: '\"+corename+\"'\" );\n            }\n          }\n          else {\n            core = multicore.getDefaultCore();\n          }\n        }\n        \n        SolrRequestHandler handler = null;\n        if( path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && handleSelect ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parsers.parse( core, path, req );\n            String qt = solrReq.getParams().get( CommonParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n            }\n          }\n        }\n\n        // Perhaps this is a muli-core admin page?\n        if( handler == null && path.equals( multicore.getAdminPath() ) ) {\n          handler = multicore.getMultiCoreHandler();\n        } \n        \n        if( handler != null ) {\n          if( solrReq == null ) {\n            solrReq = parsers.parse( core, path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n        // otherwise, let's ensure the core is in the SolrCore request attribute so\n        // the servlet can retrieve it\n        else {\n          // TEMP -- to support /admin multicore grab the core from the request\n          // TODO -- for muticore /admin support, strip the corename from the path\n          // and forward to the /admin jsp file\n          //  req.getRequestDispatcher( path ).forward( request, response );\n          String corename = request.getParameter(\"core\");\n          if( corename != null ) {\n            core = multicore.getCore( corename );\n            if( core == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \n                \"Can not find core: '\"+corename+\"'\" );\n            }\n          }\n          req.setAttribute(\"org.apache.solr.SolrCore\", core);\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":["c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef","43c800be98a24a96d9d21e62c645822de478f6a2","e1f4fbaec89fd319b1a74548fc4c728c327e584e","e1483ce01863c48b3b586ccaf6c5cde5e4404f5c","34fbb4b6afaf74f6f1e09e04694d548ec3dc85b0","048361614025800e582bfc7a7b0329dc6fd6a95e","abbfb3ad1f90df8ebf4751c8e72b2756ace50699","43a89c1b665c7572c870f5fd6951c7822f003763","fbcab5528ccee291c99ac3f46ecc2a712aed15c0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b920ba0b6285c3aaa7a64d1677f5b4ee58b0779d","date":1203633859,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        SolrRequestHandler handler = null;\n        SolrCore core = singlecore;\n        if( core == null ) {\n          // Perhaps this is a muli-core admin page?\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n          }\n          else {\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n              // invalid core name is ok.  It could fall through to some other request\n            }\n          }\n        }\n        \n        if( core != null ) {\n          // Only try to parse the handler *if* a valid core exists\n          // when multi-core is enabled, the path can lead to a null core.\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n          }\n          if( handler == null && handleSelect ) {\n            if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n              solrReq = parsers.parse( core, path, req );\n              String qt = solrReq.getParams().get( CommonParams.QT );\n              if( qt != null && qt.startsWith( \"/\" ) ) {\n                throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n              }\n              handler = core.getRequestHandler( qt );\n              if( handler == null ) {\n                throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n              }\n            }\n          }\n        }\n        \n        if( handler != null ) {\n          if( core == null ) {\n            core = multicore.getDefaultCore();\n          }\n          \n          if( solrReq == null ) {\n            solrReq = parsers.parse( core, path, req );\n          }\n          \n          final SolrConfig conf = core.getSolrConfig();\n          final Method reqMethod = Method.getMethod(req.getMethod());\n\n          if (Method.POST != reqMethod) {\n            HttpCacheHeaderUtil.setCacheControlHeader(conf, resp);\n          }\n            \n          // unless we have been explicitly told not to, do cache validation\n          if (!conf.getHttpCachingConfig().isNever304()) {\n            // if we've confirmed cache validation, return immediately\n            if (HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq,\n                                                            req,resp)) {\n              return;\n            }\n          }\n          \n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          /* even for HEAD requests, we need to execute the handler to\n           * ensure we don't get an error (and to make sure the correct \n           * QueryResponseWriter is selectedand we get the correct\n           * Content-Type)\n           */\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          if (Method.HEAD == Method.getMethod(req.getMethod())) {\n            // nothing to write out, waited this long just to get ContentType\n            return; \n          }\n          \n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n        // otherwise, let's ensure the core is in the SolrCore request attribute so\n        // the servlet/jsp can retrieve it\n        else {\n          req.setAttribute(\"org.apache.solr.SolrCore\", core);\n          \n          // Modify the request so each core gets its own /admin\n          if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n            req.getRequestDispatcher( path ).forward( request, response );\n            return;\n          }\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        SolrRequestHandler handler = null;\n        SolrCore core = singlecore;\n        if( core == null ) {\n          // Perhaps this is a muli-core admin page?\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n          }\n          else {\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n              // invalid core name is ok.  It could fall through to some other request\n            }\n          }\n        }\n        \n        if( core != null ) {\n          // Only try to parse the handler *if* a valid core exists\n          // when multi-core is enabled, the path can lead to a null core.\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n          }\n          if( handler == null && handleSelect ) {\n            if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n              solrReq = parsers.parse( core, path, req );\n              String qt = solrReq.getParams().get( CommonParams.QT );\n              if( qt != null && qt.startsWith( \"/\" ) ) {\n                throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n              }\n              handler = core.getRequestHandler( qt );\n              if( handler == null ) {\n                throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n              }\n            }\n          }\n        }\n        \n        if( handler != null ) {\n          if( core == null ) {\n            core = multicore.getDefaultCore();\n          }\n          \n          if( solrReq == null ) {\n            solrReq = parsers.parse( core, path, req );\n          }\n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n        // otherwise, let's ensure the core is in the SolrCore request attribute so\n        // the servlet/jsp can retrieve it\n        else {\n          req.setAttribute(\"org.apache.solr.SolrCore\", core);\n          \n          // Modify the request so each core gets its own /admin\n          if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n            req.getRequestDispatcher( path ).forward( request, response );\n            return;\n          }\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc6ab6902f8f70ae43365947ccf44c25986906d","date":1204603577,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        SolrRequestHandler handler = null;\n        SolrCore core = singlecore;\n        if( core == null ) {\n          // Perhaps this is a multi-core admin page?\n          if( path.equals( \"/\" ) ) {\n            chain.doFilter(request, response);\n            return;  \n          }\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            \n            // pick a core to use for output\n            Collection<SolrCore> cores = multicore.getCores();\n            if( cores != null && cores.size() > 0 ) {\n              core = cores.iterator().next();\n            }\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          }\n          else {\n            idx = path.indexOf( \"/\", 1 );\n            if( idx <= 1 ) {\n              idx = path.length();\n            }\n            \n            // try to get the corename as a request parameter first\n            String corename = path.substring( 1, idx );\n            path = path.substring( idx );\n            core = multicore.getCore( corename );\n            \n            if( path.length() == 0 ) {\n              path = \"/\";\n            }\n            \n            if( core == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown core: \"+corename );\n            }\n          }\n        }\n        \n        SolrRequestParsers parser = parsers.get( core );\n        if( parser == null ) {\n          parser = new SolrRequestParsers( core.getSolrConfig() );\n          parsers.put( core, parser );\n        }\n        \n        // Only try to parse the handler *if* a valid core exists\n        // when multi-core is enabled, the path can lead to a null core.\n        if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && parser.isHandleSelect() ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parser.parse( core, path, req );\n            String qt = solrReq.getParams().get( CommonParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        \n        if( handler != null ) {          \n          if( solrReq == null ) {\n            solrReq = parser.parse( core, path, req );\n          }\n          \n          final SolrConfig conf = core.getSolrConfig();\n          final Method reqMethod = Method.getMethod(req.getMethod());\n\n          if (Method.POST != reqMethod) {\n            HttpCacheHeaderUtil.setCacheControlHeader(conf, resp);\n          }\n            \n          // unless we have been explicitly told not to, do cache validation\n          if (!conf.getHttpCachingConfig().isNever304()) {\n            // if we've confirmed cache validation, return immediately\n            if (HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req,resp)) {\n              return;\n            }\n          }\n          \n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          /* even for HEAD requests, we need to execute the handler to\n           * ensure we don't get an error (and to make sure the correct \n           * QueryResponseWriter is selectedand we get the correct\n           * Content-Type)\n           */\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          if (Method.HEAD == Method.getMethod(req.getMethod())) {\n            // nothing to write out, waited this long just to get ContentType\n            return; \n          }\n          \n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n        // otherwise, let's ensure the core is in the SolrCore request attribute so\n        // the servlet/jsp can retrieve it\n        else {\n          req.setAttribute(\"org.apache.solr.SolrCore\", core);\n\n          // Let each core have its own admin page...\n          if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n            req.getRequestDispatcher( path ).forward( request, response );\n            return; \n          }\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        SolrRequestHandler handler = null;\n        SolrCore core = singlecore;\n        if( core == null ) {\n          // Perhaps this is a muli-core admin page?\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n          }\n          else {\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n              // invalid core name is ok.  It could fall through to some other request\n            }\n          }\n        }\n        \n        if( core != null ) {\n          // Only try to parse the handler *if* a valid core exists\n          // when multi-core is enabled, the path can lead to a null core.\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n          }\n          if( handler == null && handleSelect ) {\n            if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n              solrReq = parsers.parse( core, path, req );\n              String qt = solrReq.getParams().get( CommonParams.QT );\n              if( qt != null && qt.startsWith( \"/\" ) ) {\n                throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n              }\n              handler = core.getRequestHandler( qt );\n              if( handler == null ) {\n                throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n              }\n            }\n          }\n        }\n        \n        if( handler != null ) {\n          if( core == null ) {\n            core = multicore.getDefaultCore();\n          }\n          \n          if( solrReq == null ) {\n            solrReq = parsers.parse( core, path, req );\n          }\n          \n          final SolrConfig conf = core.getSolrConfig();\n          final Method reqMethod = Method.getMethod(req.getMethod());\n\n          if (Method.POST != reqMethod) {\n            HttpCacheHeaderUtil.setCacheControlHeader(conf, resp);\n          }\n            \n          // unless we have been explicitly told not to, do cache validation\n          if (!conf.getHttpCachingConfig().isNever304()) {\n            // if we've confirmed cache validation, return immediately\n            if (HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq,\n                                                            req,resp)) {\n              return;\n            }\n          }\n          \n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          /* even for HEAD requests, we need to execute the handler to\n           * ensure we don't get an error (and to make sure the correct \n           * QueryResponseWriter is selectedand we get the correct\n           * Content-Type)\n           */\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          if (Method.HEAD == Method.getMethod(req.getMethod())) {\n            // nothing to write out, waited this long just to get ContentType\n            return; \n          }\n          \n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n        // otherwise, let's ensure the core is in the SolrCore request attribute so\n        // the servlet/jsp can retrieve it\n        else {\n          req.setAttribute(\"org.apache.solr.SolrCore\", core);\n          \n          // Modify the request so each core gets its own /admin\n          if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n            req.getRequestDispatcher( path ).forward( request, response );\n            return;\n          }\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58b41d4093a9662306bdc051e4b46643deff70de","date":1205090944,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n        \n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n          \n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }      \n              }\n            }\n          }\n          \n            // With a valid handler and a valid core...\n          if( handler != null ) {          \n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            if (Method.POST != reqMethod) {\n              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);\n            }\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct \n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                        if (Method.HEAD != Method.getMethod(req.getMethod())) {\n                  PrintWriter out = response.getWriter();\n                  responseWriter.write(out, solrReq, solrRsp);\n                }\n                //else http HEAD request, nothing to write out, waited this long just to get ContentType\n              }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n              // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( path ).forward( request, response );\n              return; \n            }\n          }\n        }\n        log.info(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException \n  {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      SolrQueryRequest solrReq = null;\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        SolrRequestHandler handler = null;\n        SolrCore core = singlecore;\n        if( core == null ) {\n          // Perhaps this is a multi-core admin page?\n          if( path.equals( \"/\" ) ) {\n            chain.doFilter(request, response);\n            return;  \n          }\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            \n            // pick a core to use for output\n            Collection<SolrCore> cores = multicore.getCores();\n            if( cores != null && cores.size() > 0 ) {\n              core = cores.iterator().next();\n            }\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          }\n          else {\n            idx = path.indexOf( \"/\", 1 );\n            if( idx <= 1 ) {\n              idx = path.length();\n            }\n            \n            // try to get the corename as a request parameter first\n            String corename = path.substring( 1, idx );\n            path = path.substring( idx );\n            core = multicore.getCore( corename );\n            \n            if( path.length() == 0 ) {\n              path = \"/\";\n            }\n            \n            if( core == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown core: \"+corename );\n            }\n          }\n        }\n        \n        SolrRequestParsers parser = parsers.get( core );\n        if( parser == null ) {\n          parser = new SolrRequestParsers( core.getSolrConfig() );\n          parsers.put( core, parser );\n        }\n        \n        // Only try to parse the handler *if* a valid core exists\n        // when multi-core is enabled, the path can lead to a null core.\n        if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n          handler = core.getRequestHandler( path );\n        }\n        if( handler == null && parser.isHandleSelect() ) {\n          if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n            solrReq = parser.parse( core, path, req );\n            String qt = solrReq.getParams().get( CommonParams.QT );\n            if( qt != null && qt.startsWith( \"/\" ) ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n            }\n            handler = core.getRequestHandler( qt );\n            if( handler == null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n            }\n          }\n        }\n        \n        if( handler != null ) {          \n          if( solrReq == null ) {\n            solrReq = parser.parse( core, path, req );\n          }\n          \n          final SolrConfig conf = core.getSolrConfig();\n          final Method reqMethod = Method.getMethod(req.getMethod());\n\n          if (Method.POST != reqMethod) {\n            HttpCacheHeaderUtil.setCacheControlHeader(conf, resp);\n          }\n            \n          // unless we have been explicitly told not to, do cache validation\n          if (!conf.getHttpCachingConfig().isNever304()) {\n            // if we've confirmed cache validation, return immediately\n            if (HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req,resp)) {\n              return;\n            }\n          }\n          \n          SolrQueryResponse solrRsp = new SolrQueryResponse();\n          /* even for HEAD requests, we need to execute the handler to\n           * ensure we don't get an error (and to make sure the correct \n           * QueryResponseWriter is selectedand we get the correct\n           * Content-Type)\n           */\n          this.execute( req, handler, solrReq, solrRsp );\n          if( solrRsp.getException() != null ) {\n            sendError( (HttpServletResponse)response, solrRsp.getException() );\n            return;\n          }\n          \n          // Now write it out\n          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n          if (Method.HEAD == Method.getMethod(req.getMethod())) {\n            // nothing to write out, waited this long just to get ContentType\n            return; \n          }\n          \n          PrintWriter out = response.getWriter();\n          responseWriter.write(out, solrReq, solrRsp);\n          return;\n        }\n        // otherwise, let's ensure the core is in the SolrCore request attribute so\n        // the servlet/jsp can retrieve it\n        else {\n          req.setAttribute(\"org.apache.solr.SolrCore\", core);\n\n          // Let each core have its own admin page...\n          if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n            req.getRequestDispatcher( path ).forward( request, response );\n            return; \n          }\n        }\n      }\n      catch( Throwable ex ) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      }\n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":["5ff676ea3919c34f30df120b9fa469cd439203ec","8425d7ad8d82220b08eec0a5b5868eafef350270"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bbf04081e0995bba24690711acfe0b6e26ed43fe","date":1205243398,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n        \n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n          \n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }      \n              }\n            }\n          }\n          \n            // With a valid handler and a valid core...\n          if( handler != null ) {          \n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            if (Method.POST != reqMethod) {\n              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);\n            }\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct \n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                        if (Method.HEAD != Method.getMethod(req.getMethod())) {\n                  PrintWriter out = response.getWriter();\n                  responseWriter.write(out, solrReq, solrRsp);\n                }\n                //else http HEAD request, nothing to write out, waited this long just to get ContentType\n              }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n              // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( path ).forward( request, response );\n              return; \n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n        \n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n          \n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }      \n              }\n            }\n          }\n          \n            // With a valid handler and a valid core...\n          if( handler != null ) {          \n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            if (Method.POST != reqMethod) {\n              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);\n            }\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct \n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                        if (Method.HEAD != Method.getMethod(req.getMethod())) {\n                  PrintWriter out = response.getWriter();\n                  responseWriter.write(out, solrReq, solrRsp);\n                }\n                //else http HEAD request, nothing to write out, waited this long just to get ContentType\n              }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n              // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( path ).forward( request, response );\n              return; \n            }\n          }\n        }\n        log.info(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"409850dbbdb6e3184a228ed61332c3fee211f481","date":1205869216,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n        \n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n          \n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }      \n              }\n            }\n          }\n          \n            // With a valid handler and a valid core...\n          if( handler != null ) {          \n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            if (Method.POST != reqMethod) {\n              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);\n            }\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct \n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != Method.getMethod(req.getMethod())) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n              // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( path ).forward( request, response );\n              return; \n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n        \n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n          \n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }      \n              }\n            }\n          }\n          \n            // With a valid handler and a valid core...\n          if( handler != null ) {          \n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            if (Method.POST != reqMethod) {\n              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);\n            }\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct \n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                        if (Method.HEAD != Method.getMethod(req.getMethod())) {\n                  PrintWriter out = response.getWriter();\n                  responseWriter.write(out, solrReq, solrRsp);\n                }\n                //else http HEAD request, nothing to write out, waited this long just to get ContentType\n              }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n              // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( path ).forward( request, response );\n              return; \n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":["5ff676ea3919c34f30df120b9fa469cd439203ec"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"76e2779e106247db88c5b38fdc35f211f6de41a4","date":1206374026,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n        \n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n          \n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }      \n              }\n            }\n          }\n          \n            // With a valid handler and a valid core...\n          if( handler != null ) {          \n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            if (Method.POST != reqMethod) {\n              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);\n            }\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct \n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != Method.getMethod(req.getMethod())) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n              // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return; \n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n        \n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n          \n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }      \n              }\n            }\n          }\n          \n            // With a valid handler and a valid core...\n          if( handler != null ) {          \n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            if (Method.POST != reqMethod) {\n              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);\n            }\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct \n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != Method.getMethod(req.getMethod())) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n              // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( path ).forward( request, response );\n              return; \n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4a46cae2a2f75e7ff129d40effceea9918b450a5","date":1206457283,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n        \n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n          \n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }      \n              }\n            }\n          }\n          \n            // With a valid handler and a valid core...\n          if( handler != null ) {          \n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            if (Method.POST != reqMethod) {\n              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);\n            }\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct \n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != Method.getMethod(req.getMethod())) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            req.setAttribute(\"org.apache.solr.MultiCore\", multicore);\n              // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return; \n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n        \n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n          \n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }      \n              }\n            }\n          }\n          \n            // With a valid handler and a valid core...\n          if( handler != null ) {          \n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            if (Method.POST != reqMethod) {\n              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);\n            }\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct \n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != Method.getMethod(req.getMethod())) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n              // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return; \n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8e6622f6ea376d92cafec5ab54deff347157605c","date":1206497347,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          req.setAttribute(\"org.apache.solr.MultiCore\", multicore);\n          \n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n        \n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n          \n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }      \n              }\n            }\n          }\n          \n            // With a valid handler and a valid core...\n          if( handler != null ) {          \n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            if (Method.POST != reqMethod) {\n              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);\n            }\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct \n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != Method.getMethod(req.getMethod())) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return; \n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n        \n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n          \n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }      \n              }\n            }\n          }\n          \n            // With a valid handler and a valid core...\n          if( handler != null ) {          \n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            if (Method.POST != reqMethod) {\n              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);\n            }\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct \n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != Method.getMethod(req.getMethod())) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            req.setAttribute(\"org.apache.solr.MultiCore\", multicore);\n              // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return; \n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c","date":1208435858,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          req.setAttribute(\"org.apache.solr.MultiCore\", multicore);\n\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n            // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            if (Method.POST != reqMethod) {\n              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);\n            }\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n              // add info to http headers\n                try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != Method.getMethod(req.getMethod())) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n    \n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();    \n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo(); \n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        \n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n        \n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          req.setAttribute(\"org.apache.solr.MultiCore\", multicore);\n          \n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n        \n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n          \n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }      \n              }\n            }\n          }\n          \n            // With a valid handler and a valid core...\n          if( handler != null ) {          \n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n            \n            final Method reqMethod = Method.getMethod(req.getMethod());\n            if (Method.POST != reqMethod) {\n              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);\n            }\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct \n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != Method.getMethod(req.getMethod())) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return; \n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n    \n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"33b9bfa7d5034aab0430a310b0c9f2063b8c1531","date":1208451475,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          req.setAttribute(\"org.apache.solr.MultiCore\", multicore);\n\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n            // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            if (Method.POST != reqMethod) {\n              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);\n            }\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != Method.getMethod(req.getMethod())) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          req.setAttribute(\"org.apache.solr.MultiCore\", multicore);\n\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n            // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            if (Method.POST != reqMethod) {\n              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);\n            }\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n              // add info to http headers\n                try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != Method.getMethod(req.getMethod())) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ff676ea3919c34f30df120b9fa469cd439203ec","date":1211576148,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          req.setAttribute(\"org.apache.solr.MultiCore\", multicore);\n\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n            // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != reqMethod) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          req.setAttribute(\"org.apache.solr.MultiCore\", multicore);\n\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n            // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            if (Method.POST != reqMethod) {\n              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);\n            }\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != Method.getMethod(req.getMethod())) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":["58b41d4093a9662306bdc051e4b46643deff70de","409850dbbdb6e3184a228ed61332c3fee211f481"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d5151046764fb8d9662e02d6c5381b2adb69f96d","date":1216394962,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          req.setAttribute(\"org.apache.solr.MultiCore\", multicore);\n\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singleCoreDescriptor.getCore();\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n            // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != reqMethod) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( singleCoreDescriptor == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          req.setAttribute(\"org.apache.solr.MultiCore\", multicore);\n\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singlecore;\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n            // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != reqMethod) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( singlecore == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71fd2f49de58ccb4422e7181620d8f795693b7eb","date":1218407598,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          req.setAttribute(\"org.apache.solr.MultiCore\", multicore);\n\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singleCoreDescriptor.getCore();\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n            // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != reqMethod) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( singleCoreDescriptor == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        if( core == null ) {\n          req.setAttribute(\"org.apache.solr.NoCoreSet\", Boolean.TRUE );\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          req.setAttribute(\"org.apache.solr.MultiCore\", multicore);\n\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singleCoreDescriptor.getCore();\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n            // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != reqMethod) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( singleCoreDescriptor == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9c74b2e17824ac88cefd4b764b4b9f2c56ceeea5","date":1218639440,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // By default use the single core.  If cores is enabled, look for one.\n        final SolrCore core;\n        if (cores != null && cores.isEnabled()) {\n          req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( cores.getAdminPath() ) ) {\n            handler = cores.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = cores.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the cores admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = cores.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singleCoreDescriptor.getCore();\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n            // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != reqMethod) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( singleCoreDescriptor == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        if( core == null ) {\n          req.setAttribute(\"org.apache.solr.NoCoreSet\", Boolean.TRUE );\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // By default use the single core.  If multicore is enabled, look for one.\n        final SolrCore core;\n        if (multicore != null && multicore.isEnabled()) {\n          req.setAttribute(\"org.apache.solr.MultiCore\", multicore);\n\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( multicore.getAdminPath() ) ) {\n            handler = multicore.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = multicore.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = multicore.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singleCoreDescriptor.getCore();\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the multicore handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n            // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != reqMethod) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( singleCoreDescriptor == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        if( core == null ) {\n          req.setAttribute(\"org.apache.solr.NoCoreSet\", Boolean.TRUE );\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4926b5318ba4167d360445a0c5f3fc8af2cf8c49","date":1218678599,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          // pick a core to use for output generation\n          core = cores.getAdminCore();\n          if( core == null ) {\n            throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n          }\n        } \n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != reqMethod) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n\n      try {\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // By default use the single core.  If cores is enabled, look for one.\n        final SolrCore core;\n        if (cores != null && cores.isEnabled()) {\n          req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n\n          // if this is the multi-core admin page, it will handle it\n          if( path.equals( cores.getAdminPath() ) ) {\n            handler = cores.getMultiCoreHandler();\n            // pick a core to use for output generation\n            core = cores.getAdminCore();\n            if( core == null ) {\n              throw new RuntimeException( \"Can not find a valid core for the cores admin handler\" );\n            }\n          } else {\n            //otherwise, we should find a core from the path\n            idx = path.indexOf( \"/\", 1 );\n            if( idx > 1 ) {\n              // try to get the corename as a request parameter first\n              String corename = path.substring( 1, idx );\n              path = path.substring( idx );\n              core = cores.getCore( corename );\n            } else {\n              core = null;\n            }\n          }\n        }\n        else {\n          core = singleCoreDescriptor.getCore();\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n            // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != reqMethod) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( singleCoreDescriptor == null && path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        if( core == null ) {\n          req.setAttribute(\"org.apache.solr.NoCoreSet\", Boolean.TRUE );\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2284f4281eb212e60f8318c30e1d67c7d25422a7","date":1218739496,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          // pick a core to use for output generation\n          core = cores.getAdminCore();\n          if( core == null ) {\n            throw new RuntimeException( \"Can not find a valid core for the cores admin handler\" );\n          }\n        } \n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != reqMethod) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          // pick a core to use for output generation\n          core = cores.getAdminCore();\n          if( core == null ) {\n            throw new RuntimeException( \"Can not find a valid core for the multicore admin handler\" );\n          }\n        } \n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != reqMethod) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c28792ff7d1774c306e16afbd44ded91a417049b","date":1219072108,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          // pick a core to use for output generation\n          core = cores.getAdminCore();\n          if( core == null ) {\n            throw new RuntimeException( \"Can not find a valid core for the cores admin handler\" );\n          }\n        } \n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != reqMethod) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          // pick a core to use for output generation\n          core = cores.getAdminCore();\n          if( core == null ) {\n            throw new RuntimeException( \"Can not find a valid core for the cores admin handler\" );\n          }\n        } \n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != reqMethod) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"00da8b51bdeae168a5b26ec506db372b219ca7a2","date":1221704186,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          // pick a core to use for output generation\n          core = cores.getAdminCore();\n          if( core == null ) {\n            throw new RuntimeException( \"Can not find a valid core for the cores admin handler\" );\n          }\n        } \n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != reqMethod) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          // pick a core to use for output generation\n          core = cores.getAdminCore();\n          if( core == null ) {\n            throw new RuntimeException( \"Can not find a valid core for the cores admin handler\" );\n          }\n        } \n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != reqMethod) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.fine(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eeddcf8e42f213f1b4499194c6f014554e1a22ef","date":1242729902,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core.getSolrConfig(), parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          // pick a core to use for output generation\n          core = cores.getAdminCore();\n          if( core == null ) {\n            throw new RuntimeException( \"Can not find a valid core for the cores admin handler\" );\n          }\n        } \n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n                if( solrRsp.getException() != null ) {\n                  sendError( (HttpServletResponse)response, solrRsp.getException() );\n                }\n                else {\n                  // Now write it out\n                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));\n                  if (Method.HEAD != reqMethod) {\n                    if (responseWriter instanceof BinaryQueryResponseWriter) {\n                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;\n                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);\n                    } else {\n                      PrintWriter out = response.getWriter();\n                      responseWriter.write(out, solrReq, solrRsp);\n\n                    }\n\n                  }\n                  //else http HEAD request, nothing to write out, waited this long just to get ContentType\n                }\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":["8425d7ad8d82220b08eec0a5b5868eafef350270"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8425d7ad8d82220b08eec0a5b5868eafef350270","date":1243350149,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(core);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put( core.getSolrConfig(), parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":["eeddcf8e42f213f1b4499194c6f014554e1a22ef","58b41d4093a9662306bdc051e4b46643deff70de"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a7fff2cfeca66fd0d0c85f001ada861422e8d67","date":1244466663,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selectedand we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7ee462bcf591b00929fda7ed9d4d2d049c3993cf","date":1245419574,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                if( qt != null && qt.startsWith( \"/\" ) ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Invalid query type.  Do not use /select to access: \"+qt);\n                }\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5ff676ea3919c34f30df120b9fa469cd439203ec":["33b9bfa7d5034aab0430a310b0c9f2063b8c1531"],"33b9bfa7d5034aab0430a310b0c9f2063b8c1531":["ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c"],"d5151046764fb8d9662e02d6c5381b2adb69f96d":["5ff676ea3919c34f30df120b9fa469cd439203ec"],"eb87f7aa1c87656073021ebf4269992ab26f2b51":["43c800be98a24a96d9d21e62c645822de478f6a2"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"58b41d4093a9662306bdc051e4b46643deff70de":["6dc6ab6902f8f70ae43365947ccf44c25986906d"],"abbfb3ad1f90df8ebf4751c8e72b2756ace50699":["c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef"],"9c74b2e17824ac88cefd4b764b4b9f2c56ceeea5":["71fd2f49de58ccb4422e7181620d8f795693b7eb"],"8e6622f6ea376d92cafec5ab54deff347157605c":["4a46cae2a2f75e7ff129d40effceea9918b450a5"],"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996":["34fbb4b6afaf74f6f1e09e04694d548ec3dc85b0"],"409850dbbdb6e3184a228ed61332c3fee211f481":["bbf04081e0995bba24690711acfe0b6e26ed43fe"],"d80013b5e260def972025c93a0b08524f9c38f49":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef":["43a89c1b665c7572c870f5fd6951c7822f003763"],"bbf04081e0995bba24690711acfe0b6e26ed43fe":["58b41d4093a9662306bdc051e4b46643deff70de"],"ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c":["8e6622f6ea376d92cafec5ab54deff347157605c"],"2284f4281eb212e60f8318c30e1d67c7d25422a7":["4926b5318ba4167d360445a0c5f3fc8af2cf8c49"],"048361614025800e582bfc7a7b0329dc6fd6a95e":["abbfb3ad1f90df8ebf4751c8e72b2756ace50699"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e1f4fbaec89fd319b1a74548fc4c728c327e584e":["368c8927753a9ca6ee214a251da2746ff35aeef6"],"7ee462bcf591b00929fda7ed9d4d2d049c3993cf":["2a7fff2cfeca66fd0d0c85f001ada861422e8d67"],"4a46cae2a2f75e7ff129d40effceea9918b450a5":["76e2779e106247db88c5b38fdc35f211f6de41a4"],"ad94625fb8d088209f46650c8097196fec67f00c":["7ee462bcf591b00929fda7ed9d4d2d049c3993cf"],"e1483ce01863c48b3b586ccaf6c5cde5e4404f5c":["fbcab5528ccee291c99ac3f46ecc2a712aed15c0"],"71fd2f49de58ccb4422e7181620d8f795693b7eb":["d5151046764fb8d9662e02d6c5381b2adb69f96d"],"368c8927753a9ca6ee214a251da2746ff35aeef6":["eb87f7aa1c87656073021ebf4269992ab26f2b51"],"34fbb4b6afaf74f6f1e09e04694d548ec3dc85b0":["e1f4fbaec89fd319b1a74548fc4c728c327e584e"],"6dc6ab6902f8f70ae43365947ccf44c25986906d":["b920ba0b6285c3aaa7a64d1677f5b4ee58b0779d"],"c28792ff7d1774c306e16afbd44ded91a417049b":["2284f4281eb212e60f8318c30e1d67c7d25422a7"],"2a7fff2cfeca66fd0d0c85f001ada861422e8d67":["8425d7ad8d82220b08eec0a5b5868eafef350270"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["c28792ff7d1774c306e16afbd44ded91a417049b"],"1a45fbd60083428b1b13884c5c8c2e33e7e71ee7":["e1483ce01863c48b3b586ccaf6c5cde5e4404f5c"],"fbcab5528ccee291c99ac3f46ecc2a712aed15c0":["048361614025800e582bfc7a7b0329dc6fd6a95e"],"8425d7ad8d82220b08eec0a5b5868eafef350270":["eeddcf8e42f213f1b4499194c6f014554e1a22ef"],"76e2779e106247db88c5b38fdc35f211f6de41a4":["409850dbbdb6e3184a228ed61332c3fee211f481"],"4926b5318ba4167d360445a0c5f3fc8af2cf8c49":["9c74b2e17824ac88cefd4b764b4b9f2c56ceeea5"],"43c800be98a24a96d9d21e62c645822de478f6a2":["d80013b5e260def972025c93a0b08524f9c38f49"],"b920ba0b6285c3aaa7a64d1677f5b4ee58b0779d":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"eeddcf8e42f213f1b4499194c6f014554e1a22ef":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"43a89c1b665c7572c870f5fd6951c7822f003763":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"5ff676ea3919c34f30df120b9fa469cd439203ec":["d5151046764fb8d9662e02d6c5381b2adb69f96d"],"33b9bfa7d5034aab0430a310b0c9f2063b8c1531":["5ff676ea3919c34f30df120b9fa469cd439203ec"],"d5151046764fb8d9662e02d6c5381b2adb69f96d":["71fd2f49de58ccb4422e7181620d8f795693b7eb"],"eb87f7aa1c87656073021ebf4269992ab26f2b51":["368c8927753a9ca6ee214a251da2746ff35aeef6"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["d80013b5e260def972025c93a0b08524f9c38f49"],"58b41d4093a9662306bdc051e4b46643deff70de":["bbf04081e0995bba24690711acfe0b6e26ed43fe"],"abbfb3ad1f90df8ebf4751c8e72b2756ace50699":["048361614025800e582bfc7a7b0329dc6fd6a95e"],"9c74b2e17824ac88cefd4b764b4b9f2c56ceeea5":["4926b5318ba4167d360445a0c5f3fc8af2cf8c49"],"8e6622f6ea376d92cafec5ab54deff347157605c":["ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c"],"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996":["43a89c1b665c7572c870f5fd6951c7822f003763"],"409850dbbdb6e3184a228ed61332c3fee211f481":["76e2779e106247db88c5b38fdc35f211f6de41a4"],"d80013b5e260def972025c93a0b08524f9c38f49":["43c800be98a24a96d9d21e62c645822de478f6a2"],"c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef":["abbfb3ad1f90df8ebf4751c8e72b2756ace50699"],"bbf04081e0995bba24690711acfe0b6e26ed43fe":["409850dbbdb6e3184a228ed61332c3fee211f481"],"ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c":["33b9bfa7d5034aab0430a310b0c9f2063b8c1531"],"2284f4281eb212e60f8318c30e1d67c7d25422a7":["c28792ff7d1774c306e16afbd44ded91a417049b"],"048361614025800e582bfc7a7b0329dc6fd6a95e":["fbcab5528ccee291c99ac3f46ecc2a712aed15c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e1f4fbaec89fd319b1a74548fc4c728c327e584e":["34fbb4b6afaf74f6f1e09e04694d548ec3dc85b0"],"4a46cae2a2f75e7ff129d40effceea9918b450a5":["8e6622f6ea376d92cafec5ab54deff347157605c"],"7ee462bcf591b00929fda7ed9d4d2d049c3993cf":["ad94625fb8d088209f46650c8097196fec67f00c"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"e1483ce01863c48b3b586ccaf6c5cde5e4404f5c":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"71fd2f49de58ccb4422e7181620d8f795693b7eb":["9c74b2e17824ac88cefd4b764b4b9f2c56ceeea5"],"368c8927753a9ca6ee214a251da2746ff35aeef6":["e1f4fbaec89fd319b1a74548fc4c728c327e584e"],"34fbb4b6afaf74f6f1e09e04694d548ec3dc85b0":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"6dc6ab6902f8f70ae43365947ccf44c25986906d":["58b41d4093a9662306bdc051e4b46643deff70de"],"c28792ff7d1774c306e16afbd44ded91a417049b":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"2a7fff2cfeca66fd0d0c85f001ada861422e8d67":["7ee462bcf591b00929fda7ed9d4d2d049c3993cf"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["eeddcf8e42f213f1b4499194c6f014554e1a22ef"],"fbcab5528ccee291c99ac3f46ecc2a712aed15c0":["e1483ce01863c48b3b586ccaf6c5cde5e4404f5c"],"1a45fbd60083428b1b13884c5c8c2e33e7e71ee7":["b920ba0b6285c3aaa7a64d1677f5b4ee58b0779d"],"8425d7ad8d82220b08eec0a5b5868eafef350270":["2a7fff2cfeca66fd0d0c85f001ada861422e8d67"],"76e2779e106247db88c5b38fdc35f211f6de41a4":["4a46cae2a2f75e7ff129d40effceea9918b450a5"],"4926b5318ba4167d360445a0c5f3fc8af2cf8c49":["2284f4281eb212e60f8318c30e1d67c7d25422a7"],"43c800be98a24a96d9d21e62c645822de478f6a2":["eb87f7aa1c87656073021ebf4269992ab26f2b51"],"b920ba0b6285c3aaa7a64d1677f5b4ee58b0779d":["6dc6ab6902f8f70ae43365947ccf44c25986906d"],"43a89c1b665c7572c870f5fd6951c7822f003763":["c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef"],"eeddcf8e42f213f1b4499194c6f014554e1a22ef":["8425d7ad8d82220b08eec0a5b5868eafef350270"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}