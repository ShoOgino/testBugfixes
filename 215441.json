{"path":"backwards/src/java/org/apache/lucene/search/WildcardTermEnum#wildcardEquals(String,int,String,int).mjava","commits":[{"id":"480d01e5b0ef8efb136d51670fec297ae5ae2c9c","date":1268821447,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"backwards/src/java/org/apache/lucene/search/WildcardTermEnum#wildcardEquals(String,int,String,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Determines if a word matches a wildcard pattern.\n   * <small>Work released by Granta Design Ltd after originally being done on\n   * company time.</small>\n   */\n  public static final boolean wildcardEquals(String pattern, int patternIdx,\n    String string, int stringIdx)\n  {\n    int p = patternIdx;\n    \n    for (int s = stringIdx; ; ++p, ++s)\n      {\n        // End of string yet?\n        boolean sEnd = (s >= string.length());\n        // End of pattern yet?\n        boolean pEnd = (p >= pattern.length());\n\n        // If we're looking at the end of the string...\n        if (sEnd)\n        {\n          // Assume the only thing left on the pattern is/are wildcards\n          boolean justWildcardsLeft = true;\n\n          // Current wildcard position\n          int wildcardSearchPos = p;\n          // While we haven't found the end of the pattern,\n          // and haven't encountered any non-wildcard characters\n          while (wildcardSearchPos < pattern.length() && justWildcardsLeft)\n          {\n            // Check the character at the current position\n            char wildchar = pattern.charAt(wildcardSearchPos);\n            \n            // If it's not a wildcard character, then there is more\n            // pattern information after this/these wildcards.\n            if (wildchar != WILDCARD_CHAR && wildchar != WILDCARD_STRING)\n            {\n              justWildcardsLeft = false;\n            }\n            else\n            {\n              // to prevent \"cat\" matches \"ca??\"\n              if (wildchar == WILDCARD_CHAR) {\n                return false;\n              }\n              \n              // Look at the next character\n              wildcardSearchPos++;\n            }\n          }\n\n          // This was a prefix wildcard search, and we've matched, so\n          // return true.\n          if (justWildcardsLeft)\n          {\n            return true;\n          }\n        }\n\n        // If we've gone past the end of the string, or the pattern,\n        // return false.\n        if (sEnd || pEnd)\n        {\n          break;\n        }\n\n        // Match a single character, so continue.\n        if (pattern.charAt(p) == WILDCARD_CHAR)\n        {\n          continue;\n        }\n\n        //\n        if (pattern.charAt(p) == WILDCARD_STRING)\n        {\n          // Look at the character beyond the '*'.\n          ++p;\n          // Examine the string, starting at the last character.\n          for (int i = string.length(); i >= s; --i)\n          {\n            if (wildcardEquals(pattern, p, string, i))\n            {\n              return true;\n            }\n          }\n          break;\n        }\n        if (pattern.charAt(p) != string.charAt(s))\n        {\n          break;\n        }\n      }\n      return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backwards/src/java/org/apache/lucene/search/WildcardTermEnum#wildcardEquals(String,int,String,int).mjava","pathOld":"backwards/src/java/org/apache/lucene/search/WildcardTermEnum#wildcardEquals(String,int,String,int).mjava","sourceNew":"  /**\n   * Determines if a word matches a wildcard pattern.\n   * <small>Work released by Granta Design Ltd after originally being done on\n   * company time.</small>\n   */\n  public static final boolean wildcardEquals(String pattern, int patternIdx,\n    String string, int stringIdx)\n  {\n    int p = patternIdx;\n    \n    for (int s = stringIdx; ; ++p, ++s)\n      {\n        // End of string yet?\n        boolean sEnd = (s >= string.length());\n        // End of pattern yet?\n        boolean pEnd = (p >= pattern.length());\n\n        // If we're looking at the end of the string...\n        if (sEnd)\n        {\n          // Assume the only thing left on the pattern is/are wildcards\n          boolean justWildcardsLeft = true;\n\n          // Current wildcard position\n          int wildcardSearchPos = p;\n          // While we haven't found the end of the pattern,\n          // and haven't encountered any non-wildcard characters\n          while (wildcardSearchPos < pattern.length() && justWildcardsLeft)\n          {\n            // Check the character at the current position\n            char wildchar = pattern.charAt(wildcardSearchPos);\n            \n            // If it's not a wildcard character, then there is more\n            // pattern information after this/these wildcards.\n            if (wildchar != WILDCARD_CHAR && wildchar != WILDCARD_STRING)\n            {\n              justWildcardsLeft = false;\n            }\n            else\n            {\n              // to prevent \"cat\" matches \"ca??\"\n              if (wildchar == WILDCARD_CHAR) {\n                return false;\n              }\n              \n              // Look at the next character\n              wildcardSearchPos++;\n            }\n          }\n\n          // This was a prefix wildcard search, and we've matched, so\n          // return true.\n          if (justWildcardsLeft)\n          {\n            return true;\n          }\n        }\n\n        // If we've gone past the end of the string, or the pattern,\n        // return false.\n        if (sEnd || pEnd)\n        {\n          break;\n        }\n\n        // Match a single character, so continue.\n        if (pattern.charAt(p) == WILDCARD_CHAR)\n        {\n          continue;\n        }\n\n        //\n        if (pattern.charAt(p) == WILDCARD_STRING)\n        {\n          // Look at the character beyond the '*'.\n          ++p;\n          // Examine the string, starting at the last character.\n          for (int i = string.length(); i >= s; --i)\n          {\n            if (wildcardEquals(pattern, p, string, i))\n            {\n              return true;\n            }\n          }\n          break;\n        }\n        if (pattern.charAt(p) != string.charAt(s))\n        {\n          break;\n        }\n      }\n      return false;\n  }\n\n","sourceOld":"  /**\n   * Determines if a word matches a wildcard pattern.\n   * <small>Work released by Granta Design Ltd after originally being done on\n   * company time.</small>\n   */\n  public static final boolean wildcardEquals(String pattern, int patternIdx,\n    String string, int stringIdx)\n  {\n    int p = patternIdx;\n    \n    for (int s = stringIdx; ; ++p, ++s)\n      {\n        // End of string yet?\n        boolean sEnd = (s >= string.length());\n        // End of pattern yet?\n        boolean pEnd = (p >= pattern.length());\n\n        // If we're looking at the end of the string...\n        if (sEnd)\n        {\n          // Assume the only thing left on the pattern is/are wildcards\n          boolean justWildcardsLeft = true;\n\n          // Current wildcard position\n          int wildcardSearchPos = p;\n          // While we haven't found the end of the pattern,\n          // and haven't encountered any non-wildcard characters\n          while (wildcardSearchPos < pattern.length() && justWildcardsLeft)\n          {\n            // Check the character at the current position\n            char wildchar = pattern.charAt(wildcardSearchPos);\n            \n            // If it's not a wildcard character, then there is more\n            // pattern information after this/these wildcards.\n            if (wildchar != WILDCARD_CHAR && wildchar != WILDCARD_STRING)\n            {\n              justWildcardsLeft = false;\n            }\n            else\n            {\n              // to prevent \"cat\" matches \"ca??\"\n              if (wildchar == WILDCARD_CHAR) {\n                return false;\n              }\n              \n              // Look at the next character\n              wildcardSearchPos++;\n            }\n          }\n\n          // This was a prefix wildcard search, and we've matched, so\n          // return true.\n          if (justWildcardsLeft)\n          {\n            return true;\n          }\n        }\n\n        // If we've gone past the end of the string, or the pattern,\n        // return false.\n        if (sEnd || pEnd)\n        {\n          break;\n        }\n\n        // Match a single character, so continue.\n        if (pattern.charAt(p) == WILDCARD_CHAR)\n        {\n          continue;\n        }\n\n        //\n        if (pattern.charAt(p) == WILDCARD_STRING)\n        {\n          // Look at the character beyond the '*'.\n          ++p;\n          // Examine the string, starting at the last character.\n          for (int i = string.length(); i >= s; --i)\n          {\n            if (wildcardEquals(pattern, p, string, i))\n            {\n              return true;\n            }\n          }\n          break;\n        }\n        if (pattern.charAt(p) != string.charAt(s))\n        {\n          break;\n        }\n      }\n      return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"]},"commit2Childs":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}