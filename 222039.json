{"path":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", StringField.TYPE_UNSTORED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", StringField.TYPE_UNSTORED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", StringField.TYPE_UNSTORED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", StringField.TYPE_UNSTORED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", StringField.TYPE_UNSTORED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"bugIntro":["33b0cbce3d060cc2547083fc6559e6080ec5ca23"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173","date":1365631993,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = new IndexSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc","date":1366056945,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = new IndexSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"551db74111df22d4f6684319479c9f3d5f7ddf23","date":1394018258,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$FakeScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"956ed30f06fa518bc14a442f5dadfa7a0ef51c69","date":1394534863,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$FakeScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"acf00221f44c5f08ccea014f2492b53af15ecd66","date":1394568293,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"658a1d7b74c99b3d845fb1f852331a1c4623368e","date":1396631281,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.shutdown();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.shutdown();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), ConstantScoreQuery.ConstantScoreScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"22a1e22cb62fc34b060a756e6033f01cb5462247","date":1424528768,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), TermScorer.class.getName());\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), TermScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), ConstantScoreQuery.ConstantScoreScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"60596f28be69b10c37a56a303c2dbea07b2ca4ba","date":1425060541,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), TermScorer.class.getName());\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), TermScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), TermScorer.class.getName());\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), TermScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), TermScorer.class.getName());\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), TermScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), TermScorer.class.getName());\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), TermScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7f94ff172f40ff68a926d112e25b96bc38e5a27","date":1431002360,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), TermScorer.class.getName());\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), TermScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = FakeScorer.class.getName();\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScoreScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq.build());\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2dfdf766e55e943d942055d7de53c7ad6bc45283","date":1441632886,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final BoostQuery csq1 = new BoostQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\"))), 2f);\n      final BoostQuery csq2 = new BoostQuery(new ConstantScoreQuery(csq1), 5f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final BoostQuery csqbq = new BoostQuery(new ConstantScoreQuery(bq.build()), 17f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq.build());\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","bugFix":null,"bugIntro":["33b0cbce3d060cc2547083fc6559e6080ec5ca23"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"81d0720146de53dd3a4a023d2a3d1089d86d748d","date":1442268215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new ClassicSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final BoostQuery csq1 = new BoostQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\"))), 2f);\n      final BoostQuery csq2 = new BoostQuery(new ConstantScoreQuery(csq1), 5f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final BoostQuery csqbq = new BoostQuery(new ConstantScoreQuery(bq.build()), 17f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final BoostQuery csq1 = new BoostQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\"))), 2f);\n      final BoostQuery csq2 = new BoostQuery(new ConstantScoreQuery(csq1), 5f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final BoostQuery csqbq = new BoostQuery(new ConstantScoreQuery(bq.build()), 17f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02e175abd2c4c1611c5a9647486ae8ba249a94c1","date":1468327116,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      final BoostQuery csq1 = new BoostQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\"))), 2f);\n      final BoostQuery csq2 = new BoostQuery(new ConstantScoreQuery(csq1), 5f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final BoostQuery csqbq = new BoostQuery(new ConstantScoreQuery(bq.build()), 17f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new ClassicSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final BoostQuery csq1 = new BoostQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\"))), 2f);\n      final BoostQuery csq2 = new BoostQuery(new ConstantScoreQuery(csq1), 5f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final BoostQuery csqbq = new BoostQuery(new ConstantScoreQuery(bq.build()), 17f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      final BoostQuery csq1 = new BoostQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\"))), 2f);\n      final BoostQuery csq2 = new BoostQuery(new ConstantScoreQuery(csq1), 5f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final BoostQuery csqbq = new BoostQuery(new ConstantScoreQuery(bq.build()), 17f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new ClassicSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final BoostQuery csq1 = new BoostQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\"))), 2f);\n      final BoostQuery csq2 = new BoostQuery(new ConstantScoreQuery(csq1), 5f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final BoostQuery csqbq = new BoostQuery(new ConstantScoreQuery(bq.build()), 17f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33b0cbce3d060cc2547083fc6559e6080ec5ca23","date":1503308288,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term1\", Field.Store.NO));\n      doc.add(newStringField(\"field\", \"term2\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      final BoostQuery csq1 = new BoostQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term1\"))), 2f);\n      final BoostQuery csq2 = new BoostQuery(new ConstantScoreQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term2\")))), 5f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final BoostQuery csqbq = new BoostQuery(new ConstantScoreQuery(bq.build()), 17f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      final BoostQuery csq1 = new BoostQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\"))), 2f);\n      final BoostQuery csq2 = new BoostQuery(new ConstantScoreQuery(csq1), 5f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final BoostQuery csqbq = new BoostQuery(new ConstantScoreQuery(bq.build()), 17f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","bugFix":["2dfdf766e55e943d942055d7de53c7ad6bc45283","04f07771a2a7dd3a395700665ed839c3dae2def2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8e4fbf51a35a1292b838d83f793794c274932a1","date":1503371298,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term1\", Field.Store.NO));\n      doc.add(newStringField(\"field\", \"term2\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      final BoostQuery csq1 = new BoostQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term1\"))), 2f);\n      final BoostQuery csq2 = new BoostQuery(new ConstantScoreQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term2\")))), 5f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final BoostQuery csqbq = new BoostQuery(new ConstantScoreQuery(bq.build()), 17f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      final BoostQuery csq1 = new BoostQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\"))), 2f);\n      final BoostQuery csq2 = new BoostQuery(new ConstantScoreQuery(csq1), 5f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final BoostQuery csqbq = new BoostQuery(new ConstantScoreQuery(bq.build()), 17f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term1\", Field.Store.NO));\n      doc.add(newStringField(\"field\", \"term2\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      final BoostQuery csq1 = new BoostQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term1\"))), 2f);\n      final BoostQuery csq2 = new BoostQuery(new ConstantScoreQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term2\")))), 5f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final BoostQuery csqbq = new BoostQuery(new ConstantScoreQuery(bq.build()), 17f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      final BoostQuery csq1 = new BoostQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\"))), 2f);\n      final BoostQuery csq2 = new BoostQuery(new ConstantScoreQuery(csq1), 5f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final BoostQuery csqbq = new BoostQuery(new ConstantScoreQuery(bq.build()), 17f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dbd758f2776b0129f6b3641b6490ddc68d7b0f3","date":1536316907,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term1\", Field.Store.NO));\n      doc.add(newStringField(\"field\", \"term2\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      final BoostQuery csq1 = new BoostQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term1\"))), 2f);\n      final BoostQuery csq2 = new BoostQuery(new ConstantScoreQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term2\")))), 5f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final BoostQuery csqbq = new BoostQuery(new ConstantScoreQuery(bq.build()), 17f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<ScoreAndDoc> bucketScorerClass = ScoreAndDoc.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);\n\n      Document doc = new Document();\n      doc.add(newStringField(\"field\", \"term1\", Field.Store.NO));\n      doc.add(newStringField(\"field\", \"term2\", Field.Store.NO));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.\n      searcher = newSearcher(reader, true, false);\n      searcher.setQueryCache(null); // to assert on scorer impl\n      \n      final BoostQuery csq1 = new BoostQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term1\"))), 2f);\n      final BoostQuery csq2 = new BoostQuery(new ConstantScoreQuery(new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term2\")))), 5f);\n      \n      final BooleanQuery.Builder bq = new BooleanQuery.Builder();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final BoostQuery csqbq = new BoostQuery(new ConstantScoreQuery(bq.build()), 17f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);\n      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;\n      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);\n    } finally {\n      IOUtils.close(reader, directory);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6dbd758f2776b0129f6b3641b6490ddc68d7b0f3":["a8e4fbf51a35a1292b838d83f793794c274932a1"],"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"81d0720146de53dd3a4a023d2a3d1089d86d748d":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"22a1e22cb62fc34b060a756e6033f01cb5462247":["51f5280f31484820499077f41fcdfe92d527d9dc"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["a7f94ff172f40ff68a926d112e25b96bc38e5a27"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["22a1e22cb62fc34b060a756e6033f01cb5462247","60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["02e175abd2c4c1611c5a9647486ae8ba249a94c1","a8e4fbf51a35a1292b838d83f793794c274932a1"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["acf00221f44c5f08ccea014f2492b53af15ecd66","658a1d7b74c99b3d845fb1f852331a1c4623368e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["658a1d7b74c99b3d845fb1f852331a1c4623368e"],"a8e4fbf51a35a1292b838d83f793794c274932a1":["02e175abd2c4c1611c5a9647486ae8ba249a94c1","33b0cbce3d060cc2547083fc6559e6080ec5ca23"],"a7f94ff172f40ff68a926d112e25b96bc38e5a27":["60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"60596f28be69b10c37a56a303c2dbea07b2ca4ba":["22a1e22cb62fc34b060a756e6033f01cb5462247"],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"658a1d7b74c99b3d845fb1f852331a1c4623368e":["acf00221f44c5f08ccea014f2492b53af15ecd66"],"51f5280f31484820499077f41fcdfe92d527d9dc":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["81d0720146de53dd3a4a023d2a3d1089d86d748d","02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"956ed30f06fa518bc14a442f5dadfa7a0ef51c69":["551db74111df22d4f6684319479c9f3d5f7ddf23"],"551db74111df22d4f6684319479c9f3d5f7ddf23":["ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"02e175abd2c4c1611c5a9647486ae8ba249a94c1":["81d0720146de53dd3a4a023d2a3d1089d86d748d"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"acf00221f44c5f08ccea014f2492b53af15ecd66":["ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc","956ed30f06fa518bc14a442f5dadfa7a0ef51c69"],"ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc":["3b0e8c39ca08b5a02de6edcd33d6f3b90b865173"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6dbd758f2776b0129f6b3641b6490ddc68d7b0f3"],"33b0cbce3d060cc2547083fc6559e6080ec5ca23":["02e175abd2c4c1611c5a9647486ae8ba249a94c1"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"6dbd758f2776b0129f6b3641b6490ddc68d7b0f3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173":["ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc"],"81d0720146de53dd3a4a023d2a3d1089d86d748d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"22a1e22cb62fc34b060a756e6033f01cb5462247":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["3b0e8c39ca08b5a02de6edcd33d6f3b90b865173"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"a8e4fbf51a35a1292b838d83f793794c274932a1":["6dbd758f2776b0129f6b3641b6490ddc68d7b0f3","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"a7f94ff172f40ff68a926d112e25b96bc38e5a27":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"60596f28be69b10c37a56a303c2dbea07b2ca4ba":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","a7f94ff172f40ff68a926d112e25b96bc38e5a27"],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["81d0720146de53dd3a4a023d2a3d1089d86d748d"],"658a1d7b74c99b3d845fb1f852331a1c4623368e":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"51f5280f31484820499077f41fcdfe92d527d9dc":["22a1e22cb62fc34b060a756e6033f01cb5462247"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"956ed30f06fa518bc14a442f5dadfa7a0ef51c69":["acf00221f44c5f08ccea014f2492b53af15ecd66"],"551db74111df22d4f6684319479c9f3d5f7ddf23":["956ed30f06fa518bc14a442f5dadfa7a0ef51c69"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["51f5280f31484820499077f41fcdfe92d527d9dc"],"02e175abd2c4c1611c5a9647486ae8ba249a94c1":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","a8e4fbf51a35a1292b838d83f793794c274932a1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","33b0cbce3d060cc2547083fc6559e6080ec5ca23"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"acf00221f44c5f08ccea014f2492b53af15ecd66":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","658a1d7b74c99b3d845fb1f852331a1c4623368e"],"ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc":["551db74111df22d4f6684319479c9f3d5f7ddf23","acf00221f44c5f08ccea014f2492b53af15ecd66"],"33b0cbce3d060cc2547083fc6559e6080ec5ca23":["a8e4fbf51a35a1292b838d83f793794c274932a1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","3a7809d1d753b67f48b1a706e17034bf8b624ea3","15e323346eac5e4685c0a9f2df85eb96b4239bbb","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}