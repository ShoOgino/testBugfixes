{"path":"lucene/core/src/java/org/apache/lucene/index/MultiSimpleDocValues#simpleSortedValues(IndexReader,String).mjava","commits":[{"id":"94a2758d07e0d83d524af25cee0d8a04b6394f47","date":1357921039,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSimpleDocValues#simpleSortedValues(IndexReader,String).mjava","pathOld":"/dev/null","sourceNew":"  public static SortedDocValues simpleSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      SortedDocValues values = ctx.reader().getSortedDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n      // its called slow-wrapper for a reason right?\n      final Directory scratch = new RAMDirectory();\n      IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_50, null);\n      config.setCodec(Codec.forName(\"SimpleText\"));\n      IndexWriter writer = new IndexWriter(scratch, config);\n      List<AtomicReader> newLeaves = new ArrayList<AtomicReader>();\n      for (AtomicReaderContext ctx : leaves) {\n        final AtomicReader a = ctx.reader();\n        newLeaves.add(new FilterAtomicReader(a) {\n          @Override\n          public Bits getLiveDocs() {\n            return null; // lie\n          }\n        });\n      }\n      writer.addIndexes(newLeaves.toArray(new AtomicReader[0]));\n      writer.close();\n      final IndexReader newR = DirectoryReader.open(scratch);\n      assert newR.leaves().size() == 1;\n      r.addReaderClosedListener(new ReaderClosedListener() {\n        @Override\n        public void onClose(IndexReader reader) {\n          IOUtils.closeWhileHandlingException(newR, scratch);\n        }\n      });\n      return newR.leaves().get(0).reader().getSortedDocValues(field);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a49d69caa1c0ec8407b5b9138c7f8fb8919c3ff2","date":1358199580,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSimpleDocValues#simpleSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSimpleDocValues#simpleSortedValues(IndexReader,String).mjava","sourceNew":"  public static SortedDocValues simpleSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      SortedDocValues values = ctx.reader().getSortedDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n      // its called slow-wrapper for a reason right?\n      final Directory scratch = new RAMDirectory();\n      IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_50, null);\n      config.setCodec(Codec.forName(\"SimpleText\"));\n      IndexWriter writer = new IndexWriter(scratch, config);\n      List<AtomicReader> newLeaves = new ArrayList<AtomicReader>();\n      for (AtomicReaderContext ctx : leaves) {\n        final AtomicReader a = ctx.reader();\n        newLeaves.add(new FilterAtomicReader(a) {\n          @Override\n          public Bits getLiveDocs() {\n            return null; // lie\n          }\n          @Override\n          public int numDocs() {\n            return maxDoc(); // lie\n          }\n          @Override\n          public boolean hasDeletions() {\n            return false; // lie\n          }\n        });\n      }\n      writer.addIndexes(newLeaves.toArray(new AtomicReader[0]));\n      writer.close();\n      final IndexReader newR = DirectoryReader.open(scratch);\n      assert newR.leaves().size() == 1;\n      r.addReaderClosedListener(new ReaderClosedListener() {\n        @Override\n        public void onClose(IndexReader reader) {\n          IOUtils.closeWhileHandlingException(newR, scratch);\n        }\n      });\n      return newR.leaves().get(0).reader().getSortedDocValues(field);\n    }\n  }\n\n","sourceOld":"  public static SortedDocValues simpleSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      SortedDocValues values = ctx.reader().getSortedDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n      // its called slow-wrapper for a reason right?\n      final Directory scratch = new RAMDirectory();\n      IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_50, null);\n      config.setCodec(Codec.forName(\"SimpleText\"));\n      IndexWriter writer = new IndexWriter(scratch, config);\n      List<AtomicReader> newLeaves = new ArrayList<AtomicReader>();\n      for (AtomicReaderContext ctx : leaves) {\n        final AtomicReader a = ctx.reader();\n        newLeaves.add(new FilterAtomicReader(a) {\n          @Override\n          public Bits getLiveDocs() {\n            return null; // lie\n          }\n        });\n      }\n      writer.addIndexes(newLeaves.toArray(new AtomicReader[0]));\n      writer.close();\n      final IndexReader newR = DirectoryReader.open(scratch);\n      assert newR.leaves().size() == 1;\n      r.addReaderClosedListener(new ReaderClosedListener() {\n        @Override\n        public void onClose(IndexReader reader) {\n          IOUtils.closeWhileHandlingException(newR, scratch);\n        }\n      });\n      return newR.leaves().get(0).reader().getSortedDocValues(field);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","date":1358521790,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSimpleDocValues#simpleSortedValues(IndexReader,String).mjava","sourceNew":"  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      SortedDocValues values = ctx.reader().getSortedDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n      // its called slow-wrapper for a reason right?\n      final Directory scratch = new RAMDirectory();\n      IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_50, null);\n      config.setCodec(Codec.forName(\"SimpleText\"));\n      IndexWriter writer = new IndexWriter(scratch, config);\n      List<AtomicReader> newLeaves = new ArrayList<AtomicReader>();\n      for (AtomicReaderContext ctx : leaves) {\n        final AtomicReader a = ctx.reader();\n        newLeaves.add(new FilterAtomicReader(a) {\n          @Override\n          public Bits getLiveDocs() {\n            return null; // lie\n          }\n          @Override\n          public int numDocs() {\n            return maxDoc(); // lie\n          }\n          @Override\n          public boolean hasDeletions() {\n            return false; // lie\n          }\n        });\n      }\n      writer.addIndexes(newLeaves.toArray(new AtomicReader[0]));\n      writer.close();\n      final IndexReader newR = DirectoryReader.open(scratch);\n      assert newR.leaves().size() == 1;\n      r.addReaderClosedListener(new ReaderClosedListener() {\n        @Override\n        public void onClose(IndexReader reader) {\n          IOUtils.closeWhileHandlingException(newR, scratch);\n        }\n      });\n      return newR.leaves().get(0).reader().getSortedDocValues(field);\n    }\n  }\n\n","sourceOld":"  public static SortedDocValues simpleSortedValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getSortedDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      SortedDocValues values = ctx.reader().getSortedDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n      // its called slow-wrapper for a reason right?\n      final Directory scratch = new RAMDirectory();\n      IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_50, null);\n      config.setCodec(Codec.forName(\"SimpleText\"));\n      IndexWriter writer = new IndexWriter(scratch, config);\n      List<AtomicReader> newLeaves = new ArrayList<AtomicReader>();\n      for (AtomicReaderContext ctx : leaves) {\n        final AtomicReader a = ctx.reader();\n        newLeaves.add(new FilterAtomicReader(a) {\n          @Override\n          public Bits getLiveDocs() {\n            return null; // lie\n          }\n          @Override\n          public int numDocs() {\n            return maxDoc(); // lie\n          }\n          @Override\n          public boolean hasDeletions() {\n            return false; // lie\n          }\n        });\n      }\n      writer.addIndexes(newLeaves.toArray(new AtomicReader[0]));\n      writer.close();\n      final IndexReader newR = DirectoryReader.open(scratch);\n      assert newR.leaves().size() == 1;\n      r.addReaderClosedListener(new ReaderClosedListener() {\n        @Override\n        public void onClose(IndexReader reader) {\n          IOUtils.closeWhileHandlingException(newR, scratch);\n        }\n      });\n      return newR.leaves().get(0).reader().getSortedDocValues(field);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a49d69caa1c0ec8407b5b9138c7f8fb8919c3ff2":["94a2758d07e0d83d524af25cee0d8a04b6394f47"],"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["a49d69caa1c0ec8407b5b9138c7f8fb8919c3ff2"],"94a2758d07e0d83d524af25cee0d8a04b6394f47":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a49d69caa1c0ec8407b5b9138c7f8fb8919c3ff2":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200"],"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":[],"94a2758d07e0d83d524af25cee0d8a04b6394f47":["a49d69caa1c0ec8407b5b9138c7f8fb8919c3ff2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["94a2758d07e0d83d524af25cee0d8a04b6394f47","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}