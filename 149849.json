{"path":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","commits":[{"id":"175a04d27a2b736171e7e51ca46a03b2aec094d4","date":1452534768,"type":0,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getInQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", collection,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, collection);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, collection, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, collection, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(collection, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", collection, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(collection);\n          assertTrue(\"found no \"+collection, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+collection+\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+collection+\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19498030e0adab22f604f935cae3c03dcf0952a6","date":1456558851,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", collection,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, collection);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, collection, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, collection, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(collection, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", collection, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(collection);\n          assertTrue(\"found no \"+collection, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+collection+\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+collection+\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getInQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", collection,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, collection);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, collection, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, collection, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(collection, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", collection, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(collection);\n          assertTrue(\"found no \"+collection, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+collection+\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+collection+\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", collection,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, collection);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, collection, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, collection, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(collection, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", collection, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(collection);\n          assertTrue(\"found no \"+collection, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+collection+\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+collection+\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getInQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", collection,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, collection);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, collection, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, collection, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(collection, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", collection, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(collection);\n          assertTrue(\"found no \"+collection, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+collection+\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+collection+\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5de502b5478255493125e7e801411ba17a6682ec","date":1490974101,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(COLLECTION, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", collection,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, collection);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, collection, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, collection, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(collection, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", collection, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(collection);\n          assertTrue(\"found no \"+collection, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+collection+\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+collection+\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","344b0840364d990b29b97467bfcc766ff8325d11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6f20fd35e3055a0c5b387df0b986a68d65d86441","date":1491045405,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(COLLECTION, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", collection,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, collection);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, collection, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, collection, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, collection,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(collection, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", collection, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(collection);\n          assertTrue(\"found no \"+collection, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+collection+\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+collection+\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9b4296bd51ca61b482138791478afdd0f7d3a3d","date":1498058739,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(COLLECTION, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(COLLECTION, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(COLLECTION, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(COLLECTION, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(COLLECTION, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(COLLECTION, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getCollection(COLLECTION).getSlice(\"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(COLLECTION, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","bugFix":["5de502b5478255493125e7e801411ba17a6682ec"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"44bfd7d2ea76c7c37dd13eadc1889039e172f3c7","date":1501726570,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getCollection(COLLECTION).getSlice(\"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getCollection(COLLECTION).getSlice(\"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getCollection(COLLECTION).getSlice(\"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getSlice(COLLECTION, \"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89c102d671c256ef8dd67b3ecb3ab96fe7a8006e","date":1505888025,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      ZkDistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getCollection(COLLECTION).getSlice(\"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getCollection(COLLECTION).getSlice(\"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      ZkDistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getCollection(COLLECTION).getSlice(\"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      DistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getCollection(COLLECTION).getSlice(\"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n           \n          {\n            String shard = \"shard\"+ss;\n            zkStateReader.waitForState(COLLECTION, 15000, TimeUnit.MILLISECONDS, (liveNodes, collectionState) -> collectionState != null && (collectionState.getSlice(shard) == null || collectionState.getSlice(shard).getReplicasMap().get(\"core_node\"+N) == null));\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    final String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    final ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient zkClient = null;\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n      server.run();\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n\n      zkClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      ZkDistributedQueue q = Overseer.getStateUpdateQueue(zkClient);\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            int iterationsLeft = 100;\n            while (iterationsLeft-- > 0) {\n              final Slice slice = zkStateReader.getClusterState().getCollection(COLLECTION).getSlice(\"shard\"+ss);\n              if (null == slice || null == slice.getReplicasMap().get(\"core_node\"+N)) {\n                break;\n              }\n              if (VERBOSE) log.info(\"still seeing {} shard{} core_node{}, rechecking in 50ms ({} iterations left)\", COLLECTION, ss, N, iterationsLeft);\n              Thread.sleep(50);\n            }\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n      close(zkClient);\n\n      server.shutdown();\n    }\n  }\n\n","bugFix":["344b0840364d990b29b97467bfcc766ff8325d11","175a04d27a2b736171e7e51ca46a03b2aec094d4","5de502b5478255493125e7e801411ba17a6682ec","89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            String shard = \"shard\"+ss;\n            zkStateReader.waitForState(COLLECTION, 15000, TimeUnit.MILLISECONDS, (liveNodes, collectionState) -> collectionState != null && (collectionState.getSlice(shard) == null || collectionState.getSlice(shard).getReplicasMap().get(\"core_node\"+N) == null));\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n           \n          {\n            String shard = \"shard\"+ss;\n            zkStateReader.waitForState(COLLECTION, 15000, TimeUnit.MILLISECONDS, (liveNodes, collectionState) -> collectionState != null && (collectionState.getSlice(shard) == null || collectionState.getSlice(shard).getReplicasMap().get(\"core_node\"+N) == null));\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        zkClient.makePath(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + COLLECTION, true);\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            String shard = \"shard\"+ss;\n            zkStateReader.waitForState(COLLECTION, 15000, TimeUnit.MILLISECONDS, (liveNodes, collectionState) -> collectionState != null && (collectionState.getSlice(shard) == null || collectionState.getSlice(shard).getReplicasMap().get(\"core_node\"+N) == null));\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            String shard = \"shard\"+ss;\n            zkStateReader.waitForState(COLLECTION, 15000, TimeUnit.MILLISECONDS, (liveNodes, collectionState) -> collectionState != null && (collectionState.getSlice(shard) == null || collectionState.getSlice(shard).getReplicasMap().get(\"core_node\"+N) == null));\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testRemovalOfLastReplica().mjava","sourceNew":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n\n      // create collection\n      {\n        zkClient.makePath(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + COLLECTION, true);\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\"\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            String shard = \"shard\"+ss;\n            zkStateReader.waitForState(COLLECTION, 15000, TimeUnit.MILLISECONDS, (liveNodes, collectionState) -> collectionState != null && (collectionState.getSlice(shard) == null || collectionState.getSlice(shard).getReplicasMap().get(\"core_node\"+N) == null));\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRemovalOfLastReplica() throws Exception {\n\n    final Integer numReplicas = 1+random().nextInt(4); // between 1 and 4 replicas\n    final Integer numShards = 1+random().nextInt(4); // between 1 and 4 shards\n\n    ZkStateReader zkStateReader = null;\n    SolrZkClient overseerClient = null;\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n\n      // create collection\n      {\n        final Integer maxShardsPerNode = numReplicas * numShards;\n        zkClient.makePath(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + COLLECTION, true);\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", COLLECTION,\n            ZkStateReader.NUM_SHARDS_PROP, numShards.toString(),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode.toString()\n            );\n        q.offer(Utils.toJSON(m));\n      }\n      waitForCollections(zkStateReader, COLLECTION);\n\n      // create nodes with state recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify recovering\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.RECOVERING);\n        }\n      }\n\n      // publish node states (active)\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n              ZkStateReader.BASE_URL_PROP, \"http://127.0.0.1/solr\",\n              ZkStateReader.SHARD_ID_PROP, \"shard\"+ss,\n              ZkStateReader.NODE_NAME_PROP, \"node\"+N,\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NAME_PROP, \"core\"+N,\n              ZkStateReader.ROLES_PROP, \"\",\n              ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n\n          q.offer(Utils.toJSON(m));\n        }\n      }\n      // verify active\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          verifyReplicaStatus(zkStateReader, COLLECTION, \"shard\"+ss, \"core_node\"+N, Replica.State.ACTIVE);\n        }\n      }\n\n      // delete node\n      for (int rr = 1; rr <= numReplicas; ++rr) {\n        for (int ss = 1; ss <= numShards; ++ss) {\n          final int N = (numReplicas-rr)*numShards + ss;\n          ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.COLLECTION_PROP, COLLECTION,\n              ZkStateReader.CORE_NODE_NAME_PROP, \"core_node\"+N);\n\n          q.offer(Utils.toJSON(m));\n\n          {\n            String shard = \"shard\"+ss;\n            zkStateReader.waitForState(COLLECTION, 15000, TimeUnit.MILLISECONDS, (liveNodes, collectionState) -> collectionState != null && (collectionState.getSlice(shard) == null || collectionState.getSlice(shard).getReplicasMap().get(\"core_node\"+N) == null));\n          }\n\n          final DocCollection docCollection = zkStateReader.getClusterState().getCollection(COLLECTION);\n          assertTrue(\"found no \"+ COLLECTION, (null != docCollection));\n\n          final Slice slice = docCollection.getSlice(\"shard\"+ss);\n          assertTrue(\"found no \"+ COLLECTION +\" shard\"+ss+\" slice after removal of replica \"+rr+\" of \"+numReplicas, (null != slice));\n\n          final Collection<Replica> replicas = slice.getReplicas();\n          assertEquals(\"wrong number of \"+ COLLECTION +\" shard\"+ss+\" replicas left, replicas=\"+replicas, numReplicas-rr, replicas.size());\n        }\n      }\n\n    } finally {\n\n      close(overseerClient);\n      close(zkStateReader);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["175a04d27a2b736171e7e51ca46a03b2aec094d4","19498030e0adab22f604f935cae3c03dcf0952a6"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"5de502b5478255493125e7e801411ba17a6682ec":["af2638813028b254a88b418ebeafb541afb49653"],"a9b4296bd51ca61b482138791478afdd0f7d3a3d":["5de502b5478255493125e7e801411ba17a6682ec"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"344b0840364d990b29b97467bfcc766ff8325d11":["28288370235ed02234a64753cdbf0c6ec096304a"],"6f20fd35e3055a0c5b387df0b986a68d65d86441":["af2638813028b254a88b418ebeafb541afb49653"],"175a04d27a2b736171e7e51ca46a03b2aec094d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["6f20fd35e3055a0c5b387df0b986a68d65d86441","a9b4296bd51ca61b482138791478afdd0f7d3a3d"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"28288370235ed02234a64753cdbf0c6ec096304a":["5de502b5478255493125e7e801411ba17a6682ec","a9b4296bd51ca61b482138791478afdd0f7d3a3d"],"19498030e0adab22f604f935cae3c03dcf0952a6":["175a04d27a2b736171e7e51ca46a03b2aec094d4"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","44bfd7d2ea76c7c37dd13eadc1889039e172f3c7"],"44bfd7d2ea76c7c37dd13eadc1889039e172f3c7":["344b0840364d990b29b97467bfcc766ff8325d11"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"89c102d671c256ef8dd67b3ecb3ab96fe7a8006e":["44bfd7d2ea76c7c37dd13eadc1889039e172f3c7"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["5de502b5478255493125e7e801411ba17a6682ec","6f20fd35e3055a0c5b387df0b986a68d65d86441"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"5de502b5478255493125e7e801411ba17a6682ec":["a9b4296bd51ca61b482138791478afdd0f7d3a3d","28288370235ed02234a64753cdbf0c6ec096304a"],"a9b4296bd51ca61b482138791478afdd0f7d3a3d":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"344b0840364d990b29b97467bfcc766ff8325d11":["44bfd7d2ea76c7c37dd13eadc1889039e172f3c7"],"6f20fd35e3055a0c5b387df0b986a68d65d86441":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"175a04d27a2b736171e7e51ca46a03b2aec094d4":["af2638813028b254a88b418ebeafb541afb49653","19498030e0adab22f604f935cae3c03dcf0952a6"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"28288370235ed02234a64753cdbf0c6ec096304a":["344b0840364d990b29b97467bfcc766ff8325d11"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"19498030e0adab22f604f935cae3c03dcf0952a6":["af2638813028b254a88b418ebeafb541afb49653"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["6240b74b884c5587f2a4062dd27d6c32bf228889"],"44bfd7d2ea76c7c37dd13eadc1889039e172f3c7":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["175a04d27a2b736171e7e51ca46a03b2aec094d4"],"89c102d671c256ef8dd67b3ecb3ab96fe7a8006e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","6240b74b884c5587f2a4062dd27d6c32bf228889"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6240b74b884c5587f2a4062dd27d6c32bf228889","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}