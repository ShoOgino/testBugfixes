{"path":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","commits":[{"id":"a9b907a7568aa04bcad16628b3ede514dd0266ab","date":1392986355,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","pathOld":"/dev/null","sourceNew":"  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(TestUtil.getTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_46,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<IndexSearcher>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<Thread>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(dir.fileExists(name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","sourceNew":"  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(TestUtil.getTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_46,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(dir.fileExists(name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(TestUtil.getTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_46,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<IndexSearcher>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<Thread>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(dir.fileExists(name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd4e13d997cf4fb810398a20a299c2c5a9f6b796","date":1395594336,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","sourceNew":"  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(TestUtil.getTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_46,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(TestUtil.getTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_46,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(dir.fileExists(name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0d579490a72f2e6297eaa648940611234c57cf1","date":1395917140,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","sourceNew":"  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(TestUtil.createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_46,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(TestUtil.getTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_46,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c","date":1396633078,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","sourceNew":"  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_46,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(TestUtil.createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_46,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a0f5bb79c600763ffe7b8141df59a3169d31e48","date":1396689440,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","sourceNew":"  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_46,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(TestUtil.getTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_46,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","sourceNew":"  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_46,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.shutdown();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_46,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd330c9d05eacbd6e952fe0dea852e7ae037eb50","date":1398873035,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","sourceNew":"  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_4_6,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.shutdown();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_46,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.shutdown();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84cc1b583793957d9ce3e4fb600b7174ec9046ec","date":1401960748,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","sourceNew":"  // Relies on wall clock time, so it can easily false-fail when the machine is otherwise busy:\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/LUCENE-5737\")\n  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_4_6,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.shutdown();\n    dir.close();\n  }\n\n","sourceOld":"  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_4_6,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.shutdown();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","sourceNew":"  // Relies on wall clock time, so it can easily false-fail when the machine is otherwise busy:\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/LUCENE-5737\")\n  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(new MockAnalyzer(random()));\n    config.setCommitOnClose(true);\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Relies on wall clock time, so it can easily false-fail when the machine is otherwise busy:\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/LUCENE-5737\")\n  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_4_6,\n                                                     new MockAnalyzer(random()));\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.shutdown();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b516a692d03225c8f0e81a13ceed2dc32bb457d","date":1453411951,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","sourceNew":"  // Relies on wall clock time, so it can easily false-fail when the machine is otherwise busy:\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/LUCENE-5737\")\n  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(new MockAnalyzer(random()));\n    config.setCommitOnClose(true);\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Relies on wall clock time, so it can easily false-fail when the machine is otherwise busy:\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/LUCENE-5737\")\n  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(new MockAnalyzer(random()));\n    config.setCommitOnClose(true);\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, true, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"427bf5b96e9aacef8f01879bc1b93c3619c43439","date":1464134313,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","sourceNew":"  // Relies on wall clock time, so it can easily false-fail when the machine is otherwise busy:\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/LUCENE-5737\")\n  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(new MockAnalyzer(random()));\n    config.setCommitOnClose(true);\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, new SearcherFactory());\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(iw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = iw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Relies on wall clock time, so it can easily false-fail when the machine is otherwise busy:\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/LUCENE-5737\")\n  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(new MockAnalyzer(random()));\n    config.setCommitOnClose(true);\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6483e4260c08168709c02238ae083a51519a28dd","date":1465117546,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","sourceNew":"  // Relies on wall clock time, so it can easily false-fail when the machine is otherwise busy:\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/LUCENE-5737\")\n  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(new MockAnalyzer(random()));\n    config.setCommitOnClose(true);\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, new SearcherFactory());\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(iw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = iw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Relies on wall clock time, so it can easily false-fail when the machine is otherwise busy:\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/LUCENE-5737\")\n  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(new MockAnalyzer(random()));\n    config.setCommitOnClose(true);\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"191128ac5b85671b1671e2c857437694283b6ebf","date":1465297861,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","sourceNew":"  // Relies on wall clock time, so it can easily false-fail when the machine is otherwise busy:\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/LUCENE-5737\")\n  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(new MockAnalyzer(random()));\n    config.setCommitOnClose(true);\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, new SearcherFactory());\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(iw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = iw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Relies on wall clock time, so it can easily false-fail when the machine is otherwise busy:\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/LUCENE-5737\")\n  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(new MockAnalyzer(random()));\n    config.setCommitOnClose(true);\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","sourceNew":"  // Relies on wall clock time, so it can easily false-fail when the machine is otherwise busy:\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/LUCENE-5737\")\n  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(new MockAnalyzer(random()));\n    config.setCommitOnClose(true);\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, new SearcherFactory());\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(iw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = iw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Relies on wall clock time, so it can easily false-fail when the machine is otherwise busy:\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/LUCENE-5737\")\n  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(new MockAnalyzer(random()));\n    config.setCommitOnClose(true);\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, new SearcherFactory());\n    final TrackingIndexWriter tiw = new TrackingIndexWriter(iw);\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(tiw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = tiw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestControlledRealTimeReopenThread#testCRTReopen().mjava","sourceNew":"  // Relies on wall clock time, so it can easily false-fail when the machine is otherwise busy:\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/LUCENE-5737\")\n  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(new MockAnalyzer(random()));\n    config.setCommitOnClose(true);\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, new SearcherFactory());\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(iw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = iw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits.value);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Relies on wall clock time, so it can easily false-fail when the machine is otherwise busy:\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/LUCENE-5737\")\n  // LUCENE-5461\n  public void testCRTReopen() throws Exception {\n    //test behaving badly\n\n    //should be high enough\n    int maxStaleSecs = 20;\n\n    //build crap data just to store it.\n    String s = \"        abcdefghijklmnopqrstuvwxyz     \";\n    char[] chars = s.toCharArray();\n    StringBuilder builder = new StringBuilder(2048);\n    for (int i = 0; i < 2048; i++) {\n      builder.append(chars[random().nextInt(chars.length)]);\n    }\n    String content = builder.toString();\n\n    final SnapshotDeletionPolicy sdp = new SnapshotDeletionPolicy(new KeepOnlyLastCommitDeletionPolicy());\n    final Directory dir = new NRTCachingDirectory(newFSDirectory(createTempDir(\"nrt\")), 5, 128);\n    IndexWriterConfig config = new IndexWriterConfig(new MockAnalyzer(random()));\n    config.setCommitOnClose(true);\n    config.setIndexDeletionPolicy(sdp);\n    config.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);\n    final IndexWriter iw = new IndexWriter(dir, config);\n    SearcherManager sm = new SearcherManager(iw, new SearcherFactory());\n    ControlledRealTimeReopenThread<IndexSearcher> controlledRealTimeReopenThread =\n      new ControlledRealTimeReopenThread<>(iw, sm, maxStaleSecs, 0);\n\n    controlledRealTimeReopenThread.setDaemon(true);\n    controlledRealTimeReopenThread.start();\n\n    List<Thread> commitThreads = new ArrayList<>();\n\n    for (int i = 0; i < 500; i++) {\n      if (i > 0 && i % 50 == 0) {\n        Thread commitThread =  new Thread(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                iw.commit();\n                IndexCommit ic = sdp.snapshot();\n                for (String name : ic.getFileNames()) {\n                  //distribute, and backup\n                  //System.out.println(names);\n                  assertTrue(slowFileExists(dir, name));\n                }\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n            }\n          });\n        commitThread.start();\n        commitThreads.add(commitThread);\n      }\n      Document d = new Document();\n      d.add(new TextField(\"count\", i + \"\", Field.Store.NO));\n      d.add(new TextField(\"content\", content, Field.Store.YES));\n      long start = System.currentTimeMillis();\n      long l = iw.addDocument(d);\n      controlledRealTimeReopenThread.waitForGeneration(l);\n      long wait = System.currentTimeMillis() - start;\n      assertTrue(\"waited too long for generation \" + wait,\n                 wait < (maxStaleSecs *1000));\n      IndexSearcher searcher = sm.acquire();\n      TopDocs td = searcher.search(new TermQuery(new Term(\"count\", i + \"\")), 10);\n      sm.release(searcher);\n      assertEquals(1, td.totalHits);\n    }\n\n    for(Thread commitThread : commitThreads) {\n      commitThread.join();\n    }\n\n    controlledRealTimeReopenThread.close();\n    sm.close();\n    iw.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a9b907a7568aa04bcad16628b3ede514dd0266ab"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["cd4e13d997cf4fb810398a20a299c2c5a9f6b796","a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"cd4e13d997cf4fb810398a20a299c2c5a9f6b796":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"84cc1b583793957d9ce3e4fb600b7174ec9046ec":["dd330c9d05eacbd6e952fe0dea852e7ae037eb50"],"7b516a692d03225c8f0e81a13ceed2dc32bb457d":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"6483e4260c08168709c02238ae083a51519a28dd":["7b516a692d03225c8f0e81a13ceed2dc32bb457d","427bf5b96e9aacef8f01879bc1b93c3619c43439"],"191128ac5b85671b1671e2c857437694283b6ebf":["7b516a692d03225c8f0e81a13ceed2dc32bb457d","6483e4260c08168709c02238ae083a51519a28dd"],"d0d579490a72f2e6297eaa648940611234c57cf1":["cd4e13d997cf4fb810398a20a299c2c5a9f6b796"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7b516a692d03225c8f0e81a13ceed2dc32bb457d","191128ac5b85671b1671e2c857437694283b6ebf"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["d0d579490a72f2e6297eaa648940611234c57cf1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["84cc1b583793957d9ce3e4fb600b7174ec9046ec"],"dd330c9d05eacbd6e952fe0dea852e7ae037eb50":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"a9b907a7568aa04bcad16628b3ede514dd0266ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["191128ac5b85671b1671e2c857437694283b6ebf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"427bf5b96e9aacef8f01879bc1b93c3619c43439":["7b516a692d03225c8f0e81a13ceed2dc32bb457d"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd4e13d997cf4fb810398a20a299c2c5a9f6b796"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"cd4e13d997cf4fb810398a20a299c2c5a9f6b796":["2a0f5bb79c600763ffe7b8141df59a3169d31e48","d0d579490a72f2e6297eaa648940611234c57cf1"],"84cc1b583793957d9ce3e4fb600b7174ec9046ec":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"7b516a692d03225c8f0e81a13ceed2dc32bb457d":["6483e4260c08168709c02238ae083a51519a28dd","191128ac5b85671b1671e2c857437694283b6ebf","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","427bf5b96e9aacef8f01879bc1b93c3619c43439"],"6483e4260c08168709c02238ae083a51519a28dd":["191128ac5b85671b1671e2c857437694283b6ebf"],"191128ac5b85671b1671e2c857437694283b6ebf":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","83788ad129a5154d5c6562c4e8ce3db48793aada"],"d0d579490a72f2e6297eaa648940611234c57cf1":["a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a9b907a7568aa04bcad16628b3ede514dd0266ab"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["7b516a692d03225c8f0e81a13ceed2dc32bb457d"],"a9b907a7568aa04bcad16628b3ede514dd0266ab":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"dd330c9d05eacbd6e952fe0dea852e7ae037eb50":["84cc1b583793957d9ce3e4fb600b7174ec9046ec"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["dd330c9d05eacbd6e952fe0dea852e7ae037eb50"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"427bf5b96e9aacef8f01879bc1b93c3619c43439":["6483e4260c08168709c02238ae083a51519a28dd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}