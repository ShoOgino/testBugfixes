{"path":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(FieldDoc,FieldDoc).mjava","commits":[{"id":"0731e137bcbb58121034de6ddaa67332fbe6e5d1","date":1255233265,"type":1,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(FieldDoc,FieldDoc).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final FieldDoc docA, final FieldDoc docB) {\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:{\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOC:\n\t\t\t\tcase SortField.INT:{\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.LONG:{\n\t\t\t\t\tlong l1 = ((Long)docA.fields[i]).longValue();\n\t\t\t\t\tlong l2 = ((Long)docB.fields[i]).longValue();\n\t\t\t\t\tif (l1 < l2) c = -1;\n\t\t\t\t\tif (l1 > l2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.STRING:{\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.  If both are null, the next SortField is used\n\t\t\t\t\tif (s1 == null) c = (s2==null) ? 0 : -1;\n\t\t\t\t\telse if (s2 == null) c = 1;  // \n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n        }\n        case SortField.FLOAT:{\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOUBLE:{\n\t\t\t\t\tdouble d1 = ((Double)docA.fields[i]).doubleValue();\n\t\t\t\t\tdouble d2 = ((Double)docB.fields[i]).doubleValue();\n\t\t\t\t\tif (d1 < d2) c = -1;\n\t\t\t\t\tif (d1 > d2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.BYTE:{\n\t\t\t\t\tint i1 = ((Byte)docA.fields[i]).byteValue();\n\t\t\t\t\tint i2 = ((Byte)docB.fields[i]).byteValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.SHORT:{\n\t\t\t\t\tint i1 = ((Short)docA.fields[i]).shortValue();\n\t\t\t\t\tint i2 = ((Short)docB.fields[i]).shortValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.CUSTOM:{\n\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\tbreak;\n        }\n        case SortField.AUTO:{\n\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t// FLOAT contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n        }\n        default:{\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n        }\n      }\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n\t}\n\n","sourceOld":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:{\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOC:\n\t\t\t\tcase SortField.INT:{\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.LONG:{\n\t\t\t\t\tlong l1 = ((Long)docA.fields[i]).longValue();\n\t\t\t\t\tlong l2 = ((Long)docB.fields[i]).longValue();\n\t\t\t\t\tif (l1 < l2) c = -1;\n\t\t\t\t\tif (l1 > l2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.STRING:{\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.  If both are null, the next SortField is used\n\t\t\t\t\tif (s1 == null) c = (s2==null) ? 0 : -1;\n\t\t\t\t\telse if (s2 == null) c = 1;  // \n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n        }\n        case SortField.FLOAT:{\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOUBLE:{\n\t\t\t\t\tdouble d1 = ((Double)docA.fields[i]).doubleValue();\n\t\t\t\t\tdouble d2 = ((Double)docB.fields[i]).doubleValue();\n\t\t\t\t\tif (d1 < d2) c = -1;\n\t\t\t\t\tif (d1 > d2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.BYTE:{\n\t\t\t\t\tint i1 = ((Byte)docA.fields[i]).byteValue();\n\t\t\t\t\tint i2 = ((Byte)docB.fields[i]).byteValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.SHORT:{\n\t\t\t\t\tint i1 = ((Short)docA.fields[i]).shortValue();\n\t\t\t\t\tint i2 = ((Short)docB.fields[i]).shortValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.CUSTOM:{\n\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\tbreak;\n        }\n        case SortField.AUTO:{\n\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t// FLOAT contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n        }\n        default:{\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n        }\n      }\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ded38b25fe842ef1efc6715745bb8d8ed8e2fc99","date":1255432705,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(FieldDoc,FieldDoc).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(FieldDoc,FieldDoc).mjava","sourceNew":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final FieldDoc docA, final FieldDoc docB) {\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:{\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOC:\n\t\t\t\tcase SortField.INT:{\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.LONG:{\n\t\t\t\t\tlong l1 = ((Long)docA.fields[i]).longValue();\n\t\t\t\t\tlong l2 = ((Long)docB.fields[i]).longValue();\n\t\t\t\t\tif (l1 < l2) c = -1;\n\t\t\t\t\tif (l1 > l2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.STRING:{\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.  If both are null, the next SortField is used\n\t\t\t\t\tif (s1 == null) c = (s2==null) ? 0 : -1;\n\t\t\t\t\telse if (s2 == null) c = 1;  // \n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n        }\n        case SortField.FLOAT:{\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOUBLE:{\n\t\t\t\t\tdouble d1 = ((Double)docA.fields[i]).doubleValue();\n\t\t\t\t\tdouble d2 = ((Double)docB.fields[i]).doubleValue();\n\t\t\t\t\tif (d1 < d2) c = -1;\n\t\t\t\t\tif (d1 > d2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.BYTE:{\n\t\t\t\t\tint i1 = ((Byte)docA.fields[i]).byteValue();\n\t\t\t\t\tint i2 = ((Byte)docB.fields[i]).byteValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.SHORT:{\n\t\t\t\t\tint i1 = ((Short)docA.fields[i]).shortValue();\n\t\t\t\t\tint i2 = ((Short)docB.fields[i]).shortValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.CUSTOM:{\n\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\tbreak;\n        }\n        default:{\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n        }\n      }\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n\t}\n\n","sourceOld":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final FieldDoc docA, final FieldDoc docB) {\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:{\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOC:\n\t\t\t\tcase SortField.INT:{\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.LONG:{\n\t\t\t\t\tlong l1 = ((Long)docA.fields[i]).longValue();\n\t\t\t\t\tlong l2 = ((Long)docB.fields[i]).longValue();\n\t\t\t\t\tif (l1 < l2) c = -1;\n\t\t\t\t\tif (l1 > l2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.STRING:{\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.  If both are null, the next SortField is used\n\t\t\t\t\tif (s1 == null) c = (s2==null) ? 0 : -1;\n\t\t\t\t\telse if (s2 == null) c = 1;  // \n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n        }\n        case SortField.FLOAT:{\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOUBLE:{\n\t\t\t\t\tdouble d1 = ((Double)docA.fields[i]).doubleValue();\n\t\t\t\t\tdouble d2 = ((Double)docB.fields[i]).doubleValue();\n\t\t\t\t\tif (d1 < d2) c = -1;\n\t\t\t\t\tif (d1 > d2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.BYTE:{\n\t\t\t\t\tint i1 = ((Byte)docA.fields[i]).byteValue();\n\t\t\t\t\tint i2 = ((Byte)docB.fields[i]).byteValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.SHORT:{\n\t\t\t\t\tint i1 = ((Short)docA.fields[i]).shortValue();\n\t\t\t\t\tint i2 = ((Short)docB.fields[i]).shortValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.CUSTOM:{\n\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\tbreak;\n        }\n        case SortField.AUTO:{\n\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t// FLOAT contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n        }\n        default:{\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n        }\n      }\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f63c5771d883c45d43e7d5ac11344582906f7d17","date":1256132259,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(FieldDoc,FieldDoc).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(FieldDoc,FieldDoc).mjava","sourceNew":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final FieldDoc docA, final FieldDoc docB) {\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:{\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOC:\n\t\t\t\tcase SortField.INT:{\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.LONG:{\n\t\t\t\t\tlong l1 = ((Long)docA.fields[i]).longValue();\n\t\t\t\t\tlong l2 = ((Long)docB.fields[i]).longValue();\n\t\t\t\t\tif (l1 < l2) c = -1;\n\t\t\t\t\tif (l1 > l2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.STRING:{\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.  If both are null, the next SortField is used\n\t\t\t\t\tif (s1 == null) c = (s2==null) ? 0 : -1;\n\t\t\t\t\telse if (s2 == null) c = 1;  // \n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n        }\n        case SortField.FLOAT:{\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOUBLE:{\n\t\t\t\t\tdouble d1 = ((Double)docA.fields[i]).doubleValue();\n\t\t\t\t\tdouble d2 = ((Double)docB.fields[i]).doubleValue();\n\t\t\t\t\tif (d1 < d2) c = -1;\n\t\t\t\t\tif (d1 > d2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.BYTE:{\n\t\t\t\t\tint i1 = ((Byte)docA.fields[i]).byteValue();\n\t\t\t\t\tint i2 = ((Byte)docB.fields[i]).byteValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.SHORT:{\n\t\t\t\t\tint i1 = ((Short)docA.fields[i]).shortValue();\n\t\t\t\t\tint i2 = ((Short)docB.fields[i]).shortValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.CUSTOM:{\n          // TODO: Use FieldComparator? This does not make sense!\n\t\t\t\t\t@SuppressWarnings(\"unchecked\") final int temp =\n            c = ((Comparable) docA.fields[i]).compareTo((Comparable) docB.fields[i]);\n\t\t\t\t\tbreak;\n        }\n        default:{\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n        }\n      }\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n\t}\n\n","sourceOld":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final FieldDoc docA, final FieldDoc docB) {\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:{\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOC:\n\t\t\t\tcase SortField.INT:{\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.LONG:{\n\t\t\t\t\tlong l1 = ((Long)docA.fields[i]).longValue();\n\t\t\t\t\tlong l2 = ((Long)docB.fields[i]).longValue();\n\t\t\t\t\tif (l1 < l2) c = -1;\n\t\t\t\t\tif (l1 > l2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.STRING:{\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.  If both are null, the next SortField is used\n\t\t\t\t\tif (s1 == null) c = (s2==null) ? 0 : -1;\n\t\t\t\t\telse if (s2 == null) c = 1;  // \n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n        }\n        case SortField.FLOAT:{\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOUBLE:{\n\t\t\t\t\tdouble d1 = ((Double)docA.fields[i]).doubleValue();\n\t\t\t\t\tdouble d2 = ((Double)docB.fields[i]).doubleValue();\n\t\t\t\t\tif (d1 < d2) c = -1;\n\t\t\t\t\tif (d1 > d2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.BYTE:{\n\t\t\t\t\tint i1 = ((Byte)docA.fields[i]).byteValue();\n\t\t\t\t\tint i2 = ((Byte)docB.fields[i]).byteValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.SHORT:{\n\t\t\t\t\tint i1 = ((Short)docA.fields[i]).shortValue();\n\t\t\t\t\tint i2 = ((Short)docB.fields[i]).shortValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.CUSTOM:{\n\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\tbreak;\n        }\n        default:{\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n        }\n      }\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"107375340c8594fcc5f132e2dda05faef686bfda","date":1256308625,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(FieldDoc,FieldDoc).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(FieldDoc,FieldDoc).mjava","sourceNew":"  /**\n   * Returns whether <code>a</code> is less relevant than <code>b</code>.\n   * @param a ScoreDoc\n   * @param b ScoreDoc\n   * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected final boolean lessThan (final FieldDoc docA, final FieldDoc docB) {\n    final int n = fields.length;\n    int c = 0;\n    for (int i=0; i<n && c==0; ++i) {\n      final int type = fields[i].getType();\n      switch (type) {\n        case SortField.SCORE:{\n          float r1 = ((Float)docA.fields[i]).floatValue();\n          float r2 = ((Float)docB.fields[i]).floatValue();\n          if (r1 > r2) c = -1;\n          if (r1 < r2) c = 1;\n          break;\n        }\n        case SortField.DOC:\n        case SortField.INT:{\n          int i1 = ((Integer)docA.fields[i]).intValue();\n          int i2 = ((Integer)docB.fields[i]).intValue();\n          if (i1 < i2) c = -1;\n          if (i1 > i2) c = 1;\n          break;\n        }\n        case SortField.LONG:{\n          long l1 = ((Long)docA.fields[i]).longValue();\n          long l2 = ((Long)docB.fields[i]).longValue();\n          if (l1 < l2) c = -1;\n          if (l1 > l2) c = 1;\n          break;\n        }\n        case SortField.STRING:{\n          String s1 = (String) docA.fields[i];\n          String s2 = (String) docB.fields[i];\n          // null values need to be sorted first, because of how FieldCache.getStringIndex()\n          // works - in that routine, any documents without a value in the given field are\n          // put first.  If both are null, the next SortField is used\n          if (s1 == null) c = (s2==null) ? 0 : -1;\n          else if (s2 == null) c = 1;  // \n          else if (fields[i].getLocale() == null) {\n            c = s1.compareTo(s2);\n          } else {\n            c = collators[i].compare (s1, s2);\n          }\n          break;\n        }\n        case SortField.FLOAT:{\n          float f1 = ((Float)docA.fields[i]).floatValue();\n          float f2 = ((Float)docB.fields[i]).floatValue();\n          if (f1 < f2) c = -1;\n          if (f1 > f2) c = 1;\n          break;\n        }\n        case SortField.DOUBLE:{\n          double d1 = ((Double)docA.fields[i]).doubleValue();\n          double d2 = ((Double)docB.fields[i]).doubleValue();\n          if (d1 < d2) c = -1;\n          if (d1 > d2) c = 1;\n          break;\n        }\n        case SortField.BYTE:{\n          int i1 = ((Byte)docA.fields[i]).byteValue();\n          int i2 = ((Byte)docB.fields[i]).byteValue();\n          if (i1 < i2) c = -1;\n          if (i1 > i2) c = 1;\n          break;\n        }\n        case SortField.SHORT:{\n          int i1 = ((Short)docA.fields[i]).shortValue();\n          int i2 = ((Short)docB.fields[i]).shortValue();\n          if (i1 < i2) c = -1;\n          if (i1 > i2) c = 1;\n          break;\n        }\n        case SortField.CUSTOM:{\n          c = ((Comparable) docA.fields[i]).compareTo((Comparable) docB.fields[i]);\n          break;\n        }\n        default:{\n          throw new RuntimeException (\"invalid SortField type: \"+type);\n        }\n      }\n      if (fields[i].getReverse()) {\n        c = -c;\n      }\n    }\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n  }\n\n","sourceOld":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final FieldDoc docA, final FieldDoc docB) {\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:{\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOC:\n\t\t\t\tcase SortField.INT:{\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.LONG:{\n\t\t\t\t\tlong l1 = ((Long)docA.fields[i]).longValue();\n\t\t\t\t\tlong l2 = ((Long)docB.fields[i]).longValue();\n\t\t\t\t\tif (l1 < l2) c = -1;\n\t\t\t\t\tif (l1 > l2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.STRING:{\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.  If both are null, the next SortField is used\n\t\t\t\t\tif (s1 == null) c = (s2==null) ? 0 : -1;\n\t\t\t\t\telse if (s2 == null) c = 1;  // \n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n        }\n        case SortField.FLOAT:{\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOUBLE:{\n\t\t\t\t\tdouble d1 = ((Double)docA.fields[i]).doubleValue();\n\t\t\t\t\tdouble d2 = ((Double)docB.fields[i]).doubleValue();\n\t\t\t\t\tif (d1 < d2) c = -1;\n\t\t\t\t\tif (d1 > d2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.BYTE:{\n\t\t\t\t\tint i1 = ((Byte)docA.fields[i]).byteValue();\n\t\t\t\t\tint i2 = ((Byte)docB.fields[i]).byteValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.SHORT:{\n\t\t\t\t\tint i1 = ((Short)docA.fields[i]).shortValue();\n\t\t\t\t\tint i2 = ((Short)docB.fields[i]).shortValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.CUSTOM:{\n          // TODO: Use FieldComparator? This does not make sense!\n\t\t\t\t\t@SuppressWarnings(\"unchecked\") final int temp =\n            c = ((Comparable) docA.fields[i]).compareTo((Comparable) docB.fields[i]);\n\t\t\t\t\tbreak;\n        }\n        default:{\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n        }\n      }\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16a20a14080730cc0446f5db68a4e295ba27c7b6","date":1256339389,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(FieldDoc,FieldDoc).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(FieldDoc,FieldDoc).mjava","sourceNew":"  /**\n   * Returns whether <code>a</code> is less relevant than <code>b</code>.\n   * @param a ScoreDoc\n   * @param b ScoreDoc\n   * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected final boolean lessThan (final FieldDoc docA, final FieldDoc docB) {\n    final int n = fields.length;\n    int c = 0;\n    for (int i=0; i<n && c==0; ++i) {\n      final int type = fields[i].getType();\n      if (type == SortField.STRING) {\n        final String s1 = (String) docA.fields[i];\n        final String s2 = (String) docB.fields[i];\n        // null values need to be sorted first, because of how FieldCache.getStringIndex()\n        // works - in that routine, any documents without a value in the given field are\n        // put first.  If both are null, the next SortField is used\n        if (s1 == null) c = (s2==null) ? 0 : -1;\n        else if (s2 == null) c = 1;  // \n        else if (fields[i].getLocale() == null) {\n          c = s1.compareTo(s2);\n        } else {\n          c = collators[i].compare(s1, s2);\n        }\n      } else {\n        // the casts are a no-ops, its only there to make the\n        // compiler happy because of unbounded generics:\n        c = ((Comparable) docA.fields[i]).compareTo((Comparable) docB.fields[i]);\n        if (type == SortField.SCORE) {\n          c = -c;\n        }\n      }\n      // reverse sort\n      if (fields[i].getReverse()) {\n        c = -c;\n      }\n    }\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n  }\n\n","sourceOld":"  /**\n   * Returns whether <code>a</code> is less relevant than <code>b</code>.\n   * @param a ScoreDoc\n   * @param b ScoreDoc\n   * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected final boolean lessThan (final FieldDoc docA, final FieldDoc docB) {\n    final int n = fields.length;\n    int c = 0;\n    for (int i=0; i<n && c==0; ++i) {\n      final int type = fields[i].getType();\n      switch (type) {\n        case SortField.SCORE:{\n          float r1 = ((Float)docA.fields[i]).floatValue();\n          float r2 = ((Float)docB.fields[i]).floatValue();\n          if (r1 > r2) c = -1;\n          if (r1 < r2) c = 1;\n          break;\n        }\n        case SortField.DOC:\n        case SortField.INT:{\n          int i1 = ((Integer)docA.fields[i]).intValue();\n          int i2 = ((Integer)docB.fields[i]).intValue();\n          if (i1 < i2) c = -1;\n          if (i1 > i2) c = 1;\n          break;\n        }\n        case SortField.LONG:{\n          long l1 = ((Long)docA.fields[i]).longValue();\n          long l2 = ((Long)docB.fields[i]).longValue();\n          if (l1 < l2) c = -1;\n          if (l1 > l2) c = 1;\n          break;\n        }\n        case SortField.STRING:{\n          String s1 = (String) docA.fields[i];\n          String s2 = (String) docB.fields[i];\n          // null values need to be sorted first, because of how FieldCache.getStringIndex()\n          // works - in that routine, any documents without a value in the given field are\n          // put first.  If both are null, the next SortField is used\n          if (s1 == null) c = (s2==null) ? 0 : -1;\n          else if (s2 == null) c = 1;  // \n          else if (fields[i].getLocale() == null) {\n            c = s1.compareTo(s2);\n          } else {\n            c = collators[i].compare (s1, s2);\n          }\n          break;\n        }\n        case SortField.FLOAT:{\n          float f1 = ((Float)docA.fields[i]).floatValue();\n          float f2 = ((Float)docB.fields[i]).floatValue();\n          if (f1 < f2) c = -1;\n          if (f1 > f2) c = 1;\n          break;\n        }\n        case SortField.DOUBLE:{\n          double d1 = ((Double)docA.fields[i]).doubleValue();\n          double d2 = ((Double)docB.fields[i]).doubleValue();\n          if (d1 < d2) c = -1;\n          if (d1 > d2) c = 1;\n          break;\n        }\n        case SortField.BYTE:{\n          int i1 = ((Byte)docA.fields[i]).byteValue();\n          int i2 = ((Byte)docB.fields[i]).byteValue();\n          if (i1 < i2) c = -1;\n          if (i1 > i2) c = 1;\n          break;\n        }\n        case SortField.SHORT:{\n          int i1 = ((Short)docA.fields[i]).shortValue();\n          int i2 = ((Short)docB.fields[i]).shortValue();\n          if (i1 < i2) c = -1;\n          if (i1 > i2) c = 1;\n          break;\n        }\n        case SortField.CUSTOM:{\n          c = ((Comparable) docA.fields[i]).compareTo((Comparable) docB.fields[i]);\n          break;\n        }\n        default:{\n          throw new RuntimeException (\"invalid SortField type: \"+type);\n        }\n      }\n      if (fields[i].getReverse()) {\n        c = -c;\n      }\n    }\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38943be0019d2f4059a0ab0f813374b59d07f06c","date":1256371522,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(FieldDoc,FieldDoc).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(FieldDoc,FieldDoc).mjava","sourceNew":"  /**\n   * Returns whether <code>a</code> is less relevant than <code>b</code>.\n   * @param a ScoreDoc\n   * @param b ScoreDoc\n   * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n   */\n  @SuppressWarnings(\"unchecked\") @Override\n  protected final boolean lessThan(final FieldDoc docA, final FieldDoc docB) {\n    final int n = fields.length;\n    int c = 0;\n    for (int i=0; i<n && c==0; ++i) {\n      final int type = fields[i].getType();\n      if (type == SortField.STRING) {\n        final String s1 = (String) docA.fields[i];\n        final String s2 = (String) docB.fields[i];\n        // null values need to be sorted first, because of how FieldCache.getStringIndex()\n        // works - in that routine, any documents without a value in the given field are\n        // put first.  If both are null, the next SortField is used\n        if (s1 == null) {\n          c = (s2 == null) ? 0 : -1;\n        } else if (s2 == null) {\n          c = 1;\n        } else if (fields[i].getLocale() == null) {\n          c = s1.compareTo(s2);\n        } else {\n          c = collators[i].compare(s1, s2);\n        }\n      } else {\n        c = docA.fields[i].compareTo(docB.fields[i]);\n        if (type == SortField.SCORE) {\n          c = -c;\n        }\n      }\n      // reverse sort\n      if (fields[i].getReverse()) {\n        c = -c;\n      }\n    }\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n  }\n\n","sourceOld":"  /**\n   * Returns whether <code>a</code> is less relevant than <code>b</code>.\n   * @param a ScoreDoc\n   * @param b ScoreDoc\n   * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected final boolean lessThan (final FieldDoc docA, final FieldDoc docB) {\n    final int n = fields.length;\n    int c = 0;\n    for (int i=0; i<n && c==0; ++i) {\n      final int type = fields[i].getType();\n      if (type == SortField.STRING) {\n        final String s1 = (String) docA.fields[i];\n        final String s2 = (String) docB.fields[i];\n        // null values need to be sorted first, because of how FieldCache.getStringIndex()\n        // works - in that routine, any documents without a value in the given field are\n        // put first.  If both are null, the next SortField is used\n        if (s1 == null) c = (s2==null) ? 0 : -1;\n        else if (s2 == null) c = 1;  // \n        else if (fields[i].getLocale() == null) {\n          c = s1.compareTo(s2);\n        } else {\n          c = collators[i].compare(s1, s2);\n        }\n      } else {\n        // the casts are a no-ops, its only there to make the\n        // compiler happy because of unbounded generics:\n        c = ((Comparable) docA.fields[i]).compareTo((Comparable) docB.fields[i]);\n        if (type == SortField.SCORE) {\n          c = -c;\n        }\n      }\n      // reverse sort\n      if (fields[i].getReverse()) {\n        c = -c;\n      }\n    }\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(FieldDoc,FieldDoc).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(FieldDoc,FieldDoc).mjava","sourceNew":"  /**\n   * Returns whether <code>a</code> is less relevant than <code>b</code>.\n   * @param a ScoreDoc\n   * @param b ScoreDoc\n   * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n   */\n  @SuppressWarnings(\"unchecked\") @Override\n  protected final boolean lessThan(final FieldDoc docA, final FieldDoc docB) {\n    final int n = fields.length;\n    int c = 0;\n    for (int i=0; i<n && c==0; ++i) {\n      final int type = fields[i].getType();\n      if (type == SortField.STRING) {\n        final String s1 = (String) docA.fields[i];\n        final String s2 = (String) docB.fields[i];\n        // null values need to be sorted first, because of how FieldCache.getStringIndex()\n        // works - in that routine, any documents without a value in the given field are\n        // put first.  If both are null, the next SortField is used\n        if (s1 == null) {\n          c = (s2 == null) ? 0 : -1;\n        } else if (s2 == null) {\n          c = 1;\n        } else if (fields[i].getLocale() == null) {\n          c = s1.compareTo(s2);\n        } else {\n          c = collators[i].compare(s1, s2);\n        }\n      } else {\n        c = docA.fields[i].compareTo(docB.fields[i]);\n        if (type == SortField.SCORE) {\n          c = -c;\n        }\n      }\n      // reverse sort\n      if (fields[i].getReverse()) {\n        c = -c;\n      }\n    }\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n  }\n\n","sourceOld":"  /**\n   * Returns whether <code>a</code> is less relevant than <code>b</code>.\n   * @param a ScoreDoc\n   * @param b ScoreDoc\n   * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n   */\n  @SuppressWarnings(\"unchecked\") @Override\n  protected final boolean lessThan(final FieldDoc docA, final FieldDoc docB) {\n    final int n = fields.length;\n    int c = 0;\n    for (int i=0; i<n && c==0; ++i) {\n      final int type = fields[i].getType();\n      if (type == SortField.STRING) {\n        final String s1 = (String) docA.fields[i];\n        final String s2 = (String) docB.fields[i];\n        // null values need to be sorted first, because of how FieldCache.getStringIndex()\n        // works - in that routine, any documents without a value in the given field are\n        // put first.  If both are null, the next SortField is used\n        if (s1 == null) {\n          c = (s2 == null) ? 0 : -1;\n        } else if (s2 == null) {\n          c = 1;\n        } else if (fields[i].getLocale() == null) {\n          c = s1.compareTo(s2);\n        } else {\n          c = collators[i].compare(s1, s2);\n        }\n      } else {\n        c = docA.fields[i].compareTo(docB.fields[i]);\n        if (type == SortField.SCORE) {\n          c = -c;\n        }\n      }\n      // reverse sort\n      if (fields[i].getReverse()) {\n        c = -c;\n      }\n    }\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38943be0019d2f4059a0ab0f813374b59d07f06c":["16a20a14080730cc0446f5db68a4e295ba27c7b6"],"16a20a14080730cc0446f5db68a4e295ba27c7b6":["107375340c8594fcc5f132e2dda05faef686bfda"],"107375340c8594fcc5f132e2dda05faef686bfda":["f63c5771d883c45d43e7d5ac11344582906f7d17"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0731e137bcbb58121034de6ddaa67332fbe6e5d1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ded38b25fe842ef1efc6715745bb8d8ed8e2fc99":["0731e137bcbb58121034de6ddaa67332fbe6e5d1"],"f63c5771d883c45d43e7d5ac11344582906f7d17":["ded38b25fe842ef1efc6715745bb8d8ed8e2fc99"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["38943be0019d2f4059a0ab0f813374b59d07f06c"]},"commit2Childs":{"38943be0019d2f4059a0ab0f813374b59d07f06c":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"16a20a14080730cc0446f5db68a4e295ba27c7b6":["38943be0019d2f4059a0ab0f813374b59d07f06c"],"107375340c8594fcc5f132e2dda05faef686bfda":["16a20a14080730cc0446f5db68a4e295ba27c7b6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0731e137bcbb58121034de6ddaa67332fbe6e5d1"],"0731e137bcbb58121034de6ddaa67332fbe6e5d1":["ded38b25fe842ef1efc6715745bb8d8ed8e2fc99"],"ded38b25fe842ef1efc6715745bb8d8ed8e2fc99":["f63c5771d883c45d43e7d5ac11344582906f7d17"],"f63c5771d883c45d43e7d5ac11344582906f7d17":["107375340c8594fcc5f132e2dda05faef686bfda"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}