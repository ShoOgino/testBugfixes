{"path":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","sourceNew":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          queryToSpanQuery(queryClauses[i].getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\") final List<Query>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<Query>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n            inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","sourceOld":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          queryToSpanQuery(queryClauses[i].getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\") final List<Query>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<Query>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n            inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f08557cdb6c60ac7b88a9342c983a20cd236e74f","date":1330954480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","sourceNew":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          queryToSpanQuery(queryClauses[i].getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final List<Query>[] disjunctLists =\n            new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<Query>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n            inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","sourceOld":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          queryToSpanQuery(queryClauses[i].getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\") final List<Query>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<Query>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n            inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","sourceNew":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          queryToSpanQuery(queryClauses[i].getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final List<Query>[] disjunctLists =\n            new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<Query>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n            inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","sourceOld":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          queryToSpanQuery(queryClauses[i].getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\") final List<Query>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<Query>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n            inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","sourceNew":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          queryToSpanQuery(queryClauses[i].getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final List<Query>[] disjunctLists =\n            new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n            inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","sourceOld":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          queryToSpanQuery(queryClauses[i].getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final List<Query>[] disjunctLists =\n            new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<Query>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n            inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30de45e50bdc1a79a6797f34dca6271c8866cb6e","date":1427790465,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","sourceNew":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          queryToSpanQuery(queryClauses[i].getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final List<Query>[] disjunctLists =\n            new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n                                                      inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","sourceOld":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          queryToSpanQuery(queryClauses[i].getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final List<Query>[] disjunctLists =\n            new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n            inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fab172655716b96f7e42376116235017a922de3a","date":1427850611,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","sourceNew":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          queryToSpanQuery(queryClauses[i].getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final List<Query>[] disjunctLists =\n            new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n                                                      inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","sourceOld":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          queryToSpanQuery(queryClauses[i].getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final List<Query>[] disjunctLists =\n            new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n            inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","sourceNew":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          queryToSpanQuery(clause.getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final List<Query>[] disjunctLists =\n            new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n                                                      inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","sourceOld":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          queryToSpanQuery(queryClauses[i].getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final List<Query>[] disjunctLists =\n            new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n                                                      inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1db68e96dd908fcd79ef809095822736aa601d08","date":1434630596,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","sourceNew":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          queryToSpanQuery(clause.getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final List<Query>[] disjunctLists =\n            new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n                                                      inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","sourceOld":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          queryToSpanQuery(clause.getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final List<Query>[] disjunctLists =\n            new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n                                                      inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dfdf766e55e943d942055d7de53c7ad6bc45283","date":1441632886,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","sourceNew":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          queryToSpanQuery(clause.getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final List<Query>[] disjunctLists =\n            new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n                                                      inorder);\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","sourceOld":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          queryToSpanQuery(clause.getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      stq.setBoost(query.getBoost());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final List<Query>[] disjunctLists =\n            new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n                                                      inorder);\n        sp.setBoost(query.getBoost());\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eeab49258a6aca6c7e96aaf189f1794fe6ddebe4","date":1442407411,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil#queryToSpanQuery(Query,Collection[byte[]]).mjava","sourceNew":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          queryToSpanQuery(clause.getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final List<Query>[] disjunctLists =\n            new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n                                                      inorder);\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","sourceOld":"  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)\n      throws IOException {\n    if (query instanceof BooleanQuery) {\n      for (BooleanClause clause : (BooleanQuery) query) {\n        if (!clause.isProhibited()) {\n          queryToSpanQuery(clause.getQuery(), payloads);\n        }\n      }\n\n    } else if (query instanceof PhraseQuery) {\n      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n\n      int slop = ((PhraseQuery) query).getSlop();\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      getPayloads(payloads, sp);\n    } else if (query instanceof TermQuery) {\n      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());\n      getPayloads(payloads, stq);\n    } else if (query instanceof SpanQuery) {\n      getPayloads(payloads, (SpanQuery) query);\n    } else if (query instanceof DisjunctionMaxQuery) {\n\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator\n          .hasNext();) {\n        queryToSpanQuery(iterator.next(), payloads);\n      }\n\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final List<Query>[] disjunctLists =\n            new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<Query> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(\n                termArray.length));\n            ++distinctPositions;\n          }\n          for (final Term term : termArray) {\n            disjuncts.add(new SpanTermQuery(term));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<Query> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,\n                                                      inorder);\n        getPayloads(payloads, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"eeab49258a6aca6c7e96aaf189f1794fe6ddebe4":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["30de45e50bdc1a79a6797f34dca6271c8866cb6e"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"1db68e96dd908fcd79ef809095822736aa601d08":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["1db68e96dd908fcd79ef809095822736aa601d08"],"30de45e50bdc1a79a6797f34dca6271c8866cb6e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"fab172655716b96f7e42376116235017a922de3a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","30de45e50bdc1a79a6797f34dca6271c8866cb6e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["eeab49258a6aca6c7e96aaf189f1794fe6ddebe4"]},"commit2Childs":{"eeab49258a6aca6c7e96aaf189f1794fe6ddebe4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["1db68e96dd908fcd79ef809095822736aa601d08"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["30de45e50bdc1a79a6797f34dca6271c8866cb6e","fab172655716b96f7e42376116235017a922de3a"],"1db68e96dd908fcd79ef809095822736aa601d08":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["eeab49258a6aca6c7e96aaf189f1794fe6ddebe4"],"30de45e50bdc1a79a6797f34dca6271c8866cb6e":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747","fab172655716b96f7e42376116235017a922de3a"],"fab172655716b96f7e42376116235017a922de3a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","fab172655716b96f7e42376116235017a922de3a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}