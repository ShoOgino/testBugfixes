{"path":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // we cannot do delete by query\n    // as it's not supported for recovery\n    //del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    \n    Thread.sleep(atLeast(8000));\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut();\n\n    checkShardConsistency(true, false);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["933fa8f09adfcd1a858cd0fc7912e21ee993b7fc","072f211dfa8387028bb978d128c35bf9a450bbbf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // we cannot do delete by query\n    // as it's not supported for recovery\n    //del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    \n    Thread.sleep(atLeast(8000));\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut();\n\n    checkShardConsistency(true, false);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // we cannot do delete by query\n    // as it's not supported for recovery\n    //del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    \n    Thread.sleep(atLeast(8000));\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut();\n\n    checkShardConsistency(true, false);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b834dd353486678973f4157b3ba402ac3a7ca88","date":1329782329,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // we cannot do delete by query\n    // as it's not supported for recovery\n    //del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    \n    Thread.sleep(atLeast(8000));\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut();\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // we cannot do delete by query\n    // as it's not supported for recovery\n    //del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    \n    Thread.sleep(atLeast(8000));\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut();\n\n    checkShardConsistency(true, false);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // we cannot do delete by query\n    // as it's not supported for recovery\n    //del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    \n    Thread.sleep(atLeast(8000));\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut();\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // we cannot do delete by query\n    // as it's not supported for recovery\n    //del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    \n    Thread.sleep(atLeast(8000));\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut();\n\n    checkShardConsistency(true, false);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"933fa8f09adfcd1a858cd0fc7912e21ee993b7fc","date":1342989037,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // we cannot do delete by query\n    // as it's not supported for recovery\n    //del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Math.round((runLength / 1000.0f / 5.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // we cannot do delete by query\n    // as it's not supported for recovery\n    //del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    \n    Thread.sleep(atLeast(8000));\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut();\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // we cannot do delete by query\n    // as it's not supported for recovery\n    //del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Math.round((runLength / 1000.0f / 5.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // we cannot do delete by query\n    // as it's not supported for recovery\n    //del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    \n    Thread.sleep(atLeast(8000));\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut();\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // we cannot do delete by query\n    // as it's not supported for recovery\n    //del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Math.round((runLength / 1000.0f / 5.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // we cannot do delete by query\n    // as it's not supported for recovery\n    //del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    \n    Thread.sleep(atLeast(8000));\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut();\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1381b91b03f7409d8d548c7070dbc615931a0f50","date":1343667369,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Math.round((runLength / 1000.0f / 5.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // we cannot do delete by query\n    // as it's not supported for recovery\n    //del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Math.round((runLength / 1000.0f / 5.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":["fe41113ed50afe558d65ec56a090479743329617"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Math.round((runLength / 1000.0f / 5.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // we cannot do delete by query\n    // as it's not supported for recovery\n    //del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Math.round((runLength / 1000.0f / 5.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Math.round((runLength / 1000.0f / 5.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // we cannot do delete by query\n    // as it's not supported for recovery\n    //del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Math.round((runLength / 1000.0f / 5.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66c64e8cfded6a585100e6430238faaf416f3fea","date":1344964603,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Integer.MAX_VALUE);//Math.round((runLength / 1000.0f / 3.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Math.round((runLength / 1000.0f / 5.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Integer.MAX_VALUE);//Math.round((runLength / 1000.0f / 3.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Math.round((runLength / 1000.0f / 5.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Integer.MAX_VALUE);//Math.round((runLength / 1000.0f / 3.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Math.round((runLength / 1000.0f / 5.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2bceb2cdf01c012aaa9fd1132529159bd7c2fe82","date":1355878858,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(Integer.MAX_VALUE); //Math.round((runLength / 1000.0f / 3.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Integer.MAX_VALUE);//Math.round((runLength / 1000.0f / 3.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1bb9b654f11f794438e7f533a962a493cd4a0a07","date":1356496752,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = RUN_LENGTH;\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(Integer.MAX_VALUE); //Math.round((runLength / 1000.0f / 3.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"312f6f514ce2001f708333937584ff5247d85627","date":1357090436,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = RUN_LENGTH;\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = RUN_LENGTH;\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":["67e5fb3e1a3e5763eb7aabb2ee71d10e8617e699"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = RUN_LENGTH;\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(i * 50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = atLeast(BASE_RUN_LENGTH);\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n    \n    waitForThingsToLevelOut(Integer.MAX_VALUE);//Math.round((runLength / 1000.0f / 3.0f)));\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"709ec1e7204705625cbd074102a6ced459df9c99","date":1361046093,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,15000,15000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = RUN_LENGTH;\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c4c76058cf64f5f3447673694ddec6e6c1eb675","date":1361060577,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,15000,15000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,15000,15000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"95303ff3749680c743b9425f9cf99e6e4065e8a8","date":1361061922,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,15000,15000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    int runLength = RUN_LENGTH;\n    Thread.sleep(runLength);\n    \n    chaosMonkey.stopTheMonkey();\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"270612d8e1a51cded91704d7af12f8979de0f584","date":1381502089,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,15000,15000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,15000,15000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe41113ed50afe558d65ec56a090479743329617","date":1382567867,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,15000,15000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 5 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,15000,15000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":["1381b91b03f7409d8d548c7070dbc615931a0f50"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"767a42b1ba7578b44587b42170ad81003c6b479a","date":1385341911,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,25000,27000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,15000,15000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68fe0b7fa3b6a69495244529754954d2ae5cf0f7","date":1385414051,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,25000,27000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,25000,27000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7ecc0a3ce34111c2ebb18dc006e7f2f72d4162ca","date":1385777952,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,25000,27000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,25000,27000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"67e5fb3e1a3e5763eb7aabb2ee71d10e8617e699","date":1385913128,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,25000,27000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,25000,27000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":["312f6f514ce2001f708333937584ff5247d85627"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,25000,27000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(10000 + i*50000, true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,15000,15000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1fdd9a08f8add7f8120c504fc73a542881f14db","date":1387820064,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes = new int[] {5000, 6000, 10000, 25000, 27000, 30000,\n            30000, 45000, 90000, 120000};\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    long runLength;\n    if (RUN_LENGTH != -1) {\n      runLength = RUN_LENGTH;\n    } else {\n      int[] runTimes = new int[] {5000,6000,10000,25000,27000,30000,30000,45000,90000,120000};\n      runLength = runTimes[random().nextInt(runTimes.length - 1)];\n    }\n    try {\n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02c6a0e240c698414e7728a55f07361be84852d8","date":1392675457,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes = new int[] {5000, 6000, 10000, 25000, 27000, 30000,\n            30000, 45000, 90000, 120000};\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes = new int[] {5000, 6000, 10000, 25000, 27000, 30000,\n            30000, 45000, 90000, 120000};\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFails());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19389fe47925b510b2811e2b385a75f7ad19dcca","date":1393903127,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes = new int[] {5000, 6000, 10000, 25000, 27000, 30000,\n            30000, 45000, 90000, 120000};\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes = new int[] {5000, 6000, 10000, 25000, 27000, 30000,\n            30000, 45000, 90000, 120000};\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96ea64d994d340044e0d57aeb6a5871539d10ca5","date":1394225445,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes = new int[] {5000, 6000, 10000, 25000, 27000, 30000,\n            30000, 45000, 90000, 120000};\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes = new int[] {5000, 6000, 10000, 25000, 27000, 30000,\n            30000, 45000, 90000, 120000};\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes = new int[] {5000, 6000, 10000, 25000, 27000, 30000,\n            30000, 45000, 90000, 120000};\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<StopableIndexingThread>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes = new int[] {5000, 6000, 10000, 25000, 27000, 30000,\n            30000, 45000, 90000, 120000};\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<Integer>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"072f211dfa8387028bb978d128c35bf9a450bbbf","date":1406041363,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes = new int[] {5000, 6000, 10000, 25000, 27000, 30000,\n            30000, 45000, 90000, 120000};\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes = new int[] {5000, 6000, 10000, 25000, 27000, 30000,\n            30000, 45000, 90000, 120000};\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e8032245649fcad02fe90589374954021aacbb49","date":1408900458,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes = new int[] {5000, 6000, 10000, 25000, 27000, 30000,\n            30000, 45000, 90000, 120000};\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ddd074ed031e80760433263489051e831fd1e964","date":1408916314,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    del(\"*:*\");\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrClient client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrServer client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abb23fcc2461782ab204e61213240feb77d355aa","date":1422029612,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkeySafeLeaderTest#doTest().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrClient client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    // randomly turn on 1 seconds 'soft' commit\n    randomlyEnableAutoSoftCommit();\n\n    tryDelete();\n    \n    List<StopableIndexingThread> threads = new ArrayList<>();\n    int threadCount = 2;\n    for (int i = 0; i < threadCount; i++) {\n      StopableIndexingThread indexThread = new StopableIndexingThread(controlClient, cloudClient, Integer.toString(i), true);\n      threads.add(indexThread);\n      indexThread.start();\n    }\n    \n    chaosMonkey.startTheMonkey(false, 500);\n    try {\n      long runLength;\n      if (RUN_LENGTH != -1) {\n        runLength = RUN_LENGTH;\n      } else {\n        int[] runTimes;\n        if (TEST_NIGHTLY) {\n          runTimes = new int[] {5000, 6000, 10000, 15000, 25000, 30000,\n              30000, 45000, 90000, 120000};\n        } else {\n          runTimes = new int[] {5000, 7000, 15000};\n        }\n        runLength = runTimes[random().nextInt(runTimes.length - 1)];\n      }\n      \n      Thread.sleep(runLength);\n    } finally {\n      chaosMonkey.stopTheMonkey();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.safeStop();\n    }\n    \n    // wait for stop...\n    for (StopableIndexingThread indexThread : threads) {\n      indexThread.join();\n    }\n    \n    for (StopableIndexingThread indexThread : threads) {\n      assertEquals(0, indexThread.getFailCount());\n    }\n    \n    // try and wait for any replications and what not to finish...\n\n    Thread.sleep(2000);\n\n    waitForThingsToLevelOut(180000);\n\n    checkShardConsistency(true, true);\n    \n    if (VERBOSE) System.out.println(\"control docs:\" + controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() + \"\\n\\n\");\n    \n    // try and make a collection to make sure the overseer has survived the expiration and session loss\n\n    // sometimes we restart zookeeper as well\n    if (random().nextBoolean()) {\n      zkServer.shutdown();\n      zkServer = new ZkTestServer(zkServer.getZkDir(), zkServer.getPort());\n      zkServer.run();\n    }\n    \n    CloudSolrClient client = createCloudClient(\"collection1\");\n    try {\n        createCollection(null, \"testcollection\",\n            1, 1, 1, client, null, \"conf1\");\n\n    } finally {\n      client.shutdown();\n    }\n    List<Integer> numShardsNumReplicas = new ArrayList<>(2);\n    numShardsNumReplicas.add(1);\n    numShardsNumReplicas.add(1);\n    checkForCollection(\"testcollection\",numShardsNumReplicas, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"270612d8e1a51cded91704d7af12f8979de0f584":["2c4c76058cf64f5f3447673694ddec6e6c1eb675"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["66c64e8cfded6a585100e6430238faaf416f3fea","312f6f514ce2001f708333937584ff5247d85627"],"072f211dfa8387028bb978d128c35bf9a450bbbf":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":["02c6a0e240c698414e7728a55f07361be84852d8","19389fe47925b510b2811e2b385a75f7ad19dcca"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","6b834dd353486678973f4157b3ba402ac3a7ca88"],"abb23fcc2461782ab204e61213240feb77d355aa":["bafca15d8e408346a67f4282ad1143b88023893b"],"6b834dd353486678973f4157b3ba402ac3a7ca88":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","66c64e8cfded6a585100e6430238faaf416f3fea"],"a1fdd9a08f8add7f8120c504fc73a542881f14db":["67e5fb3e1a3e5763eb7aabb2ee71d10e8617e699"],"ddd074ed031e80760433263489051e831fd1e964":["e8032245649fcad02fe90589374954021aacbb49"],"bafca15d8e408346a67f4282ad1143b88023893b":["ddd074ed031e80760433263489051e831fd1e964"],"02c6a0e240c698414e7728a55f07361be84852d8":["a1fdd9a08f8add7f8120c504fc73a542881f14db"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["d6f074e73200c07d54f242d3880a8da5a35ff97b","66c64e8cfded6a585100e6430238faaf416f3fea"],"67e5fb3e1a3e5763eb7aabb2ee71d10e8617e699":["7ecc0a3ce34111c2ebb18dc006e7f2f72d4162ca"],"19389fe47925b510b2811e2b385a75f7ad19dcca":["02c6a0e240c698414e7728a55f07361be84852d8"],"933fa8f09adfcd1a858cd0fc7912e21ee993b7fc":["6b834dd353486678973f4157b3ba402ac3a7ca88"],"7ecc0a3ce34111c2ebb18dc006e7f2f72d4162ca":["68fe0b7fa3b6a69495244529754954d2ae5cf0f7"],"312f6f514ce2001f708333937584ff5247d85627":["1bb9b654f11f794438e7f533a962a493cd4a0a07"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"aba371508186796cc6151d8223a5b4e16d02e26e":["6b834dd353486678973f4157b3ba402ac3a7ca88","933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":["312f6f514ce2001f708333937584ff5247d85627","2c4c76058cf64f5f3447673694ddec6e6c1eb675"],"2bceb2cdf01c012aaa9fd1132529159bd7c2fe82":["66c64e8cfded6a585100e6430238faaf416f3fea"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"767a42b1ba7578b44587b42170ad81003c6b479a":["fe41113ed50afe558d65ec56a090479743329617"],"e8032245649fcad02fe90589374954021aacbb49":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["6b834dd353486678973f4157b3ba402ac3a7ca88","933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"709ec1e7204705625cbd074102a6ced459df9c99":["312f6f514ce2001f708333937584ff5247d85627"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["19389fe47925b510b2811e2b385a75f7ad19dcca"],"66c64e8cfded6a585100e6430238faaf416f3fea":["1381b91b03f7409d8d548c7070dbc615931a0f50"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"1381b91b03f7409d8d548c7070dbc615931a0f50":["933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"fe41113ed50afe558d65ec56a090479743329617":["270612d8e1a51cded91704d7af12f8979de0f584"],"1bb9b654f11f794438e7f533a962a493cd4a0a07":["2bceb2cdf01c012aaa9fd1132529159bd7c2fe82"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","1381b91b03f7409d8d548c7070dbc615931a0f50"],"2c4c76058cf64f5f3447673694ddec6e6c1eb675":["709ec1e7204705625cbd074102a6ced459df9c99"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","1381b91b03f7409d8d548c7070dbc615931a0f50"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["fe41113ed50afe558d65ec56a090479743329617","67e5fb3e1a3e5763eb7aabb2ee71d10e8617e699"],"68fe0b7fa3b6a69495244529754954d2ae5cf0f7":["767a42b1ba7578b44587b42170ad81003c6b479a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["abb23fcc2461782ab204e61213240feb77d355aa"]},"commit2Childs":{"270612d8e1a51cded91704d7af12f8979de0f584":["fe41113ed50afe558d65ec56a090479743329617"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"072f211dfa8387028bb978d128c35bf9a450bbbf":["e8032245649fcad02fe90589374954021aacbb49"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"6b834dd353486678973f4157b3ba402ac3a7ca88":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","933fa8f09adfcd1a858cd0fc7912e21ee993b7fc","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"abb23fcc2461782ab204e61213240feb77d355aa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"a1fdd9a08f8add7f8120c504fc73a542881f14db":["02c6a0e240c698414e7728a55f07361be84852d8"],"ddd074ed031e80760433263489051e831fd1e964":["bafca15d8e408346a67f4282ad1143b88023893b"],"bafca15d8e408346a67f4282ad1143b88023893b":["abb23fcc2461782ab204e61213240feb77d355aa"],"02c6a0e240c698414e7728a55f07361be84852d8":["96ea64d994d340044e0d57aeb6a5871539d10ca5","19389fe47925b510b2811e2b385a75f7ad19dcca"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"67e5fb3e1a3e5763eb7aabb2ee71d10e8617e699":["a1fdd9a08f8add7f8120c504fc73a542881f14db","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"19389fe47925b510b2811e2b385a75f7ad19dcca":["96ea64d994d340044e0d57aeb6a5871539d10ca5","634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"933fa8f09adfcd1a858cd0fc7912e21ee993b7fc":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","1381b91b03f7409d8d548c7070dbc615931a0f50"],"312f6f514ce2001f708333937584ff5247d85627":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","95303ff3749680c743b9425f9cf99e6e4065e8a8","709ec1e7204705625cbd074102a6ced459df9c99"],"7ecc0a3ce34111c2ebb18dc006e7f2f72d4162ca":["67e5fb3e1a3e5763eb7aabb2ee71d10e8617e699"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":[],"2bceb2cdf01c012aaa9fd1132529159bd7c2fe82":["1bb9b654f11f794438e7f533a962a493cd4a0a07"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"767a42b1ba7578b44587b42170ad81003c6b479a":["68fe0b7fa3b6a69495244529754954d2ae5cf0f7"],"e8032245649fcad02fe90589374954021aacbb49":["ddd074ed031e80760433263489051e831fd1e964"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"709ec1e7204705625cbd074102a6ced459df9c99":["2c4c76058cf64f5f3447673694ddec6e6c1eb675"],"66c64e8cfded6a585100e6430238faaf416f3fea":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","2bceb2cdf01c012aaa9fd1132529159bd7c2fe82"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"1381b91b03f7409d8d548c7070dbc615931a0f50":["66c64e8cfded6a585100e6430238faaf416f3fea","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"fe41113ed50afe558d65ec56a090479743329617":["767a42b1ba7578b44587b42170ad81003c6b479a","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"1bb9b654f11f794438e7f533a962a493cd4a0a07":["312f6f514ce2001f708333937584ff5247d85627"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"2c4c76058cf64f5f3447673694ddec6e6c1eb675":["270612d8e1a51cded91704d7af12f8979de0f584","95303ff3749680c743b9425f9cf99e6e4065e8a8"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","6b834dd353486678973f4157b3ba402ac3a7ca88","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"68fe0b7fa3b6a69495244529754954d2ae5cf0f7":["7ecc0a3ce34111c2ebb18dc006e7f2f72d4162ca"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","96ea64d994d340044e0d57aeb6a5871539d10ca5","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","0d22ac6a4146774c1bc8400160fc0b6150294e92","95303ff3749680c743b9425f9cf99e6e4065e8a8","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}