{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doContinue().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doContinue().mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doContinue().mjava","sourceNew":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copyBytes(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","sourceOld":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copyBytes(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57ae3024996ccdb3c36c42cb890e1efb37df4ce8","date":1338343651,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doContinue().mjava","sourceNew":null,"sourceOld":"    // Seek type 2 \"continue\" (back to the start of the\n    // surrogates): scan the stripped suffix from the\n    // prior term, backwards. If there was an E in that\n    // part, then we try to seek back to S.  If that\n    // seek finds a matching term, we go there.\n    private boolean doContinue() throws IOException {\n\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try cont\");\n      }\n\n      int downTo = prevTerm.length-1;\n\n      boolean didSeek = false;\n      \n      final int limit = Math.min(newSuffixStart, scratchTerm.length-1);\n\n      while(downTo > limit) {\n\n        if (isHighBMPChar(prevTerm.bytes, downTo)) {\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    found E pos=\" + downTo + \" vs len=\" + prevTerm.length);\n          }\n\n          if (seekToNonBMP(seekTermEnum, prevTerm, downTo)) {\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n            //newSuffixStart = downTo+4;\n            newSuffixStart = downTo;\n            scratchTerm.copyBytes(termEnum.term().bytes());\n            didSeek = true;\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      seek!\");\n            }\n            break;\n          } else {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      no seek\");\n            }\n          }\n        }\n\n        // Shorten prevTerm in place so that we don't redo\n        // this loop if we come back here:\n        if ((prevTerm.bytes[downTo] & 0xc0) == 0xc0 || (prevTerm.bytes[downTo] & 0x80) == 0) {\n          prevTerm.length = downTo;\n        }\n        \n        downTo--;\n      }\n\n      return didSeek;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"]},"commit2Childs":{"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}