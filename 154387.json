{"path":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testMetadata().mjava","commits":[{"id":"215e40821821b2df2e69355e208532c05ef095a5","date":1510858642,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testMetadata().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testMetadata() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    UnaryOperator<Aliases> op6 = a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\");\n    final ZkStateReader.AliasesManager aliasesHolder = zkStateReader.aliasesHolder;\n\n    aliasesHolder.applyModificationAndExportToZk(op6);\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set metadata\n    UnaryOperator<Aliases> op5 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", \"bar\");\n    aliasesHolder.applyModificationAndExportToZk(op5);\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more metadata\n    UnaryOperator<Aliases> op4 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foobar\", \"bazbam\");\n    aliasesHolder.applyModificationAndExportToZk(op4);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove metadata\n    UnaryOperator<Aliases> op3 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesHolder.applyModificationAndExportToZk(op3);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    UnaryOperator<Aliases> op2 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesHolder.applyModificationAndExportToZk(op2);\n\n    // chained invocations\n    UnaryOperator<Aliases> op1 = a ->\n        a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasMetadata(\"meta1\", \"foo3\", \"bazbam2\");\n    aliasesHolder.applyModificationAndExportToZk(op1);\n\n    // some other independent update (not overwritten)\n    UnaryOperator<Aliases> op = a -> a.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\");\n    aliasesHolder.applyModificationAndExportToZk(op);\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    String zkAddress = cluster.getZkServer().getZkAddress();\n    boolean createdZKSR = false;\n    try(SolrZkClient zkClient = new SolrZkClient(zkAddress, 30000)) {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      createdZKSR = true;\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n      assertNotNull(meta);\n\n      // verify key was removed in independent view\n      assertFalse(meta.containsKey(\"foo\"));\n\n      // but only the specified key was removed\n      assertTrue(meta.containsKey(\"foobar\"));\n      assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n      Aliases a = zkStateReader.getAliases();\n      Aliases clone = a.cloneWithCollectionAlias(\"meta1\", null);\n      meta = clone.getCollectionAliasMetadata(\"meta1\");\n      assertEquals(0,meta.size());\n    } finally {\n      if (createdZKSR) {\n        zkStateReader.close();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a980795a56f2fcbc94caeb3233071312d5684d59","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b10ab715806383f3d7f9eece13c26772a9116022","date":1517176579,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testMetadata().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testMetadata().mjava","sourceNew":"  @Test\n  public void testMetadata() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    UnaryOperator<Aliases> op6 = a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\");\n    final ZkStateReader.AliasesManager aliasesHolder = zkStateReader.aliasesHolder;\n\n    aliasesHolder.applyModificationAndExportToZk(op6);\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set metadata\n    UnaryOperator<Aliases> op5 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", \"bar\");\n    aliasesHolder.applyModificationAndExportToZk(op5);\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more metadata\n    UnaryOperator<Aliases> op4 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foobar\", \"bazbam\");\n    aliasesHolder.applyModificationAndExportToZk(op4);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove metadata\n    UnaryOperator<Aliases> op3 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesHolder.applyModificationAndExportToZk(op3);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    UnaryOperator<Aliases> op2 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesHolder.applyModificationAndExportToZk(op2);\n\n    // chained invocations\n    UnaryOperator<Aliases> op1 = a ->\n        a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasMetadata(\"meta1\", \"foo3\", \"bazbam2\");\n    aliasesHolder.applyModificationAndExportToZk(op1);\n\n    // some other independent update (not overwritten)\n    UnaryOperator<Aliases> op = a -> a.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\");\n    aliasesHolder.applyModificationAndExportToZk(op);\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    String zkAddress = cluster.getZkServer().getZkAddress();\n    boolean createdZKSR = false;\n    try(SolrZkClient zkClient = new SolrZkClient(zkAddress, 30000)) {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      createdZKSR = true;\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n      assertNotNull(meta);\n\n      // verify key was removed in independent view\n      assertFalse(meta.containsKey(\"foo\"));\n\n      // but only the specified key was removed\n      assertTrue(meta.containsKey(\"foobar\"));\n      assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n      Aliases a = zkStateReader.getAliases();\n      Aliases clone = a.cloneWithCollectionAlias(\"meta1\", null);\n      meta = clone.getCollectionAliasMetadata(\"meta1\");\n      assertEquals(0,meta.size());\n    } finally {\n      if (createdZKSR) {\n        zkStateReader.close();\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testMetadata() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    UnaryOperator<Aliases> op6 = a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\");\n    final ZkStateReader.AliasesManager aliasesHolder = zkStateReader.aliasesHolder;\n\n    aliasesHolder.applyModificationAndExportToZk(op6);\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set metadata\n    UnaryOperator<Aliases> op5 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", \"bar\");\n    aliasesHolder.applyModificationAndExportToZk(op5);\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more metadata\n    UnaryOperator<Aliases> op4 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foobar\", \"bazbam\");\n    aliasesHolder.applyModificationAndExportToZk(op4);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove metadata\n    UnaryOperator<Aliases> op3 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesHolder.applyModificationAndExportToZk(op3);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    UnaryOperator<Aliases> op2 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesHolder.applyModificationAndExportToZk(op2);\n\n    // chained invocations\n    UnaryOperator<Aliases> op1 = a ->\n        a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasMetadata(\"meta1\", \"foo3\", \"bazbam2\");\n    aliasesHolder.applyModificationAndExportToZk(op1);\n\n    // some other independent update (not overwritten)\n    UnaryOperator<Aliases> op = a -> a.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\");\n    aliasesHolder.applyModificationAndExportToZk(op);\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    String zkAddress = cluster.getZkServer().getZkAddress();\n    boolean createdZKSR = false;\n    try(SolrZkClient zkClient = new SolrZkClient(zkAddress, 30000)) {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      createdZKSR = true;\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n      assertNotNull(meta);\n\n      // verify key was removed in independent view\n      assertFalse(meta.containsKey(\"foo\"));\n\n      // but only the specified key was removed\n      assertTrue(meta.containsKey(\"foobar\"));\n      assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n      Aliases a = zkStateReader.getAliases();\n      Aliases clone = a.cloneWithCollectionAlias(\"meta1\", null);\n      meta = clone.getCollectionAliasMetadata(\"meta1\");\n      assertEquals(0,meta.size());\n    } finally {\n      if (createdZKSR) {\n        zkStateReader.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cbd743a4843f513f793670e3ab0e272bf824faf","date":1518149529,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testMetadata().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testMetadata().mjava","sourceNew":"  @Test\n  public void testMetadata() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    UnaryOperator<Aliases> op6 = a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\");\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(op6);\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set metadata\n    UnaryOperator<Aliases> op5 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", \"bar\");\n    aliasesManager.applyModificationAndExportToZk(op5);\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more metadata\n    UnaryOperator<Aliases> op4 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foobar\", \"bazbam\");\n    aliasesManager.applyModificationAndExportToZk(op4);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove metadata\n    UnaryOperator<Aliases> op3 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesManager.applyModificationAndExportToZk(op3);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    UnaryOperator<Aliases> op2 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesManager.applyModificationAndExportToZk(op2);\n\n    // chained invocations\n    UnaryOperator<Aliases> op1 = a ->\n        a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasMetadata(\"meta1\", \"foo3\", \"bazbam2\");\n    aliasesManager.applyModificationAndExportToZk(op1);\n\n    // some other independent update (not overwritten)\n    UnaryOperator<Aliases> op = a -> a.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\");\n    aliasesManager.applyModificationAndExportToZk(op);\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    String zkAddress = cluster.getZkServer().getZkAddress();\n    boolean createdZKSR = false;\n    try(SolrZkClient zkClient = new SolrZkClient(zkAddress, 30000)) {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      createdZKSR = true;\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n      assertNotNull(meta);\n\n      // verify key was removed in independent view\n      assertFalse(meta.containsKey(\"foo\"));\n\n      // but only the specified key was removed\n      assertTrue(meta.containsKey(\"foobar\"));\n      assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n      Aliases a = zkStateReader.getAliases();\n      Aliases clone = a.cloneWithCollectionAlias(\"meta1\", null);\n      meta = clone.getCollectionAliasMetadata(\"meta1\");\n      assertEquals(0,meta.size());\n    } finally {\n      if (createdZKSR) {\n        zkStateReader.close();\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testMetadata() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    UnaryOperator<Aliases> op6 = a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\");\n    final ZkStateReader.AliasesManager aliasesHolder = zkStateReader.aliasesHolder;\n\n    aliasesHolder.applyModificationAndExportToZk(op6);\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set metadata\n    UnaryOperator<Aliases> op5 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", \"bar\");\n    aliasesHolder.applyModificationAndExportToZk(op5);\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more metadata\n    UnaryOperator<Aliases> op4 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foobar\", \"bazbam\");\n    aliasesHolder.applyModificationAndExportToZk(op4);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove metadata\n    UnaryOperator<Aliases> op3 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesHolder.applyModificationAndExportToZk(op3);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    UnaryOperator<Aliases> op2 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesHolder.applyModificationAndExportToZk(op2);\n\n    // chained invocations\n    UnaryOperator<Aliases> op1 = a ->\n        a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasMetadata(\"meta1\", \"foo3\", \"bazbam2\");\n    aliasesHolder.applyModificationAndExportToZk(op1);\n\n    // some other independent update (not overwritten)\n    UnaryOperator<Aliases> op = a -> a.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\");\n    aliasesHolder.applyModificationAndExportToZk(op);\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    String zkAddress = cluster.getZkServer().getZkAddress();\n    boolean createdZKSR = false;\n    try(SolrZkClient zkClient = new SolrZkClient(zkAddress, 30000)) {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      createdZKSR = true;\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n      assertNotNull(meta);\n\n      // verify key was removed in independent view\n      assertFalse(meta.containsKey(\"foo\"));\n\n      // but only the specified key was removed\n      assertTrue(meta.containsKey(\"foobar\"));\n      assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n      Aliases a = zkStateReader.getAliases();\n      Aliases clone = a.cloneWithCollectionAlias(\"meta1\", null);\n      meta = clone.getCollectionAliasMetadata(\"meta1\");\n      assertEquals(0,meta.size());\n    } finally {\n      if (createdZKSR) {\n        zkStateReader.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a980795a56f2fcbc94caeb3233071312d5684d59"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e16ac84f9e5d560008fe1554462ff8b853b3d3c","date":1520142134,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testMetadata().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testMetadata().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testMetadata() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    UnaryOperator<Aliases> op6 = a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\");\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(op6);\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set metadata\n    UnaryOperator<Aliases> op5 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", \"bar\");\n    aliasesManager.applyModificationAndExportToZk(op5);\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more metadata\n    UnaryOperator<Aliases> op4 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foobar\", \"bazbam\");\n    aliasesManager.applyModificationAndExportToZk(op4);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove metadata\n    UnaryOperator<Aliases> op3 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesManager.applyModificationAndExportToZk(op3);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    UnaryOperator<Aliases> op2 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesManager.applyModificationAndExportToZk(op2);\n\n    // chained invocations\n    UnaryOperator<Aliases> op1 = a ->\n        a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasMetadata(\"meta1\", \"foo3\", \"bazbam2\");\n    aliasesManager.applyModificationAndExportToZk(op1);\n\n    // some other independent update (not overwritten)\n    UnaryOperator<Aliases> op = a -> a.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\");\n    aliasesManager.applyModificationAndExportToZk(op);\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    String zkAddress = cluster.getZkServer().getZkAddress();\n    boolean createdZKSR = false;\n    try(SolrZkClient zkClient = new SolrZkClient(zkAddress, 30000)) {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      createdZKSR = true;\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n      assertNotNull(meta);\n\n      // verify key was removed in independent view\n      assertFalse(meta.containsKey(\"foo\"));\n\n      // but only the specified key was removed\n      assertTrue(meta.containsKey(\"foobar\"));\n      assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n      Aliases a = zkStateReader.getAliases();\n      Aliases clone = a.cloneWithCollectionAlias(\"meta1\", null);\n      meta = clone.getCollectionAliasMetadata(\"meta1\");\n      assertEquals(0,meta.size());\n    } finally {\n      if (createdZKSR) {\n        zkStateReader.close();\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testMetadata() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    UnaryOperator<Aliases> op6 = a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\");\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(op6);\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set metadata\n    UnaryOperator<Aliases> op5 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", \"bar\");\n    aliasesManager.applyModificationAndExportToZk(op5);\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more metadata\n    UnaryOperator<Aliases> op4 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foobar\", \"bazbam\");\n    aliasesManager.applyModificationAndExportToZk(op4);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove metadata\n    UnaryOperator<Aliases> op3 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesManager.applyModificationAndExportToZk(op3);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    UnaryOperator<Aliases> op2 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesManager.applyModificationAndExportToZk(op2);\n\n    // chained invocations\n    UnaryOperator<Aliases> op1 = a ->\n        a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasMetadata(\"meta1\", \"foo3\", \"bazbam2\");\n    aliasesManager.applyModificationAndExportToZk(op1);\n\n    // some other independent update (not overwritten)\n    UnaryOperator<Aliases> op = a -> a.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\");\n    aliasesManager.applyModificationAndExportToZk(op);\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    String zkAddress = cluster.getZkServer().getZkAddress();\n    boolean createdZKSR = false;\n    try(SolrZkClient zkClient = new SolrZkClient(zkAddress, 30000)) {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      createdZKSR = true;\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n      assertNotNull(meta);\n\n      // verify key was removed in independent view\n      assertFalse(meta.containsKey(\"foo\"));\n\n      // but only the specified key was removed\n      assertTrue(meta.containsKey(\"foobar\"));\n      assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n      Aliases a = zkStateReader.getAliases();\n      Aliases clone = a.cloneWithCollectionAlias(\"meta1\", null);\n      meta = clone.getCollectionAliasMetadata(\"meta1\");\n      assertEquals(0,meta.size());\n    } finally {\n      if (createdZKSR) {\n        zkStateReader.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a980795a56f2fcbc94caeb3233071312d5684d59"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767","date":1520865397,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testMetadata().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    UnaryOperator<Aliases> op6 = a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\");\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(op6);\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    UnaryOperator<Aliases> op5 = a -> a.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\");\n    aliasesManager.applyModificationAndExportToZk(op5);\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    UnaryOperator<Aliases> op4 = a -> a.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\");\n    aliasesManager.applyModificationAndExportToZk(op4);\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    UnaryOperator<Aliases> op3 = a -> a.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null);\n    aliasesManager.applyModificationAndExportToZk(op3);\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    UnaryOperator<Aliases> op2 = a -> a.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null);\n    aliasesManager.applyModificationAndExportToZk(op2);\n\n    // chained invocations\n    UnaryOperator<Aliases> op1 = a ->\n        a.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\");\n    aliasesManager.applyModificationAndExportToZk(op1);\n\n    // some other independent update (not overwritten)\n    UnaryOperator<Aliases> op = a -> a.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\");\n    aliasesManager.applyModificationAndExportToZk(op);\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    String zkAddress = cluster.getZkServer().getZkAddress();\n    boolean createdZKSR = false;\n    try(SolrZkClient zkClient = new SolrZkClient(zkAddress, 30000)) {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      createdZKSR = true;\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n      assertNotNull(meta);\n\n      // verify key was removed in independent view\n      assertFalse(meta.containsKey(\"foo\"));\n\n      // but only the specified key was removed\n      assertTrue(meta.containsKey(\"foobar\"));\n      assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n      Aliases a = zkStateReader.getAliases();\n      Aliases clone = a.cloneWithCollectionAlias(\"meta1\", null);\n      meta = clone.getCollectionAliasProperties(\"meta1\");\n      assertEquals(0,meta.size());\n    } finally {\n      if (createdZKSR) {\n        zkStateReader.close();\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testMetadata() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    UnaryOperator<Aliases> op6 = a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\");\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(op6);\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set metadata\n    UnaryOperator<Aliases> op5 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", \"bar\");\n    aliasesManager.applyModificationAndExportToZk(op5);\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more metadata\n    UnaryOperator<Aliases> op4 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foobar\", \"bazbam\");\n    aliasesManager.applyModificationAndExportToZk(op4);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove metadata\n    UnaryOperator<Aliases> op3 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesManager.applyModificationAndExportToZk(op3);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    UnaryOperator<Aliases> op2 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesManager.applyModificationAndExportToZk(op2);\n\n    // chained invocations\n    UnaryOperator<Aliases> op1 = a ->\n        a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasMetadata(\"meta1\", \"foo3\", \"bazbam2\");\n    aliasesManager.applyModificationAndExportToZk(op1);\n\n    // some other independent update (not overwritten)\n    UnaryOperator<Aliases> op = a -> a.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\");\n    aliasesManager.applyModificationAndExportToZk(op);\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    String zkAddress = cluster.getZkServer().getZkAddress();\n    boolean createdZKSR = false;\n    try(SolrZkClient zkClient = new SolrZkClient(zkAddress, 30000)) {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      createdZKSR = true;\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n      assertNotNull(meta);\n\n      // verify key was removed in independent view\n      assertFalse(meta.containsKey(\"foo\"));\n\n      // but only the specified key was removed\n      assertTrue(meta.containsKey(\"foobar\"));\n      assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n      Aliases a = zkStateReader.getAliases();\n      Aliases clone = a.cloneWithCollectionAlias(\"meta1\", null);\n      meta = clone.getCollectionAliasMetadata(\"meta1\");\n      assertEquals(0,meta.size());\n    } finally {\n      if (createdZKSR) {\n        zkStateReader.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a980795a56f2fcbc94caeb3233071312d5684d59"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"7e16ac84f9e5d560008fe1554462ff8b853b3d3c":["3cbd743a4843f513f793670e3ab0e272bf824faf"],"6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767":["7e16ac84f9e5d560008fe1554462ff8b853b3d3c"],"215e40821821b2df2e69355e208532c05ef095a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3cbd743a4843f513f793670e3ab0e272bf824faf":["b10ab715806383f3d7f9eece13c26772a9116022"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b10ab715806383f3d7f9eece13c26772a9116022":["215e40821821b2df2e69355e208532c05ef095a5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767"]},"commit2Childs":{"7e16ac84f9e5d560008fe1554462ff8b853b3d3c":["6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767"],"6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"215e40821821b2df2e69355e208532c05ef095a5":["b10ab715806383f3d7f9eece13c26772a9116022"],"3cbd743a4843f513f793670e3ab0e272bf824faf":["7e16ac84f9e5d560008fe1554462ff8b853b3d3c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["215e40821821b2df2e69355e208532c05ef095a5"],"b10ab715806383f3d7f9eece13c26772a9116022":["3cbd743a4843f513f793670e3ab0e272bf824faf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}