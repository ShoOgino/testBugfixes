{"path":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"18c264904f4236696be3696a0d998a37931a8a50","date":1333699995,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSourceId() {\n//    return \"$Id$\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n//\n//  public String getVersion() {\n//    return \"$Revision$\";\n//  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e250f610380dc5c3ba65cb770f4076d47d2c1d89","date":1348100277,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n\n        // may be null when using facet.missing\n        final String fieldValue = kv.getKey(); \n\n        // don't reuse the same BytesRef each time since we will be \n        // constructing Term objects used in TermQueries that may be cached.\n        BytesRef termval = null;\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          termval = new BytesRef();\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        }\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          DocSet subset = null;\n          if ( null == termval ) {\n            DocSet hasVal = searcher.getDocSet\n              (new TermRangeQuery(field, null, null, false, false));\n            subset = docs.andNot(hasVal);\n          } else {\n            Query query = new TermQuery(new Term(field, termval));\n            subset = searcher.getDocSet(query, docs);\n          }\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n        // don't reuse the same BytesRef  each time since we will be constructing Term\n        // objects that will most likely be cached.\n        BytesRef termval = new BytesRef();\n        ftype.readableToIndexed(kv.getKey(), termval);\n        \n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          Query query = new TermQuery(new Term(field, termval));\n          DocSet subset = searcher.getDocSet(query, docs);\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n// TODO: This is code from various patches to support distributed search.\n//  Some parts may be helpful for whoever implements distributed search.\n//\n//  @Override\n//  public int distributedProcess(ResponseBuilder rb) throws IOException {\n//    if (!rb.doFacets) {\n//      return ResponseBuilder.STAGE_DONE;\n//    }\n//\n//    if (rb.stage == ResponseBuilder.STAGE_GET_FIELDS) {\n//      SolrParams params = rb.req.getParams();\n//      String[] pivots = params.getParams(FacetParams.FACET_PIVOT);\n//      for ( ShardRequest sreq : rb.outgoing ) {\n//        if (( sreq.purpose & ShardRequest.PURPOSE_GET_FIELDS ) != 0\n//            && sreq.shards != null && sreq.shards.length == 1 ) {\n//          sreq.params.set( FacetParams.FACET, \"true\" );\n//          sreq.params.set( FacetParams.FACET_PIVOT, pivots );\n//          sreq.params.set( FacetParams.FACET_PIVOT_MINCOUNT, 1 ); // keep this at 1 regardless so that it accumulates everything\n//            }\n//      }\n//    }\n//    return ResponseBuilder.STAGE_DONE;\n//  }\n//\n//  @Override\n//  public void handleResponses(ResponseBuilder rb, ShardRequest sreq) {\n//    if (!rb.doFacets) return;\n//\n//\n//    if ((sreq.purpose & ShardRequest.PURPOSE_GET_FACETS)!=0) {\n//      SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//      if ( null == tf ) {\n//        tf = new SimpleOrderedMap<List<NamedList<Object>>>();\n//        rb._pivots = tf;\n//      }\n//      for (ShardResponse srsp: sreq.responses) {\n//        int shardNum = rb.getShardNum(srsp.getShard());\n//\n//        NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n//\n//        // handle facet trees from shards\n//        SimpleOrderedMap<List<NamedList<Object>>> shard_pivots = \n//          (SimpleOrderedMap<List<NamedList<Object>>>)facet_counts.get( PIVOT_KEY );\n//        \n//        if ( shard_pivots != null ) {\n//          for (int j=0; j< shard_pivots.size(); j++) {\n//            // TODO -- accumulate the results from each shard\n//            // The following code worked to accumulate facets for an previous \n//            // two level patch... it is here for reference till someone can upgrade\n//            /**\n//            String shard_tree_name = (String) shard_pivots.getName( j );\n//            SimpleOrderedMap<NamedList> shard_tree = (SimpleOrderedMap<NamedList>)shard_pivots.getVal( j );\n//            SimpleOrderedMap<NamedList> facet_tree = tf.get( shard_tree_name );\n//            if ( null == facet_tree) { \n//              facet_tree = new SimpleOrderedMap<NamedList>(); \n//              tf.add( shard_tree_name, facet_tree );\n//            }\n//\n//            for( int o = 0; o < shard_tree.size() ; o++ ) {\n//              String shard_outer = (String) shard_tree.getName( o );\n//              NamedList shard_innerList = (NamedList) shard_tree.getVal( o );\n//              NamedList tree_innerList  = (NamedList) facet_tree.get( shard_outer );\n//              if ( null == tree_innerList ) { \n//                tree_innerList = new NamedList();\n//                facet_tree.add( shard_outer, tree_innerList );\n//              }\n//\n//              for ( int i = 0 ; i < shard_innerList.size() ; i++ ) {\n//                String shard_term = (String) shard_innerList.getName( i );\n//                long shard_count  = ((Number) shard_innerList.getVal(i)).longValue();\n//                int tree_idx      = tree_innerList.indexOf( shard_term, 0 );\n//\n//                if ( -1 == tree_idx ) {\n//                  tree_innerList.add( shard_term, shard_count );\n//                } else {\n//                  long tree_count = ((Number) tree_innerList.getVal( tree_idx )).longValue();\n//                  tree_innerList.setVal( tree_idx, shard_count + tree_count );\n//                }\n//              } // innerList loop\n//            } // outer loop\n//              **/\n//          } // each tree loop\n//        }\n//      }\n//    } \n//    return ;\n//  }\n//\n//  @Override\n//  public void finishStage(ResponseBuilder rb) {\n//    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n//    // wait until STAGE_GET_FIELDS\n//    // so that \"result\" is already stored in the response (for aesthetics)\n//\n//    SimpleOrderedMap<List<NamedList<Object>>> tf = rb._pivots;\n//\n//    // get 'facet_counts' from the response\n//    NamedList facetCounts = (NamedList) rb.rsp.getValues().get(\"facet_counts\");\n//    if (facetCounts == null) {\n//      facetCounts = new NamedList();\n//      rb.rsp.add(\"facet_counts\", facetCounts);\n//    }\n//    facetCounts.add( PIVOT_KEY, tf );\n//    rb._pivots = null;\n//  }\n//\n//  public String getDescription() {\n//    return \"Handle Pivot (multi-level) Faceting\";\n//  }\n//\n//  public String getSource() {\n//    return \"$URL$\";\n//  }\n\n","bugFix":["87337212608bc7aa67d96011034596313b071c0e","03a198be002bb6786dce54cf550c3ca7bb7b88a9"],"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a2ba67a463f52915e77a5fd8714aa7d36faf59c","date":1348538193,"type":5,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],ResponseBuilder,DocSet,int).mjava","sourceNew":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, Deque<String> fnames,\n                                             DocSet docs) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch) {\n\n        // may be null when using facet.missing\n        final String fieldValue = kv.getKey(); \n\n        // don't reuse the same BytesRef each time since we will be \n        // constructing Term objects used in TermQueries that may be cached.\n        BytesRef termval = null;\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          termval = new BytesRef();\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        }\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          DocSet subset = null;\n          if ( null == termval ) {\n            DocSet hasVal = searcher.getDocSet\n              (new TermRangeQuery(field, null, null, false, false));\n            subset = docs.andNot(hasVal);\n          } else {\n            Query query = new TermQuery(new Term(field, termval));\n            subset = searcher.getDocSet(query, docs);\n          }\n          super.docs = subset;//used by getTermCounts()\n\n          NamedList<Integer> nl = this.getTermCounts(subField);\n          if (nl.size() >= minMatch) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, subset) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots( NamedList<Integer> superFacets, String field, String subField, Deque<String> fnames, ResponseBuilder rb, DocSet docs, int minMatch ) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<NamedList<Object>>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch ) {\n\n        // may be null when using facet.missing\n        final String fieldValue = kv.getKey(); \n\n        // don't reuse the same BytesRef each time since we will be \n        // constructing Term objects used in TermQueries that may be cached.\n        BytesRef termval = null;\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<Object>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          termval = new BytesRef();\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval) );\n        }\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          DocSet subset = null;\n          if ( null == termval ) {\n            DocSet hasVal = searcher.getDocSet\n              (new TermRangeQuery(field, null, null, false, false));\n            subset = docs.andNot(hasVal);\n          } else {\n            Query query = new TermQuery(new Term(field, termval));\n            subset = searcher.getDocSet(query, docs);\n          }\n          SimpleFacets sf = getFacetImplementation(rb.req, subset, rb.req.getParams());\n          \n          NamedList<Integer> nl = sf.getTermCounts(subField);\n          if (nl.size() >= minMatch ) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, rb, subset, minMatch ) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"e250f610380dc5c3ba65cb770f4076d47d2c1d89":["18c264904f4236696be3696a0d998a37931a8a50"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7a2ba67a463f52915e77a5fd8714aa7d36faf59c":["e250f610380dc5c3ba65cb770f4076d47d2c1d89"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7a2ba67a463f52915e77a5fd8714aa7d36faf59c"],"18c264904f4236696be3696a0d998a37931a8a50":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"e250f610380dc5c3ba65cb770f4076d47d2c1d89":["7a2ba67a463f52915e77a5fd8714aa7d36faf59c"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["18c264904f4236696be3696a0d998a37931a8a50"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee"],"7a2ba67a463f52915e77a5fd8714aa7d36faf59c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"18c264904f4236696be3696a0d998a37931a8a50":["e250f610380dc5c3ba65cb770f4076d47d2c1d89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}