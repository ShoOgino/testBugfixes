{"path":"modules/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","commits":[{"id":"e3a908bacd530957eaa6d2dfebdd534afd9ac60e","date":1327209646,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 50: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 51: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 52: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 53: break;\n        case 26: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 54: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 55: break;\n        case 34: \n          { cumulativeDiff += yychar - inputStart + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 56: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      try {\n        int codePoint = Integer.parseInt(decimalCharRef);\n        if (codePoint <= 0x10FFFF) {\n          outputSegment = entitySegment;\n          outputSegment.clear();\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n          yybegin(CHARACTER_REFERENCE_TAIL);\n        } else {\n          outputSegment = inputSegment;\n          yybegin(YYINITIAL);\n          return outputSegment.nextChar();\n        }\n      } catch(NumberFormatException e) {\n        assert false: \"NumberFormatException parsing code point '\"\n                      + decimalCharRef + \"'\";\n      } catch(IllegalArgumentException e) {\n        assert false: \"IllegalArgumentException getting chars for code point '\"\n                      + decimalCharRef + \"'\";\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 57: break;\n        case 47: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 58: break;\n        case 27: \n          { cumulativeDiff += inputSegment.length() + yylength() - 1;\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 59: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 60: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 61: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 62: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 63: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 64: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 65: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 66: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    cumulativeDiff += yychar - inputStart;\n    int outputEnd = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      cumulativeDiff += yylength() - 1;\n      ++outputEnd;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(outputEnd, cumulativeDiff);\n    return returnValue;\n          }\n        case 67: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 68: break;\n        case 14: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 69: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    cumulativeDiff += yychar - inputStart;\n    int outputEnd = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      cumulativeDiff += yylength() - 1;\n      ++outputEnd;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(outputEnd, cumulativeDiff);\n    return returnValue;\n          }\n        case 71: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 72: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 73: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 74: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 75: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 76: break;\n        case 25: \n          { cumulativeDiff += inputSegment.length() + yylength() - 1;\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 77: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 78: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 79: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 80: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      try {\n        int codePoint = Integer.parseInt(hexCharRef, 16);\n        if (codePoint <= 0x10FFFF) {\n          outputSegment = entitySegment;\n          outputSegment.clear();\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n          yybegin(CHARACTER_REFERENCE_TAIL);\n        } else {\n          outputSegment = inputSegment;\n          yybegin(YYINITIAL);\n          return outputSegment.nextChar();\n        }\n      } catch(NumberFormatException e) {\n        assert false: \"NumberFormatException parsing hex code point '\"\n                      + hexCharRef + \"'\";\n      } catch(IllegalArgumentException e) {\n        assert false: \"IllegalArgumentException getting chars \"\n                      + \"for hex code point '\" + hexCharRef + \"'\";\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 81: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 82: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 83: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 84: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      cumulativeDiff\n          += inputSegment.length() + yylength() - outputSegment.length();\n      addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 85: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      cumulativeDiff\n          += inputSegment.length() + yylength() - outputSegment.length();\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 86: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 87: break;\n        case 37: \n          { cumulativeDiff += yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 88: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 89: break;\n        case 7: \n          { cumulativeDiff\n        += inputSegment.length() + yylength() - outputSegment.length();\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 90: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 91: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 92: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 93: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 94: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 95: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 96: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 97: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 98: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"579dc30b5d3235c34cda518b2b6018d71a61879c","date":1327235122,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 50: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 51: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 52: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 53: break;\n        case 26: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 54: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 55: break;\n        case 34: \n          { cumulativeDiff += yychar - inputStart + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 56: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      try {\n        int codePoint = Integer.parseInt(decimalCharRef);\n        if (codePoint <= 0x10FFFF) {\n          outputSegment = entitySegment;\n          outputSegment.clear();\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n          yybegin(CHARACTER_REFERENCE_TAIL);\n        } else {\n          outputSegment = inputSegment;\n          yybegin(YYINITIAL);\n          return outputSegment.nextChar();\n        }\n      } catch(NumberFormatException e) {\n        assert false: \"NumberFormatException parsing code point '\"\n                      + decimalCharRef + \"'\";\n      } catch(IllegalArgumentException e) {\n        assert false: \"IllegalArgumentException getting chars for code point '\"\n                      + decimalCharRef + \"'\";\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 57: break;\n        case 47: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 58: break;\n        case 27: \n          { cumulativeDiff += inputSegment.length() + yylength() - 1;\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 59: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 60: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 61: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 62: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 63: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 64: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 65: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 66: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    cumulativeDiff += yychar - inputStart;\n    int outputEnd = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      cumulativeDiff += yylength() - 1;\n      ++outputEnd;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(outputEnd, cumulativeDiff);\n    return returnValue;\n          }\n        case 67: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 68: break;\n        case 14: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 69: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    cumulativeDiff += yychar - inputStart;\n    int outputEnd = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      cumulativeDiff += yylength() - 1;\n      ++outputEnd;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(outputEnd, cumulativeDiff);\n    return returnValue;\n          }\n        case 71: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 72: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 73: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 74: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 75: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 76: break;\n        case 25: \n          { cumulativeDiff += inputSegment.length() + yylength() - 1;\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 77: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 78: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 79: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 80: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      try {\n        int codePoint = Integer.parseInt(hexCharRef, 16);\n        if (codePoint <= 0x10FFFF) {\n          outputSegment = entitySegment;\n          outputSegment.clear();\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n          yybegin(CHARACTER_REFERENCE_TAIL);\n        } else {\n          outputSegment = inputSegment;\n          yybegin(YYINITIAL);\n          return outputSegment.nextChar();\n        }\n      } catch(NumberFormatException e) {\n        assert false: \"NumberFormatException parsing hex code point '\"\n                      + hexCharRef + \"'\";\n      } catch(IllegalArgumentException e) {\n        assert false: \"IllegalArgumentException getting chars \"\n                      + \"for hex code point '\" + hexCharRef + \"'\";\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 81: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 82: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 83: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 84: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      cumulativeDiff\n          += inputSegment.length() + yylength() - outputSegment.length();\n      addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 85: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      cumulativeDiff\n          += inputSegment.length() + yylength() - outputSegment.length();\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 86: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 87: break;\n        case 37: \n          { cumulativeDiff += yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 88: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 89: break;\n        case 7: \n          { cumulativeDiff\n        += inputSegment.length() + yylength() - outputSegment.length();\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 90: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 91: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 92: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 93: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 94: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 95: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 96: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 97: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 98: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b55235ffc28246ab5c4e1d88861a41654043261f","date":1327304198,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 56: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 57: break;\n        case 26: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 58: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 59: break;\n        case 34: \n          { cumulativeDiff += yychar - inputStart + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 60: break;\n        case 47: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 61: break;\n        case 27: \n          { cumulativeDiff += inputSegment.length() + yylength() - 1;\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 62: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 63: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 64: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 65: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 66: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 67: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 68: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 69: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    cumulativeDiff += yychar - inputStart;\n    int outputEnd = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      cumulativeDiff += yylength() - 1;\n      ++outputEnd;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(outputEnd, cumulativeDiff);\n    return returnValue;\n          }\n        case 70: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 71: break;\n        case 14: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 72: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 73: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    cumulativeDiff += yychar - inputStart;\n    int outputEnd = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      cumulativeDiff += yylength() - 1;\n      ++outputEnd;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(outputEnd, cumulativeDiff);\n    return returnValue;\n          }\n        case 75: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 76: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 77: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 78: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 79: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 80: break;\n        case 25: \n          { cumulativeDiff += inputSegment.length() + yylength() - 1;\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 81: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 82: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 83: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 84: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 85: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 86: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 87: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 88: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      cumulativeDiff\n          += inputSegment.length() + yylength() - outputSegment.length();\n      addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 89: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      cumulativeDiff\n          += inputSegment.length() + yylength() - outputSegment.length();\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 90: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 91: break;\n        case 37: \n          { cumulativeDiff += yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 92: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 93: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 94: break;\n        case 7: \n          { cumulativeDiff\n        += inputSegment.length() + yylength() - outputSegment.length();\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 95: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 96: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 97: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 98: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 99: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 100: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 102: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 103: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 104: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 105: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 50: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 51: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 52: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 53: break;\n        case 26: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 54: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 55: break;\n        case 34: \n          { cumulativeDiff += yychar - inputStart + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 56: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      try {\n        int codePoint = Integer.parseInt(decimalCharRef);\n        if (codePoint <= 0x10FFFF) {\n          outputSegment = entitySegment;\n          outputSegment.clear();\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n          yybegin(CHARACTER_REFERENCE_TAIL);\n        } else {\n          outputSegment = inputSegment;\n          yybegin(YYINITIAL);\n          return outputSegment.nextChar();\n        }\n      } catch(NumberFormatException e) {\n        assert false: \"NumberFormatException parsing code point '\"\n                      + decimalCharRef + \"'\";\n      } catch(IllegalArgumentException e) {\n        assert false: \"IllegalArgumentException getting chars for code point '\"\n                      + decimalCharRef + \"'\";\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 57: break;\n        case 47: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 58: break;\n        case 27: \n          { cumulativeDiff += inputSegment.length() + yylength() - 1;\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 59: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 60: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 61: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 62: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 63: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 64: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 65: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 66: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    cumulativeDiff += yychar - inputStart;\n    int outputEnd = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      cumulativeDiff += yylength() - 1;\n      ++outputEnd;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(outputEnd, cumulativeDiff);\n    return returnValue;\n          }\n        case 67: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 68: break;\n        case 14: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 69: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    cumulativeDiff += yychar - inputStart;\n    int outputEnd = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      cumulativeDiff += yylength() - 1;\n      ++outputEnd;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(outputEnd, cumulativeDiff);\n    return returnValue;\n          }\n        case 71: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 72: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 73: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 74: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 75: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 76: break;\n        case 25: \n          { cumulativeDiff += inputSegment.length() + yylength() - 1;\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 77: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 78: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 79: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 80: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      try {\n        int codePoint = Integer.parseInt(hexCharRef, 16);\n        if (codePoint <= 0x10FFFF) {\n          outputSegment = entitySegment;\n          outputSegment.clear();\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n          yybegin(CHARACTER_REFERENCE_TAIL);\n        } else {\n          outputSegment = inputSegment;\n          yybegin(YYINITIAL);\n          return outputSegment.nextChar();\n        }\n      } catch(NumberFormatException e) {\n        assert false: \"NumberFormatException parsing hex code point '\"\n                      + hexCharRef + \"'\";\n      } catch(IllegalArgumentException e) {\n        assert false: \"IllegalArgumentException getting chars \"\n                      + \"for hex code point '\" + hexCharRef + \"'\";\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 81: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 82: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 83: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 84: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      cumulativeDiff\n          += inputSegment.length() + yylength() - outputSegment.length();\n      addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 85: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      cumulativeDiff\n          += inputSegment.length() + yylength() - outputSegment.length();\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 86: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 87: break;\n        case 37: \n          { cumulativeDiff += yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 88: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 89: break;\n        case 7: \n          { cumulativeDiff\n        += inputSegment.length() + yylength() - outputSegment.length();\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 90: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 91: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 92: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 93: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 94: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 95: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 96: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 97: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 98: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a89676536a5d3e2e875a9eed6b3f22a63cca643","date":1327356915,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 56: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 57: break;\n        case 26: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 58: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 59: break;\n        case 34: \n          { cumulativeDiff += yychar - inputStart + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 60: break;\n        case 47: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 61: break;\n        case 27: \n          { cumulativeDiff += inputSegment.length() + yylength() - 1;\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 62: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 63: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 64: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 65: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 66: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 67: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 68: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 69: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    cumulativeDiff += yychar - inputStart;\n    int outputEnd = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      cumulativeDiff += yylength() - 1;\n      ++outputEnd;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(outputEnd, cumulativeDiff);\n    return returnValue;\n          }\n        case 70: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 71: break;\n        case 14: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 72: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 73: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    cumulativeDiff += yychar - inputStart;\n    int outputEnd = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      cumulativeDiff += yylength() - 1;\n      ++outputEnd;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(outputEnd, cumulativeDiff);\n    return returnValue;\n          }\n        case 75: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 76: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 77: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 78: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 79: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 80: break;\n        case 25: \n          { cumulativeDiff += inputSegment.length() + yylength() - 1;\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 81: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 82: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 83: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 84: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 85: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 86: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 87: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 88: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      cumulativeDiff\n          += inputSegment.length() + yylength() - outputSegment.length();\n      addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 89: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      cumulativeDiff\n          += inputSegment.length() + yylength() - outputSegment.length();\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 90: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 91: break;\n        case 37: \n          { cumulativeDiff += yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 92: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 93: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 94: break;\n        case 7: \n          { cumulativeDiff\n        += inputSegment.length() + yylength() - outputSegment.length();\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 95: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 96: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 97: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 98: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 99: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 100: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 102: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 103: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 104: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 105: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 50: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 51: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 52: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 53: break;\n        case 26: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 54: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 55: break;\n        case 34: \n          { cumulativeDiff += yychar - inputStart + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 56: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      try {\n        int codePoint = Integer.parseInt(decimalCharRef);\n        if (codePoint <= 0x10FFFF) {\n          outputSegment = entitySegment;\n          outputSegment.clear();\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n          yybegin(CHARACTER_REFERENCE_TAIL);\n        } else {\n          outputSegment = inputSegment;\n          yybegin(YYINITIAL);\n          return outputSegment.nextChar();\n        }\n      } catch(NumberFormatException e) {\n        assert false: \"NumberFormatException parsing code point '\"\n                      + decimalCharRef + \"'\";\n      } catch(IllegalArgumentException e) {\n        assert false: \"IllegalArgumentException getting chars for code point '\"\n                      + decimalCharRef + \"'\";\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 57: break;\n        case 47: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 58: break;\n        case 27: \n          { cumulativeDiff += inputSegment.length() + yylength() - 1;\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 59: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 60: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 61: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 62: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 63: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 64: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 65: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 66: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    cumulativeDiff += yychar - inputStart;\n    int outputEnd = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      cumulativeDiff += yylength() - 1;\n      ++outputEnd;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(outputEnd, cumulativeDiff);\n    return returnValue;\n          }\n        case 67: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 68: break;\n        case 14: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 69: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    cumulativeDiff += yychar - inputStart;\n    int outputEnd = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      cumulativeDiff += yylength() - 1;\n      ++outputEnd;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(outputEnd, cumulativeDiff);\n    return returnValue;\n          }\n        case 71: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 72: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 73: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 74: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 75: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 76: break;\n        case 25: \n          { cumulativeDiff += inputSegment.length() + yylength() - 1;\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 77: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 78: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 79: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 80: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      try {\n        int codePoint = Integer.parseInt(hexCharRef, 16);\n        if (codePoint <= 0x10FFFF) {\n          outputSegment = entitySegment;\n          outputSegment.clear();\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n          yybegin(CHARACTER_REFERENCE_TAIL);\n        } else {\n          outputSegment = inputSegment;\n          yybegin(YYINITIAL);\n          return outputSegment.nextChar();\n        }\n      } catch(NumberFormatException e) {\n        assert false: \"NumberFormatException parsing hex code point '\"\n                      + hexCharRef + \"'\";\n      } catch(IllegalArgumentException e) {\n        assert false: \"IllegalArgumentException getting chars \"\n                      + \"for hex code point '\" + hexCharRef + \"'\";\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 81: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 82: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 83: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 84: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      cumulativeDiff\n          += inputSegment.length() + yylength() - outputSegment.length();\n      addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 85: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      cumulativeDiff\n          += inputSegment.length() + yylength() - outputSegment.length();\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 86: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 87: break;\n        case 37: \n          { cumulativeDiff += yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 88: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 89: break;\n        case 7: \n          { cumulativeDiff\n        += inputSegment.length() + yylength() - outputSegment.length();\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 90: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 91: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 92: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 93: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 94: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 95: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 96: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 97: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 98: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 56: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 57: break;\n        case 26: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 58: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 59: break;\n        case 34: \n          { cumulativeDiff += yychar - inputStart + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 60: break;\n        case 47: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 61: break;\n        case 27: \n          { cumulativeDiff += inputSegment.length() + yylength() - 1;\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 62: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 63: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 64: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 65: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 66: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 67: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 68: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 69: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    cumulativeDiff += yychar - inputStart;\n    int outputEnd = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      cumulativeDiff += yylength() - 1;\n      ++outputEnd;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(outputEnd, cumulativeDiff);\n    return returnValue;\n          }\n        case 70: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 71: break;\n        case 14: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 72: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 73: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    cumulativeDiff += yychar - inputStart;\n    int outputEnd = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      cumulativeDiff += yylength() - 1;\n      ++outputEnd;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(outputEnd, cumulativeDiff);\n    return returnValue;\n          }\n        case 75: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 76: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 77: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 78: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 79: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 80: break;\n        case 25: \n          { cumulativeDiff += inputSegment.length() + yylength() - 1;\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 81: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 82: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 83: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 84: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 85: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 86: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 87: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 88: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      cumulativeDiff\n          += inputSegment.length() + yylength() - outputSegment.length();\n      addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 89: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      cumulativeDiff\n          += inputSegment.length() + yylength() - outputSegment.length();\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 90: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 91: break;\n        case 37: \n          { cumulativeDiff += yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 92: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 93: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 94: break;\n        case 7: \n          { cumulativeDiff\n        += inputSegment.length() + yylength() - outputSegment.length();\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 95: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 96: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 97: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 98: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 99: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 100: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 102: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 103: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 104: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 105: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d6adf8ea59977891966389011f3905e09932183","date":1332622471,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 56: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 57: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 58: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 61: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 62: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 63: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 64: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 65: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 66: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 68: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 69: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 70: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 71: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 72: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 73: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 76: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 77: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 78: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 79: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 80: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 81: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 82: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 83: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 84: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 85: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 86: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 87: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 88: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 89: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 90: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 91: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 92: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 93: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 94: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 95: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 96: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 97: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 98: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 99: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 100: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 102: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 103: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 104: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 105: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 56: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 57: break;\n        case 26: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 58: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 59: break;\n        case 34: \n          { cumulativeDiff += yychar - inputStart + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 60: break;\n        case 47: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 61: break;\n        case 27: \n          { cumulativeDiff += inputSegment.length() + yylength() - 1;\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 62: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 63: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 64: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 65: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 66: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 67: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 68: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 69: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    cumulativeDiff += yychar - inputStart;\n    int outputEnd = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      cumulativeDiff += yylength() - 1;\n      ++outputEnd;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(outputEnd, cumulativeDiff);\n    return returnValue;\n          }\n        case 70: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 71: break;\n        case 14: \n          { cumulativeDiff += inputSegment.length() + yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 72: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 73: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    cumulativeDiff += yychar - inputStart;\n    int outputEnd = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      cumulativeDiff += yylength() - 1;\n      ++outputEnd;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(outputEnd, cumulativeDiff);\n    return returnValue;\n          }\n        case 75: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 76: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 77: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 78: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 79: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 80: break;\n        case 25: \n          { cumulativeDiff += inputSegment.length() + yylength() - 1;\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 81: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 82: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 83: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 84: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 85: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 86: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 87: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 88: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      cumulativeDiff\n          += inputSegment.length() + yylength() - outputSegment.length();\n      addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 89: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      cumulativeDiff\n          += inputSegment.length() + yylength() - outputSegment.length();\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 90: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 91: break;\n        case 37: \n          { cumulativeDiff += yylength();\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 92: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 93: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 94: break;\n        case 7: \n          { cumulativeDiff\n        += inputSegment.length() + yylength() - outputSegment.length();\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 95: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 96: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 97: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 98: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 99: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 100: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 102: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 103: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 104: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 105: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 56: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 57: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 58: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 61: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 62: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 63: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 64: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 65: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 66: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 68: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 69: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 70: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 71: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 72: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 73: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 76: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 77: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 78: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 79: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 80: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 81: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 82: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 83: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 84: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 85: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 86: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 87: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 88: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 89: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 90: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 91: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 92: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 93: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 94: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 95: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 96: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 97: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 98: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 99: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 100: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 102: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 103: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 104: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 105: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 56: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 57: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 58: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 61: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 62: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 63: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 64: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 65: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 66: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 68: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 69: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 70: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 71: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 72: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 73: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 76: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 77: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 78: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 79: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 80: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 81: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 82: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 83: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 84: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 85: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 86: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 87: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 88: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 89: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 90: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 91: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 92: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 93: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 94: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 95: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 96: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 97: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 98: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 99: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 100: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 102: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 103: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 104: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 105: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5a89676536a5d3e2e875a9eed6b3f22a63cca643":["579dc30b5d3235c34cda518b2b6018d71a61879c","b55235ffc28246ab5c4e1d88861a41654043261f"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["7d6adf8ea59977891966389011f3905e09932183"],"b55235ffc28246ab5c4e1d88861a41654043261f":["e3a908bacd530957eaa6d2dfebdd534afd9ac60e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b55235ffc28246ab5c4e1d88861a41654043261f"],"7d6adf8ea59977891966389011f3905e09932183":["b55235ffc28246ab5c4e1d88861a41654043261f"],"e3a908bacd530957eaa6d2dfebdd534afd9ac60e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"579dc30b5d3235c34cda518b2b6018d71a61879c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e3a908bacd530957eaa6d2dfebdd534afd9ac60e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"5a89676536a5d3e2e875a9eed6b3f22a63cca643":[],"b55235ffc28246ab5c4e1d88861a41654043261f":["5a89676536a5d3e2e875a9eed6b3f22a63cca643","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","7d6adf8ea59977891966389011f3905e09932183"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","e3a908bacd530957eaa6d2dfebdd534afd9ac60e","579dc30b5d3235c34cda518b2b6018d71a61879c"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"7d6adf8ea59977891966389011f3905e09932183":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"e3a908bacd530957eaa6d2dfebdd534afd9ac60e":["b55235ffc28246ab5c4e1d88861a41654043261f","579dc30b5d3235c34cda518b2b6018d71a61879c"],"579dc30b5d3235c34cda518b2b6018d71a61879c":["5a89676536a5d3e2e875a9eed6b3f22a63cca643"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5a89676536a5d3e2e875a9eed6b3f22a63cca643","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}