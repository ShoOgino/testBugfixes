{"path":"solr/core/src/java/org/apache/solr/request/SimpleFacets#computeDocSet(DocSet,List[String]).mjava","commits":[{"id":"22d0a81a05eba47d5e18976f17d88306b218cc22","date":1436341569,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#computeDocSet(DocSet,List[String]).mjava","pathOld":"/dev/null","sourceNew":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    // rb can be null if facets are being calculated from a RequestHandler e.g. MoreLikeThisHandler\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // get the new base docset for this facet\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n      grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de65fb6e86ba37c5409efafefe587d0c897c2764","date":1445143934,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#computeDocSet(DocSet,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#computeDocSet(DocSet,List[String]).mjava","sourceNew":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    // rb can be null if facets are being calculated from a RequestHandler e.g. MoreLikeThisHandler\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // get the new base docset for this facet\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n\n","sourceOld":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    // rb can be null if facets are being calculated from a RequestHandler e.g. MoreLikeThisHandler\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // get the new base docset for this facet\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n      grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"20e94e61fe5291647346b70437617e6b6c370408","date":1483783127,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#computeDocSet(DocSet,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#computeDocSet(DocSet,List[String]).mjava","sourceNew":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    // rb can be null if facets are being calculated from a RequestHandler e.g. MoreLikeThisHandler\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // get the new base docset for this facet\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n\n","sourceOld":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    // rb can be null if facets are being calculated from a RequestHandler e.g. MoreLikeThisHandler\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // get the new base docset for this facet\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#computeDocSet(DocSet,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#computeDocSet(DocSet,List[String]).mjava","sourceNew":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    // rb can be null if facets are being calculated from a RequestHandler e.g. MoreLikeThisHandler\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // get the new base docset for this facet\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n\n","sourceOld":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    // rb can be null if facets are being calculated from a RequestHandler e.g. MoreLikeThisHandler\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // get the new base docset for this facet\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e9fbf0f8ed8f52f3f2580cd0a5fcd8cab1db43f","date":1518195028,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#computeDocSet(DocSet,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#computeDocSet(DocSet,List[String]).mjava","sourceNew":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    // rb can be null if facets are being calculated from a RequestHandler e.g. MoreLikeThisHandler\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // get the new base docset for this facet\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n\n","sourceOld":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    // rb can be null if facets are being calculated from a RequestHandler e.g. MoreLikeThisHandler\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // get the new base docset for this facet\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85bef26bbc598445704c1f9c6d7953f3942d5426","date":1562162588,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#computeDocSet(DocSet,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#computeDocSet(DocSet,List[String]).mjava","sourceNew":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    // rb can be null if facets are being calculated from a RequestHandler e.g. MoreLikeThisHandler\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // get the new base docset for this facet\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getWithinGroupSortSpec().getSort());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n\n","sourceOld":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    // rb can be null if facets are being calculated from a RequestHandler e.g. MoreLikeThisHandler\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // get the new base docset for this facet\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd25fa3647fa73152703b8dccb4fb5f43633de20","date":1592060458,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#computeDocSet(DocSet,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#computeDocSet(DocSet,List[String]).mjava","sourceNew":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    // rb can be null if facets are being calculated from a RequestHandler e.g. MoreLikeThisHandler\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // get the new base docset for this facet\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getWithinGroupSortSpec().getSort());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      @SuppressWarnings({\"rawtypes\"})\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n\n","sourceOld":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    // rb can be null if facets are being calculated from a RequestHandler e.g. MoreLikeThisHandler\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    // add the base query\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    // add the filters\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    // get the new base docset for this facet\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getWithinGroupSortSpec().getSort());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1e9fbf0f8ed8f52f3f2580cd0a5fcd8cab1db43f":["20e94e61fe5291647346b70437617e6b6c370408"],"de65fb6e86ba37c5409efafefe587d0c897c2764":["22d0a81a05eba47d5e18976f17d88306b218cc22"],"20e94e61fe5291647346b70437617e6b6c370408":["de65fb6e86ba37c5409efafefe587d0c897c2764"],"85bef26bbc598445704c1f9c6d7953f3942d5426":["1e9fbf0f8ed8f52f3f2580cd0a5fcd8cab1db43f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"22d0a81a05eba47d5e18976f17d88306b218cc22":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["de65fb6e86ba37c5409efafefe587d0c897c2764","20e94e61fe5291647346b70437617e6b6c370408"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["85bef26bbc598445704c1f9c6d7953f3942d5426"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bd25fa3647fa73152703b8dccb4fb5f43633de20"]},"commit2Childs":{"1e9fbf0f8ed8f52f3f2580cd0a5fcd8cab1db43f":["85bef26bbc598445704c1f9c6d7953f3942d5426"],"de65fb6e86ba37c5409efafefe587d0c897c2764":["20e94e61fe5291647346b70437617e6b6c370408","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"20e94e61fe5291647346b70437617e6b6c370408":["1e9fbf0f8ed8f52f3f2580cd0a5fcd8cab1db43f","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"85bef26bbc598445704c1f9c6d7953f3942d5426":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["22d0a81a05eba47d5e18976f17d88306b218cc22"],"22d0a81a05eba47d5e18976f17d88306b218cc22":["de65fb6e86ba37c5409efafefe587d0c897c2764"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}