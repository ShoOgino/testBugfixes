{"path":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#getRandTerms(LeafReaderContext,int,boolean).mjava","commits":[{"id":"56fb5e4e4b239474721e13b4cd9542ea2d215451","date":1529091182,"type":0,"author":"Erick","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#getRandTerms(LeafReaderContext,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  // Get me some Ids to delete.\n  // So far this supposes that there are no deleted docs in the segment.\n  // When the numbers of docs in segments is small, rounding matters. So tests that want over a percentage\n  // pass \"true\" for roundUp, tests that want to be sure they're under some limit pass false.\n  private List<Term> getRandTerms(LeafReaderContext ctx, int pct, boolean roundUp) throws IOException {\n\n    assertFalse(\"This method assumes no deleted documents\", ctx.reader().hasDeletions());\n    // The indeterminate last segment is a pain, if we're there the number of docs is much less than we expect\n    List<Term> ret = new ArrayList<>(100);\n\n    double numDocs = ctx.reader().numDocs();\n    double tmp = (numDocs * (double) pct) / 100.0;\n\n    if (tmp <= 1.0) { // Calculations break down for segments with very few documents, the \"tail end Charlie\"\n      return ret;\n    }\n    int mod = (int) (numDocs / tmp);\n\n    if (mod == 0) return ret;\n\n    Terms terms = ctx.reader().terms(\"id\");\n    TermsEnum iter = terms.iterator();\n    int counter = 0;\n\n    // Small numbers are tricky, they're subject to off-by-one errors. bail if we're going to exceed our target if we add another doc.\n    int lim = (int) (numDocs * (double) pct / 100.0);\n    if (roundUp) ++lim;\n\n    for (BytesRef br = iter.next(); br != null && ret.size() < lim; br = iter.next()) {\n      if ((counter % mod) == 0) {\n        ret.add(new Term(\"id\", br));\n      }\n      ++counter;\n    }\n    return ret;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#getRandTerms(LeafReaderContext,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  // Get me some Ids to delete.\n  // So far this supposes that there are no deleted docs in the segment.\n  // When the numbers of docs in segments is small, rounding matters. So tests that want over a percentage\n  // pass \"true\" for roundUp, tests that want to be sure they're under some limit pass false.\n  private List<Term> getRandTerms(LeafReaderContext ctx, int pct, boolean roundUp) throws IOException {\n\n    assertFalse(\"This method assumes no deleted documents\", ctx.reader().hasDeletions());\n    // The indeterminate last segment is a pain, if we're there the number of docs is much less than we expect\n    List<Term> ret = new ArrayList<>(100);\n\n    double numDocs = ctx.reader().numDocs();\n    double tmp = (numDocs * (double) pct) / 100.0;\n\n    if (tmp <= 1.0) { // Calculations break down for segments with very few documents, the \"tail end Charlie\"\n      return ret;\n    }\n    int mod = (int) (numDocs / tmp);\n\n    if (mod == 0) return ret;\n\n    Terms terms = ctx.reader().terms(\"id\");\n    TermsEnum iter = terms.iterator();\n    int counter = 0;\n\n    // Small numbers are tricky, they're subject to off-by-one errors. bail if we're going to exceed our target if we add another doc.\n    int lim = (int) (numDocs * (double) pct / 100.0);\n    if (roundUp) ++lim;\n\n    for (BytesRef br = iter.next(); br != null && ret.size() < lim; br = iter.next()) {\n      if ((counter % mod) == 0) {\n        ret.add(new Term(\"id\", br));\n      }\n      ++counter;\n    }\n    return ret;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTieredMergePolicy#getRandTerms(LeafReaderContext,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  // Get me some Ids to delete.\n  // So far this supposes that there are no deleted docs in the segment.\n  // When the numbers of docs in segments is small, rounding matters. So tests that want over a percentage\n  // pass \"true\" for roundUp, tests that want to be sure they're under some limit pass false.\n  private List<Term> getRandTerms(LeafReaderContext ctx, int pct, boolean roundUp) throws IOException {\n\n    assertFalse(\"This method assumes no deleted documents\", ctx.reader().hasDeletions());\n    // The indeterminate last segment is a pain, if we're there the number of docs is much less than we expect\n    List<Term> ret = new ArrayList<>(100);\n\n    double numDocs = ctx.reader().numDocs();\n    double tmp = (numDocs * (double) pct) / 100.0;\n\n    if (tmp <= 1.0) { // Calculations break down for segments with very few documents, the \"tail end Charlie\"\n      return ret;\n    }\n    int mod = (int) (numDocs / tmp);\n\n    if (mod == 0) return ret;\n\n    Terms terms = ctx.reader().terms(\"id\");\n    TermsEnum iter = terms.iterator();\n    int counter = 0;\n\n    // Small numbers are tricky, they're subject to off-by-one errors. bail if we're going to exceed our target if we add another doc.\n    int lim = (int) (numDocs * (double) pct / 100.0);\n    if (roundUp) ++lim;\n\n    for (BytesRef br = iter.next(); br != null && ret.size() < lim; br = iter.next()) {\n      if ((counter % mod) == 0) {\n        ret.add(new Term(\"id\", br));\n      }\n      ++counter;\n    }\n    return ret;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","56fb5e4e4b239474721e13b4cd9542ea2d215451"],"56fb5e4e4b239474721e13b4cd9542ea2d215451":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["56fb5e4e4b239474721e13b4cd9542ea2d215451"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","56fb5e4e4b239474721e13b4cd9542ea2d215451"]},"commit2Childs":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"56fb5e4e4b239474721e13b4cd9542ea2d215451":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","56fb5e4e4b239474721e13b4cd9542ea2d215451","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}