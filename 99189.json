{"path":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#insertLong(int,int,int,long).mjava","commits":[{"id":"59ce67ef5584d0d65a576a6bbe06322cc84eb9b0","date":1412077943,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#insertLong(int,int,int,long).mjava","pathOld":"/dev/null","sourceNew":"  private void insertLong(int i4096, int i64, int i, long index) {\n    indices[i4096] |= 1L << i64; // shifts are mod 64 in java\n    // we count the number of bits that are set on the right of i64\n    // this gives us the index at which to perform the insertion\n    final int o = Long.bitCount(index & ((1L << i64) - 1));\n    final long[] bitArray = bits[i4096];\n    if (bitArray[bitArray.length - 1] == 0) {\n      // since we only store non-zero longs, if the last value is 0, it means\n      // that we alreay have extra space, make use of it\n      System.arraycopy(bitArray, o, bitArray, o + 1, bitArray.length - o - 1);\n      bitArray[o] = 1L << i;\n    } else {\n      // we don't have extra space so we need to resize to insert the new long\n      final int newSize = oversize(bitArray.length + 1);\n      final long[] newBitArray = new long[newSize];\n      System.arraycopy(bitArray, 0, newBitArray, 0, o);\n      newBitArray[o] = 1L << i;\n      System.arraycopy(bitArray, o, newBitArray, o + 1, bitArray.length - o);\n      bits[i4096] = newBitArray;\n      ramBytesUsed += (newSize - bitArray.length) * RamUsageEstimator.NUM_BYTES_LONG;\n    }\n    ++nonZeroLongCount;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9a47902d6207303f5ed3e7aaca62ca33433af66","date":1412435312,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#insertLong(int,int,int,long).mjava","pathOld":"/dev/null","sourceNew":"  private void insertLong(int i4096, int i64, int i, long index) {\n    indices[i4096] |= 1L << i64; // shifts are mod 64 in java\n    // we count the number of bits that are set on the right of i64\n    // this gives us the index at which to perform the insertion\n    final int o = Long.bitCount(index & ((1L << i64) - 1));\n    final long[] bitArray = bits[i4096];\n    if (bitArray[bitArray.length - 1] == 0) {\n      // since we only store non-zero longs, if the last value is 0, it means\n      // that we alreay have extra space, make use of it\n      System.arraycopy(bitArray, o, bitArray, o + 1, bitArray.length - o - 1);\n      bitArray[o] = 1L << i;\n    } else {\n      // we don't have extra space so we need to resize to insert the new long\n      final int newSize = oversize(bitArray.length + 1);\n      final long[] newBitArray = new long[newSize];\n      System.arraycopy(bitArray, 0, newBitArray, 0, o);\n      newBitArray[o] = 1L << i;\n      System.arraycopy(bitArray, o, newBitArray, o + 1, bitArray.length - o);\n      bits[i4096] = newBitArray;\n      ramBytesUsed += (newSize - bitArray.length) * RamUsageEstimator.NUM_BYTES_LONG;\n    }\n    ++nonZeroLongCount;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5132ed7492455ab92d26486037983253997f6c65","date":1413792495,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#insertLong(Block,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#insertLong(int,int,int,long).mjava","sourceNew":"  private void insertLong(Block block, int i64, int i) {\n    block.index |= 1L << i64; // shifts are mod 64 in java\n    // we count the number of bits that are set on the right of i64\n    // this gives us the index at which to perform the insertion\n    final int o = Long.bitCount(block.index & ((1L << i64) - 1));\n    if (block.bits[block.bits.length - 1] == 0) {\n      // since we only store non-zero longs, if the last value is 0, it means\n      // that we alreay have extra space, make use of it\n      System.arraycopy(block.bits, o, block.bits, o + 1, block.bits.length - o - 1);\n      block.bits[o] = 1L << i;\n    } else {\n      // we don't have extra space so we need to resize to insert the new long\n      final int newSize = oversize(block.bits.length + 1);\n      final long[] newBitArray = new long[newSize];\n      System.arraycopy(block.bits, 0, newBitArray, 0, o);\n      newBitArray[o] = 1L << i;\n      System.arraycopy(block.bits, o, newBitArray, o + 1, block.bits.length - o);\n      block.bits = newBitArray;\n      ramBytesUsed += (newSize - block.bits.length) * RamUsageEstimator.NUM_BYTES_LONG;\n    }\n    ++nonZeroLongCount;\n  }\n\n","sourceOld":"  private void insertLong(int i4096, int i64, int i, long index) {\n    indices[i4096] |= 1L << i64; // shifts are mod 64 in java\n    // we count the number of bits that are set on the right of i64\n    // this gives us the index at which to perform the insertion\n    final int o = Long.bitCount(index & ((1L << i64) - 1));\n    final long[] bitArray = bits[i4096];\n    if (bitArray[bitArray.length - 1] == 0) {\n      // since we only store non-zero longs, if the last value is 0, it means\n      // that we alreay have extra space, make use of it\n      System.arraycopy(bitArray, o, bitArray, o + 1, bitArray.length - o - 1);\n      bitArray[o] = 1L << i;\n    } else {\n      // we don't have extra space so we need to resize to insert the new long\n      final int newSize = oversize(bitArray.length + 1);\n      final long[] newBitArray = new long[newSize];\n      System.arraycopy(bitArray, 0, newBitArray, 0, o);\n      newBitArray[o] = 1L << i;\n      System.arraycopy(bitArray, o, newBitArray, o + 1, bitArray.length - o);\n      bits[i4096] = newBitArray;\n      ramBytesUsed += (newSize - bitArray.length) * RamUsageEstimator.NUM_BYTES_LONG;\n    }\n    ++nonZeroLongCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b97a073eaa927466c93dba638b34d56f1beef80a","date":1413793531,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#insertLong(int,int,int,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#insertLong(Block,int,int).mjava","sourceNew":"  private void insertLong(int i4096, int i64, int i, long index) {\n    indices[i4096] |= 1L << i64; // shifts are mod 64 in java\n    // we count the number of bits that are set on the right of i64\n    // this gives us the index at which to perform the insertion\n    final int o = Long.bitCount(index & ((1L << i64) - 1));\n    final long[] bitArray = bits[i4096];\n    if (bitArray[bitArray.length - 1] == 0) {\n      // since we only store non-zero longs, if the last value is 0, it means\n      // that we alreay have extra space, make use of it\n      System.arraycopy(bitArray, o, bitArray, o + 1, bitArray.length - o - 1);\n      bitArray[o] = 1L << i;\n    } else {\n      // we don't have extra space so we need to resize to insert the new long\n      final int newSize = oversize(bitArray.length + 1);\n      final long[] newBitArray = new long[newSize];\n      System.arraycopy(bitArray, 0, newBitArray, 0, o);\n      newBitArray[o] = 1L << i;\n      System.arraycopy(bitArray, o, newBitArray, o + 1, bitArray.length - o);\n      bits[i4096] = newBitArray;\n      ramBytesUsed += (newSize - bitArray.length) * RamUsageEstimator.NUM_BYTES_LONG;\n    }\n    ++nonZeroLongCount;\n  }\n\n","sourceOld":"  private void insertLong(Block block, int i64, int i) {\n    block.index |= 1L << i64; // shifts are mod 64 in java\n    // we count the number of bits that are set on the right of i64\n    // this gives us the index at which to perform the insertion\n    final int o = Long.bitCount(block.index & ((1L << i64) - 1));\n    if (block.bits[block.bits.length - 1] == 0) {\n      // since we only store non-zero longs, if the last value is 0, it means\n      // that we alreay have extra space, make use of it\n      System.arraycopy(block.bits, o, block.bits, o + 1, block.bits.length - o - 1);\n      block.bits[o] = 1L << i;\n    } else {\n      // we don't have extra space so we need to resize to insert the new long\n      final int newSize = oversize(block.bits.length + 1);\n      final long[] newBitArray = new long[newSize];\n      System.arraycopy(block.bits, 0, newBitArray, 0, o);\n      newBitArray[o] = 1L << i;\n      System.arraycopy(block.bits, o, newBitArray, o + 1, block.bits.length - o);\n      block.bits = newBitArray;\n      ramBytesUsed += (newSize - block.bits.length) * RamUsageEstimator.NUM_BYTES_LONG;\n    }\n    ++nonZeroLongCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"def2955814b2e8651b85cb7ad6e2b53626bacb7d","date":1423751097,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#insertLong(int,int,int,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#insertLong(int,int,int,long).mjava","sourceNew":"  private void insertLong(int i4096, int i64, int i, long index) {\n    indices[i4096] |= 1L << i64; // shifts are mod 64 in java\n    // we count the number of bits that are set on the right of i64\n    // this gives us the index at which to perform the insertion\n    final int o = Long.bitCount(index & ((1L << i64) - 1));\n    final long[] bitArray = bits[i4096];\n    if (bitArray[bitArray.length - 1] == 0) {\n      // since we only store non-zero longs, if the last value is 0, it means\n      // that we alreay have extra space, make use of it\n      System.arraycopy(bitArray, o, bitArray, o + 1, bitArray.length - o - 1);\n      bitArray[o] = 1L << i;\n    } else {\n      // we don't have extra space so we need to resize to insert the new long\n      final int newSize = oversize(bitArray.length + 1);\n      final long[] newBitArray = new long[newSize];\n      System.arraycopy(bitArray, 0, newBitArray, 0, o);\n      newBitArray[o] = 1L << i;\n      System.arraycopy(bitArray, o, newBitArray, o + 1, bitArray.length - o);\n      bits[i4096] = newBitArray;\n      ramBytesUsed += RamUsageEstimator.sizeOf(newBitArray) - RamUsageEstimator.sizeOf(bitArray);\n    }\n    ++nonZeroLongCount;\n  }\n\n","sourceOld":"  private void insertLong(int i4096, int i64, int i, long index) {\n    indices[i4096] |= 1L << i64; // shifts are mod 64 in java\n    // we count the number of bits that are set on the right of i64\n    // this gives us the index at which to perform the insertion\n    final int o = Long.bitCount(index & ((1L << i64) - 1));\n    final long[] bitArray = bits[i4096];\n    if (bitArray[bitArray.length - 1] == 0) {\n      // since we only store non-zero longs, if the last value is 0, it means\n      // that we alreay have extra space, make use of it\n      System.arraycopy(bitArray, o, bitArray, o + 1, bitArray.length - o - 1);\n      bitArray[o] = 1L << i;\n    } else {\n      // we don't have extra space so we need to resize to insert the new long\n      final int newSize = oversize(bitArray.length + 1);\n      final long[] newBitArray = new long[newSize];\n      System.arraycopy(bitArray, 0, newBitArray, 0, o);\n      newBitArray[o] = 1L << i;\n      System.arraycopy(bitArray, o, newBitArray, o + 1, bitArray.length - o);\n      bits[i4096] = newBitArray;\n      ramBytesUsed += (newSize - bitArray.length) * RamUsageEstimator.NUM_BYTES_LONG;\n    }\n    ++nonZeroLongCount;\n  }\n\n","bugFix":["b97a073eaa927466c93dba638b34d56f1beef80a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"def2955814b2e8651b85cb7ad6e2b53626bacb7d":["b97a073eaa927466c93dba638b34d56f1beef80a"],"5132ed7492455ab92d26486037983253997f6c65":["59ce67ef5584d0d65a576a6bbe06322cc84eb9b0"],"b97a073eaa927466c93dba638b34d56f1beef80a":["5132ed7492455ab92d26486037983253997f6c65"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","59ce67ef5584d0d65a576a6bbe06322cc84eb9b0"],"59ce67ef5584d0d65a576a6bbe06322cc84eb9b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["def2955814b2e8651b85cb7ad6e2b53626bacb7d"]},"commit2Childs":{"def2955814b2e8651b85cb7ad6e2b53626bacb7d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5132ed7492455ab92d26486037983253997f6c65":["b97a073eaa927466c93dba638b34d56f1beef80a"],"b97a073eaa927466c93dba638b34d56f1beef80a":["def2955814b2e8651b85cb7ad6e2b53626bacb7d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d9a47902d6207303f5ed3e7aaca62ca33433af66","59ce67ef5584d0d65a576a6bbe06322cc84eb9b0"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":[],"59ce67ef5584d0d65a576a6bbe06322cc84eb9b0":["5132ed7492455ab92d26486037983253997f6c65","d9a47902d6207303f5ed3e7aaca62ca33433af66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d9a47902d6207303f5ed3e7aaca62ca33433af66","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}