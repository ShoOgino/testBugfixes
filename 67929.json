{"path":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","commits":[{"id":"abb23fcc2461782ab204e61213240feb77d355aa","date":1422029612,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrClient baseClient = new HttpSolrClient(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseClient.setConnectionTimeout(30000);\n    baseClient.request(request);\n    baseClient.shutdown();\n    baseClient = null;\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrClient baseClient = new HttpSolrClient(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseClient.setConnectionTimeout(30000);\n    baseClient.request(request);\n    baseClient.shutdown();\n    baseClient = null;\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    try (HttpSolrClient baseClient = new HttpSolrClient(baseUrl)) {\n      // we only set the connect timeout, not so timeout\n      baseClient.setConnectionTimeout(30000);\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrClient baseClient = new HttpSolrClient(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseClient.setConnectionTimeout(30000);\n    baseClient.request(request);\n    baseClient.shutdown();\n    baseClient = null;\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    try (HttpSolrClient baseClient = getHttpSolrClient(baseUrl)) {\n      // we only set the connect timeout, not so timeout\n      baseClient.setConnectionTimeout(30000);\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    try (HttpSolrClient baseClient = new HttpSolrClient(baseUrl)) {\n      // we only set the connect timeout, not so timeout\n      baseClient.setConnectionTimeout(30000);\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    try (HttpSolrClient baseClient = getHttpSolrClient(baseUrl)) {\n      // we only set the connect timeout, not so timeout\n      baseClient.setConnectionTimeout(30000);\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    try (HttpSolrClient baseClient = new HttpSolrClient(baseUrl)) {\n      // we only set the connect timeout, not so timeout\n      baseClient.setConnectionTimeout(30000);\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43d1e498704edd2bba13548a189eed4dfccff11b","date":1499143458,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    // we only set the connect timeout, not so timeout\n    try (HttpSolrClient baseClient = getHttpSolrClient(baseUrl, 30000)) {\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    try (HttpSolrClient baseClient = getHttpSolrClient(baseUrl)) {\n      // we only set the connect timeout, not so timeout\n      baseClient.setConnectionTimeout(30000);\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2ea161f828a3a7a6eb9410a431aecda6d7ab1065","date":1499213384,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    // we only set the connect timeout, not so timeout\n    try (HttpSolrClient baseClient = getHttpSolrClient(baseUrl, 30000)) {\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    try (HttpSolrClient baseClient = getHttpSolrClient(baseUrl)) {\n      // we only set the connect timeout, not so timeout\n      baseClient.setConnectionTimeout(30000);\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    // we only set the connect timeout, not so timeout\n    try (HttpSolrClient baseClient = getHttpSolrClient(baseUrl, 30000)) {\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    leaderJetty.jetty.stop();\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    deadJetty.jetty.start(); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    leaderJetty.jetty.stop();\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    // we only set the connect timeout, not so timeout\n    try (HttpSolrClient baseClient = getHttpSolrClient(baseUrl, 30000)) {\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":["ce9115008b2600dda16a6765e06b6b380458c02f","efee511ca1fb9a8711021d261526526cf3e84890"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"add1e7dd742ea533ff4318cea83ca0a1f669f662","date":1585262285,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30, TimeUnit.SECONDS);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    // we only set the connect timeout, not so timeout\n    try (HttpSolrClient baseClient = getHttpSolrClient(baseUrl, 30000)) {\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15, TimeUnit.SECONDS);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    leaderJetty.jetty.stop();\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    deadJetty.jetty.start(); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    leaderJetty.jetty.stop();\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    // we only set the connect timeout, not so timeout\n    try (HttpSolrClient baseClient = getHttpSolrClient(baseUrl, 30000)) {\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    leaderJetty.jetty.stop();\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    deadJetty.jetty.start(); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    leaderJetty.jetty.stop();\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86745af74db00fc9c2e4c4dc67baee9d796a98dd","date":1587332960,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30, TimeUnit.SECONDS);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    // we only set the connect timeout, not so timeout\n    try (HttpSolrClient baseClient = getHttpSolrClient(baseUrl, 30000)) {\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15, TimeUnit.SECONDS);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    commit();\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    leaderJetty.jetty.stop();\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    deadJetty.jetty.start(); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    leaderJetty.jetty.stop();\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30, TimeUnit.SECONDS);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    // we only set the connect timeout, not so timeout\n    try (HttpSolrClient baseClient = getHttpSolrClient(baseUrl, 30000)) {\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15, TimeUnit.SECONDS);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    leaderJetty.jetty.stop();\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    deadJetty.jetty.start(); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    leaderJetty.jetty.stop();\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30, TimeUnit.SECONDS);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    // we only set the connect timeout, not so timeout\n    try (HttpSolrClient baseClient = getHttpSolrClient(baseUrl, 30000)) {\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15, TimeUnit.SECONDS);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    commit();\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    leaderJetty.jetty.stop();\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    deadJetty.jetty.start(); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    leaderJetty.jetty.stop();\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30, TimeUnit.SECONDS);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    // we only set the connect timeout, not so timeout\n    try (HttpSolrClient baseClient = getHttpSolrClient(baseUrl, 30000)) {\n      baseClient.request(request);\n    }\n\n    waitForThingsToLevelOut(15, TimeUnit.SECONDS);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    commit();\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    leaderJetty.jetty.stop();\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    deadJetty.jetty.start(); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    leaderJetty.jetty.stop();\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"43d1e498704edd2bba13548a189eed4dfccff11b":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["86745af74db00fc9c2e4c4dc67baee9d796a98dd"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","43d1e498704edd2bba13548a189eed4dfccff11b"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["43d1e498704edd2bba13548a189eed4dfccff11b"],"abb23fcc2461782ab204e61213240feb77d355aa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"add1e7dd742ea533ff4318cea83ca0a1f669f662":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"86745af74db00fc9c2e4c4dc67baee9d796a98dd":["add1e7dd742ea533ff4318cea83ca0a1f669f662"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["cc3b13b430571c2e169f98fe38e1e7666f88522d","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["abb23fcc2461782ab204e61213240feb77d355aa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"]},"commit2Childs":{"43d1e498704edd2bba13548a189eed4dfccff11b":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["add1e7dd742ea533ff4318cea83ca0a1f669f662"],"abb23fcc2461782ab204e61213240feb77d355aa":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["abb23fcc2461782ab204e61213240feb77d355aa"],"add1e7dd742ea533ff4318cea83ca0a1f669f662":["86745af74db00fc9c2e4c4dc67baee9d796a98dd"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["43d1e498704edd2bba13548a189eed4dfccff11b","2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"86745af74db00fc9c2e4c4dc67baee9d796a98dd":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}