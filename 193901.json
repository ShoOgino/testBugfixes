{"path":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","commits":[{"id":"070e0f665721fd467c6fcea5721fce31017180b7","date":1391560323,"type":0,"author":"Benson Margulies","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   * @throws IOException\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c100292f1eb936aa576edd3edc2c9333c7c731b3","date":1391588073,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   * @throws IOException\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"123698fbe83b595f9e084f0019cd35ab4a01d7f7","date":1399070065,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getIndexAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getIndexAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getIndexAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getIndexAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7c19b4ecf30c060f4d2e29c25f027e73262713d","date":1400023065,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getIndexAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getIndexAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(new DeleteByQueryWrapper(bq, core.getLatestSchema()));\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getIndexAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getIndexAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getIndexAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getIndexAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getIndexAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getIndexAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getIndexAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getIndexAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(new DeleteByQueryWrapper(bq, core.getLatestSchema()));\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getIndexAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getIndexAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getIndexAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getIndexAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getIndexAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getIndexAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getIndexAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getIndexAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(new DeleteByQueryWrapper(bq, core.getLatestSchema()));\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getIndexAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getIndexAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getIndexAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getIndexAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(bq);\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getIndexAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getIndexAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c1c5aa8e88aa52c9e1cbfc696b611d3a56223c0","date":1422781929,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd);\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument);\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(new DeleteByQueryWrapper(bq, core.getLatestSchema()));\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd);\n          } else {\n            writer.addDocument(cmd.getLuceneDocument());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd, schema.getIndexAnalyzer());\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument, schema.getIndexAnalyzer());\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(new DeleteByQueryWrapper(bq, core.getLatestSchema()));\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd, schema.getIndexAnalyzer());\n          } else {\n            writer.addDocument(cmd.getLuceneDocument(), schema.getIndexAnalyzer());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd);\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument);\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery.Builder bq = new BooleanQuery.Builder();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(new DeleteByQueryWrapper(bq.build(), core.getLatestSchema()));\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd);\n          } else {\n            writer.addDocument(cmd.getLuceneDocument());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd);\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument);\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery bq = new BooleanQuery();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(new DeleteByQueryWrapper(bq, core.getLatestSchema()));\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd);\n          } else {\n            writer.addDocument(cmd.getLuceneDocument());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b","date":1439091488,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n      addCommands.incrementAndGet();\n      addCommandsCumulative.incrementAndGet();\n      \n      // if there is no ID field, don't overwrite\n      if (idField == null) {\n        cmd.overwrite = false;\n      }\n      \n      try {\n        IndexSchema schema = cmd.getReq().getSchema();\n        \n        if (cmd.overwrite) {\n          \n          // Check for delete by query commands newer (i.e. reordered). This\n          // should always be null on a leader\n          List<UpdateLog.DBQ> deletesAfter = null;\n          if (ulog != null && cmd.version > 0) {\n            deletesAfter = ulog.getDBQNewer(cmd.version);\n          }\n          \n          if (deletesAfter != null) {\n            log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n                + deletesAfter);\n            List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n            for (UpdateLog.DBQ dbq : deletesAfter) {\n              try {\n                DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n                tmpDel.query = dbq.q;\n                tmpDel.version = -dbq.version;\n                dbqList.add(getQuery(tmpDel));\n              } catch (Exception e) {\n                log.error(\"Exception parsing reordered query : \" + dbq, e);\n              }\n            }\n            \n            addAndDelete(cmd, dbqList);\n          } else {\n            // normal update\n            \n            Term updateTerm;\n            Term idTerm = new Term(cmd.isBlock() ? \"_root_\" : idField.getName(), cmd.getIndexedId());\n            boolean del = false;\n            if (cmd.updateTerm == null) {\n              updateTerm = idTerm;\n            } else {\n              // this is only used by the dedup update processor\n              del = true;\n              updateTerm = cmd.updateTerm;\n            }\n\n            if (cmd.isBlock()) {\n              writer.updateDocuments(updateTerm, cmd);\n            } else {\n              Document luceneDocument = cmd.getLuceneDocument();\n              // SolrCore.verbose(\"updateDocument\",updateTerm,luceneDocument,writer);\n              writer.updateDocument(updateTerm, luceneDocument);\n            }\n            // SolrCore.verbose(\"updateDocument\",updateTerm,\"DONE\");\n            \n            if (del) { // ensure id remains unique\n              BooleanQuery.Builder bq = new BooleanQuery.Builder();\n              bq.add(new BooleanClause(new TermQuery(updateTerm),\n                  Occur.MUST_NOT));\n              bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n              writer.deleteDocuments(new DeleteByQueryWrapper(bq.build(), core.getLatestSchema()));\n            }\n            \n            // Add to the transaction log *after* successfully adding to the\n            // index, if there was no error.\n            // This ordering ensures that if we log it, it's definitely been\n            // added to the the index.\n            // This also ensures that if a commit sneaks in-between, that we\n            // know everything in a particular\n            // log version was definitely committed.\n            if (ulog != null) ulog.add(cmd);\n          }\n          \n        } else {\n          // allow duplicates\n          if (cmd.isBlock()) {\n            writer.addDocuments(cmd);\n          } else {\n            writer.addDocument(cmd.getLuceneDocument());\n          }\n\n          if (ulog != null) ulog.add(cmd);\n        }\n        \n        if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n          if (commitWithinSoftCommit) {\n            commitTracker.addedDocument(-1);\n            softCommitTracker.addedDocument(cmd.commitWithin);\n          } else {\n            softCommitTracker.addedDocument(-1);\n            commitTracker.addedDocument(cmd.commitWithin);\n          }\n        }\n        \n        rc = 1;\n      } finally {\n        if (rc != 1) {\n          numErrors.incrementAndGet();\n          numErrorsCumulative.incrementAndGet();\n        } else {\n          numDocsPending.incrementAndGet();\n        }\n      }\n      \n    } finally {\n      iw.decref();\n    }\n    \n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"463ff5a7b8ae719d6644ca5ddc7ff9bf3f1babb4","date":1452118928,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc0(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc0fbfa191179ae7a0081ee1cf7da0464bcd8078","date":1469530061,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.increment();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.increment();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.increment();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.increment();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.increment();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.increment();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e52c21eddb989aed5815d30ea4c8abf481ace8ad","date":1488795043,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.mark();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.increment();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.increment();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.mark();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if ( (cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.add(cmd);\n        return 1;\n      }\n\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.mark();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.mark();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if ( (cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.add(cmd);\n        return 1;\n      }\n\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.mark();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.mark();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if ( (cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.add(cmd);\n        return 1;\n      }\n\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.mark();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.mark();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.add(cmd);\n        return 1;\n      }\n\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.mark();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if ( (cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.add(cmd);\n        return 1;\n      }\n\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.mark();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.add(cmd);\n        return 1;\n      }\n\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.mark();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if ( (cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.add(cmd);\n        return 1;\n      }\n\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d07d6c279b65daaca32ee033fa06e4d7e85e0dd","date":1525384847,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc0(AddUpdateCommand).mjava","sourceNew":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.mark();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.add(cmd);\n        return 1;\n      }\n\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        long currentTlogSize = getCurrentTLogSize();\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1, currentTlogSize);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin, currentTlogSize);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  /**\n   * This is the implementation of {@link #addDoc(AddUpdateCommand)}. It is factored out to allow an exception\n   * handler to decorate RuntimeExceptions with information about the document being handled.\n   * @param cmd the command.\n   * @return the count.\n   */\n  private int addDoc0(AddUpdateCommand cmd) throws IOException {\n    int rc = -1;\n\n    addCommands.increment();\n    addCommandsCumulative.mark();\n\n    // if there is no ID field, don't overwrite\n    if (idField == null) {\n      cmd.overwrite = false;\n    }\n    try {\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.add(cmd);\n        return 1;\n      }\n\n      if (cmd.overwrite) {\n        // Check for delete by query commands newer (i.e. reordered). This\n        // should always be null on a leader\n        List<UpdateLog.DBQ> deletesAfter = null;\n        if (ulog != null && cmd.version > 0) {\n          deletesAfter = ulog.getDBQNewer(cmd.version);\n        }\n\n        if (deletesAfter != null) {\n          addAndDelete(cmd, deletesAfter);\n        } else {\n          doNormalUpdate(cmd);\n        }\n      } else {\n        allowDuplicateUpdate(cmd);\n      }\n\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {\n        if (commitWithinSoftCommit) {\n          commitTracker.addedDocument(-1);\n          softCommitTracker.addedDocument(cmd.commitWithin);\n        } else {\n          softCommitTracker.addedDocument(-1);\n          commitTracker.addedDocument(cmd.commitWithin);\n        }\n      }\n\n      rc = 1;\n    } finally {\n      if (rc != 1) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      } else {\n        numDocsPending.increment();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"070e0f665721fd467c6fcea5721fce31017180b7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c100292f1eb936aa576edd3edc2c9333c7c731b3"],"61c45e99cf6676da48f19d7511c73712ad39402b":["be320990bdc77e643388fa801e75017f19289c42"],"4d07d6c279b65daaca32ee033fa06e4d7e85e0dd":["61c45e99cf6676da48f19d7511c73712ad39402b"],"bc0fbfa191179ae7a0081ee1cf7da0464bcd8078":["463ff5a7b8ae719d6644ca5ddc7ff9bf3f1babb4"],"56572ec06f1407c066d6b7399413178b33176cd8":["123698fbe83b595f9e084f0019cd35ab4a01d7f7","93dd449115a9247533e44bab47e8429e5dccbc6d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["463ff5a7b8ae719d6644ca5ddc7ff9bf3f1babb4","bc0fbfa191179ae7a0081ee1cf7da0464bcd8078"],"5c1c5aa8e88aa52c9e1cbfc696b611d3a56223c0":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["5c1c5aa8e88aa52c9e1cbfc696b611d3a56223c0"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["ab68488225b6a6c357dda72ed11dedca9914a192","61c45e99cf6676da48f19d7511c73712ad39402b"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["e52c21eddb989aed5815d30ea4c8abf481ace8ad"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["123698fbe83b595f9e084f0019cd35ab4a01d7f7","c7c19b4ecf30c060f4d2e29c25f027e73262713d"],"123698fbe83b595f9e084f0019cd35ab4a01d7f7":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"463ff5a7b8ae719d6644ca5ddc7ff9bf3f1babb4":["76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b"],"e52c21eddb989aed5815d30ea4c8abf481ace8ad":["bc0fbfa191179ae7a0081ee1cf7da0464bcd8078"],"c100292f1eb936aa576edd3edc2c9333c7c731b3":["070e0f665721fd467c6fcea5721fce31017180b7"],"be320990bdc77e643388fa801e75017f19289c42":["e52c21eddb989aed5815d30ea4c8abf481ace8ad"],"76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"c7c19b4ecf30c060f4d2e29c25f027e73262713d":["123698fbe83b595f9e084f0019cd35ab4a01d7f7"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e52c21eddb989aed5815d30ea4c8abf481ace8ad","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["463ff5a7b8ae719d6644ca5ddc7ff9bf3f1babb4","bc0fbfa191179ae7a0081ee1cf7da0464bcd8078"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4d07d6c279b65daaca32ee033fa06e4d7e85e0dd"]},"commit2Childs":{"070e0f665721fd467c6fcea5721fce31017180b7":["c100292f1eb936aa576edd3edc2c9333c7c731b3"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["123698fbe83b595f9e084f0019cd35ab4a01d7f7"],"61c45e99cf6676da48f19d7511c73712ad39402b":["4d07d6c279b65daaca32ee033fa06e4d7e85e0dd","e9017cf144952056066919f1ebc7897ff9bd71b1"],"4d07d6c279b65daaca32ee033fa06e4d7e85e0dd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bc0fbfa191179ae7a0081ee1cf7da0464bcd8078":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e52c21eddb989aed5815d30ea4c8abf481ace8ad","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"5c1c5aa8e88aa52c9e1cbfc696b611d3a56223c0":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","5c1c5aa8e88aa52c9e1cbfc696b611d3a56223c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["070e0f665721fd467c6fcea5721fce31017180b7"],"123698fbe83b595f9e084f0019cd35ab4a01d7f7":["56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d","c7c19b4ecf30c060f4d2e29c25f027e73262713d"],"463ff5a7b8ae719d6644ca5ddc7ff9bf3f1babb4":["bc0fbfa191179ae7a0081ee1cf7da0464bcd8078","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"e52c21eddb989aed5815d30ea4c8abf481ace8ad":["f996f8177b9204bdc92f7164460c6cefad9ac99a","be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192"],"c100292f1eb936aa576edd3edc2c9333c7c731b3":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"be320990bdc77e643388fa801e75017f19289c42":["61c45e99cf6676da48f19d7511c73712ad39402b"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"c7c19b4ecf30c060f4d2e29c25f027e73262713d":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b":["463ff5a7b8ae719d6644ca5ddc7ff9bf3f1babb4"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["56572ec06f1407c066d6b7399413178b33176cd8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e9017cf144952056066919f1ebc7897ff9bd71b1","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}