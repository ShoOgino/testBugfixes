{"path":"lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory#doCacheWrite(String,IOContext).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory#doCacheWrite(String,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/NRTCachingDirectory#doCacheWrite(String,IOContext).mjava","sourceNew":"  /** Subclass can override this to customize logic; return\n   *  true if this file should be written to the RAMDirectory. */\n  protected boolean doCacheWrite(String name, IOContext context) {\n    final MergeInfo merge = context.mergeInfo;\n    //System.out.println(Thread.currentThread().getName() + \": CACHE check merge=\" + merge + \" size=\" + (merge==null ? 0 : merge.estimatedMergeBytes));\n    return !name.equals(IndexFileNames.SEGMENTS_GEN) && (merge == null || merge.estimatedMergeBytes <= maxMergeSizeBytes) && cache.sizeInBytes() <= maxCachedBytes;\n  }\n\n","sourceOld":"  /** Subclass can override this to customize logic; return\n   *  true if this file should be written to the RAMDirectory. */\n  protected boolean doCacheWrite(String name, IOContext context) {\n    final MergeInfo merge = context.mergeInfo;\n    //System.out.println(Thread.currentThread().getName() + \": CACHE check merge=\" + merge + \" size=\" + (merge==null ? 0 : merge.estimatedMergeBytes));\n    return !name.equals(IndexFileNames.SEGMENTS_GEN) && (merge == null || merge.estimatedMergeBytes <= maxMergeSizeBytes) && cache.sizeInBytes() <= maxCachedBytes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b43cc463de57963524b3835202575c1662c9e927","date":1346784739,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory#doCacheWrite(String,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory#doCacheWrite(String,IOContext).mjava","sourceNew":"  /** Subclass can override this to customize logic; return\n   *  true if this file should be written to the RAMDirectory. */\n  protected boolean doCacheWrite(String name, IOContext context) {\n    //System.out.println(Thread.currentThread().getName() + \": CACHE check merge=\" + merge + \" size=\" + (merge==null ? 0 : merge.estimatedMergeBytes));\n\n    long bytes = 0;\n    if (context.mergeInfo != null) {\n      bytes = context.mergeInfo.estimatedMergeBytes;\n    } else if (context.flushInfo != null) {\n      bytes = context.flushInfo.estimatedSegmentSize;\n    }\n\n    return !name.equals(IndexFileNames.SEGMENTS_GEN) && (bytes <= maxMergeSizeBytes) && (bytes + cache.sizeInBytes()) <= maxCachedBytes;\n  }\n\n","sourceOld":"  /** Subclass can override this to customize logic; return\n   *  true if this file should be written to the RAMDirectory. */\n  protected boolean doCacheWrite(String name, IOContext context) {\n    final MergeInfo merge = context.mergeInfo;\n    //System.out.println(Thread.currentThread().getName() + \": CACHE check merge=\" + merge + \" size=\" + (merge==null ? 0 : merge.estimatedMergeBytes));\n    return !name.equals(IndexFileNames.SEGMENTS_GEN) && (merge == null || merge.estimatedMergeBytes <= maxMergeSizeBytes) && cache.sizeInBytes() <= maxCachedBytes;\n  }\n\n","bugFix":null,"bugIntro":["8405d98acebb7e287bf7ac40e937ba05b8661285"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8405d98acebb7e287bf7ac40e937ba05b8661285","date":1401433291,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory#doCacheWrite(String,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory#doCacheWrite(String,IOContext).mjava","sourceNew":"  /** Subclass can override this to customize logic; return\n   *  true if this file should be written to the RAMDirectory. */\n  protected boolean doCacheWrite(String name, IOContext context) {\n    //System.out.println(Thread.currentThread().getName() + \": CACHE check merge=\" + merge + \" size=\" + (merge==null ? 0 : merge.estimatedMergeBytes));\n\n    long bytes = 0;\n    if (context.mergeInfo != null) {\n      bytes = context.mergeInfo.estimatedMergeBytes;\n    } else if (context.flushInfo != null) {\n      bytes = context.flushInfo.estimatedSegmentSize;\n    }\n\n    return !name.equals(IndexFileNames.SEGMENTS_GEN) && (bytes <= maxMergeSizeBytes) && (bytes + cache.ramBytesUsed()) <= maxCachedBytes;\n  }\n\n","sourceOld":"  /** Subclass can override this to customize logic; return\n   *  true if this file should be written to the RAMDirectory. */\n  protected boolean doCacheWrite(String name, IOContext context) {\n    //System.out.println(Thread.currentThread().getName() + \": CACHE check merge=\" + merge + \" size=\" + (merge==null ? 0 : merge.estimatedMergeBytes));\n\n    long bytes = 0;\n    if (context.mergeInfo != null) {\n      bytes = context.mergeInfo.estimatedMergeBytes;\n    } else if (context.flushInfo != null) {\n      bytes = context.flushInfo.estimatedSegmentSize;\n    }\n\n    return !name.equals(IndexFileNames.SEGMENTS_GEN) && (bytes <= maxMergeSizeBytes) && (bytes + cache.sizeInBytes()) <= maxCachedBytes;\n  }\n\n","bugFix":["b43cc463de57963524b3835202575c1662c9e927"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46e4a8bdfbafda795ef9c39a2bc2d47095770299","date":1410411846,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory#doCacheWrite(String,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory#doCacheWrite(String,IOContext).mjava","sourceNew":"  /** Subclass can override this to customize logic; return\n   *  true if this file should be written to the RAMDirectory. */\n  protected boolean doCacheWrite(String name, IOContext context) {\n    //System.out.println(Thread.currentThread().getName() + \": CACHE check merge=\" + merge + \" size=\" + (merge==null ? 0 : merge.estimatedMergeBytes));\n\n    long bytes = 0;\n    if (context.mergeInfo != null) {\n      bytes = context.mergeInfo.estimatedMergeBytes;\n    } else if (context.flushInfo != null) {\n      bytes = context.flushInfo.estimatedSegmentSize;\n    }\n\n    return (bytes <= maxMergeSizeBytes) && (bytes + cache.ramBytesUsed()) <= maxCachedBytes;\n  }\n\n","sourceOld":"  /** Subclass can override this to customize logic; return\n   *  true if this file should be written to the RAMDirectory. */\n  protected boolean doCacheWrite(String name, IOContext context) {\n    //System.out.println(Thread.currentThread().getName() + \": CACHE check merge=\" + merge + \" size=\" + (merge==null ? 0 : merge.estimatedMergeBytes));\n\n    long bytes = 0;\n    if (context.mergeInfo != null) {\n      bytes = context.mergeInfo.estimatedMergeBytes;\n    } else if (context.flushInfo != null) {\n      bytes = context.flushInfo.estimatedSegmentSize;\n    }\n\n    return !name.equals(IndexFileNames.SEGMENTS_GEN) && (bytes <= maxMergeSizeBytes) && (bytes + cache.ramBytesUsed()) <= maxCachedBytes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d77dafd89756a5161d244985903e3487ca109182","date":1548679743,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory#doCacheWrite(String,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory#doCacheWrite(String,IOContext).mjava","sourceNew":"  /** Subclass can override this to customize logic; return\n   *  true if this file should be written to the RAM-based cache first. */\n  protected boolean doCacheWrite(String name, IOContext context) {\n    //System.out.println(Thread.currentThread().getName() + \": CACHE check merge=\" + merge + \" size=\" + (merge==null ? 0 : merge.estimatedMergeBytes));\n\n    long bytes = 0;\n    if (context.mergeInfo != null) {\n      bytes = context.mergeInfo.estimatedMergeBytes;\n    } else if (context.flushInfo != null) {\n      bytes = context.flushInfo.estimatedSegmentSize;\n    }\n\n    return (bytes <= maxMergeSizeBytes) && (bytes + cacheSize.get()) <= maxCachedBytes;\n  }\n\n","sourceOld":"  /** Subclass can override this to customize logic; return\n   *  true if this file should be written to the RAMDirectory. */\n  protected boolean doCacheWrite(String name, IOContext context) {\n    //System.out.println(Thread.currentThread().getName() + \": CACHE check merge=\" + merge + \" size=\" + (merge==null ? 0 : merge.estimatedMergeBytes));\n\n    long bytes = 0;\n    if (context.mergeInfo != null) {\n      bytes = context.mergeInfo.estimatedMergeBytes;\n    } else if (context.flushInfo != null) {\n      bytes = context.flushInfo.estimatedSegmentSize;\n    }\n\n    return (bytes <= maxMergeSizeBytes) && (bytes + cache.ramBytesUsed()) <= maxCachedBytes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38689ac0d37a49898fab4fdee871375e5d032d08","date":1578579330,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory#doCacheWrite(String,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory#doCacheWrite(String,IOContext).mjava","sourceNew":"  /** Subclass can override this to customize logic; return\n   *  true if this file should be written to the RAM-based cache first. */\n  protected boolean doCacheWrite(String name, IOContext context) {\n    //System.out.println(Thread.currentThread().getName() + \": CACHE check merge=\" + merge + \" size=\" + (merge==null ? 0 : merge.estimatedMergeBytes));\n\n    long bytes = 0;\n    if (context.mergeInfo != null) {\n      bytes = context.mergeInfo.estimatedMergeBytes;\n    } else if (context.flushInfo != null) {\n      bytes = context.flushInfo.estimatedSegmentSize;\n    } else {\n      return false;\n    }\n\n    return (bytes <= maxMergeSizeBytes) && (bytes + cacheSize.get()) <= maxCachedBytes;\n  }\n\n","sourceOld":"  /** Subclass can override this to customize logic; return\n   *  true if this file should be written to the RAM-based cache first. */\n  protected boolean doCacheWrite(String name, IOContext context) {\n    //System.out.println(Thread.currentThread().getName() + \": CACHE check merge=\" + merge + \" size=\" + (merge==null ? 0 : merge.estimatedMergeBytes));\n\n    long bytes = 0;\n    if (context.mergeInfo != null) {\n      bytes = context.mergeInfo.estimatedMergeBytes;\n    } else if (context.flushInfo != null) {\n      bytes = context.flushInfo.estimatedSegmentSize;\n    }\n\n    return (bytes <= maxMergeSizeBytes) && (bytes + cacheSize.get()) <= maxCachedBytes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24dab91095bdf34d602ca5a18f81df6cb308709f","date":1578594129,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory#doCacheWrite(String,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory#doCacheWrite(String,IOContext).mjava","sourceNew":"  /** Subclass can override this to customize logic; return\n   *  true if this file should be written to the RAM-based cache first. */\n  protected boolean doCacheWrite(String name, IOContext context) {\n    //System.out.println(Thread.currentThread().getName() + \": CACHE check merge=\" + merge + \" size=\" + (merge==null ? 0 : merge.estimatedMergeBytes));\n\n    long bytes = 0;\n    if (context.mergeInfo != null) {\n      bytes = context.mergeInfo.estimatedMergeBytes;\n    } else if (context.flushInfo != null) {\n      bytes = context.flushInfo.estimatedSegmentSize;\n    } else {\n      return false;\n    }\n\n    return (bytes <= maxMergeSizeBytes) && (bytes + cacheSize.get()) <= maxCachedBytes;\n  }\n\n","sourceOld":"  /** Subclass can override this to customize logic; return\n   *  true if this file should be written to the RAM-based cache first. */\n  protected boolean doCacheWrite(String name, IOContext context) {\n    //System.out.println(Thread.currentThread().getName() + \": CACHE check merge=\" + merge + \" size=\" + (merge==null ? 0 : merge.estimatedMergeBytes));\n\n    long bytes = 0;\n    if (context.mergeInfo != null) {\n      bytes = context.mergeInfo.estimatedMergeBytes;\n    } else if (context.flushInfo != null) {\n      bytes = context.flushInfo.estimatedSegmentSize;\n    }\n\n    return (bytes <= maxMergeSizeBytes) && (bytes + cacheSize.get()) <= maxCachedBytes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38689ac0d37a49898fab4fdee871375e5d032d08":["d77dafd89756a5161d244985903e3487ca109182"],"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["8405d98acebb7e287bf7ac40e937ba05b8661285"],"b43cc463de57963524b3835202575c1662c9e927":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"8405d98acebb7e287bf7ac40e937ba05b8661285":["b43cc463de57963524b3835202575c1662c9e927"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d77dafd89756a5161d244985903e3487ca109182":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"24dab91095bdf34d602ca5a18f81df6cb308709f":["d77dafd89756a5161d244985903e3487ca109182","38689ac0d37a49898fab4fdee871375e5d032d08"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["38689ac0d37a49898fab4fdee871375e5d032d08"]},"commit2Childs":{"38689ac0d37a49898fab4fdee871375e5d032d08":["24dab91095bdf34d602ca5a18f81df6cb308709f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["d77dafd89756a5161d244985903e3487ca109182"],"b43cc463de57963524b3835202575c1662c9e927":["8405d98acebb7e287bf7ac40e937ba05b8661285"],"8405d98acebb7e287bf7ac40e937ba05b8661285":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["b43cc463de57963524b3835202575c1662c9e927"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d77dafd89756a5161d244985903e3487ca109182":["38689ac0d37a49898fab4fdee871375e5d032d08","24dab91095bdf34d602ca5a18f81df6cb308709f"],"24dab91095bdf34d602ca5a18f81df6cb308709f":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["24dab91095bdf34d602ca5a18f81df6cb308709f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}