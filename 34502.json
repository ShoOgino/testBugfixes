{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","commits":[{"id":"51b92ffe30c50bb08699200b62c40420378ac3df","date":1423881454,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","pathOld":"/dev/null","sourceNew":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery();\n    qRequest.setQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"preferLocalShards\", Boolean.toString(preferLocalShards));\n    qParams.add(\"shards.info\", \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query (qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(\"shards.info\");\n    assertNotNull(\"Unable to obtain shards.info\", shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in shards.info\", e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(\"shards.info did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db25f0478122f5ca8792a23291340660ff47b05c","date":1435511884,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","sourceNew":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery();\n    qRequest.setQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"preferLocalShards\", Boolean.toString(preferLocalShards));\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query (qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","sourceOld":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery();\n    qRequest.setQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"preferLocalShards\", Boolean.toString(preferLocalShards));\n    qParams.add(\"shards.info\", \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query (qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(\"shards.info\");\n    assertNotNull(\"Unable to obtain shards.info\", shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in shards.info\", e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(\"shards.info did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b940572a59da1b42b6c20ab5278155b12816807a","date":1462388874,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","sourceNew":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"preferLocalShards\", Boolean.toString(preferLocalShards));\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","sourceOld":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery();\n    qRequest.setQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"preferLocalShards\", Boolean.toString(preferLocalShards));\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query (qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd78ba595fa6cdd7fff930f26d154d13a823fa47","date":1462400514,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","sourceNew":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"preferLocalShards\", Boolean.toString(preferLocalShards));\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","sourceOld":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery();\n    qRequest.setQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"preferLocalShards\", Boolean.toString(preferLocalShards));\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query (qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73450c0955930295d34703e7ddbfc6973b7a121a","date":1462431925,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","sourceNew":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"preferLocalShards\", Boolean.toString(preferLocalShards));\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","sourceOld":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery();\n    qRequest.setQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"preferLocalShards\", Boolean.toString(preferLocalShards));\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query (qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","sourceNew":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"preferLocalShards\", Boolean.toString(preferLocalShards));\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","sourceOld":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery();\n    qRequest.setQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"preferLocalShards\", Boolean.toString(preferLocalShards));\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query (qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"304ef848381e39ff6cf3e7af6127733a6f4db389","date":1482353305,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","sourceNew":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(CommonParams.PREFER_LOCAL_SHARDS, Boolean.toString(preferLocalShards));\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","sourceOld":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"preferLocalShards\", Boolean.toString(preferLocalShards));\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","sourceNew":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(CommonParams.PREFER_LOCAL_SHARDS, Boolean.toString(preferLocalShards));\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","sourceOld":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"preferLocalShards\", Boolean.toString(preferLocalShards));\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a2576170b353998ba9157b6d148ebfde21138316","date":1523488980,"type":5,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithShardsPreferenceRules(CloudSolrClient,boolean,String).mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","sourceNew":"  @SuppressWarnings(\"deprecation\")\n  private void queryWithShardsPreferenceRules(CloudSolrClient cloudClient,\n                                          boolean useShardsPreference,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    if (useShardsPreference) {\n      qParams.add(ShardParams.SHARDS_PREFERENCE, ShardParams.SHARDS_PREFERENCE_REPLICA_LOCATION + \":\" + ShardParams.REPLICA_LOCAL);\n    } else {\n      qParams.add(CommonParams.PREFER_LOCAL_SHARDS, \"true\");\n    }\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    Set<Integer> ports = new HashSet<Integer>();\n    for (String shardAddr: shardAddresses) {\n      URL url = new URL (shardAddr);\n      ports.add(url.getPort());\n    }\n\n    // This assertion would hold true as long as every shard has a core on each node\n    assertTrue (\"Response was not received from shards on a single node\",\n        shardAddresses.size() > 1 && ports.size()==1);\n  }\n\n","sourceOld":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(CommonParams.PREFER_LOCAL_SHARDS, Boolean.toString(preferLocalShards));\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1f5a9deac6e313e80a1f56468e14bb4c491b83d7","date":1523529596,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithShardsPreferenceRules(CloudSolrClient,boolean,String).mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#queryWithPreferLocalShards(CloudSolrClient,boolean,String).mjava","sourceNew":"  @SuppressWarnings(\"deprecation\")\n  private void queryWithShardsPreferenceRules(CloudSolrClient cloudClient,\n                                          boolean useShardsPreference,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    if (useShardsPreference) {\n      qParams.add(ShardParams.SHARDS_PREFERENCE, ShardParams.SHARDS_PREFERENCE_REPLICA_LOCATION + \":\" + ShardParams.REPLICA_LOCAL);\n    } else {\n      qParams.add(CommonParams.PREFER_LOCAL_SHARDS, \"true\");\n    }\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    Set<Integer> ports = new HashSet<Integer>();\n    for (String shardAddr: shardAddresses) {\n      URL url = new URL (shardAddr);\n      ports.add(url.getPort());\n    }\n\n    // This assertion would hold true as long as every shard has a core on each node\n    assertTrue (\"Response was not received from shards on a single node\",\n        shardAddresses.size() > 1 && ports.size()==1);\n  }\n\n","sourceOld":"  private void queryWithPreferLocalShards(CloudSolrClient cloudClient,\n                                          boolean preferLocalShards,\n                                          String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(CommonParams.PREFER_LOCAL_SHARDS, Boolean.toString(preferLocalShards));\n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    // CloudSolrClient sends the request to some node.\n    // And since all the nodes are hosting cores from all shards, the\n    // distributed query formed by this node will select cores from the\n    // local shards only\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    // Iterate over shards-info and check what cores responded\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      shardAddresses.add(shardAddress);\n    }\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n\n    // Make sure the distributed queries were directed to a single node only\n    if (preferLocalShards) {\n      Set<Integer> ports = new HashSet<Integer>();\n      for (String shardAddr: shardAddresses) {\n        URL url = new URL (shardAddr);\n        ports.add(url.getPort());\n      }\n\n      // This assertion would hold true as long as every shard has a core on each node\n      assertTrue (\"Response was not received from shards on a single node\",\n          shardAddresses.size() > 1 && ports.size()==1);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bd78ba595fa6cdd7fff930f26d154d13a823fa47":["db25f0478122f5ca8792a23291340660ff47b05c","b940572a59da1b42b6c20ab5278155b12816807a"],"51b92ffe30c50bb08699200b62c40420378ac3df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1f5a9deac6e313e80a1f56468e14bb4c491b83d7":["304ef848381e39ff6cf3e7af6127733a6f4db389","a2576170b353998ba9157b6d148ebfde21138316"],"73450c0955930295d34703e7ddbfc6973b7a121a":["db25f0478122f5ca8792a23291340660ff47b05c","b940572a59da1b42b6c20ab5278155b12816807a"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["db25f0478122f5ca8792a23291340660ff47b05c","73450c0955930295d34703e7ddbfc6973b7a121a"],"db25f0478122f5ca8792a23291340660ff47b05c":["51b92ffe30c50bb08699200b62c40420378ac3df"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b940572a59da1b42b6c20ab5278155b12816807a":["db25f0478122f5ca8792a23291340660ff47b05c"],"304ef848381e39ff6cf3e7af6127733a6f4db389":["73450c0955930295d34703e7ddbfc6973b7a121a"],"a2576170b353998ba9157b6d148ebfde21138316":["304ef848381e39ff6cf3e7af6127733a6f4db389"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1f5a9deac6e313e80a1f56468e14bb4c491b83d7"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["bd78ba595fa6cdd7fff930f26d154d13a823fa47","304ef848381e39ff6cf3e7af6127733a6f4db389"]},"commit2Childs":{"bd78ba595fa6cdd7fff930f26d154d13a823fa47":["f03e4bed5023ec3ef93a771b8888cae991cf448d"],"51b92ffe30c50bb08699200b62c40420378ac3df":["db25f0478122f5ca8792a23291340660ff47b05c"],"1f5a9deac6e313e80a1f56468e14bb4c491b83d7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"73450c0955930295d34703e7ddbfc6973b7a121a":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","304ef848381e39ff6cf3e7af6127733a6f4db389"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"db25f0478122f5ca8792a23291340660ff47b05c":["bd78ba595fa6cdd7fff930f26d154d13a823fa47","73450c0955930295d34703e7ddbfc6973b7a121a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","b940572a59da1b42b6c20ab5278155b12816807a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["51b92ffe30c50bb08699200b62c40420378ac3df"],"b940572a59da1b42b6c20ab5278155b12816807a":["bd78ba595fa6cdd7fff930f26d154d13a823fa47","73450c0955930295d34703e7ddbfc6973b7a121a"],"304ef848381e39ff6cf3e7af6127733a6f4db389":["1f5a9deac6e313e80a1f56468e14bb4c491b83d7","a2576170b353998ba9157b6d148ebfde21138316","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"a2576170b353998ba9157b6d148ebfde21138316":["1f5a9deac6e313e80a1f56468e14bb4c491b83d7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[]},"heads":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}