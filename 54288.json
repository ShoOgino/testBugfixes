{"path":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateMergeThreads().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateMergeThreads().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateMergeThreads().mjava","sourceNew":"  /**\n   * Called whenever the running merges have changed, to pause & unpause\n   * threads. This method sorts the merge threads by their merge size in\n   * descending order and then pauses/unpauses threads from first to last --\n   * that way, smaller merges are guaranteed to run before larger ones.\n   */\n  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive & not in the\n    // process of stopping (ie have an active merge):\n    final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n      final MergeThread mergeThread = mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      if (mergeThread.getCurrentMerge() != null) {\n        activeMerges.add(mergeThread);\n      }\n      threadIdx++;\n    }\n\n    // Sort the merge threads in descending order.\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    \n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n      final MergeThread mergeThread = activeMerges.get(threadIdx);\n      final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n      if (merge == null) { \n        continue;\n      }\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n\n      if (verbose()) {\n        if (doPause != merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause != merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Called whenever the running merges have changed, to pause & unpause\n   * threads. This method sorts the merge threads by their merge size in\n   * descending order and then pauses/unpauses threads from first to last --\n   * that way, smaller merges are guaranteed to run before larger ones.\n   */\n  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive & not in the\n    // process of stopping (ie have an active merge):\n    final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n      final MergeThread mergeThread = mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      if (mergeThread.getCurrentMerge() != null) {\n        activeMerges.add(mergeThread);\n      }\n      threadIdx++;\n    }\n\n    // Sort the merge threads in descending order.\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    \n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n      final MergeThread mergeThread = activeMerges.get(threadIdx);\n      final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n      if (merge == null) { \n        continue;\n      }\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n\n      if (verbose()) {\n        if (doPause != merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause != merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dcc555744b1a581a4beccd0b75f8d3fe49735a2f","date":1367588265,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateMergeThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateMergeThreads().mjava","sourceNew":"  /**\n   * Called whenever the running merges have changed, to pause & unpause\n   * threads. This method sorts the merge threads by their merge size in\n   * descending order and then pauses/unpauses threads from first to last --\n   * that way, smaller merges are guaranteed to run before larger ones.\n   */\n  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive & not in the\n    // process of stopping (ie have an active merge):\n    final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n      final MergeThread mergeThread = mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      if (mergeThread.getCurrentMerge() != null) {\n        activeMerges.add(mergeThread);\n      }\n      threadIdx++;\n    }\n\n    // Sort the merge threads in descending order.\n    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n    \n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n      final MergeThread mergeThread = activeMerges.get(threadIdx);\n      final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n      if (merge == null) { \n        continue;\n      }\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n\n      if (verbose()) {\n        if (doPause != merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause != merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Called whenever the running merges have changed, to pause & unpause\n   * threads. This method sorts the merge threads by their merge size in\n   * descending order and then pauses/unpauses threads from first to last --\n   * that way, smaller merges are guaranteed to run before larger ones.\n   */\n  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive & not in the\n    // process of stopping (ie have an active merge):\n    final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n      final MergeThread mergeThread = mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      if (mergeThread.getCurrentMerge() != null) {\n        activeMerges.add(mergeThread);\n      }\n      threadIdx++;\n    }\n\n    // Sort the merge threads in descending order.\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    \n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n      final MergeThread mergeThread = activeMerges.get(threadIdx);\n      final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n      if (merge == null) { \n        continue;\n      }\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n\n      if (verbose()) {\n        if (doPause != merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause != merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateMergeThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateMergeThreads().mjava","sourceNew":"  /**\n   * Called whenever the running merges have changed, to pause & unpause\n   * threads. This method sorts the merge threads by their merge size in\n   * descending order and then pauses/unpauses threads from first to last --\n   * that way, smaller merges are guaranteed to run before larger ones.\n   */\n  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive & not in the\n    // process of stopping (ie have an active merge):\n    final List<MergeThread> activeMerges = new ArrayList<>();\n\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n      final MergeThread mergeThread = mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      if (mergeThread.getCurrentMerge() != null) {\n        activeMerges.add(mergeThread);\n      }\n      threadIdx++;\n    }\n\n    // Sort the merge threads in descending order.\n    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n    \n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n      final MergeThread mergeThread = activeMerges.get(threadIdx);\n      final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n      if (merge == null) { \n        continue;\n      }\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n\n      if (verbose()) {\n        if (doPause != merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause != merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Called whenever the running merges have changed, to pause & unpause\n   * threads. This method sorts the merge threads by their merge size in\n   * descending order and then pauses/unpauses threads from first to last --\n   * that way, smaller merges are guaranteed to run before larger ones.\n   */\n  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive & not in the\n    // process of stopping (ie have an active merge):\n    final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n      final MergeThread mergeThread = mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      if (mergeThread.getCurrentMerge() != null) {\n        activeMerges.add(mergeThread);\n      }\n      threadIdx++;\n    }\n\n    // Sort the merge threads in descending order.\n    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n    \n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n      final MergeThread mergeThread = activeMerges.get(threadIdx);\n      final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n      if (merge == null) { \n        continue;\n      }\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n\n      if (verbose()) {\n        if (doPause != merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause != merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateMergeThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateMergeThreads().mjava","sourceNew":"  /**\n   * Called whenever the running merges have changed, to pause and unpause\n   * threads. This method sorts the merge threads by their merge size in\n   * descending order and then pauses/unpauses threads from first to last --\n   * that way, smaller merges are guaranteed to run before larger ones.\n   */\n  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive & not in the\n    // process of stopping (ie have an active merge):\n    final List<MergeThread> activeMerges = new ArrayList<>();\n\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n      final MergeThread mergeThread = mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      if (mergeThread.getCurrentMerge() != null) {\n        activeMerges.add(mergeThread);\n      }\n      threadIdx++;\n    }\n\n    // Sort the merge threads in descending order.\n    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n    \n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n      final MergeThread mergeThread = activeMerges.get(threadIdx);\n      final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n      if (merge == null) { \n        continue;\n      }\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n\n      if (verbose()) {\n        if (doPause != merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause != merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Called whenever the running merges have changed, to pause & unpause\n   * threads. This method sorts the merge threads by their merge size in\n   * descending order and then pauses/unpauses threads from first to last --\n   * that way, smaller merges are guaranteed to run before larger ones.\n   */\n  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive & not in the\n    // process of stopping (ie have an active merge):\n    final List<MergeThread> activeMerges = new ArrayList<>();\n\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n      final MergeThread mergeThread = mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      if (mergeThread.getCurrentMerge() != null) {\n        activeMerges.add(mergeThread);\n      }\n      threadIdx++;\n    }\n\n    // Sort the merge threads in descending order.\n    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n    \n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n      final MergeThread mergeThread = activeMerges.get(threadIdx);\n      final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n      if (merge == null) { \n        continue;\n      }\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n\n      if (verbose()) {\n        if (doPause != merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause != merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateMergeThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateMergeThreads().mjava","sourceNew":"  /**\n   * Called whenever the running merges have changed, to set merge IO limits.\n   * This method sorts the merge threads by their merge size in\n   * descending order and then pauses/unpauses threads from first to last --\n   * that way, smaller merges are guaranteed to run before larger ones.\n   */\n\n  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive & not in the\n    // process of stopping (ie have an active merge):\n    final List<MergeThread> activeMerges = new ArrayList<>();\n\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n      final MergeThread mergeThread = mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      activeMerges.add(mergeThread);\n      threadIdx++;\n    }\n\n    // Sort the merge threads, largest first:\n    CollectionUtil.timSort(activeMerges);\n\n    final int activeMergeCount = activeMerges.size();\n\n    int bigMergeCount = 0;\n\n    for (threadIdx=activeMergeCount-1;threadIdx>=0;threadIdx--) {\n      MergeThread mergeThread = activeMerges.get(threadIdx);\n      if (mergeThread.merge.estimatedMergeBytes > MIN_BIG_MERGE_MB*1024*1024) {\n        bigMergeCount = 1+threadIdx;\n        break;\n      }\n    }\n\n    long now = System.nanoTime();\n\n    StringBuilder message;\n    if (verbose()) {\n      message = new StringBuilder();\n      message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle=%s targetMBPerSec=%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n    } else {\n      message = null;\n    }\n\n    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n      MergeThread mergeThread = activeMerges.get(threadIdx);\n\n      OneMerge merge = mergeThread.merge;\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause = threadIdx < bigMergeCount - maxThreadCount;\n\n      double newMBPerSec;\n      if (doPause) {\n        newMBPerSec = 0.0;\n      } else if (merge.maxNumSegments != -1) {\n        newMBPerSec = forceMergeMBPerSec;\n      } else if (doAutoIOThrottle == false) {\n        newMBPerSec = Double.POSITIVE_INFINITY;\n      } else if (merge.estimatedMergeBytes < MIN_BIG_MERGE_MB*1024*1024) {\n        // Don't rate limit small merges:\n        newMBPerSec = Double.POSITIVE_INFINITY;\n      } else {\n        newMBPerSec = targetMBPerSec;\n      }\n\n      double curMBPerSec = merge.rateLimiter.getMBPerSec();\n      \n      if (verbose()) {\n        long mergeStartNS = merge.mergeStartNS;\n        if (mergeStartNS == -1) {\n          // IndexWriter didn't start the merge yet:\n          mergeStartNS = now;\n        }\n        message.append('\\n');\n        message.append(String.format(Locale.ROOT, \"merge thread %s estSize=%.1f MB (written=%.1f MB) runTime=%.1fs (stopped=%.1fs, paused=%.1fs) rate=%s\\n\",\n                                     mergeThread.getName(),\n                                     bytesToMB(merge.estimatedMergeBytes),\n                                     bytesToMB(merge.rateLimiter.totalBytesWritten),\n                                     nsToSec(now - mergeStartNS),\n                                     nsToSec(merge.rateLimiter.getTotalStoppedNS()),\n                                     nsToSec(merge.rateLimiter.getTotalPausedNS()),\n                                     rateToString(merge.rateLimiter.getMBPerSec())));\n\n        if (newMBPerSec != curMBPerSec) {\n          if (newMBPerSec == 0.0) {\n            message.append(\"  now stop\");\n          } else if (curMBPerSec == 0.0) {\n            if (newMBPerSec == Double.POSITIVE_INFINITY) {\n              message.append(\"  now resume\");\n            } else {\n              message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n            }\n          } else {\n            message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n          }\n        } else if (curMBPerSec == 0.0) {\n          message.append(\"  leave stopped\");\n        } else {\n          message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n        }\n      }\n\n      merge.rateLimiter.setMBPerSec(newMBPerSec);\n    }\n    if (verbose()) {\n      message(message.toString());\n    }\n  }\n\n","sourceOld":"  /**\n   * Called whenever the running merges have changed, to pause and unpause\n   * threads. This method sorts the merge threads by their merge size in\n   * descending order and then pauses/unpauses threads from first to last --\n   * that way, smaller merges are guaranteed to run before larger ones.\n   */\n  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive & not in the\n    // process of stopping (ie have an active merge):\n    final List<MergeThread> activeMerges = new ArrayList<>();\n\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n      final MergeThread mergeThread = mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      if (mergeThread.getCurrentMerge() != null) {\n        activeMerges.add(mergeThread);\n      }\n      threadIdx++;\n    }\n\n    // Sort the merge threads in descending order.\n    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n    \n    int pri = mergeThreadPriority;\n    final int activeMergeCount = activeMerges.size();\n    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n      final MergeThread mergeThread = activeMerges.get(threadIdx);\n      final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n      if (merge == null) { \n        continue;\n      }\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n\n      if (verbose()) {\n        if (doPause != merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause != merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1ee9437ba5a8297220428d48a6bb823d1fcd57b","date":1489137809,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateMergeThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#updateMergeThreads().mjava","sourceNew":"  /**\n   * Called whenever the running merges have changed, to set merge IO limits.\n   * This method sorts the merge threads by their merge size in\n   * descending order and then pauses/unpauses threads from first to last --\n   * that way, smaller merges are guaranteed to run before larger ones.\n   */\n\n  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive & not in the\n    // process of stopping (ie have an active merge):\n    final List<MergeThread> activeMerges = new ArrayList<>();\n\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n      final MergeThread mergeThread = mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      activeMerges.add(mergeThread);\n      threadIdx++;\n    }\n\n    // Sort the merge threads, largest first:\n    CollectionUtil.timSort(activeMerges);\n\n    final int activeMergeCount = activeMerges.size();\n\n    int bigMergeCount = 0;\n\n    for (threadIdx=activeMergeCount-1;threadIdx>=0;threadIdx--) {\n      MergeThread mergeThread = activeMerges.get(threadIdx);\n      if (mergeThread.merge.estimatedMergeBytes > MIN_BIG_MERGE_MB*1024*1024) {\n        bigMergeCount = 1+threadIdx;\n        break;\n      }\n    }\n\n    long now = System.nanoTime();\n\n    StringBuilder message;\n    if (verbose()) {\n      message = new StringBuilder();\n      message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle=%s targetMBPerSec=%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n    } else {\n      message = null;\n    }\n\n    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n      MergeThread mergeThread = activeMerges.get(threadIdx);\n\n      OneMerge merge = mergeThread.merge;\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause = threadIdx < bigMergeCount - maxThreadCount;\n\n      double newMBPerSec;\n      if (doPause) {\n        newMBPerSec = 0.0;\n      } else if (merge.maxNumSegments != -1) {\n        newMBPerSec = forceMergeMBPerSec;\n      } else if (doAutoIOThrottle == false) {\n        newMBPerSec = Double.POSITIVE_INFINITY;\n      } else if (merge.estimatedMergeBytes < MIN_BIG_MERGE_MB*1024*1024) {\n        // Don't rate limit small merges:\n        newMBPerSec = Double.POSITIVE_INFINITY;\n      } else {\n        newMBPerSec = targetMBPerSec;\n      }\n\n      MergeRateLimiter rateLimiter = mergeThread.rateLimiter;\n      double curMBPerSec = rateLimiter.getMBPerSec();\n\n      if (verbose()) {\n        long mergeStartNS = merge.mergeStartNS;\n        if (mergeStartNS == -1) {\n          // IndexWriter didn't start the merge yet:\n          mergeStartNS = now;\n        }\n        message.append('\\n');\n        message.append(String.format(Locale.ROOT, \"merge thread %s estSize=%.1f MB (written=%.1f MB) runTime=%.1fs (stopped=%.1fs, paused=%.1fs) rate=%s\\n\",\n                                     mergeThread.getName(),\n                                     bytesToMB(merge.estimatedMergeBytes),\n                                     bytesToMB(rateLimiter.getTotalBytesWritten()),\n                                     nsToSec(now - mergeStartNS),\n                                     nsToSec(rateLimiter.getTotalStoppedNS()),\n                                     nsToSec(rateLimiter.getTotalPausedNS()),\n                                     rateToString(rateLimiter.getMBPerSec())));\n\n        if (newMBPerSec != curMBPerSec) {\n          if (newMBPerSec == 0.0) {\n            message.append(\"  now stop\");\n          } else if (curMBPerSec == 0.0) {\n            if (newMBPerSec == Double.POSITIVE_INFINITY) {\n              message.append(\"  now resume\");\n            } else {\n              message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n            }\n          } else {\n            message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n          }\n        } else if (curMBPerSec == 0.0) {\n          message.append(\"  leave stopped\");\n        } else {\n          message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n        }\n      }\n\n      rateLimiter.setMBPerSec(newMBPerSec);\n    }\n    if (verbose()) {\n      message(message.toString());\n    }\n  }\n\n","sourceOld":"  /**\n   * Called whenever the running merges have changed, to set merge IO limits.\n   * This method sorts the merge threads by their merge size in\n   * descending order and then pauses/unpauses threads from first to last --\n   * that way, smaller merges are guaranteed to run before larger ones.\n   */\n\n  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive & not in the\n    // process of stopping (ie have an active merge):\n    final List<MergeThread> activeMerges = new ArrayList<>();\n\n    int threadIdx = 0;\n    while (threadIdx < mergeThreads.size()) {\n      final MergeThread mergeThread = mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      activeMerges.add(mergeThread);\n      threadIdx++;\n    }\n\n    // Sort the merge threads, largest first:\n    CollectionUtil.timSort(activeMerges);\n\n    final int activeMergeCount = activeMerges.size();\n\n    int bigMergeCount = 0;\n\n    for (threadIdx=activeMergeCount-1;threadIdx>=0;threadIdx--) {\n      MergeThread mergeThread = activeMerges.get(threadIdx);\n      if (mergeThread.merge.estimatedMergeBytes > MIN_BIG_MERGE_MB*1024*1024) {\n        bigMergeCount = 1+threadIdx;\n        break;\n      }\n    }\n\n    long now = System.nanoTime();\n\n    StringBuilder message;\n    if (verbose()) {\n      message = new StringBuilder();\n      message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle=%s targetMBPerSec=%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n    } else {\n      message = null;\n    }\n\n    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n      MergeThread mergeThread = activeMerges.get(threadIdx);\n\n      OneMerge merge = mergeThread.merge;\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause = threadIdx < bigMergeCount - maxThreadCount;\n\n      double newMBPerSec;\n      if (doPause) {\n        newMBPerSec = 0.0;\n      } else if (merge.maxNumSegments != -1) {\n        newMBPerSec = forceMergeMBPerSec;\n      } else if (doAutoIOThrottle == false) {\n        newMBPerSec = Double.POSITIVE_INFINITY;\n      } else if (merge.estimatedMergeBytes < MIN_BIG_MERGE_MB*1024*1024) {\n        // Don't rate limit small merges:\n        newMBPerSec = Double.POSITIVE_INFINITY;\n      } else {\n        newMBPerSec = targetMBPerSec;\n      }\n\n      double curMBPerSec = merge.rateLimiter.getMBPerSec();\n      \n      if (verbose()) {\n        long mergeStartNS = merge.mergeStartNS;\n        if (mergeStartNS == -1) {\n          // IndexWriter didn't start the merge yet:\n          mergeStartNS = now;\n        }\n        message.append('\\n');\n        message.append(String.format(Locale.ROOT, \"merge thread %s estSize=%.1f MB (written=%.1f MB) runTime=%.1fs (stopped=%.1fs, paused=%.1fs) rate=%s\\n\",\n                                     mergeThread.getName(),\n                                     bytesToMB(merge.estimatedMergeBytes),\n                                     bytesToMB(merge.rateLimiter.totalBytesWritten),\n                                     nsToSec(now - mergeStartNS),\n                                     nsToSec(merge.rateLimiter.getTotalStoppedNS()),\n                                     nsToSec(merge.rateLimiter.getTotalPausedNS()),\n                                     rateToString(merge.rateLimiter.getMBPerSec())));\n\n        if (newMBPerSec != curMBPerSec) {\n          if (newMBPerSec == 0.0) {\n            message.append(\"  now stop\");\n          } else if (curMBPerSec == 0.0) {\n            if (newMBPerSec == Double.POSITIVE_INFINITY) {\n              message.append(\"  now resume\");\n            } else {\n              message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n            }\n          } else {\n            message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n          }\n        } else if (curMBPerSec == 0.0) {\n          message.append(\"  leave stopped\");\n        } else {\n          message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n        }\n      }\n\n      merge.rateLimiter.setMBPerSec(newMBPerSec);\n    }\n    if (verbose()) {\n      message(message.toString());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["dcc555744b1a581a4beccd0b75f8d3fe49735a2f"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dcc555744b1a581a4beccd0b75f8d3fe49735a2f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"]},"commit2Childs":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["dcc555744b1a581a4beccd0b75f8d3fe49735a2f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"dcc555744b1a581a4beccd0b75f8d3fe49735a2f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}