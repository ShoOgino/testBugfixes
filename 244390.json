{"path":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random, dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random.nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random.nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random.nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random.nextBoolean()) {\n          id = allIDsList.get(random.nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random.nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random.nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random, dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random.nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random.nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random.nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random.nextBoolean()) {\n          id = allIDsList.get(random.nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random.nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random.nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a78a90fc9701e511308346ea29f4f5e548bb39fe","date":1329489995,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random, dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random.nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random.nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random.nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random.nextBoolean()) {\n          id = allIDsList.get(random.nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random.nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random.nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random, dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random.nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random.nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random.nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random.nextBoolean()) {\n          id = allIDsList.get(random.nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random.nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random.nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random().nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random, dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random.nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random.nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random.nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random.nextBoolean()) {\n          id = allIDsList.get(random.nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random.nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random.nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random().nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random().nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1fc791afc075c00a9ce29ca03eca7a6c143c28a","date":1341671452,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random().nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random().nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2acf500f78aa12b92e371fd89c719291986b6b90","date":1341846236,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random().nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random().nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46d8ada1fff8d18cb197c38c7983225162599948","date":1341853497,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random().nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random().nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random().nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random().nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173","date":1365631993,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random().nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random().nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8","date":1373996650,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random().nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random().nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d245db17aaa41b338dae9da5d4edba4dd6f61612","date":1394644847,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n\n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n\n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.shutdown();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n\n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n\n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.shutdown();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n\n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.shutdown();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n\n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n\n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.shutdown();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n\n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator();\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n\n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"470eaac3a77cf637b62126a5408b178d7be93eb1","date":1531830722,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n\n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.count(new TermQuery(new Term(\"id\", id))));\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator();\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n\n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator();\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n\n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.count(new TermQuery(new Term(\"id\", id))));\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator();\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n\n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator();\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e775de416dd2d8067b10db1c8af975a1d5017e","date":1539906554,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n\n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.count(new TermQuery(new Term(\"id\", id))));\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiTerms.getTerms(r, \"id\").iterator();\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n                                                  newIndexWriterConfig(new MockAnalyzer(random())).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n      doc.add(idField);\n\n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(Locale.ROOT, \"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random().nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setStringValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = newSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(Locale.ROOT, \"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random().nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random().nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.count(new TermQuery(new Term(\"id\", id))));\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator();\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random().nextBoolean()) {\n          id = allIDsList.get(random().nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random().nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(Locale.ROOT, \"%07da\", idv);\n            nextID = String.format(Locale.ROOT, \"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id))) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id));\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"d245db17aaa41b338dae9da5d4edba4dd6f61612":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2acf500f78aa12b92e371fd89c719291986b6b90":["04f07771a2a7dd3a395700665ed839c3dae2def2","c1fc791afc075c00a9ce29ca03eca7a6c143c28a"],"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173":["2acf500f78aa12b92e371fd89c719291986b6b90"],"46d8ada1fff8d18cb197c38c7983225162599948":["04f07771a2a7dd3a395700665ed839c3dae2def2","2acf500f78aa12b92e371fd89c719291986b6b90"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","470eaac3a77cf637b62126a5408b178d7be93eb1"],"c1fc791afc075c00a9ce29ca03eca7a6c143c28a":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["04f07771a2a7dd3a395700665ed839c3dae2def2","2acf500f78aa12b92e371fd89c719291986b6b90"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["3b0e8c39ca08b5a02de6edcd33d6f3b90b865173"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["470eaac3a77cf637b62126a5408b178d7be93eb1"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["d245db17aaa41b338dae9da5d4edba4dd6f61612"],"470eaac3a77cf637b62126a5408b178d7be93eb1":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["3b0e8c39ca08b5a02de6edcd33d6f3b90b865173"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["04e775de416dd2d8067b10db1c8af975a1d5017e"]},"commit2Childs":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","470eaac3a77cf637b62126a5408b178d7be93eb1"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d245db17aaa41b338dae9da5d4edba4dd6f61612"],"d245db17aaa41b338dae9da5d4edba4dd6f61612":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"2acf500f78aa12b92e371fd89c719291986b6b90":["3b0e8c39ca08b5a02de6edcd33d6f3b90b865173","46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"46d8ada1fff8d18cb197c38c7983225162599948":[],"04f07771a2a7dd3a395700665ed839c3dae2def2":["2acf500f78aa12b92e371fd89c719291986b6b90","46d8ada1fff8d18cb197c38c7983225162599948","c1fc791afc075c00a9ce29ca03eca7a6c143c28a","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"c1fc791afc075c00a9ce29ca03eca7a6c143c28a":["2acf500f78aa12b92e371fd89c719291986b6b90"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"470eaac3a77cf637b62126a5408b178d7be93eb1":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","04e775de416dd2d8067b10db1c8af975a1d5017e"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["46d8ada1fff8d18cb197c38c7983225162599948","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","fe33227f6805edab2036cbb80645cc4e2d1fa424","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}