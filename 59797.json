{"path":"solr/core/src/java/org/apache/solr/cloud/Overseer.ExclusiveSliceProperty#ExclusiveSliceProperty(ClusterStateUpdater,ClusterState,ZkNodeProps).mjava","commits":[{"id":"64707d25b6352cf02909d3916038a3b3cec7f0a8","date":1412782122,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ExclusiveSliceProperty#ExclusiveSliceProperty(ClusterStateUpdater,ClusterState,ZkNodeProps).mjava","pathOld":"/dev/null","sourceNew":"    ExclusiveSliceProperty(ClusterStateUpdater updater, ClusterState clusterState, ZkNodeProps message) {\n      this.updater = updater;\n      this.clusterState = clusterState;\n      String tmp = message.getStr(ZkStateReader.PROPERTY_PROP);\n      if (StringUtils.startsWith(tmp, OverseerCollectionProcessor.COLL_PROP_PREFIX) == false) {\n        tmp = OverseerCollectionProcessor.COLL_PROP_PREFIX + tmp;\n      }\n      this.property = tmp.toLowerCase(Locale.ROOT);\n      collectionName = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n      if (StringUtils.isBlank(collectionName) || StringUtils.isBlank(property)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Overseer '\" + message.getStr(QUEUE_OPERATION) + \"'  requires both the '\" + ZkStateReader.COLLECTION_PROP + \"' and '\" +\n                ZkStateReader.PROPERTY_PROP + \"' parameters. No action taken \");\n      }\n\n      Boolean sliceUnique = Boolean.parseBoolean(message.getStr(SLICE_UNIQUE));\n      if (sliceUnique == false &&\n          Overseer.sliceUniqueBooleanProperties.contains(this.property) == false) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Balancing properties amongst replicas in a slice requires that\"\n            + \" the property be a pre-defined property (e.g. 'preferredLeader') or that 'sliceUnique' be set to 'true' \" +\n            \" Property: \" + this.property + \" sliceUnique: \" + Boolean.toString(sliceUnique));\n      }\n\n      collection = clusterState.getCollection(collectionName);\n      if (collection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Could not find collection ' \" + collectionName + \"' for overseer operation '\" +\n                message.getStr(QUEUE_OPERATION) + \"'. No action taken.\");\n      }\n      onlyActiveNodes = Boolean.parseBoolean(message.getStr(ONLY_ACTIVE_NODES, \"true\"));\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ExclusiveSliceProperty#ExclusiveSliceProperty(ClusterStateUpdater,ClusterState,ZkNodeProps).mjava","pathOld":"/dev/null","sourceNew":"    ExclusiveSliceProperty(ClusterStateUpdater updater, ClusterState clusterState, ZkNodeProps message) {\n      this.updater = updater;\n      this.clusterState = clusterState;\n      String tmp = message.getStr(ZkStateReader.PROPERTY_PROP);\n      if (StringUtils.startsWith(tmp, OverseerCollectionProcessor.COLL_PROP_PREFIX) == false) {\n        tmp = OverseerCollectionProcessor.COLL_PROP_PREFIX + tmp;\n      }\n      this.property = tmp.toLowerCase(Locale.ROOT);\n      collectionName = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n      if (StringUtils.isBlank(collectionName) || StringUtils.isBlank(property)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Overseer '\" + message.getStr(QUEUE_OPERATION) + \"'  requires both the '\" + ZkStateReader.COLLECTION_PROP + \"' and '\" +\n                ZkStateReader.PROPERTY_PROP + \"' parameters. No action taken \");\n      }\n\n      Boolean sliceUnique = Boolean.parseBoolean(message.getStr(SLICE_UNIQUE));\n      if (sliceUnique == false &&\n          Overseer.sliceUniqueBooleanProperties.contains(this.property) == false) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Balancing properties amongst replicas in a slice requires that\"\n            + \" the property be a pre-defined property (e.g. 'preferredLeader') or that 'sliceUnique' be set to 'true' \" +\n            \" Property: \" + this.property + \" sliceUnique: \" + Boolean.toString(sliceUnique));\n      }\n\n      collection = clusterState.getCollection(collectionName);\n      if (collection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Could not find collection ' \" + collectionName + \"' for overseer operation '\" +\n                message.getStr(QUEUE_OPERATION) + \"'. No action taken.\");\n      }\n      onlyActiveNodes = Boolean.parseBoolean(message.getStr(ONLY_ACTIVE_NODES, \"true\"));\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cfb61c9baefa8681e40fca3c803f61bf485a9d8d","date":1414979559,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ExclusiveSliceProperty#ExclusiveSliceProperty(ClusterStateUpdater,ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ExclusiveSliceProperty#ExclusiveSliceProperty(ClusterStateUpdater,ClusterState,ZkNodeProps).mjava","sourceNew":"    ExclusiveSliceProperty(ClusterStateUpdater updater, ClusterState clusterState, ZkNodeProps message) {\n      this.updater = updater;\n      this.clusterState = clusterState;\n      String tmp = message.getStr(ZkStateReader.PROPERTY_PROP);\n      if (StringUtils.startsWith(tmp, OverseerCollectionProcessor.COLL_PROP_PREFIX) == false) {\n        tmp = OverseerCollectionProcessor.COLL_PROP_PREFIX + tmp;\n      }\n      this.property = tmp.toLowerCase(Locale.ROOT);\n      collectionName = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n      if (StringUtils.isBlank(collectionName) || StringUtils.isBlank(property)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Overseer '\" + message.getStr(QUEUE_OPERATION) + \"'  requires both the '\" + ZkStateReader.COLLECTION_PROP + \"' and '\" +\n                ZkStateReader.PROPERTY_PROP + \"' parameters. No action taken \");\n      }\n\n      Boolean shardUnique = Boolean.parseBoolean(message.getStr(SHARD_UNIQUE));\n      if (shardUnique == false &&\n          Overseer.sliceUniqueBooleanProperties.contains(this.property) == false) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Balancing properties amongst replicas in a slice requires that\"\n            + \" the property be a pre-defined property (e.g. 'preferredLeader') or that 'shardUnique' be set to 'true' \" +\n            \" Property: \" + this.property + \" shardUnique: \" + Boolean.toString(shardUnique));\n      }\n\n      collection = clusterState.getCollection(collectionName);\n      if (collection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Could not find collection ' \" + collectionName + \"' for overseer operation '\" +\n                message.getStr(QUEUE_OPERATION) + \"'. No action taken.\");\n      }\n      onlyActiveNodes = Boolean.parseBoolean(message.getStr(ONLY_ACTIVE_NODES, \"true\"));\n    }\n\n","sourceOld":"    ExclusiveSliceProperty(ClusterStateUpdater updater, ClusterState clusterState, ZkNodeProps message) {\n      this.updater = updater;\n      this.clusterState = clusterState;\n      String tmp = message.getStr(ZkStateReader.PROPERTY_PROP);\n      if (StringUtils.startsWith(tmp, OverseerCollectionProcessor.COLL_PROP_PREFIX) == false) {\n        tmp = OverseerCollectionProcessor.COLL_PROP_PREFIX + tmp;\n      }\n      this.property = tmp.toLowerCase(Locale.ROOT);\n      collectionName = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n      if (StringUtils.isBlank(collectionName) || StringUtils.isBlank(property)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Overseer '\" + message.getStr(QUEUE_OPERATION) + \"'  requires both the '\" + ZkStateReader.COLLECTION_PROP + \"' and '\" +\n                ZkStateReader.PROPERTY_PROP + \"' parameters. No action taken \");\n      }\n\n      Boolean sliceUnique = Boolean.parseBoolean(message.getStr(SLICE_UNIQUE));\n      if (sliceUnique == false &&\n          Overseer.sliceUniqueBooleanProperties.contains(this.property) == false) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Balancing properties amongst replicas in a slice requires that\"\n            + \" the property be a pre-defined property (e.g. 'preferredLeader') or that 'sliceUnique' be set to 'true' \" +\n            \" Property: \" + this.property + \" sliceUnique: \" + Boolean.toString(sliceUnique));\n      }\n\n      collection = clusterState.getCollection(collectionName);\n      if (collection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Could not find collection ' \" + collectionName + \"' for overseer operation '\" +\n                message.getStr(QUEUE_OPERATION) + \"'. No action taken.\");\n      }\n      onlyActiveNodes = Boolean.parseBoolean(message.getStr(ONLY_ACTIVE_NODES, \"true\"));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"24a5da2a0d397ff29f3de8f6cf451d3412c2509a","date":1417276391,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ExclusiveSliceProperty#ExclusiveSliceProperty(ClusterStateUpdater,ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ExclusiveSliceProperty#ExclusiveSliceProperty(ClusterStateUpdater,ClusterState,ZkNodeProps).mjava","sourceNew":"    ExclusiveSliceProperty(ClusterStateUpdater updater, ClusterState clusterState, ZkNodeProps message) {\n      this.updater = updater;\n      this.clusterState = clusterState;\n      String tmp = message.getStr(ZkStateReader.PROPERTY_PROP);\n      if (StringUtils.startsWith(tmp, OverseerCollectionProcessor.COLL_PROP_PREFIX) == false) {\n        tmp = OverseerCollectionProcessor.COLL_PROP_PREFIX + tmp;\n      }\n      this.property = tmp.toLowerCase(Locale.ROOT);\n      collectionName = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n      if (StringUtils.isBlank(collectionName) || StringUtils.isBlank(property)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Overseer '\" + message.getStr(QUEUE_OPERATION) + \"'  requires both the '\" + ZkStateReader.COLLECTION_PROP + \"' and '\" +\n                ZkStateReader.PROPERTY_PROP + \"' parameters. No action taken \");\n      }\n\n      Boolean shardUnique = Boolean.parseBoolean(message.getStr(SHARD_UNIQUE));\n      if (shardUnique == false &&\n          SliceMutator.SLICE_UNIQUE_BOOLEAN_PROPERTIES.contains(this.property) == false) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Balancing properties amongst replicas in a slice requires that\"\n            + \" the property be a pre-defined property (e.g. 'preferredLeader') or that 'shardUnique' be set to 'true' \" +\n            \" Property: \" + this.property + \" shardUnique: \" + Boolean.toString(shardUnique));\n      }\n\n      collection = clusterState.getCollection(collectionName);\n      if (collection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Could not find collection ' \" + collectionName + \"' for overseer operation '\" +\n                message.getStr(QUEUE_OPERATION) + \"'. No action taken.\");\n      }\n      onlyActiveNodes = Boolean.parseBoolean(message.getStr(ONLY_ACTIVE_NODES, \"true\"));\n    }\n\n","sourceOld":"    ExclusiveSliceProperty(ClusterStateUpdater updater, ClusterState clusterState, ZkNodeProps message) {\n      this.updater = updater;\n      this.clusterState = clusterState;\n      String tmp = message.getStr(ZkStateReader.PROPERTY_PROP);\n      if (StringUtils.startsWith(tmp, OverseerCollectionProcessor.COLL_PROP_PREFIX) == false) {\n        tmp = OverseerCollectionProcessor.COLL_PROP_PREFIX + tmp;\n      }\n      this.property = tmp.toLowerCase(Locale.ROOT);\n      collectionName = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n      if (StringUtils.isBlank(collectionName) || StringUtils.isBlank(property)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Overseer '\" + message.getStr(QUEUE_OPERATION) + \"'  requires both the '\" + ZkStateReader.COLLECTION_PROP + \"' and '\" +\n                ZkStateReader.PROPERTY_PROP + \"' parameters. No action taken \");\n      }\n\n      Boolean shardUnique = Boolean.parseBoolean(message.getStr(SHARD_UNIQUE));\n      if (shardUnique == false &&\n          Overseer.sliceUniqueBooleanProperties.contains(this.property) == false) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Balancing properties amongst replicas in a slice requires that\"\n            + \" the property be a pre-defined property (e.g. 'preferredLeader') or that 'shardUnique' be set to 'true' \" +\n            \" Property: \" + this.property + \" shardUnique: \" + Boolean.toString(shardUnique));\n      }\n\n      collection = clusterState.getCollection(collectionName);\n      if (collection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Could not find collection ' \" + collectionName + \"' for overseer operation '\" +\n                message.getStr(QUEUE_OPERATION) + \"'. No action taken.\");\n      }\n      onlyActiveNodes = Boolean.parseBoolean(message.getStr(ONLY_ACTIVE_NODES, \"true\"));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"584c1ee8712b5af28075d98028ccab111d6eeda2","date":1417444624,"type":5,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ExclusiveSliceProperty#ExclusiveSliceProperty(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ExclusiveSliceProperty#ExclusiveSliceProperty(ClusterStateUpdater,ClusterState,ZkNodeProps).mjava","sourceNew":"    ExclusiveSliceProperty(ClusterState clusterState, ZkNodeProps message) {\n      this.clusterState = clusterState;\n      String tmp = message.getStr(ZkStateReader.PROPERTY_PROP);\n      if (StringUtils.startsWith(tmp, OverseerCollectionProcessor.COLL_PROP_PREFIX) == false) {\n        tmp = OverseerCollectionProcessor.COLL_PROP_PREFIX + tmp;\n      }\n      this.property = tmp.toLowerCase(Locale.ROOT);\n      collectionName = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n      if (StringUtils.isBlank(collectionName) || StringUtils.isBlank(property)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Overseer '\" + message.getStr(QUEUE_OPERATION) + \"'  requires both the '\" + ZkStateReader.COLLECTION_PROP + \"' and '\" +\n                ZkStateReader.PROPERTY_PROP + \"' parameters. No action taken \");\n      }\n\n      Boolean shardUnique = Boolean.parseBoolean(message.getStr(SHARD_UNIQUE));\n      if (shardUnique == false &&\n          SliceMutator.SLICE_UNIQUE_BOOLEAN_PROPERTIES.contains(this.property) == false) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Balancing properties amongst replicas in a slice requires that\"\n            + \" the property be a pre-defined property (e.g. 'preferredLeader') or that 'shardUnique' be set to 'true' \" +\n            \" Property: \" + this.property + \" shardUnique: \" + Boolean.toString(shardUnique));\n      }\n\n      collection = clusterState.getCollection(collectionName);\n      if (collection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Could not find collection ' \" + collectionName + \"' for overseer operation '\" +\n                message.getStr(QUEUE_OPERATION) + \"'. No action taken.\");\n      }\n      onlyActiveNodes = Boolean.parseBoolean(message.getStr(ONLY_ACTIVE_NODES, \"true\"));\n    }\n\n","sourceOld":"    ExclusiveSliceProperty(ClusterStateUpdater updater, ClusterState clusterState, ZkNodeProps message) {\n      this.updater = updater;\n      this.clusterState = clusterState;\n      String tmp = message.getStr(ZkStateReader.PROPERTY_PROP);\n      if (StringUtils.startsWith(tmp, OverseerCollectionProcessor.COLL_PROP_PREFIX) == false) {\n        tmp = OverseerCollectionProcessor.COLL_PROP_PREFIX + tmp;\n      }\n      this.property = tmp.toLowerCase(Locale.ROOT);\n      collectionName = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n      if (StringUtils.isBlank(collectionName) || StringUtils.isBlank(property)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Overseer '\" + message.getStr(QUEUE_OPERATION) + \"'  requires both the '\" + ZkStateReader.COLLECTION_PROP + \"' and '\" +\n                ZkStateReader.PROPERTY_PROP + \"' parameters. No action taken \");\n      }\n\n      Boolean shardUnique = Boolean.parseBoolean(message.getStr(SHARD_UNIQUE));\n      if (shardUnique == false &&\n          SliceMutator.SLICE_UNIQUE_BOOLEAN_PROPERTIES.contains(this.property) == false) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Balancing properties amongst replicas in a slice requires that\"\n            + \" the property be a pre-defined property (e.g. 'preferredLeader') or that 'shardUnique' be set to 'true' \" +\n            \" Property: \" + this.property + \" shardUnique: \" + Boolean.toString(shardUnique));\n      }\n\n      collection = clusterState.getCollection(collectionName);\n      if (collection == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Could not find collection ' \" + collectionName + \"' for overseer operation '\" +\n                message.getStr(QUEUE_OPERATION) + \"'. No action taken.\");\n      }\n      onlyActiveNodes = Boolean.parseBoolean(message.getStr(ONLY_ACTIVE_NODES, \"true\"));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["cfb61c9baefa8681e40fca3c803f61bf485a9d8d"],"55980207f1977bd1463465de1659b821347e2fa8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","64707d25b6352cf02909d3916038a3b3cec7f0a8"],"cfb61c9baefa8681e40fca3c803f61bf485a9d8d":["64707d25b6352cf02909d3916038a3b3cec7f0a8"],"584c1ee8712b5af28075d98028ccab111d6eeda2":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"64707d25b6352cf02909d3916038a3b3cec7f0a8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["584c1ee8712b5af28075d98028ccab111d6eeda2"]},"commit2Childs":{"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["584c1ee8712b5af28075d98028ccab111d6eeda2"],"55980207f1977bd1463465de1659b821347e2fa8":[],"cfb61c9baefa8681e40fca3c803f61bf485a9d8d":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55980207f1977bd1463465de1659b821347e2fa8","64707d25b6352cf02909d3916038a3b3cec7f0a8"],"584c1ee8712b5af28075d98028ccab111d6eeda2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"64707d25b6352cf02909d3916038a3b3cec7f0a8":["55980207f1977bd1463465de1659b821347e2fa8","cfb61c9baefa8681e40fca3c803f61bf485a9d8d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}