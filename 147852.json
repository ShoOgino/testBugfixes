{"path":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","commits":[{"id":"40b4f9867bcb3a1cf45f8a02b05af0bdf552746f","date":1477377788,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestLeaderRecoverFromLogOnStartup#test().mjava","sourceNew":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    assertEquals(4, countReplayLog.get());\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 4)\n  public void test() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        countReplayLog.incrementAndGet();\n      }\n    };\n\n    String testCollectionName = \"testCollection\";\n    createCollection(testCollectionName, 2, 2, 1);\n    waitForRecoveriesToFinish(false);\n\n    cloudClient.setDefaultCollection(testCollectionName);\n    cloudClient.add(sdoc(\"id\", \"1\"));\n    cloudClient.add(sdoc(\"id\", \"2\"));\n    cloudClient.add(sdoc(\"id\", \"3\"));\n    cloudClient.add(sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), testCollectionName, 120000));\n\n    cloudClient.commit();\n    resp = cloudClient.query(params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    assertEquals(4, countReplayLog.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60b61628d1912768f51eccaa8ead5a5a32ab34c6","date":1477427681,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestLeaderRecoverFromLogOnStartup#test().mjava","sourceNew":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    assertEquals(4, countReplayLog.get());\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 4)\n  public void test() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        countReplayLog.incrementAndGet();\n      }\n    };\n\n    String testCollectionName = \"testCollection\";\n    createCollection(testCollectionName, 2, 2, 1);\n    waitForRecoveriesToFinish(false);\n\n    cloudClient.setDefaultCollection(testCollectionName);\n    cloudClient.add(sdoc(\"id\", \"1\"));\n    cloudClient.add(sdoc(\"id\", \"2\"));\n    cloudClient.add(sdoc(\"id\", \"3\"));\n    cloudClient.add(sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), testCollectionName, 120000));\n\n    cloudClient.commit();\n    resp = cloudClient.query(params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    assertEquals(4, countReplayLog.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":1,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestLeaderRecoverFromLogOnStartup#test().mjava","sourceNew":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    assertEquals(4, countReplayLog.get());\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 4)\n  public void test() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        countReplayLog.incrementAndGet();\n      }\n    };\n\n    String testCollectionName = \"testCollection\";\n    createCollection(testCollectionName, 2, 2, 1);\n    waitForRecoveriesToFinish(false);\n\n    cloudClient.setDefaultCollection(testCollectionName);\n    cloudClient.add(sdoc(\"id\", \"1\"));\n    cloudClient.add(sdoc(\"id\", \"2\"));\n    cloudClient.add(sdoc(\"id\", \"3\"));\n    cloudClient.add(sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(jettys);\n    ChaosMonkey.stop(controlJetty);\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(jettys);\n    ChaosMonkey.start(controlJetty);\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), testCollectionName, 120000));\n\n    cloudClient.commit();\n    resp = cloudClient.query(params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    assertEquals(4, countReplayLog.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"268f09ed3a9a9b77003b15a5ae30386dc4e3721f","date":1483992000,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    assertEquals(4, countReplayLog.get());\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    assertEquals(2, replicationCount);\n  }\n\n","sourceOld":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    assertEquals(4, countReplayLog.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    assertEquals(4, countReplayLog.get());\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    assertEquals(2, replicationCount);\n  }\n\n","sourceOld":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    assertEquals(4, countReplayLog.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"073f1aa70444ec64f3e216816af2a3b43fa38fe7","date":1488920481,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    assertEquals(4, countReplayLog.get());\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    assertEquals(2, replicationCount);\n  }\n\n","sourceOld":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    assertEquals(4, countReplayLog.get());\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    assertEquals(2, replicationCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 append replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    assertEquals(4, countReplayLog.get());\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    assertEquals(2, replicationCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 append replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    assertEquals(4, countReplayLog.get());\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    assertEquals(2, replicationCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 append replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    assertEquals(4, countReplayLog.get());\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    assertEquals(2, replicationCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 append replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 append replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c9595c75582a7ea7efb585014102ed83f2d9c8b","date":1523581112,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 09-Apr-2018\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b87d1f8719d7f05be003f3477450b74af13706a","date":1523590376,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 09-Apr-2018\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddd2d71ed1b949bd0bdb81cb2e586348ba842095","date":1526614574,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  // Removed BadApple on 18-May-2018\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 09-Apr-2018\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a7544ad4b63d1b5f556c3da8f9c63d332aa034e","date":1529622176,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","sourceOld":"  @Test\n  // Removed BadApple on 18-May-2018\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","sourceOld":"  @Test\n  // Removed BadApple on 18-May-2018\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","sourceOld":"  @Test\n  // Removed BadApple on 18-May-2018\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15600ceffc7023bfa1f532afbf1854e7f8c4e6d3","date":1532119025,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 20-Jul-2018\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a","date":1536291831,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  // commented 4-Sep-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 20-Jul-2018\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 20-Jul-2018\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  // commented 4-Sep-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 20-Jul-2018\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n\n    \n    for (JettySolrRunner jettySolrRunner : cluster.getJettySolrRunners()) {\n      cluster.waitForJettyToStop(jettySolrRunner);\n    }\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    \n    cluster.waitForAllNodes(30);\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","sourceOld":"  @Test\n  // commented 4-Sep-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 20-Jul-2018\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1","date":1579200426,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudRecovery#leaderRecoverFromLogOnStartupTest().mjava","sourceNew":"  @Test\n  // commented 4-Sep-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 20-Jul-2018\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    TestInjection.skipIndexWriterCommitOnClose = true;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n\n    \n    for (JettySolrRunner jettySolrRunner : cluster.getJettySolrRunners()) {\n      cluster.waitForJettyToStop(jettySolrRunner);\n    }\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    \n    cluster.waitForAllNodes(30);\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","sourceOld":"  @Test\n  // commented 4-Sep-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 20-Jul-2018\n  public void leaderRecoverFromLogOnStartupTest() throws Exception {\n    AtomicInteger countReplayLog = new AtomicInteger(0);\n    DirectUpdateHandler2.commitOnClose = false;\n    UpdateLog.testing_logReplayFinishHook = countReplayLog::incrementAndGet;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"1\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"2\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"3\"));\n    cloudClient.add(COLLECTION, sdoc(\"id\", \"4\"));\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"q\", \"*:*\");\n    QueryResponse resp = cloudClient.query(COLLECTION, params);\n    assertEquals(0, resp.getResults().getNumFound());\n\n    ChaosMonkey.stop(cluster.getJettySolrRunners());\n\n    \n    for (JettySolrRunner jettySolrRunner : cluster.getJettySolrRunners()) {\n      cluster.waitForJettyToStop(jettySolrRunner);\n    }\n    assertTrue(\"Timeout waiting for all not live\", ClusterStateUtil.waitForAllReplicasNotLive(cloudClient.getZkStateReader(), 45000));\n    ChaosMonkey.start(cluster.getJettySolrRunners());\n    \n    cluster.waitForAllNodes(30);\n    \n    assertTrue(\"Timeout waiting for all live and active\", ClusterStateUtil.waitForAllActiveAndLiveReplicas(cloudClient.getZkStateReader(), COLLECTION, 120000));\n\n    resp = cloudClient.query(COLLECTION, params);\n    assertEquals(4, resp.getResults().getNumFound());\n    // Make sure all nodes is recover from tlog\n    if (onlyLeaderIndexes) {\n      // Leader election can be kicked off, so 2 tlog replicas will replay its tlog before becoming new leader\n      assertTrue( countReplayLog.get() >=2);\n    } else {\n      assertEquals(4, countReplayLog.get());\n    }\n\n    // check metrics\n    int replicationCount = 0;\n    int errorsCount = 0;\n    int skippedCount = 0;\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      SolrMetricManager manager = jetty.getCoreContainer().getMetricManager();\n      List<String> registryNames = manager.registryNames().stream()\n          .filter(s -> s.startsWith(\"solr.core.\")).collect(Collectors.toList());\n      for (String registry : registryNames) {\n        Map<String, Metric> metrics = manager.registry(registry).getMetrics();\n        Timer timer = (Timer)metrics.get(\"REPLICATION.peerSync.time\");\n        Counter counter = (Counter)metrics.get(\"REPLICATION.peerSync.errors\");\n        Counter skipped = (Counter)metrics.get(\"REPLICATION.peerSync.skipped\");\n        replicationCount += timer.getCount();\n        errorsCount += counter.getCount();\n        skippedCount += skipped.getCount();\n      }\n    }\n    if (onlyLeaderIndexes) {\n      assertTrue(replicationCount >= 2);\n    } else {\n      assertEquals(2, replicationCount);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"61c45e99cf6676da48f19d7511c73712ad39402b":["be320990bdc77e643388fa801e75017f19289c42"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a"],"268f09ed3a9a9b77003b15a5ae30386dc4e3721f":["60b61628d1912768f51eccaa8ead5a5a32ab34c6"],"3c9595c75582a7ea7efb585014102ed83f2d9c8b":["61c45e99cf6676da48f19d7511c73712ad39402b"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","268f09ed3a9a9b77003b15a5ae30386dc4e3721f"],"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"ddd2d71ed1b949bd0bdb81cb2e586348ba842095":["6b87d1f8719d7f05be003f3477450b74af13706a"],"60b61628d1912768f51eccaa8ead5a5a32ab34c6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","40b4f9867bcb3a1cf45f8a02b05af0bdf552746f"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["ab68488225b6a6c357dda72ed11dedca9914a192","61c45e99cf6676da48f19d7511c73712ad39402b"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["ddd2d71ed1b949bd0bdb81cb2e586348ba842095","7a7544ad4b63d1b5f556c3da8f9c63d332aa034e"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["073f1aa70444ec64f3e216816af2a3b43fa38fe7"],"40b4f9867bcb3a1cf45f8a02b05af0bdf552746f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6b87d1f8719d7f05be003f3477450b74af13706a":["61c45e99cf6676da48f19d7511c73712ad39402b","3c9595c75582a7ea7efb585014102ed83f2d9c8b"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","60b61628d1912768f51eccaa8ead5a5a32ab34c6"],"073f1aa70444ec64f3e216816af2a3b43fa38fe7":["268f09ed3a9a9b77003b15a5ae30386dc4e3721f"],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["15600ceffc7023bfa1f532afbf1854e7f8c4e6d3"],"15600ceffc7023bfa1f532afbf1854e7f8c4e6d3":["7a7544ad4b63d1b5f556c3da8f9c63d332aa034e"],"7a7544ad4b63d1b5f556c3da8f9c63d332aa034e":["ddd2d71ed1b949bd0bdb81cb2e586348ba842095"],"be320990bdc77e643388fa801e75017f19289c42":["073f1aa70444ec64f3e216816af2a3b43fa38fe7"],"ab68488225b6a6c357dda72ed11dedca9914a192":["073f1aa70444ec64f3e216816af2a3b43fa38fe7","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["ddd2d71ed1b949bd0bdb81cb2e586348ba842095","7a7544ad4b63d1b5f556c3da8f9c63d332aa034e"]},"commit2Childs":{"61c45e99cf6676da48f19d7511c73712ad39402b":["3c9595c75582a7ea7efb585014102ed83f2d9c8b","e9017cf144952056066919f1ebc7897ff9bd71b1","6b87d1f8719d7f05be003f3477450b74af13706a"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1"],"268f09ed3a9a9b77003b15a5ae30386dc4e3721f":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","073f1aa70444ec64f3e216816af2a3b43fa38fe7"],"3c9595c75582a7ea7efb585014102ed83f2d9c8b":["6b87d1f8719d7f05be003f3477450b74af13706a"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ddd2d71ed1b949bd0bdb81cb2e586348ba842095":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7a7544ad4b63d1b5f556c3da8f9c63d332aa034e","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"60b61628d1912768f51eccaa8ead5a5a32ab34c6":["268f09ed3a9a9b77003b15a5ae30386dc4e3721f","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"40b4f9867bcb3a1cf45f8a02b05af0bdf552746f":["60b61628d1912768f51eccaa8ead5a5a32ab34c6"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"6b87d1f8719d7f05be003f3477450b74af13706a":["ddd2d71ed1b949bd0bdb81cb2e586348ba842095"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["60b61628d1912768f51eccaa8ead5a5a32ab34c6","40b4f9867bcb3a1cf45f8a02b05af0bdf552746f","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"073f1aa70444ec64f3e216816af2a3b43fa38fe7":["f996f8177b9204bdc92f7164460c6cefad9ac99a","be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192"],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"15600ceffc7023bfa1f532afbf1854e7f8c4e6d3":["f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a"],"7a7544ad4b63d1b5f556c3da8f9c63d332aa034e":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","15600ceffc7023bfa1f532afbf1854e7f8c4e6d3","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"be320990bdc77e643388fa801e75017f19289c42":["61c45e99cf6676da48f19d7511c73712ad39402b"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","e9017cf144952056066919f1ebc7897ff9bd71b1","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}